diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/AUTHORS.rst hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/AUTHORS.rst
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/AUTHORS.rst	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/AUTHORS.rst	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,29 @@
+AUTHORS
+=======
+
+PGP key fingerprints are enclosed in parentheses.
+
+* Alex Gaynor <alex.gaynor@gmail.com> (E27D 4AA0 1651 72CB C5D2  AF2B 125F 5C67 DFE9 4084)
+* Hynek Schlawack <hs@ox.cx> (C2A0 4F86 ACE2 8ADC F817 DBB7 AE25 3622 7F69 F181)
+* Donald Stufft <donald@stufft.io>
+* Laurens Van Houtven <_@lvh.io> (D9DC 4315 772F 8E91 DD22 B153 DFD1 3DF7 A8DD 569B)
+* Christian Heimes <christian@python.org>
+* Paul Kehrer <paul.l.kehrer@gmail.com> (05FD 9FA1 6CF7 5735 0D91 A560 235A E5F1 29F9 ED98)
+* Jarret Raim <jarito@gmail.com>
+* Alex Stapleton <alexs@prol.etari.at> (A1C7 E50B 66DE 39ED C847 9665 8E3C 20D1 9BD9 5C4C)
+* David Reid <dreid@dreid.org> (0F83 CC87 B32F 482B C726  B58A 9FBF D8F4 DA89 6D74)
+* Matthew Lefkowitz <glyph@twistedmatrix.com> (06AB F638 E878 CD29 1264  18AB 7EC2 8125 0FBC 4A07)
+* Konstantinos Koukopoulos <koukopoulos@gmail.com> (D6BD 52B6 8C99 A91C E2C8  934D 3300 566B 3A46 726E)
+* Stephen Holsapple <sholsapp@gmail.com>
+* Terry Chia <terrycwk1994@gmail.com>
+* Matthew Iversen <matt@notevencode.com> (2F04 3DCC D6E6 D5AC D262  2E0B C046 E8A8 7452 2973)
+* Mohammed Attia <skeuomorf@gmail.com>
+* Michael Hart <michael.hart1994@gmail.com>
+* Mark Adams <mark@markadams.me> (A18A 7DD3 283C CF2A B0CE FE0E C7A0 5E3F C972 098C)
+* Gregory Haynes <greg@greghaynes.net> (6FB6 44BF 9FD0 EBA2 1CE9  471F B08F 42F9 0DC6 599F)
+* Chelsea Winfree <chelsea.winfree@gmail.com>
+* Steven Buss <steven.buss@gmail.com> (1FB9 2EC1 CF93 DFD6 B47F F583 B1A5 6C22 290D A4C3)
+* Andre Caron <andre.l.caron@gmail.com>
+* Jiangge Zhang <tonyseek@gmail.com> (BBEC 782B 015F 71B1 5FF7  EACA 1A8C AA98 255F 5000)
+* Major Hayden <major@mhtx.net> (1BF9 9264 9596 0033 698C  252B 7370 51E0 C101 1FB1)
+* Phoebe Queen <foibey@gmail.com> (10D4 7741 AB65 50F4 B264 3888 DA40 201A 072B C1FA)
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/CHANGELOG.rst hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/CHANGELOG.rst
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/CHANGELOG.rst	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/CHANGELOG.rst	2015-11-19 05:01:40.000000000 +0100
@@ -0,0 +1,545 @@
+Changelog
+=========
+
+1.1.1 - 2015-11-19
+~~~~~~~~~~~~~~~~~~
+
+* Fixed several small bugs related to compiling the OpenSSL bindings with
+  unusual OpenSSL configurations.
+* Resolved an issue where, depending on the method of installation and
+  which Python interpreter they were using, users on El Capitan (OS X 10.11)
+  may have seen an ``InternalError`` on import.
+
+1.1 - 2015-10-28
+~~~~~~~~~~~~~~~~
+
+* Added support for Elliptic Curve Diffie-Hellman with
+  :class:`~cryptography.hazmat.primitives.asymmetric.ec.ECDH`.
+* Added :class:`~cryptography.hazmat.primitives.kdf.x963kdf.X963KDF`.
+* Added support for parsing certificate revocation lists (CRLs) using
+  :func:`~cryptography.x509.load_pem_x509_crl` and
+  :func:`~cryptography.x509.load_der_x509_crl`.
+* Add support for AES key wrapping with
+  :func:`~cryptography.hazmat.primitives.keywrap.aes_key_wrap` and
+  :func:`~cryptography.hazmat.primitives.keywrap.aes_key_unwrap`.
+* Added a ``__hash__`` method to :class:`~cryptography.x509.Name`.
+* Add support for encoding and decoding elliptic curve points to a byte string
+  form using
+  :meth:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePublicNumbers.encode_point`
+  and
+  :meth:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePublicNumbers.from_encoded_point`.
+* Added :meth:`~cryptography.x509.Extensions.get_extension_for_class`.
+* :class:`~cryptography.x509.CertificatePolicies` are now supported in the
+  :class:`~cryptography.x509.CertificateBuilder`.
+* ``countryName`` is now encoded as a ``PrintableString`` when creating subject
+  and issuer distinguished names with the Certificate and CSR builder classes.
+
+
+1.0.2 - 2015-09-27
+~~~~~~~~~~~~~~~~~~
+* **SECURITY ISSUE**: The OpenSSL backend prior to 1.0.2 made extensive use
+  of assertions to check response codes where our tests could not trigger a
+  failure.  However, when Python is run with ``-O`` these asserts are optimized
+  away.  If a user ran Python with this flag and got an invalid response code
+  this could result in undefined behavior or worse. Accordingly, all response
+  checks from the OpenSSL backend have been converted from ``assert``
+  to a true function call. Credit **Emilia KÃ¤sper (Google Security Team)**
+  for the report.
+
+1.0.1 - 2015-09-05
+~~~~~~~~~~~~~~~~~~
+
+* We now ship OS X wheels that statically link OpenSSL by default. When
+  installing a wheel on OS X 10.10+ (and using a Python compiled against the
+  10.10 SDK) users will no longer need to compile. See :doc:`/installation` for
+  alternate installation methods if required.
+* Set the default string mask to UTF-8 in the OpenSSL backend to resolve
+  character encoding issues with older versions of OpenSSL.
+* Several new OpenSSL bindings have been added to support a future pyOpenSSL
+  release.
+* Raise an error during install on PyPy < 2.6. 1.0+ requires PyPy 2.6+.
+
+1.0 - 2015-08-12
+~~~~~~~~~~~~~~~~
+
+* Switched to the new `cffi`_ ``set_source`` out-of-line API mode for
+  compilation. This results in significantly faster imports and lowered
+  memory consumption. Due to this change we no longer support PyPy releases
+  older than 2.6 nor do we support any released version of PyPy3 (until a
+  version supporting cffi 1.0 comes out).
+* Fix parsing of OpenSSH public keys that have spaces in comments.
+* Support serialization of certificate signing requests using the
+  ``public_bytes`` method of
+  :class:`~cryptography.x509.CertificateSigningRequest`.
+* Support serialization of certificates using the ``public_bytes`` method of
+  :class:`~cryptography.x509.Certificate`.
+* Add ``get_provisioning_uri`` method to
+  :class:`~cryptography.hazmat.primitives.twofactor.hotp.HOTP` and
+  :class:`~cryptography.hazmat.primitives.twofactor.totp.TOTP` for generating
+  provisioning URIs.
+* Add :class:`~cryptography.hazmat.primitives.kdf.concatkdf.ConcatKDFHash`
+  and :class:`~cryptography.hazmat.primitives.kdf.concatkdf.ConcatKDFHMAC`.
+* Raise a ``TypeError`` when passing objects that are not text as the value to
+  :class:`~cryptography.x509.NameAttribute`.
+* Add support for :class:`~cryptography.x509.OtherName` as a general name
+  type.
+* Added new X.509 extension support in :class:`~cryptography.x509.Certificate`
+  The following new extensions are now supported:
+
+  * :class:`~cryptography.x509.OCSPNoCheck`
+  * :class:`~cryptography.x509.InhibitAnyPolicy`
+  * :class:`~cryptography.x509.IssuerAlternativeName`
+  * :class:`~cryptography.x509.NameConstraints`
+
+* Extension support was added to
+  :class:`~cryptography.x509.CertificateSigningRequest`.
+* Add support for creating signed certificates with
+  :class:`~cryptography.x509.CertificateBuilder`. This includes support for
+  the following extensions:
+
+  * :class:`~cryptography.x509.BasicConstraints`
+  * :class:`~cryptography.x509.SubjectAlternativeName`
+  * :class:`~cryptography.x509.KeyUsage`
+  * :class:`~cryptography.x509.ExtendedKeyUsage`
+  * :class:`~cryptography.x509.SubjectKeyIdentifier`
+  * :class:`~cryptography.x509.AuthorityKeyIdentifier`
+  * :class:`~cryptography.x509.AuthorityInformationAccess`
+  * :class:`~cryptography.x509.CRLDistributionPoints`
+  * :class:`~cryptography.x509.InhibitAnyPolicy`
+  * :class:`~cryptography.x509.IssuerAlternativeName`
+  * :class:`~cryptography.x509.OCSPNoCheck`
+
+* Add support for creating certificate signing requests with
+  :class:`~cryptography.x509.CertificateSigningRequestBuilder`. This includes
+  support for the same extensions supported in the ``CertificateBuilder``.
+* Deprecate ``encode_rfc6979_signature`` and ``decode_rfc6979_signature`` in
+  favor of
+  :func:`~cryptography.hazmat.primitives.asymmetric.utils.encode_dss_signature`
+  and
+  :func:`~cryptography.hazmat.primitives.asymmetric.utils.decode_dss_signature`.
+
+
+0.9.3 - 2015-07-09
+~~~~~~~~~~~~~~~~~~
+
+* Updated Windows wheels to be compiled against OpenSSL 1.0.2d.
+
+0.9.2 - 2015-07-04
+~~~~~~~~~~~~~~~~~~
+
+* Updated Windows wheels to be compiled against OpenSSL 1.0.2c.
+
+0.9.1 - 2015-06-06
+~~~~~~~~~~~~~~~~~~
+
+* **SECURITY ISSUE**: Fixed a double free in the OpenSSL backend when using DSA
+  to verify signatures. Note that this only affects PyPy 2.6.0 and (presently
+  unreleased) CFFI versions greater than 1.1.0.
+
+0.9 - 2015-05-13
+~~~~~~~~~~~~~~~~
+
+* Removed support for Python 3.2. This version of Python is rarely used
+  and caused support headaches. Users affected by this should upgrade to 3.3+.
+* Deprecated support for Python 2.6. At the time there is no time table for
+  actually dropping support, however we strongly encourage all users to upgrade
+  their Python, as Python 2.6 no longer receives support from the Python core
+  team.
+* Add support for the
+  :class:`~cryptography.hazmat.primitives.asymmetric.ec.SECP256K1` elliptic
+  curve.
+* Fixed compilation when using an OpenSSL which was compiled with the
+  ``no-comp`` (``OPENSSL_NO_COMP``) option.
+* Support :attr:`~cryptography.hazmat.primitives.serialization.Encoding.DER`
+  serialization of public keys using the ``public_bytes`` method of
+  :class:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPublicKeyWithSerialization`,
+  :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPublicKeyWithSerialization`,
+  and
+  :class:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePublicKeyWithSerialization`.
+* Support :attr:`~cryptography.hazmat.primitives.serialization.Encoding.DER`
+  serialization of private keys using the ``private_bytes`` method of
+  :class:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPrivateKeyWithSerialization`,
+  :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPrivateKeyWithSerialization`,
+  and
+  :class:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePrivateKeyWithSerialization`.
+* Add support for parsing X.509 certificate signing requests (CSRs) with
+  :func:`~cryptography.x509.load_pem_x509_csr` and
+  :func:`~cryptography.x509.load_der_x509_csr`.
+* Moved ``cryptography.exceptions.InvalidToken`` to
+  :class:`cryptography.hazmat.primitives.twofactor.InvalidToken` and deprecated
+  the old location. This was moved to minimize confusion between this exception
+  and :class:`cryptography.fernet.InvalidToken`.
+* Added support for X.509 extensions in :class:`~cryptography.x509.Certificate`
+  objects. The following extensions are supported as of this release:
+
+  * :class:`~cryptography.x509.BasicConstraints`
+  * :class:`~cryptography.x509.AuthorityKeyIdentifier`
+  * :class:`~cryptography.x509.SubjectKeyIdentifier`
+  * :class:`~cryptography.x509.KeyUsage`
+  * :class:`~cryptography.x509.SubjectAlternativeName`
+  * :class:`~cryptography.x509.ExtendedKeyUsage`
+  * :class:`~cryptography.x509.CRLDistributionPoints`
+  * :class:`~cryptography.x509.AuthorityInformationAccess`
+  * :class:`~cryptography.x509.CertificatePolicies`
+
+  Note that unsupported extensions with the critical flag raise
+  :class:`~cryptography.x509.UnsupportedExtension` while unsupported extensions
+  set to non-critical are silently ignored. Read the
+  :doc:`X.509 documentation</x509/index>` for more information.
+
+0.8.2 - 2015-04-10
+~~~~~~~~~~~~~~~~~~
+
+* Fixed a race condition when initializing the OpenSSL or CommonCrypto backends
+  in a multi-threaded scenario.
+
+0.8.1 - 2015-03-20
+~~~~~~~~~~~~~~~~~~
+
+* Updated Windows wheels to be compiled against OpenSSL 1.0.2a.
+
+0.8 - 2015-03-08
+~~~~~~~~~~~~~~~~
+
+* :func:`~cryptography.hazmat.primitives.serialization.load_ssh_public_key` can
+  now load elliptic curve public keys.
+* Added
+  :attr:`~cryptography.x509.Certificate.signature_hash_algorithm` support to
+  :class:`~cryptography.x509.Certificate`.
+* Added
+  :func:`~cryptography.hazmat.primitives.asymmetric.rsa.rsa_recover_prime_factors`
+* :class:`~cryptography.hazmat.primitives.kdf.KeyDerivationFunction` was moved
+  from :mod:`~cryptography.hazmat.primitives.interfaces` to
+  :mod:`~cryptography.hazmat.primitives.kdf`.
+* Added support for parsing X.509 names. See the
+  :doc:`X.509 documentation</x509/index>` for more information.
+* Added
+  :func:`~cryptography.hazmat.primitives.serialization.load_der_private_key` to
+  support loading of DER encoded private keys and
+  :func:`~cryptography.hazmat.primitives.serialization.load_der_public_key` to
+  support loading DER encoded public keys.
+* Fixed building against LibreSSL, a compile-time substitute for OpenSSL.
+* FreeBSD 9.2 was removed from the continuous integration system.
+* Updated Windows wheels to be compiled against OpenSSL 1.0.2.
+* :func:`~cryptography.hazmat.primitives.serialization.load_pem_public_key`
+  and :func:`~cryptography.hazmat.primitives.serialization.load_der_public_key`
+  now support PKCS1 RSA public keys (in addition to the previous support for
+  SubjectPublicKeyInfo format for RSA, EC, and DSA).
+* Added
+  :class:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePrivateKeyWithSerialization`
+  and deprecated ``EllipticCurvePrivateKeyWithNumbers``.
+* Added
+  :meth:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePrivateKeyWithSerialization.private_bytes`
+  to
+  :class:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePrivateKeyWithSerialization`.
+* Added
+  :class:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPrivateKeyWithSerialization`
+  and deprecated ``RSAPrivateKeyWithNumbers``.
+* Added
+  :meth:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPrivateKeyWithSerialization.private_bytes`
+  to
+  :class:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPrivateKeyWithSerialization`.
+* Added
+  :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPrivateKeyWithSerialization`
+  and deprecated ``DSAPrivateKeyWithNumbers``.
+* Added
+  :meth:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPrivateKeyWithSerialization.private_bytes`
+  to
+  :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPrivateKeyWithSerialization`.
+* Added
+  :class:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPublicKeyWithSerialization`
+  and deprecated ``RSAPublicKeyWithNumbers``.
+* Added ``public_bytes`` to
+  :class:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPublicKeyWithSerialization`.
+* Added
+  :class:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePublicKeyWithSerialization`
+  and deprecated ``EllipticCurvePublicKeyWithNumbers``.
+* Added ``public_bytes`` to
+  :class:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePublicKeyWithSerialization`.
+* Added
+  :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPublicKeyWithSerialization`
+  and deprecated ``DSAPublicKeyWithNumbers``.
+* Added ``public_bytes`` to
+  :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPublicKeyWithSerialization`.
+* :class:`~cryptography.hazmat.primitives.hashes.HashAlgorithm` and
+  :class:`~cryptography.hazmat.primitives.hashes.HashContext` were moved from
+  :mod:`~cryptography.hazmat.primitives.interfaces` to
+  :mod:`~cryptography.hazmat.primitives.hashes`.
+* :class:`~cryptography.hazmat.primitives.ciphers.CipherContext`,
+  :class:`~cryptography.hazmat.primitives.ciphers.AEADCipherContext`,
+  :class:`~cryptography.hazmat.primitives.ciphers.AEADEncryptionContext`,
+  :class:`~cryptography.hazmat.primitives.ciphers.CipherAlgorithm`, and
+  :class:`~cryptography.hazmat.primitives.ciphers.BlockCipherAlgorithm`
+  were moved from :mod:`~cryptography.hazmat.primitives.interfaces` to
+  :mod:`~cryptography.hazmat.primitives.ciphers`.
+* :class:`~cryptography.hazmat.primitives.ciphers.modes.Mode`,
+  :class:`~cryptography.hazmat.primitives.ciphers.modes.ModeWithInitializationVector`,
+  :class:`~cryptography.hazmat.primitives.ciphers.modes.ModeWithNonce`, and
+  :class:`~cryptography.hazmat.primitives.ciphers.modes.ModeWithAuthenticationTag`
+  were moved from :mod:`~cryptography.hazmat.primitives.interfaces` to
+  :mod:`~cryptography.hazmat.primitives.ciphers.modes`.
+* :class:`~cryptography.hazmat.primitives.padding.PaddingContext` was moved
+  from :mod:`~cryptography.hazmat.primitives.interfaces` to
+  :mod:`~cryptography.hazmat.primitives.padding`.
+*
+  :class:`~cryptography.hazmat.primitives.asymmetric.padding.AsymmetricPadding`
+  was moved from :mod:`~cryptography.hazmat.primitives.interfaces` to
+  :mod:`~cryptography.hazmat.primitives.asymmetric.padding`.
+*
+  :class:`~cryptography.hazmat.primitives.asymmetric.AsymmetricSignatureContext`
+  and
+  :class:`~cryptography.hazmat.primitives.asymmetric.AsymmetricVerificationContext`
+  were moved from :mod:`~cryptography.hazmat.primitives.interfaces` to
+  :mod:`~cryptography.hazmat.primitives.asymmetric`.
+* :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAParameters`,
+  :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAParametersWithNumbers`,
+  :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPrivateKey`,
+  ``DSAPrivateKeyWithNumbers``,
+  :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPublicKey` and
+  ``DSAPublicKeyWithNumbers`` were moved from
+  :mod:`~cryptography.hazmat.primitives.interfaces` to
+  :mod:`~cryptography.hazmat.primitives.asymmetric.dsa`
+* :class:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurve`,
+  :class:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurveSignatureAlgorithm`,
+  :class:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePrivateKey`,
+  ``EllipticCurvePrivateKeyWithNumbers``,
+  :class:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePublicKey`,
+  and ``EllipticCurvePublicKeyWithNumbers``
+  were moved from :mod:`~cryptography.hazmat.primitives.interfaces` to
+  :mod:`~cryptography.hazmat.primitives.asymmetric.ec`.
+* :class:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPrivateKey`,
+  ``RSAPrivateKeyWithNumbers``,
+  :class:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPublicKey` and
+  ``RSAPublicKeyWithNumbers`` were moved from
+  :mod:`~cryptography.hazmat.primitives.interfaces` to
+  :mod:`~cryptography.hazmat.primitives.asymmetric.rsa`.
+
+0.7.2 - 2015-01-16
+~~~~~~~~~~~~~~~~~~
+
+* Updated Windows wheels to be compiled against OpenSSL 1.0.1l.
+* ``enum34`` is no longer installed on Python 3.4, where it is included in
+  the standard library.
+* Added a new function to the OpenSSL bindings to support additional
+  functionality in pyOpenSSL.
+
+0.7.1 - 2014-12-28
+~~~~~~~~~~~~~~~~~~
+
+* Fixed an issue preventing compilation on platforms where ``OPENSSL_NO_SSL3``
+  was defined.
+
+0.7 - 2014-12-17
+~~~~~~~~~~~~~~~~
+
+* Cryptography has been relicensed from the Apache Software License, Version
+  2.0, to being available under *either* the Apache Software License, Version
+  2.0, or the BSD license.
+* Added key-rotation support to :doc:`Fernet </fernet>` with
+  :class:`~cryptography.fernet.MultiFernet`.
+* More bit-lengths are now supported for ``p`` and ``q`` when loading DSA keys
+  from numbers.
+* Added :class:`~cryptography.hazmat.primitives.interfaces.MACContext` as a
+  common interface for CMAC and HMAC and deprecated ``CMACContext``.
+* Added support for encoding and decoding :rfc:`6979` signatures in
+  :doc:`/hazmat/primitives/asymmetric/utils`.
+* Added
+  :func:`~cryptography.hazmat.primitives.serialization.load_ssh_public_key` to
+  support the loading of OpenSSH public keys (:rfc:`4253`). Only RSA and DSA
+  keys are currently supported.
+* Added initial support for X.509 certificate parsing. See the
+  :doc:`X.509 documentation</x509/index>` for more information.
+
+0.6.1 - 2014-10-15
+~~~~~~~~~~~~~~~~~~
+
+* Updated Windows wheels to be compiled against OpenSSL 1.0.1j.
+* Fixed an issue where OpenSSL 1.0.1j changed the errors returned by some
+  functions.
+* Added our license file to the ``cryptography-vectors`` package.
+* Implemented DSA hash truncation support (per FIPS 186-3) in the OpenSSL
+  backend. This works around an issue in 1.0.0, 1.0.0a, and 1.0.0b where
+  truncation was not implemented.
+
+0.6 - 2014-09-29
+~~~~~~~~~~~~~~~~
+
+* Added
+  :func:`~cryptography.hazmat.primitives.serialization.load_pem_private_key` to
+  ease loading private keys, and
+  :func:`~cryptography.hazmat.primitives.serialization.load_pem_public_key` to
+  support loading public keys.
+* Removed the, deprecated in 0.4, support for the ``salt_length`` argument to
+  the :class:`~cryptography.hazmat.primitives.asymmetric.padding.MGF1`
+  constructor. The ``salt_length`` should be passed to
+  :class:`~cryptography.hazmat.primitives.asymmetric.padding.PSS` instead.
+* Fix compilation on OS X Yosemite.
+* Deprecated ``elliptic_curve_private_key_from_numbers`` and
+  ``elliptic_curve_public_key_from_numbers`` in favor of
+  ``load_elliptic_curve_private_numbers`` and
+  ``load_elliptic_curve_public_numbers`` on
+  :class:`~cryptography.hazmat.backends.interfaces.EllipticCurveBackend`.
+* Added ``EllipticCurvePrivateKeyWithNumbers`` and
+  ``EllipticCurvePublicKeyWithNumbers`` support.
+* Work around three GCM related bugs in CommonCrypto and OpenSSL.
+
+  * On the CommonCrypto backend adding AAD but not subsequently calling update
+    would return null tag bytes.
+
+  * One the CommonCrypto backend a call to update without an empty add AAD call
+    would return null ciphertext bytes.
+
+  * On the OpenSSL backend with certain versions adding AAD only would give
+    invalid tag bytes.
+
+* Support loading EC private keys from PEM.
+
+0.5.4 - 2014-08-20
+~~~~~~~~~~~~~~~~~~
+
+* Added several functions to the OpenSSL bindings to support new
+  functionality in pyOpenSSL.
+* Fixed a redefined constant causing compilation failure with Solaris 11.2.
+
+0.5.3 - 2014-08-06
+~~~~~~~~~~~~~~~~~~
+
+* Updated Windows wheels to be compiled against OpenSSL 1.0.1i.
+
+0.5.2 - 2014-07-09
+~~~~~~~~~~~~~~~~~~
+
+* Add ``TraditionalOpenSSLSerializationBackend`` support to
+  :doc:`/hazmat/backends/multibackend`.
+* Fix compilation error on OS X 10.8 (Mountain Lion).
+
+0.5.1 - 2014-07-07
+~~~~~~~~~~~~~~~~~~
+
+* Add ``PKCS8SerializationBackend`` support to
+  :doc:`/hazmat/backends/multibackend`.
+
+0.5 - 2014-07-07
+~~~~~~~~~~~~~~~~
+
+* **BACKWARDS INCOMPATIBLE:**
+  :class:`~cryptography.hazmat.primitives.ciphers.modes.GCM` no longer allows
+  truncation of tags by default. Previous versions of ``cryptography`` allowed
+  tags to be truncated by default, applications wishing to preserve this
+  behavior (not recommended) can pass the ``min_tag_length`` argument.
+* Windows builds now statically link OpenSSL by default. When installing a
+  wheel on Windows you no longer need to install OpenSSL separately. Windows
+  users can switch between static and dynamic linking with an environment
+  variable. See :doc:`/installation` for more details.
+* Added :class:`~cryptography.hazmat.primitives.kdf.hkdf.HKDFExpand`.
+* Added :class:`~cryptography.hazmat.primitives.ciphers.modes.CFB8` support
+  for :class:`~cryptography.hazmat.primitives.ciphers.algorithms.AES` and
+  :class:`~cryptography.hazmat.primitives.ciphers.algorithms.TripleDES` on
+  :doc:`/hazmat/backends/commoncrypto` and :doc:`/hazmat/backends/openssl`.
+* Added ``AES`` :class:`~cryptography.hazmat.primitives.ciphers.modes.CTR`
+  support to the OpenSSL backend when linked against 0.9.8.
+* Added ``PKCS8SerializationBackend`` and
+  ``TraditionalOpenSSLSerializationBackend`` support to the
+  :doc:`/hazmat/backends/openssl`.
+* Added :doc:`/hazmat/primitives/asymmetric/ec` and
+  :class:`~cryptography.hazmat.backends.interfaces.EllipticCurveBackend`.
+* Added :class:`~cryptography.hazmat.primitives.ciphers.modes.ECB` support
+  for :class:`~cryptography.hazmat.primitives.ciphers.algorithms.TripleDES` on
+  :doc:`/hazmat/backends/commoncrypto` and :doc:`/hazmat/backends/openssl`.
+* Deprecated the concrete ``RSAPrivateKey`` class in favor of backend
+  specific providers of the
+  :class:`cryptography.hazmat.primitives.asymmetric.rsa.RSAPrivateKey`
+  interface.
+* Deprecated the concrete ``RSAPublicKey`` in favor of backend specific
+  providers of the
+  :class:`cryptography.hazmat.primitives.asymmetric.rsa.RSAPublicKey`
+  interface.
+* Deprecated the concrete ``DSAPrivateKey`` class in favor of backend
+  specific providers of the
+  :class:`cryptography.hazmat.primitives.asymmetric.dsa.DSAPrivateKey`
+  interface.
+* Deprecated the concrete ``DSAPublicKey`` class in favor of backend specific
+  providers of the
+  :class:`cryptography.hazmat.primitives.asymmetric.dsa.DSAPublicKey`
+  interface.
+* Deprecated the concrete ``DSAParameters`` class in favor of backend specific
+  providers of the
+  :class:`cryptography.hazmat.primitives.asymmetric.dsa.DSAParameters`
+  interface.
+* Deprecated ``encrypt_rsa``, ``decrypt_rsa``, ``create_rsa_signature_ctx`` and
+  ``create_rsa_verification_ctx`` on
+  :class:`~cryptography.hazmat.backends.interfaces.RSABackend`.
+* Deprecated ``create_dsa_signature_ctx`` and ``create_dsa_verification_ctx``
+  on :class:`~cryptography.hazmat.backends.interfaces.DSABackend`.
+
+0.4 - 2014-05-03
+~~~~~~~~~~~~~~~~
+
+* Deprecated ``salt_length`` on
+  :class:`~cryptography.hazmat.primitives.asymmetric.padding.MGF1` and added it
+  to :class:`~cryptography.hazmat.primitives.asymmetric.padding.PSS`. It will
+  be removed from ``MGF1`` in two releases per our :doc:`/api-stability`
+  policy.
+* Added :class:`~cryptography.hazmat.primitives.ciphers.algorithms.SEED`
+  support.
+* Added :class:`~cryptography.hazmat.primitives.cmac.CMAC`.
+* Added decryption support to
+  :class:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPrivateKey`
+  and encryption support to
+  :class:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPublicKey`.
+* Added signature support to
+  :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPrivateKey`
+  and verification support to
+  :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPublicKey`.
+
+0.3 - 2014-03-27
+~~~~~~~~~~~~~~~~
+
+* Added :class:`~cryptography.hazmat.primitives.twofactor.hotp.HOTP`.
+* Added :class:`~cryptography.hazmat.primitives.twofactor.totp.TOTP`.
+* Added :class:`~cryptography.hazmat.primitives.ciphers.algorithms.IDEA`
+  support.
+* Added signature support to
+  :class:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPrivateKey`
+  and verification support to
+  :class:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPublicKey`.
+* Moved test vectors to the new ``cryptography_vectors`` package.
+
+0.2.2 - 2014-03-03
+~~~~~~~~~~~~~~~~~~
+
+* Removed a constant definition that was causing compilation problems with
+  specific versions of OpenSSL.
+
+0.2.1 - 2014-02-22
+~~~~~~~~~~~~~~~~~~
+
+* Fix a bug where importing cryptography from multiple paths could cause
+  initialization to fail.
+
+0.2 - 2014-02-20
+~~~~~~~~~~~~~~~~
+
+* Added :doc:`/hazmat/backends/commoncrypto`.
+* Added initial :doc:`/hazmat/bindings/commoncrypto`.
+* Removed ``register_cipher_adapter`` method from
+  :class:`~cryptography.hazmat.backends.interfaces.CipherBackend`.
+* Added support for the OpenSSL backend under Windows.
+* Improved thread-safety for the OpenSSL backend.
+* Fixed compilation on systems where OpenSSL's ``ec.h`` header is not
+  available, such as CentOS.
+* Added :class:`~cryptography.hazmat.primitives.kdf.pbkdf2.PBKDF2HMAC`.
+* Added :class:`~cryptography.hazmat.primitives.kdf.hkdf.HKDF`.
+* Added :doc:`/hazmat/backends/multibackend`.
+* Set default random for the :doc:`/hazmat/backends/openssl` to the OS
+  random engine.
+* Added :class:`~cryptography.hazmat.primitives.ciphers.algorithms.CAST5`
+  (CAST-128) support.
+
+0.1 - 2014-01-08
+~~~~~~~~~~~~~~~~
+
+* Initial release.
+
+.. _`master`: https://github.com/pyca/cryptography/
+.. _`cffi`: https://cffi.readthedocs.org/en/latest/
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/CONTRIBUTING.rst hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/CONTRIBUTING.rst
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/CONTRIBUTING.rst	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/CONTRIBUTING.rst	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,23 @@
+Contributing to cryptography
+============================
+
+As an open source project, cryptography welcomes contributions of many forms.
+
+Examples of contributions include:
+
+* Code patches
+* Documentation improvements
+* Bug reports and patch reviews
+
+Extensive contribution guidelines are available in the repository at
+``docs/development/index.rst``, or online at:
+
+https://cryptography.io/en/latest/development/
+
+Security issues
+---------------
+
+To report a security issue, please follow the special `security reporting
+guidelines`_, do not report them in the public issue tracker.
+
+.. _`security reporting guidelines`: https://cryptography.io/en/latest/security/
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/api-stability.rst hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/api-stability.rst
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/api-stability.rst	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/api-stability.rst	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,51 @@
+API stability
+=============
+
+From its first release, ``cryptography`` will have a strong API stability
+policy.
+
+What does this policy cover?
+----------------------------
+
+This policy includes any API or behavior that is documented in this
+documentation.
+
+What does "stable" mean?
+------------------------
+
+* Public APIs will not be removed or renamed without providing a compatibility
+  alias.
+* The behavior of existing APIs will not change.
+
+What doesn't this policy cover?
+-------------------------------
+
+* We may add new features, things like the result of ``dir(obj))`` or the
+  contents of ``obj.__dict__`` may change.
+* Objects are not guaranteed to be pickleable, and pickled objects from one
+  version of ``cryptography`` may not be loadable in future versions.
+* Development versions of ``cryptography``. Before a feature is in a release,
+  it is not covered by this policy and may change.
+
+Security
+~~~~~~~~
+
+One exception to our API stability policy is for security. We will violate this
+policy as necessary in order to resolve a security issue or harden
+``cryptography`` against a possible attack.
+
+Deprecation
+-----------
+
+From time to time we will want to change the behavior of an API or remove it
+entirely. In that case, here's how the process will work:
+
+* In ``cryptography X.Y`` the feature exists.
+* In ``cryptography X.Y+1`` using that feature will emit a
+  ``PendingDeprecationWarning``.
+* In ``cryptography X.Y+2`` using that feature will emit a
+  ``DeprecationWarning``.
+* In ``cryptography X.Y+3`` the feature will be removed or changed.
+
+In short, code that runs without warnings will always continue to work for a
+period of two releases.
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/changelog.rst hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/changelog.rst
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/changelog.rst	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/changelog.rst	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1 @@
+.. include:: ../CHANGELOG.rst
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/community.rst hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/community.rst
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/community.rst	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/community.rst	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,20 @@
+Community
+=========
+
+You can find ``cryptography`` all over the web:
+
+* `Mailing list`_
+* `Source code`_
+* `Issue tracker`_
+* `Documentation`_
+* IRC: ``#cryptography-dev`` on ``irc.freenode.net``
+
+Wherever we interact, we strive to follow the `Python Community Code of
+Conduct`_.
+
+
+.. _`Mailing list`: https://mail.python.org/mailman/listinfo/cryptography-dev
+.. _`Source code`: https://github.com/pyca/cryptography
+.. _`Issue tracker`: https://github.com/pyca/cryptography/issues
+.. _`Documentation`: https://cryptography.io/
+.. _`Python Community Code of Conduct`: https://www.python.org/psf/codeofconduct/
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/conf.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/conf.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/conf.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/conf.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,275 @@
+# -*- coding: utf-8 -*-
+
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+#
+# Cryptography documentation build configuration file, created by
+# sphinx-quickstart on Tue Aug  6 19:19:14 2013.
+#
+# This file is execfile()d with the current directory set to its containing dir
+#
+# Note that not all possible configuration values are present in this
+# autogenerated file.
+#
+# All configuration values have a default; values that are commented out
+# serve to show the default.
+
+from __future__ import absolute_import, division, print_function
+
+import os
+import sys
+
+try:
+    import sphinx_rtd_theme
+except ImportError:
+    sphinx_rtd_theme = None
+
+try:
+    from sphinxcontrib import spelling
+except ImportError:
+    spelling = None
+
+
+# If extensions (or modules to document with autodoc) are in another directory,
+# add these directories to sys.path here. If the directory is relative to the
+# documentation root, use os.path.abspath to make it absolute, like shown here.
+sys.path.insert(0, os.path.abspath('.'))
+
+# -- General configuration ----------------------------------------------------
+
+# If your documentation needs a minimal Sphinx version, state it here.
+# needs_sphinx = '1.0'
+
+# Add any Sphinx extension module names here, as strings. They can be
+# extensions  coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
+extensions = [
+    'sphinx.ext.autodoc',
+    'sphinx.ext.doctest',
+    'sphinx.ext.intersphinx',
+    'sphinx.ext.viewcode',
+    'cryptography-docs',
+]
+
+if spelling is not None:
+    extensions.append('sphinxcontrib.spelling')
+
+# Add any paths that contain templates here, relative to this directory.
+templates_path = ['_templates']
+
+nitpicky = True
+
+# The suffix of source filenames.
+source_suffix = '.rst'
+
+# The encoding of source files.
+# source_encoding = 'utf-8-sig'
+
+# The master toctree document.
+master_doc = 'index'
+
+# General information about the project.
+project = 'Cryptography'
+copyright = '2013-2015, Individual Contributors'
+
+# The version info for the project you're documenting, acts as replacement for
+# |version| and |release|, also used in various other places throughout the
+# built documents.
+#
+
+base_dir = os.path.join(os.path.dirname(__file__), os.pardir)
+about = {}
+with open(os.path.join(base_dir, "src", "cryptography", "__about__.py")) as f:
+    exec(f.read(), about)
+
+version = release = about["__version__"]
+
+# The language for content autogenerated by Sphinx. Refer to documentation
+# for a list of supported languages.
+# language = None
+
+# There are two options for replacing |today|: either, you set today to some
+# non-false value, then it is used:
+# today = ''
+# Else, today_fmt is used as the format for a strftime call.
+# today_fmt = '%B %d, %Y'
+
+# List of patterns, relative to source directory, that match files and
+# directories to ignore when looking for source files.
+exclude_patterns = ['_build']
+
+# The reST default role (used for this markup: `text`) to use for all documents
+# default_role = None
+
+# If true, '()' will be appended to :func: etc. cross-reference text.
+# add_function_parentheses = True
+
+# If true, the current module name will be prepended to all description
+# unit titles (such as .. function::).
+# add_module_names = True
+
+# If true, sectionauthor and moduleauthor directives will be shown in the
+# output. They are ignored by default.
+# show_authors = False
+
+# The name of the Pygments (syntax highlighting) style to use.
+pygments_style = 'sphinx'
+
+# A list of ignored prefixes for module index sorting.
+# modindex_common_prefix = []
+
+
+# -- Options for HTML output --------------------------------------------------
+
+# The theme to use for HTML and HTML Help pages.  See the documentation for
+# a list of builtin themes.
+
+if sphinx_rtd_theme:
+    html_theme = "sphinx_rtd_theme"
+    html_theme_path = [sphinx_rtd_theme.get_html_theme_path()]
+else:
+    html_theme = "default"
+
+# Theme options are theme-specific and customize the look and feel of a theme
+# further.  For a list of options available for each theme, see the
+# documentation.
+# html_theme_options = {}
+
+# The name for this set of Sphinx documents.  If None, it defaults to
+# "<project> v<release> documentation".
+# html_title = None
+
+# A shorter title for the navigation bar.  Default is the same as html_title.
+# html_short_title = None
+
+# The name of an image file (relative to this directory) to place at the top
+# of the sidebar.
+# html_logo = None
+
+# The name of an image file (within the static path) to use as favicon of the
+# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
+# pixels large.
+# html_favicon = None
+
+# Add any paths that contain custom static files (such as style sheets) here,
+# relative to this directory. They are copied after the builtin static files,
+# so a file named "default.css" will overwrite the builtin "default.css".
+html_static_path = ['_static']
+
+# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
+# using the given strftime format.
+# html_last_updated_fmt = '%b %d, %Y'
+
+# If true, SmartyPants will be used to convert quotes and dashes to
+# typographically correct entities.
+# html_use_smartypants = True
+
+# Custom sidebar templates, maps document names to template names.
+# html_sidebars = {}
+
+# Additional templates that should be rendered to pages, maps page names to
+# template names.
+# html_additional_pages = {}
+
+# If false, no module index is generated.
+# html_domain_indices = True
+
+# If false, no index is generated.
+# html_use_index = True
+
+# If true, the index is split into individual pages for each letter.
+# html_split_index = False
+
+# If true, links to the reST sources are added to the pages.
+# html_show_sourcelink = True
+
+# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
+# html_show_sphinx = True
+
+# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
+# html_show_copyright = True
+
+# If true, an OpenSearch description file will be output, and all pages will
+# contain a <link> tag referring to it.  The value of this option must be the
+# base URL from which the finished HTML is served.
+# html_use_opensearch = ''
+
+# This is the file name suffix for HTML files (e.g. ".xhtml").
+# html_file_suffix = None
+
+# Output file base name for HTML help builder.
+htmlhelp_basename = 'Cryptographydoc'
+
+
+# -- Options for LaTeX output -------------------------------------------------
+
+latex_elements = {
+}
+
+# Grouping the document tree into LaTeX files. List of tuples
+# (source start file, target name, title, author, documentclass [howto/manual])
+latex_documents = [
+    ('index', 'Cryptography.tex', 'Cryptography Documentation',
+        'Individual Contributors', 'manual'),
+]
+
+# The name of an image file (relative to this directory) to place at the top of
+# the title page.
+# latex_logo = None
+
+# For "manual" documents, if this is true, then toplevel headings are parts,
+# not chapters.
+# latex_use_parts = False
+
+# If true, show page references after internal links.
+# latex_show_pagerefs = False
+
+# If true, show URL addresses after external links.
+# latex_show_urls = False
+
+# Documents to append as an appendix to all manuals.
+# latex_appendices = []
+
+# If false, no module index is generated.
+# latex_domain_indices = True
+
+
+# -- Options for manual page output -------------------------------------------
+
+# One entry per manual page. List of tuples
+# (source start file, name, description, authors, manual section).
+man_pages = [
+    ('index', 'cryptography', 'Cryptography Documentation',
+        ['Individual Contributors'], 1)
+]
+
+# If true, show URL addresses after external links.
+# man_show_urls = False
+
+
+# -- Options for Texinfo output -----------------------------------------------
+
+# Grouping the document tree into Texinfo files. List of tuples
+# (source start file, target name, title, author,
+#  dir menu entry, description, category)
+texinfo_documents = [
+    ('index', 'Cryptography', 'Cryptography Documentation',
+        'Individual Contributors', 'Cryptography',
+        'One line description of project.',
+        'Miscellaneous'),
+]
+
+# Documents to append as an appendix to all manuals.
+# texinfo_appendices = []
+
+# If false, no module index is generated.
+# texinfo_domain_indices = True
+
+# How to display URL addresses: 'footnote', 'no', or 'inline'.
+# texinfo_show_urls = 'footnote'
+
+# Example configuration for intersphinx: refer to the Python standard library.
+intersphinx_mapping = {'https://docs.python.org/3': None}
+
+epub_theme = 'epub'
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/cryptography-docs.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/cryptography-docs.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/cryptography-docs.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/cryptography-docs.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,70 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+from docutils import nodes
+
+from sphinx.util.compat import Directive, make_admonition
+
+
+DANGER_MESSAGE = """
+This is a "Hazardous Materials" module. You should **ONLY** use it if you're
+100% absolutely sure that you know what you're doing because this module is
+full of land mines, dragons, and dinosaurs with laser guns.
+"""
+
+DANGER_ALTERNATE = """
+
+You may instead be interested in :doc:`{alternate}`.
+"""
+
+
+class HazmatDirective(Directive):
+    has_content = True
+
+    def run(self):
+        message = DANGER_MESSAGE
+        if self.content:
+            message += DANGER_ALTERNATE.format(alternate=self.content[0])
+
+        ad = make_admonition(
+            Hazmat,
+            self.name,
+            [],
+            self.options,
+            nodes.paragraph("", message),
+            self.lineno,
+            self.content_offset,
+            self.block_text,
+            self.state,
+            self.state_machine
+        )
+        ad[0].line = self.lineno
+        return ad
+
+
+class Hazmat(nodes.Admonition, nodes.Element):
+    pass
+
+
+def html_visit_hazmat_node(self, node):
+    return self.visit_admonition(node, "danger")
+
+
+def latex_visit_hazmat_node(self, node):
+    return self.visit_admonition(node)
+
+
+def depart_hazmat_node(self, node):
+    return self.depart_admonition(node)
+
+
+def setup(app):
+    app.add_node(
+        Hazmat,
+        html=(html_visit_hazmat_node, depart_hazmat_node),
+        latex=(latex_visit_hazmat_node, depart_hazmat_node),
+    )
+    app.add_directive("hazmat", HazmatDirective)
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/development/c-bindings.rst hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/development/c-bindings.rst
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/development/c-bindings.rst	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/development/c-bindings.rst	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,196 @@
+C bindings
+==========
+
+C bindings are bindings to C libraries, using cffi_ whenever possible.
+
+.. _cffi: https://cffi.readthedocs.org
+
+Bindings live in :py:mod:`cryptography.hazmat.bindings`.
+
+When modifying the bindings you will need to recompile the C extensions to
+test the changes. This can be accomplished with ``pip install -e .`` in the
+project root. If you do not do this a ``RuntimeError`` will be raised.
+
+Style guide
+-----------
+
+Don't name parameters:
+
+.. code-block:: c
+
+    /* Good */
+    long f(long);
+    /* Bad */
+    long f(long x);
+
+...unless they're inside a struct:
+
+.. code-block:: c
+
+    struct my_struct {
+        char *name;
+        int number;
+        ...;
+    };
+
+Include ``void`` if the function takes no arguments:
+
+.. code-block:: c
+
+    /* Good */
+    long f(void);
+    /* Bad */
+    long f();
+
+Wrap lines at 80 characters like so:
+
+.. code-block:: c
+
+    /* Pretend this went to 80 characters */
+    long f(long, long,
+           int *)
+
+Include a space after commas between parameters:
+
+.. code-block:: c
+
+    /* Good */
+    long f(int, char *)
+    /* Bad */
+    long f(int,char *)
+
+Use C-style ``/* */`` comments instead of C++-style ``//``:
+
+.. code-block:: c
+
+    // Bad
+    /* Good */
+
+Values set by ``#define`` should be assigned the appropriate type. If you see
+this:
+
+.. code-block:: c
+
+    #define SOME_INTEGER_LITERAL 0x0;
+    #define SOME_UNSIGNED_INTEGER_LITERAL 0x0001U;
+    #define SOME_STRING_LITERAL "hello";
+
+...it should be added to the bindings like so:
+
+.. code-block:: c
+
+    static const int SOME_INTEGER_LITERAL;
+    static const unsigned int SOME_UNSIGNED_INTEGER_LITERAL;
+    static const char *const SOME_STRING_LITERAL;
+
+Adding constant, types, functions...
+------------------------------------
+
+You can create bindings for any name that exists in some version of
+the library you're binding against. However, the project also has to
+keep supporting older versions of the library. In order to achieve
+this, binding modules have ``CUSTOMIZATIONS`` and
+``CONDITIONAL_NAMES`` constants.
+
+Let's say you want to enable quantum transmogrification. The upstream
+library implements this as the following API::
+
+    static const int QM_TRANSMOGRIFICATION_ALIGNMENT_LEFT;
+    static const int QM_TRANSMOGRIFICATION_ALIGNMENT_RIGHT;
+    typedef ... QM_TRANSMOGRIFICATION_CTX;
+    int QM_transmogrify(QM_TRANSMOGRIFICATION_CTX *, int);
+
+To start, create a new constant that defines if the *actual* library
+has the feature you want, and add it to ``TYPES``::
+
+    static const long Cryptography_HAS_QUANTUM_TRANSMOGRIFICATION;
+
+This should start with ``Cryptography_``, since we're adding it in
+this library. This prevents namespace collisions.
+
+Then, define the actual features (constants, types, functions...) you
+want to expose. If it's a constant, just add it to ``TYPES``::
+
+    static const int QM_TRANSMOGRIFICATION_ALIGNMENT_LEFT;
+    static const int QM_TRANSMOGRIFICATION_ALIGNMENT_RIGHT;
+
+If it's a struct, add it to ``TYPES`` as well. The following is an
+opaque struct::
+
+    typedef ... QM_TRANSMOGRIFICATION_CTX;
+
+... but you can also make some or all items in the struct accessible::
+
+    typedef struct {
+        /* Fundamental constant k for your particular universe */
+        BIGNUM *k;
+        ...;
+    } QM_TRANSMOGRIFICATION_CTX;
+
+Confusingly, functions that aren't always available on all supported
+versions of the library, should be defined in ``MACROS`` and *not* in
+``FUNCTIONS``. Fortunately, you just have to copy the signature::
+
+    int QM_transmogrify(QM_TRANSMOGRIFICATION_CTX *, int);
+
+Then, we define the ``CUSTOMIZATIONS`` entry. To do that, we have to
+come up with a C preprocessor expression that decides whether or not a
+feature exists in the library. For example::
+
+    #ifdef QM_transmogrify
+
+Then, we set the flag that signifies the feature exists::
+
+    static const long Cryptography_HAS_QUANTUM_TRANSMOGRIFICATION = 1;
+
+Otherwise, we set that flag to 0::
+
+    #else
+    static const long Cryptography_HAS_QUANTUM_TRANSMOGRIFICATION = 0;
+
+Then, in that ``#else`` block, we define the names that aren't
+available as dummy values. For an integer constant, use 0::
+
+    static const int QM_TRANSMOGRIFICATION_ALIGNMENT_LEFT = 0;
+    static const int QM_TRANSMOGRIFICATION_ALIGNMENT_RIGHT = 0;
+
+For a function, it's a bit trickier. You have to define a function
+pointer of the appropriate type to be NULL::
+
+    int (*QM_transmogrify)(QM_TRANSMOGRIFICATION_CTX *, int) = NULL;
+
+(To do that, copy the signature, put a ``*`` in front of the function
+name and wrap it in parentheses, and then put ``= NULL`` at the end).
+
+Note how types don't need to be conditionally defined, as long as all
+the necessarily type definitions are in place.
+
+Finally, add an entry to ``CONDITIONAL_NAMES`` with all of the things
+you want to conditionally export::
+
+    CONDITIONAL_NAMES = {
+        ...
+        "Cryptography_HAS_QUANTUM_TRANSMOGRIFICATION": [
+            "QM_TRANSMOGRIFICATION_ALIGNMENT_LEFT",
+            "QM_TRANSMOGRIFICATION_ALIGNMENT_RIGHT",
+            "QM_transmogrify"
+        ]
+    }
+
+Caveats
+~~~~~~~
+
+Sometimes, a set of loosely related features are added in the same
+version, and it's impractical to create ``#ifdef`` statements for each
+one. In that case, it may make sense to either check for a particular
+version. For example, to check for OpenSSL 1.0.0 or newer::
+
+    #if OPENSSL_VERSION_NUMBER >= 0x10000000L
+
+Sometimes, the version of a library on a particular platform will have
+features that you thought it wouldn't, based on its version.
+Occasionally, packagers appear to ship arbitrary VCS checkouts. As a
+result, sometimes you may have to add separate ``#ifdef`` statements
+for particular features. This kind of issue is typically only caught
+by running the tests on a wide variety of systems, which is the job of
+our continuous integration infrastructure.
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/development/custom-vectors/cast5/generate_cast5.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/development/custom-vectors/cast5/generate_cast5.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/development/custom-vectors/cast5/generate_cast5.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/development/custom-vectors/cast5/generate_cast5.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,67 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import binascii
+
+from cryptography.hazmat.backends import default_backend
+from cryptography.hazmat.primitives.ciphers import algorithms, base, modes
+
+
+def encrypt(mode, key, iv, plaintext):
+    cipher = base.Cipher(
+        algorithms.CAST5(binascii.unhexlify(key)),
+        mode(binascii.unhexlify(iv)),
+        default_backend()
+    )
+    encryptor = cipher.encryptor()
+    ct = encryptor.update(binascii.unhexlify(plaintext))
+    ct += encryptor.finalize()
+    return binascii.hexlify(ct)
+
+
+def build_vectors(mode, filename):
+    vector_file = open(filename, "r")
+
+    count = 0
+    output = []
+    key = None
+    iv = None
+    plaintext = None
+    for line in vector_file:
+        line = line.strip()
+        if line.startswith("KEY"):
+            if count != 0:
+                output.append("CIPHERTEXT = {}".format(
+                    encrypt(mode, key, iv, plaintext))
+                )
+            output.append("\nCOUNT = {}".format(count))
+            count += 1
+            name, key = line.split(" = ")
+            output.append("KEY = {}".format(key))
+        elif line.startswith("IV"):
+            name, iv = line.split(" = ")
+            iv = iv[0:16]
+            output.append("IV = {}".format(iv))
+        elif line.startswith("PLAINTEXT"):
+            name, plaintext = line.split(" = ")
+            output.append("PLAINTEXT = {}".format(plaintext))
+
+    output.append("CIPHERTEXT = {}".format(encrypt(mode, key, iv, plaintext)))
+    return "\n".join(output)
+
+
+def write_file(data, filename):
+    with open(filename, "w") as f:
+        f.write(data)
+
+cbc_path = "tests/hazmat/primitives/vectors/ciphers/AES/CBC/CBCMMT128.rsp"
+write_file(build_vectors(modes.CBC, cbc_path), "cast5-cbc.txt")
+ofb_path = "tests/hazmat/primitives/vectors/ciphers/AES/OFB/OFBMMT128.rsp"
+write_file(build_vectors(modes.OFB, ofb_path), "cast5-ofb.txt")
+cfb_path = "tests/hazmat/primitives/vectors/ciphers/AES/CFB/CFB128MMT128.rsp"
+write_file(build_vectors(modes.CFB, cfb_path), "cast5-cfb.txt")
+ctr_path = "tests/hazmat/primitives/vectors/ciphers/AES/CTR/aes-128-ctr.txt"
+write_file(build_vectors(modes.CTR, ctr_path), "cast5-ctr.txt")
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/development/custom-vectors/cast5/verify_cast5.go hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/development/custom-vectors/cast5/verify_cast5.go
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/development/custom-vectors/cast5/verify_cast5.go	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/development/custom-vectors/cast5/verify_cast5.go	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,164 @@
+package main
+
+import (
+	"bufio"
+	"bytes"
+	"code.google.com/p/go.crypto/cast5"
+	"crypto/cipher"
+	"encoding/hex"
+	"fmt"
+	"os"
+	"strings"
+)
+
+func unhexlify(s string) []byte {
+	bytes, err := hex.DecodeString(s)
+	if err != nil {
+		panic(err)
+	}
+	return bytes
+}
+
+type vectorArgs struct {
+	count      string
+	key        string
+	iv         string
+	plaintext  string
+	ciphertext string
+}
+
+type vectorVerifier interface {
+	validate(count string, key, iv, plaintext, expectedCiphertext []byte)
+}
+
+type ofbVerifier struct{}
+
+func (o ofbVerifier) validate(count string, key, iv, plaintext, expectedCiphertext []byte) {
+	block, err := cast5.NewCipher(key)
+	if err != nil {
+		panic(err)
+	}
+
+	ciphertext := make([]byte, len(plaintext))
+	stream := cipher.NewOFB(block, iv)
+	stream.XORKeyStream(ciphertext, plaintext)
+
+	if !bytes.Equal(ciphertext, expectedCiphertext) {
+		panic(fmt.Errorf("vector mismatch @ COUNT = %s:\n  %s != %s\n",
+			count,
+			hex.EncodeToString(expectedCiphertext),
+			hex.EncodeToString(ciphertext)))
+	}
+}
+
+type cbcVerifier struct{}
+
+func (o cbcVerifier) validate(count string, key, iv, plaintext, expectedCiphertext []byte) {
+	block, err := cast5.NewCipher(key)
+	if err != nil {
+		panic(err)
+	}
+
+	ciphertext := make([]byte, len(plaintext))
+	mode := cipher.NewCBCEncrypter(block, iv)
+	mode.CryptBlocks(ciphertext, plaintext)
+
+	if !bytes.Equal(ciphertext, expectedCiphertext) {
+		panic(fmt.Errorf("vector mismatch @ COUNT = %s:\n  %s != %s\n",
+			count,
+			hex.EncodeToString(expectedCiphertext),
+			hex.EncodeToString(ciphertext)))
+	}
+}
+
+type cfbVerifier struct{}
+
+func (o cfbVerifier) validate(count string, key, iv, plaintext, expectedCiphertext []byte) {
+	block, err := cast5.NewCipher(key)
+	if err != nil {
+		panic(err)
+	}
+
+	ciphertext := make([]byte, len(plaintext))
+	stream := cipher.NewCFBEncrypter(block, iv)
+	stream.XORKeyStream(ciphertext, plaintext)
+
+	if !bytes.Equal(ciphertext, expectedCiphertext) {
+		panic(fmt.Errorf("vector mismatch @ COUNT = %s:\n  %s != %s\n",
+			count,
+			hex.EncodeToString(expectedCiphertext),
+			hex.EncodeToString(ciphertext)))
+	}
+}
+
+type ctrVerifier struct{}
+
+func (o ctrVerifier) validate(count string, key, iv, plaintext, expectedCiphertext []byte) {
+	block, err := cast5.NewCipher(key)
+	if err != nil {
+		panic(err)
+	}
+
+	ciphertext := make([]byte, len(plaintext))
+	stream := cipher.NewCTR(block, iv)
+	stream.XORKeyStream(ciphertext, plaintext)
+
+	if !bytes.Equal(ciphertext, expectedCiphertext) {
+		panic(fmt.Errorf("vector mismatch @ COUNT = %s:\n  %s != %s\n",
+			count,
+			hex.EncodeToString(expectedCiphertext),
+			hex.EncodeToString(ciphertext)))
+	}
+}
+
+func validateVectors(verifier vectorVerifier, filename string) {
+	vectors, err := os.Open(filename)
+	if err != nil {
+		panic(err)
+	}
+	defer vectors.Close()
+
+	var segments []string
+	var vector *vectorArgs
+
+	scanner := bufio.NewScanner(vectors)
+	for scanner.Scan() {
+		segments = strings.Split(scanner.Text(), " = ")
+
+		switch {
+		case strings.ToUpper(segments[0]) == "COUNT":
+			if vector != nil {
+				verifier.validate(vector.count,
+					unhexlify(vector.key),
+					unhexlify(vector.iv),
+					unhexlify(vector.plaintext),
+					unhexlify(vector.ciphertext))
+			}
+			vector = &vectorArgs{count: segments[1]}
+		case strings.ToUpper(segments[0]) == "IV":
+			vector.iv = segments[1][:16]
+		case strings.ToUpper(segments[0]) == "KEY":
+			vector.key = segments[1]
+		case strings.ToUpper(segments[0]) == "PLAINTEXT":
+			vector.plaintext = segments[1]
+		case strings.ToUpper(segments[0]) == "CIPHERTEXT":
+			vector.ciphertext = segments[1]
+		}
+	}
+
+}
+
+func main() {
+	validateVectors(ofbVerifier{},
+		"vectors/cryptography_vectors/ciphers/CAST5/cast5-ofb.txt")
+	fmt.Println("OFB OK.")
+	validateVectors(cfbVerifier{},
+		"vectors/cryptography_vectors/ciphers/CAST5/cast5-cfb.txt")
+	fmt.Println("CFB OK.")
+	validateVectors(cbcVerifier{},
+		"vectors/cryptography_vectors/ciphers/CAST5/cast5-cbc.txt")
+	fmt.Println("CBC OK.")
+	validateVectors(ctrVerifier{},
+		"vectors/cryptography_vectors/ciphers/CAST5/cast5-ctr.txt")
+	fmt.Println("CTR OK.")
+}
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/development/custom-vectors/cast5.rst hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/development/custom-vectors/cast5.rst
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/development/custom-vectors/cast5.rst	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/development/custom-vectors/cast5.rst	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,31 @@
+CAST5 vector creation
+=====================
+
+This page documents the code that was used to generate the CAST5 CBC, CFB, OFB,
+and CTR test vectors as well as the code used to verify them against another
+implementation. The CBC, CFB, and OFB vectors were generated using OpenSSL and
+the CTR vectors were generated using Apple's CommonCrypto. All the generated
+vectors were verified with Go.
+
+Creation
+--------
+
+``cryptography`` was modified to support CAST5 in CBC, CFB, and OFB modes. Then
+the following Python script was run to generate the vector files.
+
+.. literalinclude:: /development/custom-vectors/cast5/generate_cast5.py
+
+Download link: :download:`generate_cast5.py
+</development/custom-vectors/cast5/generate_cast5.py>`
+
+
+Verification
+------------
+
+The following Go code was used to verify the vectors.
+
+.. literalinclude:: /development/custom-vectors/cast5/verify_cast5.go
+    :language: go
+
+Download link: :download:`verify_cast5.go
+</development/custom-vectors/cast5/verify_cast5.go>`
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/development/custom-vectors/idea/generate_idea.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/development/custom-vectors/idea/generate_idea.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/development/custom-vectors/idea/generate_idea.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/development/custom-vectors/idea/generate_idea.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,60 @@
+import binascii
+
+from cryptography.hazmat.backends.openssl.backend import backend
+from cryptography.hazmat.primitives.ciphers import algorithms, base, modes
+
+
+def encrypt(mode, key, iv, plaintext):
+    cipher = base.Cipher(
+        algorithms.IDEA(binascii.unhexlify(key)),
+        mode(binascii.unhexlify(iv)),
+        backend
+    )
+    encryptor = cipher.encryptor()
+    ct = encryptor.update(binascii.unhexlify(plaintext))
+    ct += encryptor.finalize()
+    return binascii.hexlify(ct)
+
+
+def build_vectors(mode, filename):
+    with open(filename, "r") as f:
+        vector_file = f.read().splitlines()
+
+    count = 0
+    output = []
+    key = None
+    iv = None
+    plaintext = None
+    for line in vector_file:
+        line = line.strip()
+        if line.startswith("KEY"):
+            if count != 0:
+                output.append("CIPHERTEXT = {0}".format(
+                    encrypt(mode, key, iv, plaintext))
+                )
+            output.append("\nCOUNT = {0}".format(count))
+            count += 1
+            name, key = line.split(" = ")
+            output.append("KEY = {0}".format(key))
+        elif line.startswith("IV"):
+            name, iv = line.split(" = ")
+            iv = iv[0:16]
+            output.append("IV = {0}".format(iv))
+        elif line.startswith("PLAINTEXT"):
+            name, plaintext = line.split(" = ")
+            output.append("PLAINTEXT = {0}".format(plaintext))
+
+    output.append("CIPHERTEXT = {0}".format(encrypt(mode, key, iv, plaintext)))
+    return "\n".join(output)
+
+
+def write_file(data, filename):
+    with open(filename, "w") as f:
+        f.write(data)
+
+CBC_PATH = "tests/hazmat/primitives/vectors/ciphers/AES/CBC/CBCMMT128.rsp"
+write_file(build_vectors(modes.CBC, CBC_PATH), "idea-cbc.txt")
+OFB_PATH = "tests/hazmat/primitives/vectors/ciphers/AES/OFB/OFBMMT128.rsp"
+write_file(build_vectors(modes.OFB, OFB_PATH), "idea-ofb.txt")
+CFB_PATH = "tests/hazmat/primitives/vectors/ciphers/AES/CFB/CFB128MMT128.rsp"
+write_file(build_vectors(modes.CFB, CFB_PATH), "idea-cfb.txt")
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/development/custom-vectors/idea/verify_idea.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/development/custom-vectors/idea/verify_idea.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/development/custom-vectors/idea/verify_idea.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/development/custom-vectors/idea/verify_idea.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,39 @@
+import binascii
+
+import botan
+
+from tests.utils import load_nist_vectors
+
+BLOCK_SIZE = 64
+
+
+def encrypt(mode, key, iv, plaintext):
+    encryptor = botan.Cipher("IDEA/{0}/NoPadding".format(mode), "encrypt",
+                             binascii.unhexlify(key))
+
+    cipher_text = encryptor.cipher(binascii.unhexlify(plaintext),
+                                   binascii.unhexlify(iv))
+    return binascii.hexlify(cipher_text)
+
+
+def verify_vectors(mode, filename):
+    with open(filename, "r") as f:
+        vector_file = f.read().splitlines()
+
+    vectors = load_nist_vectors(vector_file)
+    for vector in vectors:
+        ct = encrypt(
+            mode,
+            vector["key"],
+            vector["iv"],
+            vector["plaintext"]
+        )
+        assert ct == vector["ciphertext"]
+
+
+cbc_path = "tests/hazmat/primitives/vectors/ciphers/IDEA/idea-cbc.txt"
+verify_vectors("CBC", cbc_path)
+ofb_path = "tests/hazmat/primitives/vectors/ciphers/IDEA/idea-ofb.txt"
+verify_vectors("OFB", ofb_path)
+cfb_path = "tests/hazmat/primitives/vectors/ciphers/IDEA/idea-cfb.txt"
+verify_vectors("CFB", cfb_path)
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/development/custom-vectors/idea.rst hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/development/custom-vectors/idea.rst
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/development/custom-vectors/idea.rst	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/development/custom-vectors/idea.rst	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,32 @@
+IDEA vector creation
+=====================
+
+This page documents the code that was used to generate the IDEA CBC, CFB, and
+OFB test vectors as well as the code used to verify them against another
+implementation. The vectors were generated using OpenSSL and verified with
+`Botan`_.
+
+Creation
+--------
+
+``cryptography`` was modified to support IDEA in CBC, CFB, and OFB modes. Then
+the following python script was run to generate the vector files.
+
+.. literalinclude:: /development/custom-vectors/idea/generate_idea.py
+
+Download link: :download:`generate_idea.py
+</development/custom-vectors/idea/generate_idea.py>`
+
+
+Verification
+------------
+
+The following Python code was used to verify the vectors using the `Botan`_
+project's Python bindings.
+
+.. literalinclude:: /development/custom-vectors/idea/verify_idea.py
+
+Download link: :download:`verify_idea.py
+</development/custom-vectors/idea/verify_idea.py>`
+
+.. _`Botan`: http://botan.randombit.net
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/development/custom-vectors/secp256k1/generate_secp256k1.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/development/custom-vectors/secp256k1/generate_secp256k1.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/development/custom-vectors/secp256k1/generate_secp256k1.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/development/custom-vectors/secp256k1/generate_secp256k1.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,89 @@
+from __future__ import absolute_import, print_function
+
+import hashlib
+import os
+from binascii import hexlify
+from collections import defaultdict
+
+from ecdsa import SECP256k1, SigningKey
+from ecdsa.util import sigdecode_der, sigencode_der
+
+from cryptography_vectors import open_vector_file
+
+from tests.utils import (
+    load_fips_ecdsa_signing_vectors, load_vectors_from_file
+)
+
+HASHLIB_HASH_TYPES = {
+    "SHA-1": hashlib.sha1,
+    "SHA-224": hashlib.sha224,
+    "SHA-256": hashlib.sha256,
+    "SHA-384": hashlib.sha384,
+    "SHA-512": hashlib.sha512,
+}
+
+
+class TruncatedHash(object):
+    def __init__(self, hasher):
+        self.hasher = hasher
+
+    def __call__(self, data):
+        self.hasher.update(data)
+        return self
+
+    def digest(self):
+        return self.hasher.digest()[:256 // 8]
+
+
+def build_vectors(fips_vectors):
+    vectors = defaultdict(list)
+    for vector in fips_vectors:
+        vectors[vector['digest_algorithm']].append(vector['message'])
+
+    for digest_algorithm, messages in vectors.items():
+        if digest_algorithm not in HASHLIB_HASH_TYPES:
+            continue
+
+        yield ""
+        yield "[K-256,{0}]".format(digest_algorithm)
+        yield ""
+
+        for message in messages:
+            # Make a hash context
+            hash_func = TruncatedHash(HASHLIB_HASH_TYPES[digest_algorithm]())
+
+            # Sign the message using warner/ecdsa
+            secret_key = SigningKey.generate(curve=SECP256k1)
+            public_key = secret_key.get_verifying_key()
+            signature = secret_key.sign(message, hashfunc=hash_func,
+                                        sigencode=sigencode_der)
+
+            r, s = sigdecode_der(signature, None)
+
+            yield "Msg = {0}".format(hexlify(message))
+            yield "d = {0:x}".format(secret_key.privkey.secret_multiplier)
+            yield "Qx = {0:x}".format(public_key.pubkey.point.x())
+            yield "Qy = {0:x}".format(public_key.pubkey.point.y())
+            yield "R = {0:x}".format(r)
+            yield "S = {0:x}".format(s)
+            yield ""
+
+
+def write_file(lines, dest):
+    for line in lines:
+        print(line)
+        print(line, file=dest)
+
+source_path = os.path.join("asymmetric", "ECDSA", "FIPS_186-3", "SigGen.txt")
+dest_path = os.path.join("asymmetric", "ECDSA", "SECP256K1", "SigGen.txt")
+
+fips_vectors = load_vectors_from_file(
+    source_path,
+    load_fips_ecdsa_signing_vectors
+)
+
+with open_vector_file(dest_path, "w") as dest_file:
+    write_file(
+        build_vectors(fips_vectors),
+        dest_file
+    )
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/development/custom-vectors/secp256k1/verify_secp256k1.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/development/custom-vectors/secp256k1/verify_secp256k1.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/development/custom-vectors/secp256k1/verify_secp256k1.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/development/custom-vectors/secp256k1/verify_secp256k1.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,59 @@
+from __future__ import absolute_import, print_function
+
+import os
+
+from cryptography.hazmat.backends import default_backend
+from cryptography.hazmat.primitives import hashes
+from cryptography.hazmat.primitives.asymmetric import ec
+from cryptography.hazmat.primitives.asymmetric.utils import (
+    encode_rfc6979_signature
+)
+
+from tests.utils import (
+    load_fips_ecdsa_signing_vectors, load_vectors_from_file
+)
+
+CRYPTOGRAPHY_HASH_TYPES = {
+    "SHA-1": hashes.SHA1,
+    "SHA-224": hashes.SHA224,
+    "SHA-256": hashes.SHA256,
+    "SHA-384": hashes.SHA384,
+    "SHA-512": hashes.SHA512,
+}
+
+
+def verify_one_vector(vector):
+    digest_algorithm = vector['digest_algorithm']
+    message = vector['message']
+    x = vector['x']
+    y = vector['y']
+    signature = encode_rfc6979_signature(vector['r'], vector['s'])
+
+    numbers = ec.EllipticCurvePublicNumbers(
+        x, y,
+        ec.SECP256K1()
+    )
+
+    key = numbers.public_key(default_backend())
+
+    verifier = key.verifier(
+        signature,
+        ec.ECDSA(CRYPTOGRAPHY_HASH_TYPES[digest_algorithm]())
+    )
+    verifier.update(message)
+    return verifier.verify()
+
+
+def verify_vectors(vectors):
+    for vector in vectors:
+        assert verify_one_vector(vector)
+
+
+vector_path = os.path.join("asymmetric", "ECDSA", "SECP256K1", "SigGen.txt")
+
+secp256k1_vectors = load_vectors_from_file(
+    vector_path,
+    load_fips_ecdsa_signing_vectors
+)
+
+verify_vectors(secp256k1_vectors)
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/development/custom-vectors/secp256k1.rst hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/development/custom-vectors/secp256k1.rst
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/development/custom-vectors/secp256k1.rst	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/development/custom-vectors/secp256k1.rst	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,32 @@
+SECP256K1 vector creation
+=========================
+
+This page documents the code that was used to generate the SECP256K1 elliptic
+curve test vectors as well as code used to verify them against another
+implementation.
+
+
+Creation
+--------
+
+The vectors are generated using a `pure Python ecdsa`_ implementation. The test
+messages and combinations of algorithms are derived from the NIST vector data.
+
+.. literalinclude:: /development/custom-vectors/secp256k1/generate_secp256k1.py
+
+Download link: :download:`generate_secp256k1.py
+</development/custom-vectors/secp256k1/generate_secp256k1.py>`
+
+
+Verification
+------------
+
+``cryptography`` was modified to support the SECP256K1 curve. Then
+the following python script was run to generate the vector files.
+
+.. literalinclude:: /development/custom-vectors/secp256k1/verify_secp256k1.py
+
+Download link: :download:`verify_secp256k1.py
+</development/custom-vectors/secp256k1/verify_secp256k1.py>`
+
+.. _`pure Python ecdsa`: https://pypi.python.org/pypi/ecdsa
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/development/custom-vectors/seed/generate_seed.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/development/custom-vectors/seed/generate_seed.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/development/custom-vectors/seed/generate_seed.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/development/custom-vectors/seed/generate_seed.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,57 @@
+import binascii
+
+from cryptography.hazmat.backends.openssl.backend import backend
+from cryptography.hazmat.primitives.ciphers import algorithms, base, modes
+
+
+def encrypt(mode, key, iv, plaintext):
+    cipher = base.Cipher(
+        algorithms.SEED(binascii.unhexlify(key)),
+        mode(binascii.unhexlify(iv)),
+        backend
+    )
+    encryptor = cipher.encryptor()
+    ct = encryptor.update(binascii.unhexlify(plaintext))
+    ct += encryptor.finalize()
+    return binascii.hexlify(ct)
+
+
+def build_vectors(mode, filename):
+    with open(filename, "r") as f:
+        vector_file = f.read().splitlines()
+
+    count = 0
+    output = []
+    key = None
+    iv = None
+    plaintext = None
+    for line in vector_file:
+        line = line.strip()
+        if line.startswith("KEY"):
+            if count != 0:
+                output.append("CIPHERTEXT = {0}".format(
+                    encrypt(mode, key, iv, plaintext))
+                )
+            output.append("\nCOUNT = {0}".format(count))
+            count += 1
+            name, key = line.split(" = ")
+            output.append("KEY = {0}".format(key))
+        elif line.startswith("IV"):
+            name, iv = line.split(" = ")
+            output.append("IV = {0}".format(iv))
+        elif line.startswith("PLAINTEXT"):
+            name, plaintext = line.split(" = ")
+            output.append("PLAINTEXT = {0}".format(plaintext))
+
+    output.append("CIPHERTEXT = {0}".format(encrypt(mode, key, iv, plaintext)))
+    return "\n".join(output)
+
+
+def write_file(data, filename):
+    with open(filename, "w") as f:
+        f.write(data)
+
+OFB_PATH = "vectors/cryptography_vectors/ciphers/AES/OFB/OFBMMT128.rsp"
+write_file(build_vectors(modes.OFB, OFB_PATH), "seed-ofb.txt")
+CFB_PATH = "vectors/cryptography_vectors/ciphers/AES/CFB/CFB128MMT128.rsp"
+write_file(build_vectors(modes.CFB, CFB_PATH), "seed-cfb.txt")
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/development/custom-vectors/seed/verify_seed.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/development/custom-vectors/seed/verify_seed.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/development/custom-vectors/seed/verify_seed.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/development/custom-vectors/seed/verify_seed.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,35 @@
+import binascii
+
+import botan
+
+from tests.utils import load_nist_vectors
+
+
+def encrypt(mode, key, iv, plaintext):
+    encryptor = botan.Cipher("SEED/{0}/NoPadding".format(mode), "encrypt",
+                             binascii.unhexlify(key))
+
+    cipher_text = encryptor.cipher(binascii.unhexlify(plaintext),
+                                   binascii.unhexlify(iv))
+    return binascii.hexlify(cipher_text)
+
+
+def verify_vectors(mode, filename):
+    with open(filename, "r") as f:
+        vector_file = f.read().splitlines()
+
+    vectors = load_nist_vectors(vector_file)
+    for vector in vectors:
+        ct = encrypt(
+            mode,
+            vector["key"],
+            vector["iv"],
+            vector["plaintext"]
+        )
+        assert ct == vector["ciphertext"]
+
+
+ofb_path = "vectors/cryptography_vectors/ciphers/SEED/seed-ofb.txt"
+verify_vectors("OFB", ofb_path)
+cfb_path = "vectors/cryptography_vectors/ciphers/SEED/seed-cfb.txt"
+verify_vectors("CFB", cfb_path)
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/development/custom-vectors/seed.rst hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/development/custom-vectors/seed.rst
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/development/custom-vectors/seed.rst	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/development/custom-vectors/seed.rst	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,32 @@
+SEED vector creation
+=====================
+
+This page documents the code that was used to generate the SEED CFB and OFB
+test vectors as well as the code used to verify them against another
+implementation. The vectors were generated using OpenSSL and verified
+with `Botan`_.
+
+Creation
+--------
+
+``cryptography`` was modified to support SEED in CFB and OFB modes. Then
+the following python script was run to generate the vector files.
+
+.. literalinclude:: /development/custom-vectors/seed/generate_seed.py
+
+Download link: :download:`generate_seed.py
+</development/custom-vectors/seed/generate_seed.py>`
+
+
+Verification
+------------
+
+The following Python code was used to verify the vectors using the `Botan`_
+project's Python bindings.
+
+.. literalinclude:: /development/custom-vectors/seed/verify_seed.py
+
+Download link: :download:`verify_seed.py
+</development/custom-vectors/seed/verify_seed.py>`
+
+.. _`Botan`: http://botan.randombit.net
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/development/getting-started.rst hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/development/getting-started.rst
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/development/getting-started.rst	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/development/getting-started.rst	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,92 @@
+Getting started
+===============
+
+Working on ``cryptography`` requires the installation of a small number of
+development dependencies in addition to the dependencies for
+:doc:`/installation`. These are listed in ``dev-requirements.txt`` and they can
+be installed in a `virtualenv`_ using `pip`_. Once you've installed the
+dependencies, install ``cryptography`` in ``editable`` mode. For example:
+
+.. code-block:: console
+
+    $ # Create a virtualenv and activate it
+    $ pip install --requirement dev-requirements.txt
+    $ pip install --editable .
+
+You will also need to install ``enchant`` using your system's package manager
+to check spelling in the documentation.
+
+You are now ready to run the tests and build the documentation.
+
+Running tests
+~~~~~~~~~~~~~
+
+``cryptography`` unit tests are found in the ``tests/`` directory and are
+designed to be run using `pytest`_. `pytest`_ will discover the tests
+automatically, so all you have to do is:
+
+.. code-block:: console
+
+    $ py.test
+    ...
+    62746 passed in 220.43 seconds
+
+This runs the tests with the default Python interpreter.
+
+You can also verify that the tests pass on other supported Python interpreters.
+For this we use `tox`_, which will automatically create a `virtualenv`_ for
+each supported Python version and run the tests. For example:
+
+.. code-block:: console
+
+    $ tox
+    ...
+    ERROR:   py26: InterpreterNotFound: python2.6
+     py27: commands succeeded
+    ERROR:   pypy: InterpreterNotFound: pypy
+     py33: commands succeeded
+     docs: commands succeeded
+     pep8: commands succeeded
+
+You may not have all the required Python versions installed, in which case you
+will see one or more ``InterpreterNotFound`` errors.
+
+
+Explicit backend selection
+~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+While testing you may want to run tests against a subset of the backends that
+cryptography supports. Explicit backend selection can be done via the
+``--backend`` flag. This flag should be passed to ``py.test`` with a comma
+delimited list of backend names.
+
+
+.. code-block:: console
+
+    $ tox -- --backend=openssl
+    $ py.test --backend=openssl,commoncrypto
+
+Building documentation
+~~~~~~~~~~~~~~~~~~~~~~
+
+``cryptography`` documentation is stored in the ``docs/`` directory. It is
+written in `reStructured Text`_ and rendered using `Sphinx`_.
+
+Use `tox`_ to build the documentation. For example:
+
+.. code-block:: console
+
+    $ tox -e docs
+    ...
+    docs: commands succeeded
+    congratulations :)
+
+The HTML documentation index can now be found at
+``docs/_build/html/index.html``.
+
+.. _`pytest`: https://pypi.python.org/pypi/pytest
+.. _`tox`: https://pypi.python.org/pypi/tox
+.. _`virtualenv`: https://pypi.python.org/pypi/virtualenv
+.. _`pip`: https://pypi.python.org/pypi/pip
+.. _`sphinx`: https://pypi.python.org/pypi/Sphinx
+.. _`reStructured Text`: http://sphinx-doc.org/rest.html
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/development/index.rst hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/development/index.rst
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/development/index.rst	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/development/index.rst	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,20 @@
+Development
+===========
+
+As an open source project, ``cryptography`` welcomes contributions of all
+forms. The sections below will help you get started.
+
+File bugs and feature requests on our issue tracker on `GitHub`_. If it is a
+bug check out `what to put in your bug report`_.
+
+.. toctree::
+    :maxdepth: 2
+
+    getting-started
+    submitting-patches
+    reviewing-patches
+    test-vectors
+    c-bindings
+
+.. _`GitHub`: https://github.com/pyca/cryptography
+.. _`what to put in your bug report`: http://www.contribution-guide.org/#what-to-put-in-your-bug-report
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/development/reviewing-patches.rst hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/development/reviewing-patches.rst
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/development/reviewing-patches.rst	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/development/reviewing-patches.rst	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,60 @@
+Reviewing and merging patches
+=============================
+
+Everyone is encouraged to review open pull requests. We only ask that you try
+and think carefully, ask questions and are `excellent to one another`_. Code
+review is our opportunity to share knowledge, design ideas and make friends.
+
+When reviewing a patch try to keep each of these concepts in mind:
+
+Architecture
+------------
+
+* Is the proposed change being made in the correct place? Is it a fix in a
+  backend when it should be in the primitives?
+
+Intent
+------
+
+* What is the change being proposed?
+* Do we want this feature or is the bug they're fixing really a bug?
+
+Implementation
+--------------
+
+* Does the change do what the author claims?
+* Are there sufficient tests?
+* Has it been documented?
+* Will this change introduce new bugs?
+
+Grammar and style
+-----------------
+
+These are small things that are not caught by the automated style checkers.
+
+* Does a variable need a better name?
+* Should this be a keyword argument?
+
+Merge requirements
+------------------
+
+Because cryptography is so complex, and the implications of getting it wrong so
+devastating, ``cryptography`` has a strict merge policy for committers:
+
+* Patches must *never* be pushed directly to ``master``, all changes (even the
+  most trivial typo fixes!) must be submitted as a pull request.
+* A committer may *never* merge their own pull request, a second party must
+  merge their changes. If multiple people work on a pull request, it must be
+  merged by someone who did not work on it.
+* A patch that breaks tests, or introduces regressions by changing or removing
+  existing tests should not be merged. Tests must always be passing on
+  ``master``.
+* If somehow the tests get into a failing state on ``master`` (such as by a
+  backwards incompatible release of a dependency) no pull requests may be
+  merged until this is rectified.
+* All merged patches must have 100% test coverage.
+
+The purpose of these policies is to minimize the chances we merge a change
+that jeopardizes our users' security.
+
+.. _`excellent to one another`: https://speakerdeck.com/ohrite/better-code-review
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/development/submitting-patches.rst hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/development/submitting-patches.rst
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/development/submitting-patches.rst	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/development/submitting-patches.rst	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,156 @@
+Submitting patches
+==================
+
+* Always make a new branch for your work.
+* Patches should be small to facilitate easier review. `Studies have shown`_
+  that review quality falls off as patch size grows. Sometimes this will result
+  in many small PRs to land a single large feature.
+* Larger changes should be discussed on `our mailing list`_ before submission.
+* New features and significant bug fixes should be documented in the
+  :doc:`/changelog`.
+* You must have legal permission to distribute any code you contribute to
+  ``cryptography``, and it must be available under both the BSD and Apache
+  Software License Version 2.0 licenses.
+
+If you believe you've identified a security issue in ``cryptography``, please
+follow the directions on the :doc:`security page </security>`.
+
+Code
+----
+
+When in doubt, refer to :pep:`8` for Python code. You can check if your code
+meets our automated requirements by running ``flake8`` against it. If you've
+installed the development requirements this will automatically use our
+configuration. You can also run the ``tox`` job with ``tox -e pep8``.
+
+`Write comments as complete sentences.`_
+
+Class names which contains acronyms or initialisms should always be
+capitalized. A class should be named ``HTTPClient``, not ``HttpClient``.
+
+Every code file must start with the boilerplate licensing notice:
+
+.. code-block:: python
+
+    # This file is dual licensed under the terms of the Apache License, Version
+    # 2.0, and the BSD License. See the LICENSE file in the root of this repository
+    # for complete details.
+
+Additionally, every Python code file must contain
+
+.. code-block:: python
+
+    from __future__ import absolute_import, division, print_function
+
+API considerations
+~~~~~~~~~~~~~~~~~~
+
+Most projects' APIs are designed with a philosophy of "make easy things easy,
+and make hard things possible". One of the perils of writing cryptographic code
+is that secure code looks just like insecure code, and its results are almost
+always indistinguishable. As a result ``cryptography`` has, as a design
+philosophy: "make it hard to do insecure things". Here are a few strategies for
+API design that should be both followed, and should inspire other API choices:
+
+If it is necessary to compare a user provided value with a computed value (for
+example, verifying a signature), there should be an API provided that performs
+the verification in a secure way (for example, using a constant time
+comparison), rather than requiring the user to perform the comparison
+themselves.
+
+If it is incorrect to ignore the result of a method, it should raise an
+exception, and not return a boolean ``True``/``False`` flag. For example, a
+method to verify a signature should raise ``InvalidSignature``, and not return
+whether the signature was valid.
+
+.. code-block:: python
+
+    # This is bad.
+    def verify(sig):
+        # ...
+        return is_valid
+
+    # Good!
+    def verify(sig):
+        # ...
+        if not is_valid:
+            raise InvalidSignature
+
+Every recipe should include a version or algorithmic marker of some sort in its
+output in order to allow transparent upgrading of the algorithms in use, as
+the algorithms or parameters needed to achieve a given security margin evolve.
+
+APIs at the :doc:`/hazmat/primitives/index` layer should always take an
+explicit backend, APIs at the recipes layer should automatically use the
+:func:`~cryptography.hazmat.backends.default_backend`, but optionally allow
+specifying a different backend.
+
+C bindings
+~~~~~~~~~~
+
+More information on C bindings can be found in :doc:`the dedicated
+section of the documentation <c-bindings>`.
+
+Tests
+-----
+
+All code changes must be accompanied by unit tests with 100% code coverage (as
+measured by the combined metrics across our build matrix).
+
+When implementing a new primitive or recipe ``cryptography`` requires that you
+provide a set of test vectors. See :doc:`/development/test-vectors` for more
+details.
+
+Documentation
+-------------
+
+All features should be documented with prose in the ``docs`` section. To ensure
+it builds and passes `doc8`_ style checks you can run ``tox -e docs``.
+
+Because of the inherent challenges in implementing correct cryptographic
+systems, we want to make our documentation point people in the right directions
+as much as possible. To that end:
+
+* When documenting a generic interface, use a strong algorithm in examples.
+  (e.g. when showing a hashing example, don't use
+  :class:`~cryptography.hazmat.primitives.hashes.MD5`)
+* When giving prescriptive advice, always provide references and supporting
+  material.
+* When there is real disagreement between cryptographic experts, represent both
+  sides of the argument and describe the trade-offs clearly.
+
+When documenting a new module in the ``hazmat`` package, its documentation
+should begin with the "Hazardous Materials" warning:
+
+.. code-block:: rest
+
+    .. hazmat::
+
+When referring to a hypothetical individual (such as "a person receiving an
+encrypted message") use gender neutral pronouns (they/them/their).
+
+Docstrings are typically only used when writing abstract classes, but should
+be written like this if required:
+
+.. code-block:: python
+
+    def some_function(some_arg):
+        """
+        Does some things.
+
+        :param some_arg: Some argument.
+        """
+
+So, specifically:
+
+* Always use three double quotes.
+* Put the three double quotes on their own line.
+* No blank line at the end.
+* Use Sphinx parameter/attribute documentation `syntax`_.
+
+
+.. _`Write comments as complete sentences.`: http://nedbatchelder.com/blog/201401/comments_should_be_sentences.html
+.. _`syntax`: http://sphinx-doc.org/domains.html#info-field-lists
+.. _`Studies have shown`: https://smartbear.com/smartbear/media/pdfs/wp-cc-11-best-practices-of-peer-code-review.pdf
+.. _`our mailing list`: https://mail.python.org/mailman/listinfo/cryptography-dev
+.. _`doc8`: https://github.com/stackforge/doc8
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/development/test-vectors.rst hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/development/test-vectors.rst
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/development/test-vectors.rst	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/development/test-vectors.rst	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,434 @@
+Test vectors
+============
+
+Testing the correctness of the primitives implemented in each ``cryptography``
+backend requires trusted test vectors. Where possible these vectors are
+obtained from official sources such as `NIST`_ or `IETF`_ RFCs. When this is
+not possible ``cryptography`` has chosen to create a set of custom vectors
+using an official vector file as input to verify consistency between
+implemented backends.
+
+Vectors are kept in the `cryptography_vectors` package rather than within our
+main test suite.
+
+Sources
+-------
+
+Asymmetric ciphers
+~~~~~~~~~~~~~~~~~~
+
+* RSA PKCS #1 from the RSA FTP site (ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-1/
+  and ftp://ftp.rsa.com/pub/rsalabs/tmp/).
+* RSA FIPS 186-2 and PKCS1 v1.5 vulnerability test vectors from `NIST CAVP`_.
+* FIPS 186-2 and FIPS 186-3 DSA test vectors from `NIST CAVP`_.
+* FIPS 186-2 and FIPS 186-3 ECDSA test vectors from `NIST CAVP`_.
+* DH and ECDH and ECDH+KDF(17.4) test vectors from `NIST CAVP`_.
+* Ed25519 test vectors from the `Ed25519 website_`.
+* OpenSSL PEM RSA serialization vectors from the `OpenSSL example key`_ and
+  `GnuTLS key parsing tests`_.
+* OpenSSL PEM DSA serialization vectors from the `GnuTLS example keys`_.
+* PKCS #8 PEM serialization vectors from
+
+  * GnuTLS: `enc-rsa-pkcs8.pem`_, `enc2-rsa-pkcs8.pem`_,
+    `unenc-rsa-pkcs8.pem`_, `pkcs12_s2k_pem.c`_. The contents of
+    `enc2-rsa-pkcs8.pem`_ was re-encrypted using a stronger PKCS#8 cipher.
+  * `Botan's ECC private keys`_.
+* `asymmetric/public/PKCS1/dsa.pub.pem`_ is a PKCS1 DSA public key from the
+  Ruby test suite.
+
+
+Custom asymmetric vectors
+~~~~~~~~~~~~~~~~~~~~~~~~~
+
+.. toctree::
+    :maxdepth: 1
+
+    custom-vectors/secp256k1
+
+* ``asymmetric/PEM_Serialization/ec_private_key.pem`` and
+  ``asymmetric/DER_Serialization/ec_private_key.der`` - Contains an Elliptic
+  Curve key generated by OpenSSL from the curve ``secp256r1``.
+* ``asymmetric/PEM_Serialization/ec_private_key_encrypted.pem`` and
+  ``asymmetric/DER_Serialization/ec_private_key_encrypted.der``- Contains the
+  same Elliptic Curve key as ``ec_private_key.pem``, except that it is
+  encrypted with AES-128 with the password "123456".
+* ``asymmetric/PEM_Serialization/ec_public_key.pem`` and
+  ``asymmetric/DER_Serialization/ec_public_key.der``- Contains the public key
+  corresponding to ``ec_private_key.pem``, generated using OpenSSL.
+* ``asymmetric/PEM_Serialization/rsa_private_key.pem`` - Contains an RSA 2048
+  bit key generated using OpenSSL, protected by the secret "123456" with DES3
+  encryption.
+* ``asymmetric/PEM_Serialization/rsa_public_key.pem`` and
+  ``asymmetric/DER_Serialization/rsa_public_key.der``- Contains an RSA 2048
+  bit public generated using OpenSSL from ``rsa_private_key.pem``.
+* ``asymmetric/PEM_Serialization/dsaparam.pem`` - Contains 2048-bit DSA
+  parameters generated using OpenSSL; contains no keys.
+* ``asymmetric/PEM_Serialization/dsa_private_key.pem`` - Contains a DSA 2048
+  bit key generated using OpenSSL from the parameters in ``dsaparam.pem``,
+  protected by the secret "123456" with DES3 encryption.
+* ``asymmetric/PEM_Serialization/dsa_public_key.pem`` and
+  ``asymmetric/DER_Serialization/dsa_public_key.der`` - Contains a DSA 2048 bit
+  key generated using OpenSSL from ``dsa_private_key.pem``.
+* ``asymmetric/PKCS8/unenc-dsa-pkcs8.pem`` and
+  ``asymmetric/DER_Serialization/unenc-dsa-pkcs8.der`` - Contains a DSA 1024
+  bit key generated using OpenSSL.
+* ``asymmetric/PKCS8/unenc-dsa-pkcs8.pub.pem`` and
+  ``asymmetric/DER_Serialization/unenc-dsa-pkcs8.pub.der`` - Contains a DSA
+  2048 bit public key generated using OpenSSL from ``unenc-dsa-pkcs8.pem``.
+* DER conversions of the `GnuTLS example keys`_ for DSA as well as the
+  `OpenSSL example key`_ for RSA.
+* DER conversions of `enc-rsa-pkcs8.pem`_, `enc2-rsa-pkcs8.pem`_, and
+  `unenc-rsa-pkcs8.pem`_.
+* ``asymmetric/public/PKCS1/rsa.pub.pem`` and
+  ``asymmetric/public/PKCS1/rsa.pub.der`` are PKCS1 conversions of the public
+  key from ``asymmetric/PKCS8/unenc-rsa-pkcs8.pem`` using PEM and DER encoding.
+
+
+Key exchange
+~~~~~~~~~~~~
+
+* ``vectors/cryptography_vectors/asymmetric/DH/RFC5114.txt`` contains
+  Diffie-Hellman examples from appendix A.1, A.2 and A.3 of :rfc:`5114`.
+
+X.509
+~~~~~
+
+* PKITS test suite from `NIST PKI Testing`_.
+* ``v1_cert.pem`` from the OpenSSL source tree (`testx509.pem`_).
+* ``ecdsa_root.pem`` - `DigiCert Global Root G3`_, a ``secp384r1`` ECDSA root
+  certificate.
+* ``verisign-md2-root.pem`` - A legacy Verisign public root signed using the
+  MD2 algorithm. This is a PEM conversion of the `root data`_ in the NSS source
+  tree.
+* ``cryptography.io.pem`` - A leaf certificate issued by RapidSSL for the
+  cryptography website.
+* ``rapidssl_sha256_ca_g3.pem`` - The intermediate CA that issued the
+  ``cryptography.io.pem`` certificate.
+* ``wildcard_san.pem`` - A leaf certificate issued by a public CA for
+  ``langui.sh`` that contains wildcard entries in the SAN extension.
+* ``san_edipartyname.der`` - A DSA certificate from a `Mozilla bug`_
+  containing a SAN extension with an ``ediPartyName`` general name.
+* ``san_x400address.der`` - A DSA certificate from a `Mozilla bug`_ containing
+  a SAN extension with an ``x400Address`` general name.
+
+Custom X.509 Vectors
+~~~~~~~~~~~~~~~~~~~~
+
+* ``invalid_version.pem`` - Contains an RSA 2048 bit certificate with the
+  X.509 version field set to ``0x7``.
+* ``post2000utctime.pem`` - Contains an RSA 2048 bit certificate with the
+  ``notBefore`` and ``notAfter`` fields encoded as post-2000 ``UTCTime``.
+* ``dsa_selfsigned_ca.pem`` - Contains a DSA self-signed CA certificate
+  generated using OpenSSL.
+* ``ec_no_named_curve.pem`` - Contains an ECDSA certificate that does not have
+  an embedded OID defining the curve.
+* ``all_supported_names.pem`` - An RSA 2048 bit certificate generated using
+  OpenSSL that contains a subject and issuer that have two of each supported
+  attribute type from :rfc:`5280`.
+* ``unsupported_subject_name.pem`` - An RSA 2048 bit self-signed CA certificate
+  generated using OpenSSL that contains the unsupported "initials" name.
+* ``utf8_common_name.pem`` - An RSA 2048 bit self-signed CA certificate
+  generated using OpenSSL that contains a UTF8String common name with the value
+  "We heart UTF8!â¢".
+* ``two_basic_constraints.pem`` - An RSA 2048 bit self-signed certificate
+  containing two basic constraints extensions.
+* ``basic_constraints_not_critical.pem`` - An RSA 2048 bit self-signed
+  certificate containing a basic constraints extension that is not marked as
+  critical.
+* ``bc_path_length_zero.pem`` - An RSA 2048 bit self-signed
+  certificate containing a basic constraints extension with a path length of
+  zero.
+* ``unsupported_extension.pem`` - An RSA 2048 bit self-signed certificate
+  containing an unsupported extension type. The OID was encoded as
+  "1.2.3.4" with an ``extnValue`` of "value".
+* ``unsupported_extension_critical.pem`` - An RSA 2048 bit self-signed
+  certificate containing an unsupported extension type marked critical. The OID
+  was encoded as "1.2.3.4" with an ``extnValue`` of "value".
+* ``san_email_dns_ip_dirname_uri.pem`` - An RSA 2048 bit self-signed
+  certificate containing a subject alternative name extension with the
+  following general names: ``rfc822Name``, ``dNSName``, ``iPAddress``,
+  ``directoryName``, and ``uniformResourceIdentifier``.
+* ``san_empty_hostname.pem`` - An RSA 2048 bit self-signed certificate
+  containing a subject alternative extension with an empty ``dNSName``
+  general name.
+* ``san_other_name.pem`` - An RSA 2048 bit self-signed certificate containing
+  a subject alternative name extension with the ``otherName`` general name.
+* ``san_registered_id.pem`` - An RSA 1024 bit certificate containing a
+  subject alternative name extension with the ``registeredID`` general name.
+* ``all_key_usages.pem`` - An RSA 2048 bit self-signed certificate containing
+  a key usage extension with all nine purposes set to true.
+* ``extended_key_usage.pem`` - An RSA 2048 bit self-signed certificate
+  containing an extended key usage extension with eight usages.
+* ``san_idna_names.pem`` - An RSA 2048 bit self-signed certificate containing
+  a subject alternative name extension with ``rfc822Name``, ``dNSName``, and
+  ``uniformResourceIdentifier`` general names with IDNA (:rfc:`5895`) encoding.
+* ``san_wildcard_idna.pem`` - An RSA 2048 bit self-signed certificate
+  containing a subject alternative name extension with a ``dNSName`` general
+  name with a wildcard IDNA (:rfc:`5895`) domain.
+* ``san_idna2003_dnsname.pem`` - An RSA 2048 bit self-signed certificate
+  containing a subject alternative name extension with an IDNA 2003
+  (:rfc:`3490`) ``dNSName``.
+* ``san_rfc822_names.pem`` - An RSA 2048 bit self-signed certificate containing
+  a subject alternative name extension with various ``rfc822Name`` values.
+* ``san_rfc822_idna.pem`` - An RSA 2048 bit self-signed certificate containing
+  a subject alternative name extension with an IDNA ``rfc822Name``.
+* ``san_uri_with_port.pem`` - An RSA 2048 bit self-signed certificate
+  containing a subject alternative name extension with various
+  ``uniformResourceIdentifier`` values.
+* ``san_ipaddr.pem`` - An RSA 2048 bit self-signed certificate containing a
+  subject alternative name extension with an ``iPAddress`` value.
+* ``san_dirname.pem`` - An RSA 2048 bit self-signed certificate containing a
+  subject alternative name extension with a ``directoryName`` value.
+* ``inhibit_any_policy_5.pem`` - An RSA 2048 bit self-signed certificate
+  containing an inhibit any policy extension with the value 5.
+* ``inhibit_any_policy_negative.pem`` - An RSA 2048 bit self-signed certificate
+  containing an inhibit any policy extension with the value -1.
+* ``authority_key_identifier.pem`` - An RSA 2048 bit self-signed certificate
+  containing an authority key identifier extension with key identifier,
+  authority certificate issuer, and authority certificate serial number fields.
+* ``authority_key_identifier_no_keyid.pem`` - An RSA 2048 bit self-signed
+  certificate containing an authority key identifier extension with authority
+  certificate issuer and authority certificate serial number fields.
+* ``aia_ocsp_ca_issuers.pem`` - An RSA 2048 bit self-signed certificate
+  containing an authority information access extension with two OCSP and one
+  CA issuers entry.
+* ``aia_ocsp.pem`` - An RSA 2048 bit self-signed certificate
+  containing an authority information access extension with an OCSP entry.
+* ``aia_ca_issuers.pem`` - An RSA 2048 bit self-signed certificate
+  containing an authority information access extension with a CA issuers entry.
+* ``cdp_empty_hostname.pem`` - An RSA 2048 bit self-signed certificate
+  containing a CRL distribution point extension with ``fullName`` URI without
+  a hostname.
+* ``cdp_fullname_reasons_crl_issuer.pem`` - An RSA 1024 bit certificate
+  containing a CRL distribution points extension with ``fullName``,
+  ``cRLIssuer``, and ``reasons`` data.
+* ``cdp_crl_issuer.pem`` - An RSA 1024 bit certificate containing a CRL
+  distribution points extension with ``cRLIssuer`` data.
+* ``cdp_all_reasons.pem`` - An RSA 1024 bit certificate containing a CRL
+  distribution points extension with all ``reasons`` bits set.
+* ``cdp_reason_aa_compromise.pem`` - An RSA 1024 bit certificate containing a
+  CRL distribution points extension with the ``AACompromise`` ``reasons`` bit
+  set.
+* ``nc_permitted_excluded.pem`` - An RSA 2048 bit self-signed certificate
+  containing a name constraints extension with both permitted and excluded
+  elements. Contains ``IPv4`` and ``IPv6`` addresses with network mask as well
+  as ``dNSName`` with a leading period.
+* ``nc_permitted_excluded_2.pem`` - An RSA 2048 bit self-signed certificate
+  containing a name constraints extension with both permitted and excluded
+  elements. Unlike ``nc_permitted_excluded.pem``, the general names do not
+  contain any name constraints specific values.
+* ``nc_permitted.pem`` - An RSA 2048 bit self-signed certificate containing a
+  name constraints extension with permitted elements.
+* ``nc_permitted_2.pem`` - An RSA 2048 bit self-signed certificate containing a
+  name constraints extension with permitted elements that do not contain any
+  name constraints specific values.
+* ``nc_excluded.pem`` - An RSA 2048 bit self-signed certificate containing a
+  name constraints extension with excluded elements.
+* ``nc_invalid_ip_netmask.pem`` - An RSA 2048 bit self-signed certificate
+  containing a name constraints extension with a permitted element that has an
+  ``IPv6`` IP and an invalid network mask.
+* ``nc_single_ip_netmask.pem`` - An RSA 2048 bit self-signed certificate
+  containing a name constraints extension with a permitted element that has two
+  IPs with ``/32`` and ``/128`` network masks.
+* ``cp_user_notice_with_notice_reference.pem`` - An RSA 2048 bit self-signed
+  certificate containing a certificate policies extension with a
+  notice reference in the user notice.
+* ``cp_user_notice_with_explicit_text.pem`` - An RSA 2048 bit self-signed
+  certificate containing a certificate policies extension with explicit
+  text and no notice reference.
+* ``cp_cps_uri.pem`` - An RSA 2048 bit self-signed certificate containing a
+  certificate policies extension with a CPS URI and no user notice.
+* ``cp_user_notice_no_explicit_text.pem`` - An RSA 2048 bit self-signed
+  certificate containing a certificate policies extension with a user notice
+  with no explicit text.
+* ``cp_invalid.pem`` - An RSA 2048 bit self-signed certificate containing a
+  certificate policies extension with invalid data.
+* ``ian_uri.pem`` - An RSA 2048 bit certificate containing an issuer
+  alternative name extension with a ``URI`` general name.
+* ``ocsp_nocheck.pem`` - An RSA 2048 bit self-signed certificate containing
+  an ``OCSPNoCheck`` extension.
+* ``pc_inhibit_require.pem`` - An RSA 2048 bit self-signed certificate
+  containing a policy constraints extension with both inhibit policy mapping
+  and require explicit policy elements.
+* ``pc_inhibit.pem`` - An RSA 2048 bit self-signed certificate containing a
+  policy constraints extension with an inhibit policy mapping element.
+* ``pc_require.pem`` - An RSA 2048 bit self-signed certificate containing a
+  policy constraints extension with a require explicit policy element.
+* ``unsupported_subject_public_key_info.pem`` - A certificate whose public key
+  is an unknown OID (``1.3.6.1.4.1.8432.1.1.2``).
+
+Custom X.509 Request Vectors
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+* ``dsa_sha1.pem`` and ``dsa_sha1.der`` - Contain a certificate request using
+  1024-bit DSA parameters and SHA1 generated using OpenSSL.
+* ``rsa_md4.pem`` and ``rsa_md4.der`` - Contain a certificate request using
+  2048 bit RSA and MD4 generated using OpenSSL.
+* ``rsa_sha1.pem`` and ``rsa_sha1.der`` - Contain a certificate request using
+  2048 bit RSA and SHA1 generated using OpenSSL.
+* ``rsa_sha256.pem`` and ``rsa_sha256.der`` - Contain a certificate request
+  using 2048 bit RSA and SHA256 generated using OpenSSL.
+* ``ec_sha256.pem`` and ``ec_sha256.der`` - Contain a certificate request
+  using EC (``secp384r1``) and SHA256 generated using OpenSSL.
+* ``san_rsa_sha1.pem`` and ``san_rsa_sha1.der`` - Contain a certificate
+  request using RSA and SHA1 with a subject alternative name extension
+  generated using OpenSSL.
+* ``two_basic_constraints.pem`` - A certificate signing request
+  for a RSA 2048 bit key containing two basic constraints extensions.
+* ``unsupported_extension.pem`` - A certificate signing request
+  for an RSA 2048 bit key containing containing an unsupported
+  extension type. The OID was encoded as "1.2.3.4" with an
+  ``extnValue`` of "value".
+* ``unsupported_extension_critical.pem`` - A certificate signing
+  request for an RSA 2048 bit key containing containing an unsupported
+  extension type marked critical. The OID was encoded as "1.2.3.4"
+  with an ``extnValue`` of "value".
+* ``basic_constraints.pem`` - A certificate signing request for a RSA
+  2048 bit key containing a basic constraints extension marked as
+  critical.
+
+Custom X.509 Certificate Revocation List Vectors
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+* ``crl_all_reasons.pem`` - Contains a CRL with 12 revoked certificates, whose
+  serials match their list position. It includes one revocation without
+  any entry extensions, 10 revocations with every supported reason code and one
+  revocation with an unsupported, non-critical entry extension with the OID
+  value set to "1.2.3.4".
+* ``crl_dup_entry_ext.pem`` - Contains a CRL with one revocation which has a
+  duplicate entry extension.
+* ``crl_md2_unknown_crit_entry_ext.pem`` - Contains a CRL with one revocation
+  which contains an unsupported critical entry extension with the OID value set
+  to "1.2.3.4". The CRL uses an unsupported MD2 signature algorithm.
+* ``crl_unsupported_reason.pem`` - Contains a CRL with one revocation which has
+  an unsupported reason code.
+* ``crl_inval_cert_issuer_entry_ext.pem`` - Contains a CRL with one revocation
+  which has one entry extension for certificate issuer with an empty value.
+
+Hashes
+~~~~~~
+
+* MD5 from :rfc:`1321`.
+* RIPEMD160 from the `RIPEMD website`_.
+* SHA1 from `NIST CAVP`_.
+* SHA2 (224, 256, 384, 512) from `NIST CAVP`_.
+* Whirlpool from the `Whirlpool website`_.
+
+HMAC
+~~~~
+
+* HMAC-MD5 from :rfc:`2202`.
+* HMAC-SHA1 from :rfc:`2202`.
+* HMAC-RIPEMD160 from :rfc:`2286`.
+* HMAC-SHA2 (224, 256, 384, 512) from :rfc:`4231`.
+
+Key derivation functions
+~~~~~~~~~~~~~~~~~~~~~~~~
+
+* HKDF (SHA1, SHA256) from :rfc:`5869`.
+* PBKDF2 (HMAC-SHA1) from :rfc:`6070`.
+* scrypt from the `draft RFC`_.
+* X9.63 KDF from `NIST CAVP`_.
+
+Key wrapping
+~~~~~~~~~~~~
+
+* AES key wrap (AESKW) and 3DES key wrap test vectors from `NIST CAVP`_.
+
+Recipes
+~~~~~~~
+
+* Fernet from its `specification repository`_.
+
+Symmetric ciphers
+~~~~~~~~~~~~~~~~~
+
+* AES (CBC, CFB, ECB, GCM, OFB) from `NIST CAVP`_.
+* AES CTR from :rfc:`3686`.
+* 3DES (CBC, CFB, ECB, OFB) from `NIST CAVP`_.
+* ARC4 from :rfc:`6229`.
+* Blowfish (CBC, CFB, ECB, OFB) from `Bruce Schneier's vectors`_.
+* Camellia (ECB) from NTT's `Camellia page`_ as linked by `CRYPTREC`_.
+* Camellia (CBC, CFB, OFB) from `OpenSSL's test vectors`_.
+* CAST5 (ECB) from :rfc:`2144`.
+* CAST5 (CBC, CFB, OFB) generated by this project.
+  See: :doc:`/development/custom-vectors/cast5`
+* IDEA (ECB) from the `NESSIE IDEA vectors`_ created by `NESSIE`_.
+* IDEA (CBC, CFB, OFB) generated by this project.
+  See: :doc:`/development/custom-vectors/idea`
+* SEED (ECB) from :rfc:`4269`.
+* SEED (CBC) from :rfc:`4196`.
+* SEED (CFB, OFB) generated by this project.
+  See: :doc:`/development/custom-vectors/seed`
+
+Two factor authentication
+~~~~~~~~~~~~~~~~~~~~~~~~~
+
+* HOTP from :rfc:`4226`
+* TOTP from :rfc:`6238` (Note that an `errata`_ for the test vectors in RFC
+  6238 exists)
+
+CMAC
+~~~~
+
+* AES-128, AES-192, AES-256, 3DES from `NIST SP-800-38B`_
+
+Creating test vectors
+---------------------
+
+When official vectors are unavailable ``cryptography`` may choose to build
+its own using existing vectors as source material.
+
+Custom Symmetric Vectors
+~~~~~~~~~~~~~~~~~~~~~~~~
+
+.. toctree::
+    :maxdepth: 1
+
+    custom-vectors/cast5
+    custom-vectors/idea
+    custom-vectors/seed
+
+If official test vectors appear in the future the custom generated vectors
+should be discarded.
+
+Any vectors generated by this method must also be prefixed with the following
+header format (substituting the correct information):
+
+.. code-block:: python
+
+    # CAST5 CBC vectors built for https://github.com/pyca/cryptography
+    # Derived from the AESVS MMT test data for CBC
+    # Verified against the CommonCrypto and Go crypto packages
+    # Key Length : 128
+
+.. _`NIST`: http://www.nist.gov/
+.. _`IETF`: https://www.ietf.org/
+.. _`NIST CAVP`: http://csrc.nist.gov/groups/STM/cavp/
+.. _`Bruce Schneier's vectors`: https://www.schneier.com/code/vectors.txt
+.. _`Camellia page`: https://info.isl.ntt.co.jp/crypt/eng/camellia/
+.. _`CRYPTREC`: http://www.cryptrec.go.jp
+.. _`OpenSSL's test vectors`: https://github.com/openssl/openssl/blob/97cf1f6c2854a3a955fd7dd3a1f113deba00c9ef/crypto/evp/evptests.txt#L232
+.. _`RIPEMD website`: http://homes.esat.kuleuven.be/~bosselae/ripemd160.html
+.. _`Whirlpool website`: http://www.larc.usp.br/~pbarreto/WhirlpoolPage.html
+.. _`draft RFC`: https://tools.ietf.org/html/draft-josefsson-scrypt-kdf-01
+.. _`Specification repository`: https://github.com/fernet/spec
+.. _`errata`: https://www.rfc-editor.org/errata_search.php?rfc=6238
+.. _`OpenSSL example key`: https://github.com/openssl/openssl/blob/d02b48c63a58ea4367a0e905979f140b7d090f86/test/testrsa.pem
+.. _`GnuTLS key parsing tests`: https://gitlab.com/gnutls/gnutls/commit/f16ef39ef0303b02d7fa590a37820440c466ce8d
+.. _`enc-rsa-pkcs8.pem`: https://gitlab.com/gnutls/gnutls/blob/f8d943b38bf74eaaa11d396112daf43cb8aa82ae/tests/pkcs8-decode/encpkcs8.pem
+.. _`enc2-rsa-pkcs8.pem`: https://gitlab.com/gnutls/gnutls/blob/f8d943b38bf74eaaa11d396112daf43cb8aa82ae/tests/pkcs8-decode/enc2pkcs8.pem
+.. _`unenc-rsa-pkcs8.pem`: https://gitlab.com/gnutls/gnutls/blob/f8d943b38bf74eaaa11d396112daf43cb8aa82ae/tests/pkcs8-decode/unencpkcs8.pem
+.. _`pkcs12_s2k_pem.c`: https://gitlab.com/gnutls/gnutls/blob/f8d943b38bf74eaaa11d396112daf43cb8aa82ae/tests/pkcs12_s2k_pem.c
+.. _`Botan's ECC private keys`: https://github.com/randombit/botan/tree/4917f26a2b154e841cd27c1bcecdd41d2bdeb6ce/src/tests/data/ecc
+.. _`GnuTLS example keys`: https://gitlab.com/gnutls/gnutls/commit/ad2061deafdd7db78fd405f9d143b0a7c579da7b
+.. _`NESSIE IDEA vectors`: https://www.cosic.esat.kuleuven.be/nessie/testvectors/bc/idea/Idea-128-64.verified.test-vectors
+.. _`NESSIE`: https://en.wikipedia.org/wiki/NESSIE
+.. _`Ed25519 website`: http://ed25519.cr.yp.to/software.html
+.. _`NIST SP-800-38B`: http://csrc.nist.gov/publications/nistpubs/800-38B/Updated_CMAC_Examples.pdf
+.. _`NIST PKI Testing`: http://csrc.nist.gov/groups/ST/crypto_apps_infra/pki/pkitesting.html
+.. _`testx509.pem`: https://github.com/openssl/openssl/blob/master/test/testx509.pem
+.. _`DigiCert Global Root G3`: http://cacerts.digicert.com/DigiCertGlobalRootG3.crt
+.. _`root data`: https://hg.mozilla.org/projects/nss/file/25b2922cc564/security/nss/lib/ckfw/builtins/certdata.txt#l2053
+.. _`asymmetric/public/PKCS1/dsa.pub.pem`: https://github.com/ruby/ruby/blob/4ccb387f3bc436a08fc6d72c4931994f5de95110/test/openssl/test_pkey_dsa.rb#L53
+.. _`Mozilla bug`: https://bugzilla.mozilla.org/show_bug.cgi?id=233586
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/doing-a-release.rst hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/doing-a-release.rst
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/doing-a-release.rst	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/doing-a-release.rst	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,89 @@
+Doing a release
+===============
+
+Doing a release of ``cryptography`` requires a few steps.
+
+Verifying and upgrading OpenSSL version
+---------------------------------------
+
+The release process uses a static build for Windows and OS X wheels. Check that
+the Windows and OS X Jenkins builders have the latest version of OpenSSL
+installed before performing the release. If they do not:
+
+Upgrading Windows
+~~~~~~~~~~~~~~~~~
+
+Run the ``openssl-release`` Jenkins job, then copy the resulting artifacts to
+the Windows builders and unzip them in the root of the file system.
+
+Upgrading OS X
+~~~~~~~~~~~~~~
+
+``brew update`` and then ``brew upgrade openssl --universal --build-bottle`` to
+build a universal library (32-bit and 64-bit) compatible with all Intel Macs.
+This can be confirmed by using
+``lipo -info /usr/local/opt/openssl/lib/libssl.dylib`` to see the available
+architectures.
+
+Bumping the version number
+--------------------------
+
+The next step in doing a release is bumping the version number in the
+software.
+
+* Update the version number in ``src/cryptography/__about__.py``.
+* Update the version number in ``vectors/cryptography_vectors/__about__.py``.
+* Set the release date in the :doc:`/changelog`.
+* Do a commit indicating this.
+* Send a pull request with this.
+* Wait for it to be merged.
+
+Performing the release
+----------------------
+
+The commit that merged the version number bump is now the official release
+commit for this release. You will need to have ``gpg`` installed and a ``gpg``
+key in order to do a release. Once this has happened:
+
+* Run ``invoke release {version}``.
+
+The release should now be available on PyPI and a tag should be available in
+the repository.
+
+Verifying the release
+---------------------
+
+You should verify that ``pip install cryptography`` works correctly:
+
+.. code-block:: pycon
+
+    >>> import cryptography
+    >>> cryptography.__version__
+    '...'
+    >>> import cryptography_vectors
+    >>> cryptography_vectors.__version__
+    '...'
+
+Verify that this is the version you just released.
+
+For the Windows wheels check the builds for the ``cryptography-wheel-builder``
+job and verify that the final output for each build shows it loaded and linked
+the expected OpenSSL version.
+
+Post-release tasks
+------------------
+
+* Update the version number to the next major (e.g. ``0.5.dev1``) in
+  ``cryptography/__about__.py`` and
+  ``vectors/cryptography_vectors/__about__.py``.
+* Add new :doc:`/changelog` entry with next version and note that it is under
+  active development
+* Send a pull request with these items
+* Check for any outstanding code undergoing a deprecation cycle by looking in
+  ``cryptography.utils`` for ``DeprecatedIn**`` definitions. If any exist open
+  a ticket to increment them for the next release.
+* Send an email to the `mailing list`_ and `python-announce`_ announcing the
+  release.
+
+.. _`mailing list`: https://mail.python.org/mailman/listinfo/cryptography-dev
+.. _`python-announce`: https://mail.python.org/mailman/listinfo/python-announce-list
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/exceptions.rst hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/exceptions.rst
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/exceptions.rst	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/exceptions.rst	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,39 @@
+Exceptions
+==========
+
+.. currentmodule:: cryptography.exceptions
+
+
+.. class:: UnsupportedAlgorithm
+
+    Raised when the requested algorithm, or combination of algorithms is not
+    supported.
+
+
+.. class:: AlreadyFinalized
+
+    This is raised when a context is used after being finalized.
+
+
+.. class:: InvalidSignature
+
+    This is raised when signature verification fails. This can occur with
+    HMAC or asymmetric key signature validation.
+
+
+.. class:: NotYetFinalized
+
+    This is raised when the AEAD tag property is accessed on a context
+    before it is finalized.
+
+
+.. class:: AlreadyUpdated
+
+    This is raised when additional data is added to a context after update
+    has already been called.
+
+
+.. class:: InvalidKey
+
+    This is raised when the verify method of a key derivation function's
+    computed key does not match the expected key.
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/faq.rst hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/faq.rst
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/faq.rst	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/faq.rst	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,18 @@
+Frequently asked questions
+==========================
+
+How does ``cryptography`` compare to NaCl (Networking and Cryptography Library)?
+--------------------------------------------------------------------------------
+
+While ``cryptography`` and `NaCl`_ both share the goal of making cryptography
+easier, and safer, to use for developers, ``cryptography`` is designed to be a
+general purpose library, interoperable with existing systems, while NaCl
+features a collection of hand selected algorithms.
+
+``cryptography``'s :ref:`recipes <cryptography-layout>` layer has similar goals
+to NaCl.
+
+If you prefer NaCl's design, we highly recommend `PyNaCl`_.
+
+.. _`NaCl`: http://nacl.cr.yp.to/
+.. _`PyNaCl`: https://pynacl.readthedocs.org
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/fernet.rst hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/fernet.rst
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/fernet.rst	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/fernet.rst	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,169 @@
+Fernet (symmetric encryption)
+=============================
+
+.. currentmodule:: cryptography.fernet
+
+Fernet guarantees that a message encrypted using it cannot be
+manipulated or read without the key. `Fernet`_ is an implementation of
+symmetric (also known as "secret key") authenticated cryptography. Fernet also
+has support for implementing key rotation via :class:`MultiFernet`.
+
+.. class:: Fernet(key)
+
+    This class provides both encryption and decryption facilities.
+
+    .. doctest::
+
+        >>> from cryptography.fernet import Fernet
+        >>> key = Fernet.generate_key()
+        >>> f = Fernet(key)
+        >>> token = f.encrypt(b"my deep dark secret")
+        >>> token
+        '...'
+        >>> f.decrypt(token)
+        'my deep dark secret'
+
+    :param bytes key: A URL-safe base64-encoded 32-byte key. This **must** be
+                      kept secret. Anyone with this key is able to create and
+                      read messages.
+
+    .. classmethod:: generate_key()
+
+        Generates a fresh fernet key. Keep this some place safe! If you lose it
+        you'll no longer be able to decrypt messages; if anyone else gains
+        access to it, they'll be able to decrypt all of your messages, and
+        they'll also be able forge arbitrary messages that will be
+        authenticated and decrypted.
+
+    .. method:: encrypt(data)
+
+        :param bytes data: The message you would like to encrypt.
+        :returns bytes: A secure message that cannot be read or altered
+                        without the key. It is URL-safe base64-encoded. This is
+                        referred to as a "Fernet token".
+        :raises TypeError: This exception is raised if ``data`` is not
+                           ``bytes``.
+
+        .. note::
+
+            The encrypted message contains the current time when it was
+            generated in *plaintext*, the time a message was created will
+            therefore be visible to a possible attacker.
+
+    .. method:: decrypt(token, ttl=None)
+
+        :param bytes token: The Fernet token. This is the result of calling
+                            :meth:`encrypt`.
+        :param int ttl: Optionally, the number of seconds old a message may be
+                        for it to be valid. If the message is older than
+                        ``ttl`` seconds (from the time it was originally
+                        created) an exception will be raised. If ``ttl`` is not
+                        provided (or is ``None``), the age of the message is
+                        not considered.
+        :returns bytes: The original plaintext.
+        :raises cryptography.fernet.InvalidToken: If the ``token`` is in any
+                                                  way invalid, this exception
+                                                  is raised. A token may be
+                                                  invalid for a number of
+                                                  reasons: it is older than the
+                                                  ``ttl``, it is malformed, or
+                                                  it does not have a valid
+                                                  signature.
+        :raises TypeError: This exception is raised if ``token`` is not
+                           ``bytes``.
+
+
+.. class:: MultiFernet(fernets)
+
+    .. versionadded:: 0.7
+
+    This class implements key rotation for Fernet. It takes a ``list`` of
+    :class:`Fernet` instances, and implements the same API:
+
+    .. doctest::
+
+        >>> from cryptography.fernet import Fernet, MultiFernet
+        >>> key1 = Fernet(Fernet.generate_key())
+        >>> key2 = Fernet(Fernet.generate_key())
+        >>> f = MultiFernet([key1, key2])
+        >>> token = f.encrypt(b"Secret message!")
+        >>> token
+        '...'
+        >>> f.decrypt(token)
+        'Secret message!'
+
+    MultiFernet performs all encryption options using the *first* key in the
+    ``list`` provided. MultiFernet attempts to decrypt tokens with each key in
+    turn. A :class:`cryptography.fernet.InvalidToken` exception is raised if
+    the correct key is not found in the ``list`` provided.
+
+    Key rotation makes it easy to replace old keys. You can add your new key at
+    the front of the list to start encrypting new messages, and remove old keys
+    as they are no longer needed.
+
+
+.. class:: InvalidToken
+
+    See :meth:`Fernet.decrypt` for more information.
+
+
+Using passwords with Fernet
+---------------------------
+
+It is possible to use passwords with Fernet. To do this, you need to run the
+password through a key derivation function such as
+:class:`~cryptography.hazmat.primitives.kdf.pbkdf2.PBKDF2HMAC`, bcrypt or
+scrypt.
+
+.. doctest::
+
+    >>> import base64
+    >>> import os
+    >>> from cryptography.fernet import Fernet
+    >>> from cryptography.hazmat.backends import default_backend
+    >>> from cryptography.hazmat.primitives import hashes
+    >>> from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
+    >>> password = b"password"
+    >>> salt = os.urandom(16)
+    >>> kdf = PBKDF2HMAC(
+    ...     algorithm=hashes.SHA256(),
+    ...     length=32,
+    ...     salt=salt,
+    ...     iterations=100000,
+    ...     backend=default_backend()
+    ... )
+    >>> key = base64.urlsafe_b64encode(kdf.derive(password))
+    >>> f = Fernet(key)
+    >>> token = f.encrypt(b"Secret message!")
+    >>> token
+    '...'
+    >>> f.decrypt(token)
+    'Secret message!'
+
+In this scheme, the salt has to be stored in a retrievable location in order
+to derive the same key from the password in the future.
+
+The iteration count used should be adjusted to be as high as your server can
+tolerate. A good default is at least 100,000 iterations which is what Django
+`recommends`_ in 2014.
+
+Implementation
+--------------
+
+Fernet is built on top of a number of standard cryptographic primitives.
+Specifically it uses:
+
+* :class:`~cryptography.hazmat.primitives.ciphers.algorithms.AES` in
+  :class:`~cryptography.hazmat.primitives.ciphers.modes.CBC` mode with a
+  128-bit key for encryption; using
+  :class:`~cryptography.hazmat.primitives.padding.PKCS7` padding.
+* :class:`~cryptography.hazmat.primitives.hmac.HMAC` using
+  :class:`~cryptography.hazmat.primitives.hashes.SHA256` for authentication.
+* Initialization vectors are generated using ``os.urandom()``.
+
+For complete details consult the `specification`_.
+
+
+.. _`Fernet`: https://github.com/fernet/spec/
+.. _`specification`: https://github.com/fernet/spec/blob/master/Spec.md
+.. _`recommends`: https://github.com/django/django/blob/master/django/utils/crypto.py#L148
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/glossary.rst hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/glossary.rst
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/glossary.rst	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/glossary.rst	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,74 @@
+Glossary
+========
+
+.. glossary::
+    :sorted:
+
+    plaintext
+        User-readable data you care about.
+
+    ciphertext
+        The encoded data, it's not user readable. Potential attackers are able
+        to see this.
+
+    encryption
+        The process of converting plaintext to ciphertext.
+
+    decryption
+        The process of converting ciphertext to plaintext.
+
+    key
+        Secret data is encoded with a function using this key. Sometimes
+        multiple keys are used. These **must** be kept secret, if a key is
+        exposed to an attacker, any data encrypted with it will be exposed.
+
+    symmetric cryptography
+        Cryptographic operations where encryption and decryption use the same
+        key.
+
+    public-key cryptography
+    asymmetric cryptography
+        Cryptographic operations where encryption and decryption use different
+        keys. There are separate encryption and decryption keys. Typically
+        encryption is performed using a :term:`public key`, and it can then be
+        decrypted using a :term:`private key`. Asymmetric cryptography can also
+        be used to create signatures, which can be generated with a
+        :term:`private key` and verified with a :term:`public key`.
+
+    public key
+        This is one of two keys involved in :term:`public-key cryptography`. It
+        can be used to encrypt messages for someone possessing the
+        corresponding :term:`private key` and to verify signatures created with
+        the corresponding :term:`private key`. This can be distributed
+        publicly, hence the name.
+
+    private key
+        This is one of two keys involved in :term:`public-key cryptography`. It
+        can be used to decrypt messages which were encrypted with the
+        corresponding :term:`public key`, as well as to create signatures,
+        which can be verified with the corresponding :term:`public key`. These
+        **must** be kept secret, if they are exposed, all encrypted messages
+        are compromised, and an attacker will be able to forge signatures.
+
+    authentication
+        The process of verifying that a message was created by a specific
+        individual (or program). Like encryption, authentication can be either
+        symmetric or asymmetric. Authentication is necessary for effective
+        encryption.
+
+    ciphertext indistinguishability
+        This is a property of encryption systems whereby two encrypted messages
+        aren't distinguishable without knowing the encryption key. This is
+        considered a basic, necessary property for a working encryption system.
+
+    text
+        This type corresponds to ``unicode`` on Python 2 and ``str`` on Python
+        3.  This is equivalent to ``six.text_type``.
+
+    nonce
+        A nonce is a **n**\ umber used **once**. Nonces are used in many
+        cryptographic protocols. Generally, a nonce does not have to be secret
+        or unpredictable, but it must be unique. A nonce is often a random
+        or pseudo-random number (see :doc:`Random number generation
+        </random-numbers>`). Since a nonce does not have to be unpredictable,
+        it can also take a form of a counter.
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/backends/commoncrypto.rst hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/backends/commoncrypto.rst
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/backends/commoncrypto.rst	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/backends/commoncrypto.rst	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,30 @@
+.. hazmat::
+
+CommonCrypto backend
+====================
+
+The `CommonCrypto`_ C library provided by Apple on OS X and iOS. The
+CommonCrypto backend is only supported on OS X versions 10.8 and above.
+
+.. currentmodule:: cryptography.hazmat.backends.commoncrypto.backend
+
+.. versionadded:: 0.2
+
+.. data:: cryptography.hazmat.backends.commoncrypto.backend
+
+    This is the exposed API for the CommonCrypto backend.
+
+    It implements the following interfaces:
+
+    * :class:`~cryptography.hazmat.backends.interfaces.CipherBackend`
+    * :class:`~cryptography.hazmat.backends.interfaces.HashBackend`
+    * :class:`~cryptography.hazmat.backends.interfaces.HMACBackend`
+    * :class:`~cryptography.hazmat.backends.interfaces.PBKDF2HMACBackend`
+
+    It has one additional public attribute.
+
+    .. attribute:: name
+
+        The string name of this backend: ``"commoncrypto"``
+
+.. _`CommonCrypto`: https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man3/Common%20Crypto.3cc.html
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/backends/index.rst hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/backends/index.rst
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/backends/index.rst	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/backends/index.rst	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,36 @@
+.. hazmat::
+
+Backends
+========
+
+Getting a backend
+-----------------
+
+.. currentmodule:: cryptography.hazmat.backends
+
+``cryptography`` aims to support multiple backends to ensure it can provide
+the widest number of supported cryptographic algorithms as well as supporting
+platform specific implementations.
+
+You can get the default backend by calling :func:`~default_backend`.
+
+The default backend will change over time as we implement new backends and
+the libraries we use in those backends changes.
+
+
+.. function:: default_backend()
+
+    :returns: An object that provides at least
+        :class:`~interfaces.CipherBackend`, :class:`~interfaces.HashBackend`, and
+        :class:`~interfaces.HMACBackend`.
+
+Individual backends
+-------------------
+
+.. toctree::
+    :maxdepth: 1
+
+    openssl
+    commoncrypto
+    multibackend
+    interfaces
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/backends/interfaces.rst hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/backends/interfaces.rst
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/backends/interfaces.rst	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/backends/interfaces.rst	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,656 @@
+.. hazmat::
+
+Backend interfaces
+==================
+
+.. currentmodule:: cryptography.hazmat.backends.interfaces
+
+
+Backend implementations may provide a number of interfaces to support
+operations such as :doc:`/hazmat/primitives/symmetric-encryption`,
+:doc:`/hazmat/primitives/cryptographic-hashes`, and
+:doc:`/hazmat/primitives/mac/hmac`.
+
+A specific ``backend`` may provide one or more of these interfaces.
+
+
+.. class:: CipherBackend
+
+    A backend that provides methods for using ciphers for encryption
+    and decryption.
+
+    The following backends implement this interface:
+
+    * :doc:`/hazmat/backends/openssl`
+    * :doc:`/hazmat/backends/commoncrypto`
+
+    .. method:: cipher_supported(cipher, mode)
+
+        Check if a ``cipher`` and ``mode`` combination is supported by
+        this backend.
+
+        :param cipher: An instance of a
+            :class:`~cryptography.hazmat.primitives.ciphers.CipherAlgorithm`
+            provider.
+        :param mode: An instance of a
+            :class:`~cryptography.hazmat.primitives.ciphers.modes.Mode` provider.
+
+        :returns: ``True`` if the specified ``cipher`` and ``mode`` combination
+            is supported by this backend, otherwise ``False``
+
+
+    .. method:: create_symmetric_encryption_ctx(cipher, mode)
+
+        Create a
+        :class:`~cryptography.hazmat.primitives.ciphers.CipherContext` that
+        can be used for encrypting data with the symmetric ``cipher`` using
+        the given ``mode``.
+
+        :param cipher: An instance of a
+            :class:`~cryptography.hazmat.primitives.ciphers.CipherAlgorithm`
+            provider.
+        :param mode: An instance of a
+            :class:`~cryptography.hazmat.primitives.ciphers.modes.Mode` provider.
+
+        :returns:
+            :class:`~cryptography.hazmat.primitives.ciphers.CipherContext`
+
+        :raises ValueError: When tag is not None in an AEAD mode
+
+
+    .. method:: create_symmetric_decryption_ctx(cipher, mode)
+
+        Create a
+        :class:`~cryptography.hazmat.primitives.ciphers.CipherContext` that
+        can be used for decrypting data with the symmetric ``cipher`` using
+        the given ``mode``.
+
+        :param cipher: An instance of a
+            :class:`~cryptography.hazmat.primitives.ciphers.CipherAlgorithm`
+            provider.
+        :param mode: An instance of a
+            :class:`~cryptography.hazmat.primitives.ciphers.modes.Mode` provider.
+
+        :returns:
+            :class:`~cryptography.hazmat.primitives.ciphers.CipherContext`
+
+        :raises ValueError: When tag is None in an AEAD mode
+
+
+.. class:: HashBackend
+
+    A backend with methods for using cryptographic hash functions.
+
+    The following backends implement this interface:
+
+    * :doc:`/hazmat/backends/openssl`
+    * :doc:`/hazmat/backends/commoncrypto`
+
+    .. method:: hash_supported(algorithm)
+
+        Check if the specified ``algorithm`` is supported by this backend.
+
+        :param algorithm: An instance of a
+            :class:`~cryptography.hazmat.primitives.hashes.HashAlgorithm`
+            provider.
+
+        :returns: ``True`` if the specified ``algorithm`` is supported by this
+            backend, otherwise ``False``.
+
+
+    .. method:: create_hash_ctx(algorithm)
+
+        Create a
+        :class:`~cryptography.hazmat.primitives.hashes.HashContext` that
+        uses the specified ``algorithm`` to calculate a message digest.
+
+        :param algorithm: An instance of a
+            :class:`~cryptography.hazmat.primitives.hashes.HashAlgorithm`
+            provider.
+
+        :returns:
+            :class:`~cryptography.hazmat.primitives.hashes.HashContext`
+
+
+.. class:: HMACBackend
+
+    A backend with methods for using cryptographic hash functions as message
+    authentication codes.
+
+    The following backends implement this interface:
+
+    * :doc:`/hazmat/backends/openssl`
+    * :doc:`/hazmat/backends/commoncrypto`
+
+    .. method:: hmac_supported(algorithm)
+
+        Check if the specified ``algorithm`` is supported by this backend.
+
+        :param algorithm: An instance of a
+            :class:`~cryptography.hazmat.primitives.hashes.HashAlgorithm`
+            provider.
+
+        :returns: ``True`` if the specified ``algorithm`` is supported for HMAC
+            by this backend, otherwise ``False``.
+
+    .. method:: create_hmac_ctx(algorithm)
+
+        Create a
+        :class:`~cryptography.hazmat.primitives.hashes.HashContext` that
+        uses the specified ``algorithm`` to calculate a hash-based message
+        authentication code.
+
+        :param algorithm: An instance of a
+            :class:`~cryptography.hazmat.primitives.hashes.HashAlgorithm`
+            provider.
+
+        :returns:
+            :class:`~cryptography.hazmat.primitives.hashes.HashContext`
+
+
+.. class:: CMACBackend
+
+    .. versionadded:: 0.4
+
+    A backend with methods for using CMAC
+
+    .. method:: cmac_algorithm_supported(algorithm)
+
+        :param algorithm: An instance of a
+            :class:`~cryptography.hazmat.primitives.ciphers.BlockCipherAlgorithm`
+            provider.
+        :return: Returns True if the block cipher is supported for CMAC by this backend
+
+    .. method:: create_cmac_ctx(algorithm)
+
+        Create a
+        :class:`~cryptography.hazmat.primitives.interfaces.MACContext` that
+        uses the specified ``algorithm`` to calculate a message authentication code.
+
+        :param algorithm: An instance of a
+            :class:`~cryptography.hazmat.primitives.ciphers.BlockCipherAlgorithm`
+            provider.
+
+        :returns:
+            :class:`~cryptography.hazmat.primitives.interfaces.MACContext`
+
+
+.. class:: PBKDF2HMACBackend
+
+    .. versionadded:: 0.2
+
+    A backend with methods for using PBKDF2 using HMAC as a PRF.
+
+    The following backends implement this interface:
+
+    * :doc:`/hazmat/backends/openssl`
+    * :doc:`/hazmat/backends/commoncrypto`
+
+    .. method:: pbkdf2_hmac_supported(algorithm)
+
+        Check if the specified ``algorithm`` is supported by this backend.
+
+        :param algorithm: An instance of a
+            :class:`~cryptography.hazmat.primitives.hashes.HashAlgorithm`
+            provider.
+
+        :returns: ``True`` if the specified ``algorithm`` is supported for
+            PBKDF2 HMAC by this backend, otherwise ``False``.
+
+    .. method:: derive_pbkdf2_hmac(self, algorithm, length, salt, iterations, key_material)
+
+        :param algorithm: An instance of a
+            :class:`~cryptography.hazmat.primitives.hashes.HashAlgorithm`
+            provider.
+
+        :param int length: The desired length of the derived key. Maximum is
+            (2\ :sup:`32` - 1) * ``algorithm.digest_size``
+
+        :param bytes salt: A salt.
+
+        :param int iterations: The number of iterations to perform of the hash
+            function. This can be used to control the length of time the
+            operation takes. Higher numbers help mitigate brute force attacks
+            against derived keys.
+
+        :param bytes key_material: The key material to use as a basis for
+            the derived key. This is typically a password.
+
+        :return bytes: Derived key.
+
+
+.. class:: RSABackend
+
+    .. versionadded:: 0.2
+
+    A backend with methods for using RSA.
+
+    .. method:: generate_rsa_private_key(public_exponent, key_size)
+
+        :param int public_exponent: The public exponent of the new key.
+            Often one of the small Fermat primes 3, 5, 17, 257 or 65537.
+
+        :param int key_size: The length in bits of the modulus. Should be
+            at least 2048.
+
+        :return: A new instance of a
+            :class:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPrivateKey`
+            provider.
+
+        :raises ValueError: If the public_exponent is not valid.
+
+    .. method:: rsa_padding_supported(padding)
+
+        Check if the specified ``padding`` is supported by the backend.
+
+        :param padding: An instance of an
+            :class:`~cryptography.hazmat.primitives.asymmetric.padding.AsymmetricPadding`
+            provider.
+
+        :returns: ``True`` if the specified ``padding`` is supported by this
+            backend, otherwise ``False``.
+
+    .. method:: generate_rsa_parameters_supported(public_exponent, key_size)
+
+        Check if the specified parameters are supported for key generation by
+        the backend.
+
+        :param int public_exponent: The public exponent.
+
+        :param int key_size: The bit length of the generated modulus.
+
+    .. method:: load_rsa_private_numbers(numbers)
+
+        :param numbers: An instance of
+            :class:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPrivateNumbers`.
+
+        :returns: A provider of
+            :class:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPrivateKey`.
+
+        :raises ValueError: This is raised when the values of ``p``, ``q``,
+            ``private_exponent``, ``public_exponent``, or ``modulus`` do not
+            match the bounds specified in :rfc:`3447`.
+
+        :raises cryptography.exceptions.UnsupportedAlgorithm: This is raised
+            when any backend specific criteria are not met.
+
+    .. method:: load_rsa_public_numbers(numbers)
+
+        :param numbers: An instance of
+            :class:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPrivateNumbers`.
+
+        :returns: A provider of
+            :class:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPublicKey`.
+
+        :raises ValueError: This is raised when the values of
+            ``public_exponent`` or ``modulus`` do not match the bounds
+            specified in :rfc:`3447`.
+
+        :raises cryptography.exceptions.UnsupportedAlgorithm: This is raised
+            when any backend specific criteria are not met.
+
+
+.. class:: DSABackend
+
+    .. versionadded:: 0.4
+
+    A backend with methods for using DSA.
+
+    .. method:: generate_dsa_parameters(key_size)
+
+        :param int key_size: The length of the modulus in bits. It should be
+            either 1024, 2048 or 3072. For keys generated in 2015 this should
+            be at least 2048.
+            Note that some applications (such as SSH) have not yet gained
+            support for larger key sizes specified in FIPS 186-3 and are still
+            restricted to only the 1024-bit keys specified in FIPS 186-2.
+
+        :return: A new instance of a
+            :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAParameters`
+            provider.
+
+    .. method:: generate_dsa_private_key(parameters)
+
+        :param parameters: A
+            :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAParameters`
+            provider.
+
+        :return: A new instance of a
+            :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPrivateKey`
+            provider.
+
+        :raises ValueError: This is raised if the key size is not one of 1024,
+            2048, or 3072. It is also raised when OpenSSL is older than version
+            1.0.0 and the key size is larger than 1024; older OpenSSL versions
+            do not support keys larger than 1024 bits.
+
+    .. method:: generate_dsa_private_key_and_parameters(key_size)
+
+        :param int key_size: The length of the modulus in bits. It should be
+            either 1024, 2048 or 3072. For keys generated in 2015 this should
+            be at least 2048.
+            Note that some applications (such as SSH) have not yet gained
+            support for larger key sizes specified in FIPS 186-3 and are still
+            restricted to only the 1024-bit keys specified in FIPS 186-2.
+
+        :return: A new instance of a
+            :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPrivateKey`
+            provider.
+
+        :raises ValueError: This is raised if the key size is not supported
+            by the backend.
+
+    .. method:: dsa_hash_supported(algorithm)
+
+        :param algorithm: An instance of a
+            :class:`~cryptography.hazmat.primitives.hashes.HashAlgorithm`
+            provider.
+
+        :returns: ``True`` if the specified ``algorithm`` is supported by this
+            backend, otherwise ``False``.
+
+    .. method:: dsa_parameters_supported(p, q, g)
+
+        :param int p: The p value of a DSA key.
+
+        :param int q: The q value of a DSA key.
+
+        :param int g: The g value of a DSA key.
+
+        :returns: ``True`` if the given values of ``p``, ``q``, and ``g`` are
+            supported by this backend, otherwise ``False``.
+
+    .. method:: load_dsa_parameter_numbers(numbers)
+
+        :param numbers: An instance of
+            :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAParameterNumbers`.
+
+        :returns: A provider of
+            :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAParameters`.
+
+        :raises cryptography.exceptions.UnsupportedAlgorithm: This is raised
+            when any backend specific criteria are not met.
+
+    .. method:: load_dsa_private_numbers(numbers)
+
+        :param numbers: An instance of
+            :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPrivateNumbers`.
+
+        :returns: A provider of
+            :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPrivateKey`.
+
+        :raises cryptography.exceptions.UnsupportedAlgorithm: This is raised
+            when any backend specific criteria are not met.
+
+    .. method:: load_dsa_public_numbers(numbers)
+
+        :param numbers: An instance of
+            :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPublicNumbers`.
+
+        :returns: A provider of
+            :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPublicKey`.
+
+        :raises cryptography.exceptions.UnsupportedAlgorithm: This is raised
+            when any backend specific criteria are not met.
+
+
+.. class:: EllipticCurveBackend
+
+    .. versionadded:: 0.5
+
+    .. method:: elliptic_curve_supported(curve)
+
+        :param curve: An instance of a
+            :class:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurve`
+            provider.
+
+        :returns: True if the elliptic curve is supported by this backend.
+
+    .. method:: elliptic_curve_signature_algorithm_supported(signature_algorithm, curve)
+
+        :param signature_algorithm: An instance of a
+            :class:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurveSignatureAlgorithm`
+            provider.
+
+        :param curve: An instance of a
+            :class:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurve`
+            provider.
+
+        :returns: True if the signature algorithm and curve are supported by this backend.
+
+    .. method:: generate_elliptic_curve_private_key(curve)
+
+        :param curve: An instance of a
+            :class:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurve`
+            provider.
+
+    .. method:: load_elliptic_curve_private_numbers(numbers)
+
+        :param numbers: An instance of a
+            :class:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePrivateNumbers`
+            provider.
+
+        :returns: An instance of a
+            :class:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePrivateKey`
+            provider.
+
+    .. method:: load_elliptic_curve_public_numbers(numbers)
+
+        :param numbers: An instance of a
+            :class:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePublicNumbers`
+            provider.
+
+        :returns: An instance of a
+            :class:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePublicKey`
+            provider.
+
+.. class:: PEMSerializationBackend
+
+    .. versionadded:: 0.6
+
+    A backend with methods for working with any PEM encoded keys.
+
+    .. method:: load_pem_private_key(data, password)
+
+        :param bytes data: PEM data to load.
+        :param bytes password: The password to use if the data is encrypted.
+            Should be ``None`` if the data is not encrypted.
+        :return: A new instance of the appropriate type of private key that the
+            serialized data contains.
+        :raises ValueError: If the data could not be deserialized.
+        :raises cryptography.exceptions.UnsupportedAlgorithm: If the data is
+            encrypted with an unsupported algorithm.
+
+    .. method:: load_pem_public_key(data)
+
+        :param bytes data: PEM data to load.
+        :return: A new instance of the appropriate type of public key
+            serialized data contains.
+        :raises ValueError: If the data could not be deserialized.
+
+.. class:: DERSerializationBackend
+
+    .. versionadded:: 0.8
+
+    A backend with methods for working with DER encoded keys.
+
+    .. method:: load_der_private_key(data, password)
+
+        :param bytes data: DER data to load.
+        :param bytes password: The password to use if the data is encrypted.
+            Should be ``None`` if the data is not encrypted.
+        :return: A new instance of the appropriate type of private key that the
+            serialized data contains.
+        :raises ValueError: If the data could not be deserialized.
+        :raises cryptography.exceptions.UnsupportedAlgorithm: If the data is
+            encrypted with an unsupported algorithm.
+
+    .. method:: load_der_public_key(data)
+
+        :param bytes data: DER data to load.
+        :return: A new instance of the appropriate type of public key
+            serialized data contains.
+        :raises ValueError: If the data could not be deserialized.
+
+.. class:: X509Backend
+
+    .. versionadded:: 0.7
+
+    A backend with methods for working with X.509 objects.
+
+    .. method:: load_pem_x509_certificate(data)
+
+        :param bytes data: PEM formatted certificate data.
+
+        :returns: An instance of :class:`~cryptography.x509.Certificate`.
+
+    .. method:: load_der_x509_certificate(data)
+
+        :param bytes data: DER formatted certificate data.
+
+        :returns: An instance of :class:`~cryptography.x509.Certificate`.
+
+    .. method:: load_pem_x509_csr(data)
+
+        .. versionadded:: 0.9
+
+        :param bytes data: PEM formatted certificate signing request data.
+
+        :returns: An instance of
+            :class:`~cryptography.x509.CertificateSigningRequest`.
+
+    .. method:: load_der_x509_csr(data)
+
+        .. versionadded:: 0.9
+
+        :param bytes data: DER formatted certificate signing request data.
+
+        :returns: An instance of
+            :class:`~cryptography.x509.CertificateSigningRequest`.
+
+    .. method:: create_x509_csr(builder, private_key, algorithm)
+
+        .. versionadded:: 1.0
+
+        :param builder: An instance of
+            :class:`~cryptography.x509.CertificateSigningRequestBuilder`.
+
+        :param private_key: The
+            :class:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPrivateKey`,
+            :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPrivateKey` or
+            :class:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePrivateKey`
+            that will be used to sign the request.  When the request is
+            signed by a certificate authority, the private key's associated
+            public key will be stored in the resulting certificate.
+
+        :param algorithm: The
+            :class:`~cryptography.hazmat.primitives.hashes.HashAlgorithm`
+            that will be used to generate the request signature.
+
+        :returns: A new object with the
+            :class:`~cryptography.x509.CertificateSigningRequest` interface.
+
+    .. method:: create_x509_certificate(builder, private_key, algorithm)
+
+        .. versionadded:: 1.0
+
+        :param builder: An instance of
+            :class:`~cryptography.x509.CertificateBuilder`.
+
+        :param private_key: The
+            :class:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPrivateKey`,
+            :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPrivateKey` or
+            :class:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePrivateKey`
+            that will be used to sign the certificate.
+
+        :param algorithm: The
+            :class:`~cryptography.hazmat.primitives.hashes.HashAlgorithm`
+            that will be used to generate the certificate signature.
+
+        :returns: A new object with the
+            :class:`~cryptography.x509.Certificate` interface.
+
+
+.. class:: DHBackend
+
+    .. versionadded:: 0.9
+
+    A backend with methods for doing Diffie-Hellman key exchange.
+
+    .. method:: generate_dh_parameters(key_size)
+
+        :param int key_size: The bit length of the prime modulus to generate.
+
+        :return: A new instance of a
+            :class:`~cryptography.hazmat.primitives.asymmetric.dh.DHParameters`
+            provider.
+
+        :raises ValueError: If ``key_size`` is not at least 512.
+
+    .. method:: generate_dh_private_key(parameters)
+
+        :param parameters: A
+            :class:`~cryptography.hazmat.primitives.asymmetric.dh.DHParameters`
+            provider.
+
+        :return: A new instance of a
+            :class:`~cryptography.hazmat.primitives.asymmetric.dh.DHPrivateKey`
+            provider.
+
+    .. method:: generate_dh_private_key_and_parameters(self, key_size)
+
+        :param int key_size: The bit length of the prime modulus to generate.
+
+        :return: A new instance of a
+            :class:`~cryptography.hazmat.primitives.asymmetric.dh.DHPrivateKey`
+            provider.
+
+        :raises ValueError: If ``key_size`` is not at least 512.
+
+    .. method:: load_dh_private_numbers(numbers)
+
+        :param numbers: A
+            :class:`~cryptography.hazmat.primitives.asymmetric.dh.DHPrivateNumbers`
+            instance.
+
+        :return: A new instance of a
+            :class:`~cryptography.hazmat.primitives.asymmetric.dh.DHPrivateKey`
+            provider.
+
+        :raises cryptography.exceptions.UnsupportedAlgorithm: This is raised
+            when any backend specific criteria are not met.
+
+    .. method:: load_dh_public_numbers(numbers)
+
+        :param numbers: A
+            :class:`~cryptography.hazmat.primitives.asymmetric.dh.DHPublicNumbers`
+            instance.
+
+        :return: A new instance of a
+            :class:`~cryptography.hazmat.primitives.asymmetric.dh.DHPublicKey`
+            provider.
+
+        :raises cryptography.exceptions.UnsupportedAlgorithm: This is raised
+            when any backend specific criteria are not met.
+
+    .. method:: load_dh_parameter_numbers(numbers)
+
+        :param numbers: A
+            :class:`~cryptography.hazmat.primitives.asymmetric.dh.DHParameterNumbers`
+            instance.
+
+        :return: A new instance of a
+            :class:`~cryptography.hazmat.primitives.asymmetric.dh.DHParameters`
+            provider.
+
+        :raises cryptography.exceptions.UnsupportedAlgorithm: This is raised
+            when any backend specific criteria are not met.
+
+    .. method:: dh_parameters_supported(p, g)
+
+        :param int p: The p value of the DH key.
+
+        :param int g: The g value of the DH key.
+
+        :returns: ``True`` if the given values of ``p`` and ``g`` are supported
+            by this backend, otherwise ``False``.
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/backends/multibackend.rst hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/backends/multibackend.rst
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/backends/multibackend.rst	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/backends/multibackend.rst	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,45 @@
+.. hazmat::
+
+MultiBackend
+============
+
+.. currentmodule:: cryptography.hazmat.backends.multibackend
+
+.. class:: MultiBackend(backends)
+
+    .. versionadded:: 0.2
+
+    This class allows you to combine multiple backends into a single backend
+    that offers the combined features of all of its constituents.
+
+    .. testsetup::
+
+        from cryptography import utils
+        from cryptography.exceptions import UnsupportedAlgorithm, _Reasons
+        from cryptography.hazmat.backends.interfaces import HashBackend
+        from cryptography.hazmat.backends.openssl.backend import backend as backend2
+
+        @utils.register_interface(HashBackend)
+        class DummyHashBackend(object):
+            def hash_supported(self, algorithm):
+                return False
+
+            def create_hash_ctx(self, algorithm):
+                raise UnsupportedAlgorithm("", _Reasons.UNSUPPORTED_HASH)
+
+        backend1 = DummyHashBackend()
+
+    .. doctest::
+
+        >>> from cryptography.hazmat.backends.multibackend import MultiBackend
+        >>> from cryptography.hazmat.primitives import hashes
+        >>> backend1.hash_supported(hashes.SHA256())
+        False
+        >>> backend2.hash_supported(hashes.SHA256())
+        True
+        >>> multi_backend = MultiBackend([backend1, backend2])
+        >>> multi_backend.hash_supported(hashes.SHA256())
+        True
+
+    :param backends: A ``list`` of backend objects. Backends are checked for
+                     feature support in the order they appear in this list.
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/backends/openssl.rst hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/backends/openssl.rst
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/backends/openssl.rst	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/backends/openssl.rst	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,84 @@
+.. hazmat::
+
+OpenSSL backend
+===============
+
+The `OpenSSL`_ C library. Cryptography supports version ``0.9.8e`` (present in
+Red Hat Enterprise Linux 5) and greater. Earlier versions may work but are
+**not tested or supported**.
+
+.. data:: cryptography.hazmat.backends.openssl.backend
+
+    This is the exposed API for the OpenSSL backend.
+
+    It implements the following interfaces:
+
+    * :class:`~cryptography.hazmat.backends.interfaces.CipherBackend`
+    * :class:`~cryptography.hazmat.backends.interfaces.CMACBackend`
+    * :class:`~cryptography.hazmat.backends.interfaces.DERSerializationBackend`
+    * :class:`~cryptography.hazmat.backends.interfaces.DSABackend`
+    * :class:`~cryptography.hazmat.backends.interfaces.EllipticCurveBackend`
+    * :class:`~cryptography.hazmat.backends.interfaces.HashBackend`
+    * :class:`~cryptography.hazmat.backends.interfaces.HMACBackend`
+    * :class:`~cryptography.hazmat.backends.interfaces.PBKDF2HMACBackend`
+    * :class:`~cryptography.hazmat.backends.interfaces.RSABackend`
+    * :class:`~cryptography.hazmat.backends.interfaces.PEMSerializationBackend`
+    * :class:`~cryptography.hazmat.backends.interfaces.X509Backend`
+
+    It also exposes the following:
+
+    .. attribute:: name
+
+        The string name of this backend: ``"openssl"``
+
+    .. method:: activate_osrandom_engine()
+
+        Activates the OS random engine. This will effectively disable OpenSSL's
+        default CSPRNG.
+
+    .. method:: activate_builtin_random()
+
+        This will activate the default OpenSSL CSPRNG.
+
+OS random engine
+----------------
+
+OpenSSL uses a user-space CSPRNG that is seeded from system random (
+``/dev/urandom`` or ``CryptGenRandom``). This CSPRNG is not reseeded
+automatically when a process calls ``fork()``. This can result in situations
+where two different processes can return similar or identical keys and
+compromise the security of the system.
+
+The approach this project has chosen to mitigate this vulnerability is to
+include an engine that replaces the OpenSSL default CSPRNG with one that
+sources its entropy from ``/dev/urandom`` on UNIX-like operating systems and
+uses ``CryptGenRandom`` on Windows. This method of pulling from the system pool
+allows us to avoid potential issues with `initializing the RNG`_ as well as
+protecting us from the ``fork()`` weakness.
+
+This engine is **active** by default when importing the OpenSSL backend. When
+active this engine will be used to generate all the random data OpenSSL
+requests.
+
+When importing only the binding it is added to the engine list but
+**not activated**.
+
+
+OS random sources
+-----------------
+
+On OS X and FreeBSD ``/dev/urandom`` is an alias for ``/dev/random`` and
+utilizes the `Yarrow`_ algorithm.
+
+On Windows the implementation of ``CryptGenRandom`` depends on which version of
+the operation system you are using. See the `Microsoft documentation`_ for more
+details.
+
+Linux uses its own PRNG design. ``/dev/urandom`` is a non-blocking source
+seeded from the same pool as ``/dev/random``.
+
+
+.. _`OpenSSL`: https://www.openssl.org/
+.. _`initializing the RNG`: https://en.wikipedia.org/wiki/OpenSSL#Predictable_private_keys_.28Debian-specific.29
+.. _`Yarrow`: https://en.wikipedia.org/wiki/Yarrow_algorithm
+.. _`Microsoft documentation`: https://msdn.microsoft.com/en-us/library/windows/desktop/aa379942(v=vs.85).aspx
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/bindings/commoncrypto.rst hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/bindings/commoncrypto.rst
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/bindings/commoncrypto.rst	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/bindings/commoncrypto.rst	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,30 @@
+.. hazmat::
+
+CommonCrypto binding
+====================
+
+.. currentmodule:: cryptography.hazmat.bindings.commoncrypto.binding
+
+.. versionadded:: 0.2
+
+These are `CFFI`_ bindings to the `CommonCrypto`_ C library. It is only
+available on Mac OS X versions 10.8 and above.
+
+.. class:: cryptography.hazmat.bindings.commoncrypto.binding.Binding()
+
+    This is the exposed API for the CommonCrypto bindings. It has two public
+    attributes:
+
+    .. attribute:: ffi
+
+        This is a ``cffi.FFI`` instance. It can be used to allocate and
+        otherwise manipulate CommonCrypto structures.
+
+    .. attribute:: lib
+
+        This is a ``cffi`` library. It can be used to call CommonCrypto
+        functions, and access constants.
+
+
+.. _`CFFI`: https://cffi.readthedocs.org/
+.. _`CommonCrypto`: https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man3/Common%20Crypto.3cc.html
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/bindings/index.rst hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/bindings/index.rst
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/bindings/index.rst	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/bindings/index.rst	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,23 @@
+.. hazmat::
+
+Bindings
+========
+
+.. module:: cryptography.hazmat.bindings
+
+``cryptography`` aims to provide low-level CFFI based bindings to multiple
+native C libraries. These provide no automatic initialization of the library
+and may not provide complete wrappers for its API.
+
+Using these functions directly is likely to require you to be careful in
+managing memory allocation, locking and other resources.
+
+
+Individual bindings
+-------------------
+
+.. toctree::
+    :maxdepth: 1
+
+    openssl
+    commoncrypto
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/bindings/openssl.rst hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/bindings/openssl.rst
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/bindings/openssl.rst	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/bindings/openssl.rst	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,49 @@
+.. hazmat::
+
+OpenSSL binding
+===============
+
+.. currentmodule:: cryptography.hazmat.bindings.openssl.binding
+
+These are `CFFI`_ bindings to the `OpenSSL`_ C library. Cryptography supports
+version ``0.9.8e`` (present in Red Hat Enterprise Linux 5) and greater. Earlier
+versions may work but are **not tested or supported**.
+
+.. class:: cryptography.hazmat.bindings.openssl.binding.Binding()
+
+    This is the exposed API for the OpenSSL bindings. It has two public
+    attributes:
+
+    .. attribute:: ffi
+
+        This is a ``cffi.FFI`` instance. It can be used to allocate and
+        otherwise manipulate OpenSSL structures.
+
+    .. attribute:: lib
+
+        This is a ``cffi`` library. It can be used to call OpenSSL functions,
+        and access constants.
+
+    .. classmethod:: init_static_locks
+
+        Enables the best available locking callback for OpenSSL.
+        See :ref:`openssl-threading`.
+
+.. _openssl-threading:
+
+Threading
+---------
+
+``cryptography`` enables OpenSSLs `thread safety facilities`_ in two different
+ways depending on the configuration of your system. Normally the locking
+callbacks provided by your Python implementation specifically for OpenSSL will
+be used. However, if you have linked ``cryptography`` to a different version of
+OpenSSL than that used by your Python implementation we enable an alternative
+locking callback. This version is implemented in Python and so may result in
+lower performance in some situations. In particular parallelism is reduced
+because it has to acquire the GIL whenever any lock operations occur within
+OpenSSL.
+
+.. _`CFFI`: https://cffi.readthedocs.org/
+.. _`OpenSSL`: https://www.openssl.org/
+.. _`thread safety facilities`: https://www.openssl.org/docs/crypto/threads.html
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/asymmetric/dh.rst hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/asymmetric/dh.rst
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/asymmetric/dh.rst	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/asymmetric/dh.rst	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,162 @@
+.. hazmat::
+
+Diffie-Hellman key exchange
+===========================
+
+.. currentmodule:: cryptography.hazmat.primitives.asymmetric.dh
+
+
+Numbers
+~~~~~~~
+
+.. class:: DHPrivateNumbers(x, public_numbers)
+
+    .. versionadded:: 0.8
+
+    The collection of integers that make up a Diffie-Hellman private key.
+
+    .. attribute:: public_numbers
+
+        :type: :class:`~cryptography.hazmat.primitives.asymmetric.dh.DHPublicNumbers`
+
+        The :class:`DHPublicNumbers` which makes up the DH public
+        key associated with this DH private key.
+
+    .. attribute:: x
+
+        :type: int
+
+        The private value.
+
+
+.. class:: DHPublicNumbers(y, parameter_numbers)
+
+    .. versionadded:: 0.8
+
+    The collection of integers that make up a Diffie-Hellman public key.
+
+     .. attribute:: parameter_numbers
+
+        :type: :class:`~cryptography.hazmat.primitives.asymmetric.dh.DHParameterNumbers`
+
+        The parameters for this DH group.
+
+    .. attribute:: y
+
+        :type: int
+
+        The public value.
+
+
+.. class:: DHParameterNumbers(p, g)
+
+    .. versionadded:: 0.8
+
+    The collection of integers that define a Diffie-Hellman group.
+
+    .. attribute:: p
+
+        :type: int
+
+        The prime modulus value.
+
+    .. attribute:: g
+
+        :type: int
+
+        The generator value.
+
+
+Key interfaces
+~~~~~~~~~~~~~~
+
+.. class:: DHParameters
+
+    .. versionadded:: 0.9
+
+
+    .. method:: generate_private_key()
+
+        .. versionadded:: 0.9
+
+        Generate a DH private key. This method can be used to generate many
+        new private keys from a single set of parameters.
+
+        :return: A
+            :class:`~cryptography.hazmat.primitives.asymmetric.dh.DHPrivateKey`
+            provider.
+
+
+.. class:: DHParametersWithSerialization
+
+    .. versionadded:: 0.9
+
+    Inherits from :class:`~cryptography.hazmat.primitives.asymmetric.dh.DHParameters`.
+
+    .. method:: parameter_numbers()
+
+        Return the numbers that make up this set of parameters.
+
+        :return: A :class:`~cryptography.hazmat.primitives.asymmetric.dh.DHParameterNumbers`.
+
+
+.. class:: DHPrivateKey
+
+    .. versionadded:: 0.9
+
+    .. attribute:: key_size
+
+        The bit length of the prime modulus.
+
+    .. method:: public_key()
+
+        Return the public key associated with this private key.
+
+        :return: A :class:`~cryptography.hazmat.primitives.asymmetric.dh.DHPublicKey`.
+
+    .. method:: parameters()
+
+        Return the parameters associated with this private key.
+
+        :return: A :class:`~cryptography.hazmat.primitives.asymmetric.dh.DHParameters`.
+
+
+.. class:: DHPrivateKeyWithSerialization
+
+    .. versionadded:: 0.9
+
+    Inherits from :class:`~cryptography.hazmat.primitives.asymmetric.dh.DHPrivateKey`.
+
+    .. method:: private_numbers()
+
+        Return the numbers that make up this private key.
+
+        :return: A :class:`~cryptography.hazmat.primitives.asymmetric.dh.DHPrivateNumbers`.
+
+
+.. class:: DHPublicKey
+
+    .. versionadded:: 0.9
+
+    .. attribute:: key_size
+
+        The bit length of the prime modulus.
+
+    .. method:: parameters()
+
+        Return the parameters associated with this private key.
+
+        :return: A :class:`~cryptography.hazmat.primitives.asymmetric.dh.DHParameters`.
+
+
+.. class:: DHPublicKeyWithSerialization
+
+    .. versionadded:: 0.9
+
+    Inherits from :class:`~cryptography.hazmat.primitives.asymmetric.dh.DHPublicKey`.
+
+    .. method:: public_numbers()
+
+        Return the numbers that make up this public key.
+
+        :return: A :class:`~cryptography.hazmat.primitives.asymmetric.dh.DHPublicNumbers`.
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/asymmetric/dsa.rst hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/asymmetric/dsa.rst
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/asymmetric/dsa.rst	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/asymmetric/dsa.rst	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,414 @@
+.. hazmat::
+
+DSA
+===
+
+.. module:: cryptography.hazmat.primitives.asymmetric.dsa
+
+`DSA`_ is a `public-key`_ algorithm for signing messages.
+
+Generation
+~~~~~~~~~~
+
+.. function:: generate_private_key(key_size, backend)
+
+    .. versionadded:: 0.5
+
+    Generate a DSA private key from the given key size. This function will
+    generate a new set of parameters and key in one step.
+
+    :param int key_size: The length of the modulus in bits. It should be
+        either 1024, 2048 or 3072. For keys generated in 2015 this should
+        be `at least 2048`_ (See page 41).  Note that some applications
+        (such as SSH) have not yet gained support for larger key sizes
+        specified in FIPS 186-3 and are still restricted to only the
+        1024-bit keys specified in FIPS 186-2.
+
+    :param backend: A
+        :class:`~cryptography.hazmat.backends.interfaces.DSABackend`
+        provider.
+
+    :return: A :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPrivateKey`
+        provider.
+
+    :raises cryptography.exceptions.UnsupportedAlgorithm: This is raised if
+        the provided ``backend`` does not implement
+        :class:`~cryptography.hazmat.backends.interfaces.DSABackend`
+
+.. function:: generate_parameters(key_size, backend)
+
+    .. versionadded:: 0.5
+
+    Generate DSA parameters using the provided ``backend``.
+
+    :param int key_size: The length of the modulus in bits. It should be
+        either 1024, 2048 or 3072. For keys generated in 2015 this should
+        be `at least 2048`_ (See page 41).  Note that some applications
+        (such as SSH) have not yet gained support for larger key sizes
+        specified in FIPS 186-3 and are still restricted to only the
+        1024-bit keys specified in FIPS 186-2.
+
+    :param backend: A
+        :class:`~cryptography.hazmat.backends.interfaces.DSABackend`
+        provider.
+
+    :return: A :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAParameters`
+        provider.
+
+    :raises cryptography.exceptions.UnsupportedAlgorithm: This is raised if
+        the provided ``backend`` does not implement
+        :class:`~cryptography.hazmat.backends.interfaces.DSABackend`
+
+Signing
+~~~~~~~
+
+Using a :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPrivateKey`
+provider.
+
+.. doctest::
+
+    >>> from cryptography.hazmat.backends import default_backend
+    >>> from cryptography.hazmat.primitives import hashes
+    >>> from cryptography.hazmat.primitives.asymmetric import dsa
+    >>> private_key = dsa.generate_private_key(
+    ...     key_size=1024,
+    ...     backend=default_backend()
+    ... )
+    >>> signer = private_key.signer(hashes.SHA256())
+    >>> data = b"this is some data I'd like to sign"
+    >>> signer.update(data)
+    >>> signature = signer.finalize()
+
+The ``signature`` is a ``bytes`` object, whose contents is DER encoded as
+described in :rfc:`3279`. This can be decoded using
+:func:`~cryptography.hazmat.primitives.asymmetric.utils.decode_dss_signature`.
+
+Verification
+~~~~~~~~~~~~
+
+Verification is performed using a
+:class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPublicKey` provider.
+You can get a public key object with
+:func:`~cryptography.hazmat.primitives.serialization.load_pem_public_key`,
+:func:`~cryptography.hazmat.primitives.serialization.load_der_public_key`,
+:meth:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPublicNumbers.public_key`
+, or
+:meth:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPrivateKey.public_key`.
+
+.. doctest::
+
+    >>> public_key = private_key.public_key()
+    >>> verifier = public_key.verifier(signature, hashes.SHA256())
+    >>> verifier.update(data)
+    >>> verifier.verify()
+
+``verifier()`` takes the signature in the same format as is returned by
+``signer.finalize()``.
+
+``verify()`` will raise an :class:`~cryptography.exceptions.InvalidSignature`
+exception if the signature isn't valid.
+
+Numbers
+~~~~~~~
+
+.. class:: DSAParameterNumbers(p, q, g)
+
+    .. versionadded:: 0.5
+
+    The collection of integers that make up a set of DSA parameters.
+
+    .. attribute:: p
+
+        :type: int
+
+        The public modulus.
+
+    .. attribute:: q
+
+        :type: int
+
+        The sub-group order.
+
+    .. attribute:: g
+
+        :type: int
+
+        The generator.
+
+    .. method:: parameters(backend)
+
+        :param backend: A
+            :class:`~cryptography.hazmat.backends.interfaces.DSABackend`
+            provider.
+
+        :returns: A new instance of a
+            :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAParameters`
+            provider.
+
+.. class:: DSAPublicNumbers(y, parameter_numbers)
+
+    .. versionadded:: 0.5
+
+    The collection of integers that make up a DSA public key.
+
+    .. attribute:: y
+
+        :type: int
+
+        The public value ``y``.
+
+    .. attribute:: parameter_numbers
+
+        :type: :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAParameterNumbers`
+
+        The :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAParameterNumbers`
+        associated with the public key.
+
+    .. method:: public_key(backend)
+
+        :param backend: A
+            :class:`~cryptography.hazmat.backends.interfaces.DSABackend`
+            provider.
+
+        :returns: A new instance of a
+            :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPublicKey`
+            provider.
+
+.. class:: DSAPrivateNumbers(x, public_numbers)
+
+    .. versionadded:: 0.5
+
+    The collection of integers that make up a DSA private key.
+
+    .. warning::
+
+        Revealing the value of ``x`` will compromise the security of any
+        cryptographic operations performed.
+
+    .. attribute:: x
+
+        :type: int
+
+        The private value ``x``.
+
+    .. attribute:: public_numbers
+
+        :type: :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPublicNumbers`
+
+        The :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPublicNumbers`
+        associated with the private key.
+
+    .. method:: private_key(backend)
+
+        :param backend: A
+            :class:`~cryptography.hazmat.backends.interfaces.DSABackend`
+            provider.
+
+        :returns: A new instance of a
+            :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPrivateKey`
+            provider.
+
+Key interfaces
+~~~~~~~~~~~~~~
+
+.. class:: DSAParameters
+
+    .. versionadded:: 0.3
+
+    `DSA`_ parameters.
+
+    .. method:: generate_private_key()
+
+        .. versionadded:: 0.5
+
+        Generate a DSA private key. This method can be used to generate many
+        new private keys from a single set of parameters.
+
+        :return: A
+            :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPrivateKey`
+            provider.
+
+
+.. class:: DSAParametersWithNumbers
+
+    .. versionadded:: 0.5
+
+    Extends :class:`DSAParameters`.
+
+    .. method:: parameter_numbers()
+
+        Create a
+        :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAParameterNumbers`
+        object.
+
+        :returns: A
+            :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAParameterNumbers`
+            instance.
+
+
+.. class:: DSAPrivateKey
+
+    .. versionadded:: 0.3
+
+    A `DSA`_ private key.
+
+    .. method:: public_key()
+
+        :return: :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPublicKey`
+
+        An DSA public key object corresponding to the values of the private key.
+
+    .. method:: parameters()
+
+        :return: :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAParameters`
+
+        The DSAParameters object associated with this private key.
+
+    .. method:: signer(algorithm, backend)
+
+        .. versionadded:: 0.4
+
+        Sign data which can be verified later by others using the public key.
+        The signature is formatted as DER-encoded bytes, as specified in
+        :rfc:`3279`.
+
+        :param algorithm: An instance of a
+            :class:`~cryptography.hazmat.primitives.hashes.HashAlgorithm`
+            provider.
+
+        :param backend: A
+            :class:`~cryptography.hazmat.backends.interfaces.DSABackend`
+            provider.
+
+        :returns:
+            :class:`~cryptography.hazmat.primitives.asymmetric.AsymmetricSignatureContext`
+
+    .. attribute:: key_size
+
+        :type: int
+
+        The bit length of the modulus.
+
+
+.. class:: DSAPrivateKeyWithSerialization
+
+    .. versionadded:: 0.8
+
+    Extends :class:`DSAPrivateKey`.
+
+    .. method:: private_numbers()
+
+        Create a
+        :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPrivateNumbers`
+        object.
+
+        :returns: A
+            :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPrivateNumbers`
+            instance.
+
+    .. method:: private_bytes(encoding, format, encryption_algorithm)
+
+        Allows serialization of the key to bytes. Encoding (
+        :attr:`~cryptography.hazmat.primitives.serialization.Encoding.PEM` or
+        :attr:`~cryptography.hazmat.primitives.serialization.Encoding.DER`),
+        format (
+        :attr:`~cryptography.hazmat.primitives.serialization.PrivateFormat.TraditionalOpenSSL`
+        or
+        :attr:`~cryptography.hazmat.primitives.serialization.PrivateFormat.PKCS8`)
+        and encryption algorithm (such as
+        :class:`~cryptography.hazmat.primitives.serialization.BestAvailableEncryption`
+        or :class:`~cryptography.hazmat.primitives.serialization.NoEncryption`)
+        are chosen to define the exact serialization.
+
+        :param encoding: A value from the
+            :class:`~cryptography.hazmat.primitives.serialization.Encoding` enum.
+
+        :param format: A value from the
+            :class:`~cryptography.hazmat.primitives.serialization.PrivateFormat`
+            enum.
+
+        :param encryption_algorithm: An instance of an object conforming to the
+            :class:`~cryptography.hazmat.primitives.serialization.KeySerializationEncryption`
+            interface.
+
+        :return bytes: Serialized key.
+
+
+.. class:: DSAPublicKey
+
+    .. versionadded:: 0.3
+
+    A `DSA`_ public key.
+
+    .. attribute:: key_size
+
+        :type: int
+
+        The bit length of the modulus.
+
+    .. method:: parameters()
+
+        :return: :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAParameters`
+
+        The DSAParameters object associated with this public key.
+
+    .. method:: verifier(signature, algorithm, backend)
+
+        .. versionadded:: 0.4
+
+        Verify data was signed by the private key associated with this public
+        key.
+
+        :param bytes signature: The signature to verify. DER encoded as
+            specified in :rfc:`3279`.
+
+        :param algorithm: An instance of a
+            :class:`~cryptography.hazmat.primitives.hashes.HashAlgorithm`
+            provider.
+
+        :param backend: A
+            :class:`~cryptography.hazmat.backends.interfaces.DSABackend`
+            provider.
+
+        :returns:
+            :class:`~cryptography.hazmat.primitives.asymmetric.AsymmetricVerificationContext`
+
+    .. method:: public_numbers()
+
+        Create a
+        :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPublicNumbers`
+        object.
+
+        :returns: A
+            :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPublicNumbers`
+            instance.
+
+    .. method:: public_bytes(encoding, format)
+
+        Allows serialization of the key to bytes. Encoding (
+        :attr:`~cryptography.hazmat.primitives.serialization.Encoding.PEM` or
+        :attr:`~cryptography.hazmat.primitives.serialization.Encoding.DER`) and
+        format (
+        :attr:`~cryptography.hazmat.primitives.serialization.PublicFormat.SubjectPublicKeyInfo`)
+        are chosen to define the exact serialization.
+
+        :param encoding: A value from the
+            :class:`~cryptography.hazmat.primitives.serialization.Encoding` enum.
+
+        :param format: A value from the
+            :class:`~cryptography.hazmat.primitives.serialization.PublicFormat` enum.
+
+        :return bytes: Serialized key.
+
+
+.. class:: DSAPublicKeyWithSerialization
+
+    .. versionadded:: 0.8
+
+    Alias for :class:`DSAPublicKey`.
+
+
+.. _`DSA`: https://en.wikipedia.org/wiki/Digital_Signature_Algorithm
+.. _`public-key`: https://en.wikipedia.org/wiki/Public-key_cryptography
+.. _`FIPS 186-4`: http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf
+.. _`at least 2048`: http://www.ecrypt.eu.org/ecrypt2/documents/D.SPA.20.pdf
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/asymmetric/ec.rst hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/asymmetric/ec.rst
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/asymmetric/ec.rst	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/asymmetric/ec.rst	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,512 @@
+.. hazmat::
+
+Elliptic curve cryptography
+===========================
+
+.. module:: cryptography.hazmat.primitives.asymmetric.ec
+
+
+.. function:: generate_private_key(curve, backend)
+
+    .. versionadded:: 0.5
+
+    Generate a new private key on ``curve`` for use with ``backend``.
+
+    :param curve: A :class:`EllipticCurve` provider.
+
+    :param backend: A
+        :class:`~cryptography.hazmat.backends.interfaces.EllipticCurveBackend`
+        provider.
+
+    :returns: A new instance of a :class:`EllipticCurvePrivateKey` provider.
+
+
+Elliptic Curve Signature Algorithms
+-----------------------------------
+
+.. class:: ECDSA(algorithm)
+
+    .. versionadded:: 0.5
+
+    The ECDSA signature algorithm first standardized in NIST publication
+    `FIPS 186-3`_, and later in `FIPS 186-4`_.
+
+    :param algorithm: An instance of a
+        :class:`~cryptography.hazmat.primitives.hashes.HashAlgorithm`
+        provider.
+
+    .. doctest::
+
+        >>> from cryptography.hazmat.backends import default_backend
+        >>> from cryptography.hazmat.primitives import hashes
+        >>> from cryptography.hazmat.primitives.asymmetric import ec
+        >>> private_key = ec.generate_private_key(
+        ...     ec.SECP384R1(), default_backend()
+        ... )
+        >>> signer = private_key.signer(ec.ECDSA(hashes.SHA256()))
+        >>> signer.update(b"this is some data I'd like")
+        >>> signer.update(b" to sign")
+        >>> signature = signer.finalize()
+
+    The ``signature`` is a ``bytes`` object, whose contents is DER encoded as
+    described in :rfc:`3279`. This can be decoded using
+    :func:`~cryptography.hazmat.primitives.asymmetric.utils.decode_dss_signature`.
+
+
+
+.. class:: EllipticCurvePrivateNumbers(private_value, public_numbers)
+
+    .. versionadded:: 0.5
+
+    The collection of integers that make up an EC private key.
+
+    .. attribute:: public_numbers
+
+        :type: :class:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePublicNumbers`
+
+        The :class:`EllipticCurvePublicNumbers` which makes up the EC public
+        key associated with this EC private key.
+
+    .. attribute:: private_value
+
+        :type: int
+
+        The private value.
+
+    .. method:: private_key(backend)
+
+        Convert a collection of numbers into a private key suitable for doing
+        actual cryptographic operations.
+
+        :param backend: A
+            :class:`~cryptography.hazmat.backends.interfaces.EllipticCurveBackend`
+            provider.
+
+        :returns: A new instance of a :class:`EllipticCurvePrivateKey`
+            provider.
+
+
+.. class:: EllipticCurvePublicNumbers(x, y, curve)
+
+    .. versionadded:: 0.5
+
+    The collection of integers that make up an EC public key.
+
+     .. attribute:: curve
+
+        :type: :class:`EllipticCurve`
+
+        The elliptic curve for this key.
+
+    .. attribute:: x
+
+        :type: int
+
+        The affine x component of the public point used for verifying.
+
+    .. attribute:: y
+
+        :type: int
+
+        The affine y component of the public point used for verifying.
+
+    .. method:: public_key(backend)
+
+        Convert a collection of numbers into a public key suitable for doing
+        actual cryptographic operations.
+
+        :param backend: A
+            :class:`~cryptography.hazmat.backends.interfaces.EllipticCurveBackend`
+            provider.
+
+        :returns: A new instance of a :class:`EllipticCurvePublicKey`
+            provider.
+
+    .. method:: encode_point()
+
+        .. versionadded:: 1.1
+
+        Encodes an elliptic curve point to a byte string as described in
+        `SEC 1 v2.0`_ section 2.3.3. This method only supports uncompressed
+        points.
+
+        :return bytes: The encoded point.
+
+    .. classmethod:: from_encoded_point(curve, data)
+
+        .. versionadded:: 1.1
+
+        Decodes a byte string as described in `SEC 1 v2.0`_ section 2.3.3 and
+        returns an :class:`EllipticCurvePublicNumbers`. This method only
+        supports uncompressed points.
+
+        :param curve: An
+            :class:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurve`
+            instance.
+
+        :param bytes data: The serialized point byte string.
+
+        :returns: An :class:`EllipticCurvePublicNumbers` instance.
+
+        :raises ValueError: Raised on invalid point type or data length.
+
+        :raises TypeError: Raised when curve is not an
+            :class:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurve`.
+
+Elliptic Curve Key Exchange algorithm
+-------------------------------------
+
+.. class:: ECDH()
+
+    .. versionadded:: 1.1
+
+    The Elliptic Curve Diffie-Hellman Key Exchange algorithm first standardized
+    in NIST publication `800-56A`_, and later in `800-56Ar2`_.
+
+    For most applications the ``shared_key`` should be passed to a key
+    derivation function.
+
+    .. doctest::
+
+        >>> from cryptography.hazmat.backends import default_backend
+        >>> from cryptography.hazmat.primitives.asymmetric import ec
+        >>> private_key = ec.generate_private_key(
+        ...     ec.SECP384R1(), default_backend()
+        ... )
+        >>> peer_public_key = ec.generate_private_key(
+        ...     ec.SECP384R1(), default_backend()
+        ... ).public_key()
+        >>> shared_key = private_key.exchange(ec.ECDH(), peer_public_key)
+
+    ECDHE (or EECDH), the ephemeral form of this exchange, is **strongly
+    preferred** over simple ECDH and provides `forward secrecy`_ when used.
+    You must generate a new private key using :func:`generate_private_key` for
+    each :meth:`~EllipticCurvePrivateKey.exchange` when performing an ECDHE key
+    exchange.
+
+Elliptic Curves
+---------------
+
+Elliptic curves provide equivalent security at much smaller key sizes than
+other asymmetric cryptography systems such as RSA or DSA. For many operations
+elliptic curves are also significantly faster; `elliptic curve diffie-hellman
+is faster than diffie-hellman`_.
+
+.. note::
+    Curves with a size of `less than 224 bits`_ should not be used. You should
+    strongly consider using curves of at least 224 bits.
+
+Generally the NIST prime field ("P") curves are significantly faster than the
+other types suggested by NIST at both signing and verifying with ECDSA.
+
+Prime fields also `minimize the number of security concerns for elliptic-curve
+cryptography`_. However, there is `some concern`_ that both the prime field and
+binary field ("B") NIST curves may have been weakened during their generation.
+
+Currently `cryptography` only supports NIST curves, none of which are
+considered "safe" by the `SafeCurves`_ project run by Daniel J. Bernstein and
+Tanja Lange.
+
+All named curves are providers of :class:`EllipticCurve`.
+
+.. class:: SECT571K1
+
+    .. versionadded:: 0.5
+
+    SECG curve ``sect571k1``. Also called NIST K-571.
+
+
+.. class:: SECT409K1
+
+    .. versionadded:: 0.5
+
+    SECG curve ``sect409k1``. Also called NIST K-409.
+
+
+.. class:: SECT283K1
+
+    .. versionadded:: 0.5
+
+    SECG curve ``sect283k1``. Also called NIST K-283.
+
+
+.. class:: SECT233K1
+
+    .. versionadded:: 0.5
+
+    SECG curve ``sect233k1``. Also called NIST K-233.
+
+
+.. class:: SECT163K1
+
+    .. versionadded:: 0.5
+
+    SECG curve ``sect163k1``. Also called NIST K-163.
+
+
+.. class:: SECT571R1
+
+    .. versionadded:: 0.5
+
+    SECG curve ``sect571r1``. Also called NIST B-571.
+
+
+.. class:: SECT409R1
+
+    .. versionadded:: 0.5
+
+    SECG curve ``sect409r1``. Also called NIST B-409.
+
+
+.. class:: SECT283R1
+
+    .. versionadded:: 0.5
+
+    SECG curve ``sect283r1``. Also called NIST B-283.
+
+
+.. class:: SECT233R1
+
+    .. versionadded:: 0.5
+
+    SECG curve ``sect233r1``. Also called NIST B-233.
+
+
+.. class:: SECT163R2
+
+    .. versionadded:: 0.5
+
+    SECG curve ``sect163r2``. Also called NIST B-163.
+
+
+.. class:: SECP521R1
+
+    .. versionadded:: 0.5
+
+    SECG curve ``secp521r1``. Also called NIST P-521.
+
+
+.. class:: SECP384R1
+
+    .. versionadded:: 0.5
+
+    SECG curve ``secp384r1``. Also called NIST P-384.
+
+
+.. class:: SECP256R1
+
+    .. versionadded:: 0.5
+
+    SECG curve ``secp256r1``. Also called NIST P-256.
+
+
+.. class:: SECT224R1
+
+    .. versionadded:: 0.5
+
+    SECG curve ``secp224r1``. Also called NIST P-224.
+
+
+.. class:: SECP192R1
+
+    .. versionadded:: 0.5
+
+    SECG curve ``secp192r1``. Also called NIST P-192.
+
+
+.. class:: SECP256K1
+
+    .. versionadded:: 0.9
+
+    SECG curve ``secp256k1``.
+
+
+Key Interfaces
+~~~~~~~~~~~~~~
+
+.. class:: EllipticCurve
+
+    .. versionadded:: 0.5
+
+    A named elliptic curve.
+
+    .. attribute:: name
+
+        :type: string
+
+        The name of the curve. Usually the name used for the ASN.1 OID such as
+        ``secp256k1``.
+
+    .. attribute:: key_size
+
+        :type: int
+
+        The bit length of the curve's base point.
+
+
+.. class:: EllipticCurveSignatureAlgorithm
+
+    .. versionadded:: 0.5
+
+    A signature algorithm for use with elliptic curve keys.
+
+    .. attribute:: algorithm
+
+        :type: :class:`~cryptography.hazmat.primitives.hashes.HashAlgorithm`
+
+        The digest algorithm to be used with the signature scheme.
+
+
+.. class:: EllipticCurvePrivateKey
+
+    .. versionadded:: 0.5
+
+    An elliptic curve private key for use with an algorithm such as `ECDSA`_ or
+    `EdDSA`_.
+
+    .. method:: signer(signature_algorithm)
+
+        Sign data which can be verified later by others using the public key.
+        The signature is formatted as DER-encoded bytes, as specified in
+        :rfc:`3279`.
+
+        :param signature_algorithm: An instance of a
+            :class:`EllipticCurveSignatureAlgorithm` provider.
+
+        :returns:
+            :class:`~cryptography.hazmat.primitives.asymmetric.AsymmetricSignatureContext`
+
+    .. method:: exchange(algorithm, peer_public_key)
+
+        .. versionadded:: 1.1
+
+        Perform's a key exchange operation using the provided algorithm with
+        the peer's public key.
+
+        For most applications the result should be passed to a key derivation
+        function.
+
+        :param algorithm: The key exchange algorithm, currently only
+            :class:`~cryptography.hazmat.primitives.asymmetric.ec.ECDH` is
+            supported.
+        :param EllipticCurvePublicKey peer_public_key: The public key for the
+            peer.
+
+        :returns bytes: A shared key.
+
+    .. method:: public_key()
+
+        :return: :class:`EllipticCurvePublicKey`
+
+        The EllipticCurvePublicKey object for this private key.
+
+
+.. class:: EllipticCurvePrivateKeyWithSerialization
+
+    .. versionadded:: 0.8
+
+    Extends :class:`EllipticCurvePrivateKey`.
+
+    .. method:: private_numbers()
+
+        Create a :class:`EllipticCurvePrivateNumbers` object.
+
+        :returns: An :class:`EllipticCurvePrivateNumbers` instance.
+
+    .. method:: private_bytes(encoding, format, encryption_algorithm)
+
+        Allows serialization of the key to bytes. Encoding (
+        :attr:`~cryptography.hazmat.primitives.serialization.Encoding.PEM` or
+        :attr:`~cryptography.hazmat.primitives.serialization.Encoding.DER`),
+        format (
+        :attr:`~cryptography.hazmat.primitives.serialization.PrivateFormat.TraditionalOpenSSL`
+        or
+        :attr:`~cryptography.hazmat.primitives.serialization.PrivateFormat.PKCS8`)
+        and encryption algorithm (such as
+        :class:`~cryptography.hazmat.primitives.serialization.BestAvailableEncryption`
+        or :class:`~cryptography.hazmat.primitives.serialization.NoEncryption`)
+        are chosen to define the exact serialization.
+
+        :param encoding: A value from the
+            :class:`~cryptography.hazmat.primitives.serialization.Encoding` enum.
+
+        :param format: A value from the
+            :class:`~cryptography.hazmat.primitives.serialization.PrivateFormat` enum.
+
+        :param encryption_algorithm: An instance of an object conforming to the
+            :class:`~cryptography.hazmat.primitives.serialization.KeySerializationEncryption`
+            interface.
+
+        :return bytes: Serialized key.
+
+
+.. class:: EllipticCurvePublicKey
+
+    .. versionadded:: 0.5
+
+    An elliptic curve public key.
+
+    .. method:: verifier(signature, signature_algorithm)
+
+        Verify data was signed by the private key associated with this public
+        key.
+
+        :param bytes signature: The signature to verify. DER encoded as
+            specified in :rfc:`3279`.
+
+        :param signature_algorithm: An instance of a
+            :class:`EllipticCurveSignatureAlgorithm` provider.
+
+        :returns:
+            :class:`~cryptography.hazmat.primitives.asymmetric.AsymmetricVerificationContext`
+
+     .. attribute:: curve
+
+        :type: :class:`EllipticCurve`
+
+        The elliptic curve for this key.
+
+    .. method:: public_numbers()
+
+        Create a :class:`EllipticCurvePublicNumbers` object.
+
+        :returns: An :class:`EllipticCurvePublicNumbers` instance.
+
+    .. method:: public_bytes(encoding, format)
+
+        Allows serialization of the key to bytes. Encoding (
+        :attr:`~cryptography.hazmat.primitives.serialization.Encoding.PEM` or
+        :attr:`~cryptography.hazmat.primitives.serialization.Encoding.DER`) and
+        format (
+        :attr:`~cryptography.hazmat.primitives.serialization.PublicFormat.SubjectPublicKeyInfo`)
+        are chosen to define the exact serialization.
+
+        :param encoding: A value from the
+            :class:`~cryptography.hazmat.primitives.serialization.Encoding` enum.
+
+        :param format: A value from the
+            :class:`~cryptography.hazmat.primitives.serialization.PublicFormat` enum.
+
+        :return bytes: Serialized key.
+
+
+.. class:: EllipticCurvePublicKeyWithSerialization
+
+    .. versionadded:: 0.6
+
+    Alias for :class:`EllipticCurvePublicKey`.
+
+
+.. _`FIPS 186-3`: http://csrc.nist.gov/publications/fips/fips186-3/fips_186-3.pdf
+.. _`FIPS 186-4`: http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf
+.. _`800-56A`: http://csrc.nist.gov/publications/nistpubs/800-56A/SP800-56A_Revision1_Mar08-2007.pdf
+.. _`800-56Ar2`: http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-56Ar2.pdf
+.. _`some concern`: https://crypto.stackexchange.com/questions/10263/should-we-trust-the-nist-recommended-ecc-parameters
+.. _`less than 224 bits`: http://www.ecrypt.eu.org/ecrypt2/documents/D.SPA.20.pdf
+.. _`elliptic curve diffie-hellman is faster than diffie-hellman`: http://digitalcommons.unl.edu/cgi/viewcontent.cgi?article=1100&context=cseconfwork
+.. _`minimize the number of security concerns for elliptic-curve cryptography`: http://cr.yp.to/ecdh/curve25519-20060209.pdf
+.. _`SafeCurves`: http://safecurves.cr.yp.to/
+.. _`ECDSA`: https://en.wikipedia.org/wiki/ECDSA
+.. _`EdDSA`: https://en.wikipedia.org/wiki/EdDSA
+.. _`forward secrecy`: https://en.wikipedia.org/wiki/Forward_secrecy
+.. _`SEC 1 v2.0`: http://www.secg.org/sec1-v2.pdf
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/asymmetric/index.rst hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/asymmetric/index.rst
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/asymmetric/index.rst	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/asymmetric/index.rst	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,38 @@
+.. hazmat::
+
+Asymmetric algorithms
+=====================
+
+Asymmetric cryptography is a branch of cryptography where a secret key can be
+divided into two parts, a :term:`public key` and a :term:`private key`. The
+public key can be given to anyone, trusted or not, while the private key must
+be kept secret (just like the key in symmetric cryptography).
+
+Asymmetric cryptography has two primary use cases: authentication and
+confidentiality. Using asymmetric cryptography, messages can be signed with a
+private key, and then anyone with the public key is able to verify that the
+message was created by someone possessing the corresponding private key. This
+can be combined with a `proof of identity`_ system to know what entity (person
+or group) actually owns that private key, providing authentication.
+
+Encryption with asymmetric cryptography works in a slightly different way from
+symmetric encryption. Someone with the public key is able to encrypt a message,
+providing confidentiality, and then only the person in possession of the
+private key is able to decrypt it.
+
+Cryptography supports three different sets of asymmetric algorithms: RSA, DSA,
+and Elliptic Curve.
+
+.. toctree::
+    :maxdepth: 1
+
+    dsa
+    ec
+    rsa
+    dh
+    serialization
+    interfaces
+    utils
+
+
+.. _`proof of identity`: https://en.wikipedia.org/wiki/Public-key_infrastructure
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/asymmetric/interfaces.rst hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/asymmetric/interfaces.rst
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/asymmetric/interfaces.rst	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/asymmetric/interfaces.rst	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,32 @@
+.. hazmat::
+
+.. module:: cryptography.hazmat.primitives.asymmetric
+
+Signature Interfaces
+====================
+
+.. class:: AsymmetricSignatureContext
+
+    .. versionadded:: 0.2
+
+    .. method:: update(data)
+
+        :param bytes data: The data you want to sign.
+
+    .. method:: finalize()
+
+        :return bytes signature: The signature.
+
+
+.. class:: AsymmetricVerificationContext
+
+    .. versionadded:: 0.2
+
+    .. method:: update(data)
+
+        :param bytes data: The data you wish to verify using the signature.
+
+    .. method:: verify()
+
+        :raises cryptography.exceptions.InvalidSignature: If the signature does
+            not validate.
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/asymmetric/rsa.rst hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/asymmetric/rsa.rst
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/asymmetric/rsa.rst	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/asymmetric/rsa.rst	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,661 @@
+.. hazmat::
+
+RSA
+===
+
+.. module:: cryptography.hazmat.primitives.asymmetric.rsa
+
+`RSA`_ is a `public-key`_ algorithm for encrypting and signing messages.
+
+Generation
+~~~~~~~~~~
+
+Unlike symmetric cryptography, where the key is typically just a random series
+of bytes, RSA keys have a complex internal structure with `specific
+mathematical properties`_.
+
+.. function:: generate_private_key(public_exponent, key_size, backend)
+
+    .. versionadded:: 0.5
+
+    Generates a new RSA private key using the provided ``backend``.
+    ``key_size`` describes how many bits long the key should be, larger keys
+    provide more security, currently ``1024`` and below are considered
+    breakable, and ``2048`` or ``4096`` are reasonable default key sizes for
+    new keys. The ``public_exponent`` indicates what one mathematical property
+    of the key generation will be, ``65537`` should almost always be used.
+
+    .. doctest::
+
+        >>> from cryptography.hazmat.backends import default_backend
+        >>> from cryptography.hazmat.primitives.asymmetric import rsa
+        >>> private_key = rsa.generate_private_key(
+        ...     public_exponent=65537,
+        ...     key_size=2048,
+        ...     backend=default_backend()
+        ... )
+
+    :param int public_exponent: The public exponent of the new key.
+        Usually one of the small Fermat primes 3, 5, 17, 257, 65537. If in
+        doubt you should `use 65537`_.
+
+    :param int key_size: The length of the modulus in bits. For keys
+        generated in 2015 it is strongly recommended to be
+        `at least 2048`_ (See page 41). It must not be less than 512.
+        Some backends may have additional limitations.
+
+    :param backend: A backend which provides
+        :class:`~cryptography.hazmat.backends.interfaces.RSABackend`.
+
+    :return: An instance of
+        :class:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPrivateKey`.
+
+    :raises cryptography.exceptions.UnsupportedAlgorithm: This is raised if
+        the provided ``backend`` does not implement
+        :class:`~cryptography.hazmat.backends.interfaces.RSABackend`
+
+Key loading
+~~~~~~~~~~~
+
+If you already have an on-disk key in the PEM format (which are recognizable by
+the distinctive ``-----BEGIN {format}-----`` and ``-----END {format}-----``
+markers), you can load it:
+
+.. code-block:: pycon
+
+    >>> from cryptography.hazmat.primitives import serialization
+
+    >>> with open("path/to/key.pem", "rb") as key_file:
+    ...     private_key = serialization.load_pem_private_key(
+    ...         key_file.read(),
+    ...         password=None,
+    ...         backend=default_backend()
+    ...     )
+
+Serialized keys may optionally be encrypted on disk using a password. In this
+example we loaded an unencrypted key, and therefore we did not provide a
+password. If the key is encrypted we can pass a ``bytes`` object as the
+``password`` argument.
+
+There is also support for :func:`loading public keys in the SSH format
+<cryptography.hazmat.primitives.serialization.load_ssh_public_key>`.
+
+Key serialization
+~~~~~~~~~~~~~~~~~
+
+If you have a private key that you've loaded or generated which implements the
+:class:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPrivateKeyWithSerialization`
+interface you can use
+:meth:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPrivateKeyWithSerialization.private_bytes`
+to serialize the key.
+
+.. doctest::
+
+    >>> from cryptography.hazmat.primitives import serialization
+    >>> pem = private_key.private_bytes(
+    ...    encoding=serialization.Encoding.PEM,
+    ...    format=serialization.PrivateFormat.PKCS8,
+    ...    encryption_algorithm=serialization.BestAvailableEncryption(b'mypassword')
+    ... )
+    >>> pem.splitlines()[0]
+    '-----BEGIN ENCRYPTED PRIVATE KEY-----'
+
+It is also possible to serialize without encryption using
+:class:`~cryptography.hazmat.primitives.serialization.NoEncryption`.
+
+.. doctest::
+
+    >>> pem = private_key.private_bytes(
+    ...    encoding=serialization.Encoding.PEM,
+    ...    format=serialization.PrivateFormat.TraditionalOpenSSL,
+    ...    encryption_algorithm=serialization.NoEncryption()
+    ... )
+    >>> pem.splitlines()[0]
+    '-----BEGIN RSA PRIVATE KEY-----'
+
+For public keys you can use
+:meth:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPublicKey.public_bytes`
+to serialize the key.
+
+.. doctest::
+
+    >>> from cryptography.hazmat.primitives import serialization
+    >>> public_key = private_key.public_key()
+    >>> pem = public_key.public_bytes(
+    ...    encoding=serialization.Encoding.PEM,
+    ...    format=serialization.PublicFormat.SubjectPublicKeyInfo
+    ... )
+    >>> pem.splitlines()[0]
+    '-----BEGIN PUBLIC KEY-----'
+
+Signing
+~~~~~~~
+
+A private key can be used to sign a message. This allows anyone with the public
+key to verify that the message was created by someone who possesses the
+corresponding private key. RSA signatures require a specific hash function, and
+padding to be used. Here is an example of signing ``message`` using RSA, with a
+secure hash function and padding:
+
+.. doctest::
+
+    >>> from cryptography.hazmat.primitives import hashes
+    >>> from cryptography.hazmat.primitives.asymmetric import padding
+
+    >>> signer = private_key.signer(
+    ...     padding.PSS(
+    ...         mgf=padding.MGF1(hashes.SHA256()),
+    ...         salt_length=padding.PSS.MAX_LENGTH
+    ...     ),
+    ...     hashes.SHA256()
+    ... )
+    >>> message = b"A message I want to sign"
+    >>> signer.update(message)
+    >>> signature = signer.finalize()
+
+Valid paddings for signatures are
+:class:`~cryptography.hazmat.primitives.asymmetric.padding.PSS` and
+:class:`~cryptography.hazmat.primitives.asymmetric.padding.PKCS1v15`. ``PSS``
+is the recommended choice for any new protocols or applications, ``PKCS1v15``
+should only be used to support legacy protocols.
+
+Verification
+~~~~~~~~~~~~
+
+The previous section describes what to do if you have a private key and want to
+sign something. If you have a public key, a message, a signature, and the
+signing algorithm that was used you can check that the private key associated
+with a given public key was used to sign that specific message.  You can obtain
+a public key to use in verification using
+:func:`~cryptography.hazmat.primitives.serialization.load_pem_public_key`,
+:func:`~cryptography.hazmat.primitives.serialization.load_der_public_key`,
+:meth:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPublicNumbers.public_key`
+, or
+:meth:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPrivateKey.public_key`.
+
+.. doctest::
+
+    >>> public_key = private_key.public_key()
+    >>> verifier = public_key.verifier(
+    ...     signature,
+    ...     padding.PSS(
+    ...         mgf=padding.MGF1(hashes.SHA256()),
+    ...         salt_length=padding.PSS.MAX_LENGTH
+    ...     ),
+    ...     hashes.SHA256()
+    ... )
+    >>> verifier.update(message)
+    >>> verifier.verify()
+
+If the signature does not match, ``verify()`` will raise an
+:class:`~cryptography.exceptions.InvalidSignature` exception.
+
+Encryption
+~~~~~~~~~~
+
+RSA encryption is interesting because encryption is performed using the
+**public** key, meaning anyone can encrypt data. The data is then decrypted
+using the **private** key.
+
+Like signatures, RSA supports encryption with several different padding
+options. Here's an example using a secure padding and hash function:
+
+.. doctest::
+
+    >>> message = b"encrypted data"
+    >>> ciphertext = public_key.encrypt(
+    ...     message,
+    ...     padding.OAEP(
+    ...         mgf=padding.MGF1(algorithm=hashes.SHA1()),
+    ...         algorithm=hashes.SHA1(),
+    ...         label=None
+    ...     )
+    ... )
+
+Valid paddings for encryption are
+:class:`~cryptography.hazmat.primitives.asymmetric.padding.OAEP` and
+:class:`~cryptography.hazmat.primitives.asymmetric.padding.PKCS1v15`. ``OAEP``
+is the recommended choice for any new protocols or applications, ``PKCS1v15``
+should only be used to support legacy protocols.
+
+
+Decryption
+~~~~~~~~~~
+
+Once you have an encrypted message, it can be decrypted using the private key:
+
+.. doctest::
+
+    >>> plaintext = private_key.decrypt(
+    ...     ciphertext,
+    ...     padding.OAEP(
+    ...         mgf=padding.MGF1(algorithm=hashes.SHA1()),
+    ...         algorithm=hashes.SHA1(),
+    ...         label=None
+    ...     )
+    ... )
+    >>> plaintext == message
+    True
+
+Padding
+~~~~~~~
+
+.. module:: cryptography.hazmat.primitives.asymmetric.padding
+
+.. class:: AsymmetricPadding
+
+    .. versionadded:: 0.2
+
+    .. attribute:: name
+
+.. class:: PSS(mgf, salt_length)
+
+    .. versionadded:: 0.3
+
+    .. versionchanged:: 0.4
+        Added ``salt_length`` parameter.
+
+    PSS (Probabilistic Signature Scheme) is a signature scheme defined in
+    :rfc:`3447`. It is more complex than PKCS1 but possesses a `security proof`_.
+    This is the `recommended padding algorithm`_ for RSA signatures. It cannot
+    be used with RSA encryption.
+
+    :param mgf: A mask generation function object. At this time the only
+        supported MGF is :class:`MGF1`.
+
+    :param int salt_length: The length of the salt. It is recommended that this
+        be set to ``PSS.MAX_LENGTH``.
+
+    .. attribute:: MAX_LENGTH
+
+        Pass this attribute to ``salt_length`` to get the maximum salt length
+        available.
+
+.. class:: OAEP(mgf, label)
+
+    .. versionadded:: 0.4
+
+    OAEP (Optimal Asymmetric Encryption Padding) is a padding scheme defined in
+    :rfc:`3447`. It provides probabilistic encryption and is `proven secure`_
+    against several attack types. This is the `recommended padding algorithm`_
+    for RSA encryption. It cannot be used with RSA signing.
+
+    :param mgf: A mask generation function object. At this time the only
+        supported MGF is :class:`MGF1`.
+
+    :param bytes label: A label to apply. This is a rarely used field and
+        should typically be set to ``None`` or ``b""``, which are equivalent.
+
+.. class:: PKCS1v15()
+
+    .. versionadded:: 0.3
+
+    PKCS1 v1.5 (also known as simply PKCS1) is a simple padding scheme
+    developed for use with RSA keys. It is defined in :rfc:`3447`. This padding
+    can be used for signing and encryption.
+
+    It is not recommended that ``PKCS1v15`` be used for new applications,
+    :class:`OAEP` should be preferred for encryption and :class:`PSS` should be
+    preferred for signatures.
+
+Mask generation functions
+-------------------------
+
+.. class:: MGF1(algorithm)
+
+    .. versionadded:: 0.3
+
+    .. versionchanged:: 0.6
+        Removed the deprecated ``salt_length`` parameter.
+
+    MGF1 (Mask Generation Function 1) is used as the mask generation function
+    in :class:`PSS` padding. It takes a hash algorithm and a salt length.
+
+    :param algorithm: An instance of a
+        :class:`~cryptography.hazmat.primitives.hashes.HashAlgorithm`
+        provider.
+
+Numbers
+~~~~~~~
+
+.. currentmodule:: cryptography.hazmat.primitives.asymmetric.rsa
+
+These classes hold the constituent components of an RSA key. They are useful
+only when more traditional :doc:`/hazmat/primitives/asymmetric/serialization`
+is unavailable.
+
+.. class:: RSAPublicNumbers(e, n)
+
+    .. versionadded:: 0.5
+
+    The collection of integers that make up an RSA public key.
+
+    .. attribute:: n
+
+        :type: int
+
+        The public modulus.
+
+    .. attribute:: e
+
+        :type: int
+
+        The public exponent.
+
+    .. method:: public_key(backend)
+
+        :param backend: A
+            :class:`~cryptography.hazmat.backends.interfaces.RSABackend`
+            provider.
+
+        :returns: A new instance of a
+            :class:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPublicKey`
+            provider.
+
+.. class:: RSAPrivateNumbers(p, q, d, dmp1, dmq1, iqmp, public_numbers)
+
+    .. versionadded:: 0.5
+
+    The collection of integers that make up an RSA private key.
+
+    .. warning::
+
+        With the exception of the integers contained in the
+        :class:`RSAPublicNumbers` all attributes of this class must be kept
+        secret. Revealing them will compromise the security of any
+        cryptographic operations performed with a key loaded from them.
+
+    .. attribute:: public_numbers
+
+        :type: :class:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPublicNumbers`
+
+        The :class:`RSAPublicNumbers` which makes up the RSA public key
+        associated with this RSA private key.
+
+    .. attribute:: p
+
+        :type: int
+
+        ``p``, one of the two primes composing ``n``.
+
+    .. attribute:: q
+
+        :type: int
+
+        ``q``, one of the two primes composing ``n``.
+
+    .. attribute:: d
+
+        :type: int
+
+        The private exponent.
+
+    .. attribute:: dmp1
+
+        :type: int
+
+        A `Chinese remainder theorem`_ coefficient used to speed up RSA
+        operations. Calculated as: d mod (p-1)
+
+    .. attribute:: dmq1
+
+        :type: int
+
+        A `Chinese remainder theorem`_ coefficient used to speed up RSA
+        operations. Calculated as: d mod (q-1)
+
+    .. attribute:: iqmp
+
+        :type: int
+
+        A `Chinese remainder theorem`_ coefficient used to speed up RSA
+        operations. Calculated as: q\ :sup:`-1` mod p
+
+    .. method:: private_key(backend)
+
+        :param backend: A new instance of a
+            :class:`~cryptography.hazmat.backends.interfaces.RSABackend`
+            provider.
+
+        :returns: A
+            :class:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPrivateKey`
+            provider.
+
+Handling partial RSA private keys
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+If you are trying to load RSA private keys yourself you may find that not all
+parameters required by ``RSAPrivateNumbers`` are available. In particular the
+`Chinese Remainder Theorem`_ (CRT) values ``dmp1``, ``dmq1``, ``iqmp`` may be
+missing or present in a different form. For example, `OpenPGP`_ does not include
+the ``iqmp``, ``dmp1`` or ``dmq1`` parameters.
+
+The following functions are provided for users who want to work with keys like
+this without having to do the math themselves.
+
+.. function:: rsa_crt_iqmp(p, q)
+
+    .. versionadded:: 0.4
+
+    Computes the ``iqmp`` (also known as ``qInv``) parameter from the RSA
+    primes ``p`` and ``q``.
+
+.. function:: rsa_crt_dmp1(private_exponent, p)
+
+    .. versionadded:: 0.4
+
+    Computes the ``dmp1`` parameter from the RSA private exponent and prime
+    ``p``.
+
+.. function:: rsa_crt_dmq1(private_exponent, q)
+
+    .. versionadded:: 0.4
+
+    Computes the ``dmq1`` parameter from the RSA private exponent and prime
+    ``q``.
+
+.. function:: rsa_recover_prime_factors(n, e, d)
+
+    .. versionadded:: 0.8
+
+    Computes the prime factors ``(p, q)`` given the modulus, public exponent,
+    and private exponent.
+
+    .. note::
+
+        When recovering prime factors this algorithm will always return ``p``
+        and ``q`` such that ``p < q``.
+
+    :return: A tuple ``(p, q)``
+
+
+Key interfaces
+~~~~~~~~~~~~~~
+
+.. class:: RSAPrivateKey
+
+    .. versionadded:: 0.2
+
+    An `RSA`_ private key.
+
+    .. method:: signer(padding, algorithm)
+
+        .. versionadded:: 0.3
+
+        Sign data which can be verified later by others using the public key.
+
+        :param padding: An instance of a
+            :class:`~cryptography.hazmat.primitives.asymmetric.padding.AsymmetricPadding`
+            provider.
+
+        :param algorithm: An instance of a
+            :class:`~cryptography.hazmat.primitives.hashes.HashAlgorithm`
+            provider.
+
+        :returns:
+            :class:`~cryptography.hazmat.primitives.asymmetric.AsymmetricSignatureContext`
+
+    .. method:: decrypt(ciphertext, padding)
+
+        .. versionadded:: 0.4
+
+        Decrypt data that was encrypted with the public key.
+
+        :param bytes ciphertext: The ciphertext to decrypt.
+
+        :param padding: An instance of an
+            :class:`~cryptography.hazmat.primitives.asymmetric.padding.AsymmetricPadding`
+            provider.
+
+        :return bytes: Decrypted data.
+
+    .. method:: public_key()
+
+        :return: :class:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPublicKey`
+
+        An RSA public key object corresponding to the values of the private key.
+
+    .. attribute:: key_size
+
+        :type: int
+
+        The bit length of the modulus.
+
+
+.. class:: RSAPrivateKeyWithSerialization
+
+    .. versionadded:: 0.8
+
+    Extends :class:`RSAPrivateKey`.
+
+    .. method:: private_numbers()
+
+        Create a
+        :class:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPrivateNumbers`
+        object.
+
+        :returns: An
+            :class:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPrivateNumbers`
+            instance.
+
+    .. method:: private_bytes(encoding, format, encryption_algorithm)
+
+        Allows serialization of the key to bytes. Encoding (
+        :attr:`~cryptography.hazmat.primitives.serialization.Encoding.PEM` or
+        :attr:`~cryptography.hazmat.primitives.serialization.Encoding.DER`),
+        format (
+        :attr:`~cryptography.hazmat.primitives.serialization.PrivateFormat.TraditionalOpenSSL`
+        or
+        :attr:`~cryptography.hazmat.primitives.serialization.PrivateFormat.PKCS8`)
+        and encryption algorithm (such as
+        :class:`~cryptography.hazmat.primitives.serialization.BestAvailableEncryption`
+        or :class:`~cryptography.hazmat.primitives.serialization.NoEncryption`)
+        are chosen to define the exact serialization.
+
+        :param encoding: A value from the
+            :class:`~cryptography.hazmat.primitives.serialization.Encoding` enum.
+
+        :param format: A value from the
+            :class:`~cryptography.hazmat.primitives.serialization.PrivateFormat`
+            enum.
+
+        :param encryption_algorithm: An instance of an object conforming to the
+            :class:`~cryptography.hazmat.primitives.serialization.KeySerializationEncryption`
+            interface.
+
+        :return bytes: Serialized key.
+
+
+.. class:: RSAPublicKey
+
+    .. versionadded:: 0.2
+
+    An `RSA`_ public key.
+
+    .. method:: verifier(signature, padding, algorithm)
+
+        .. versionadded:: 0.3
+
+        Verify data was signed by the private key associated with this public
+        key.
+
+        :param bytes signature: The signature to verify.
+
+        :param padding: An instance of a
+            :class:`~cryptography.hazmat.primitives.asymmetric.padding.AsymmetricPadding`
+            provider.
+
+        :param algorithm: An instance of a
+            :class:`~cryptography.hazmat.primitives.hashes.HashAlgorithm`
+            provider.
+
+        :returns:
+            :class:`~cryptography.hazmat.primitives.asymmetric.AsymmetricVerificationContext`
+
+    .. method:: encrypt(plaintext, padding)
+
+        .. versionadded:: 0.4
+
+        Encrypt data with the public key.
+
+        :param bytes plaintext: The plaintext to encrypt.
+
+        :param padding: An instance of a
+            :class:`~cryptography.hazmat.primitives.asymmetric.padding.AsymmetricPadding`
+            provider.
+
+        :return bytes: Encrypted data.
+
+    .. attribute:: key_size
+
+        :type: int
+
+        The bit length of the modulus.
+
+    .. method:: public_numbers()
+
+        Create a
+        :class:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPublicNumbers`
+        object.
+
+        :returns: An
+            :class:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPublicNumbers`
+            instance.
+
+    .. method:: public_bytes(encoding, format)
+
+        Allows serialization of the key to bytes. Encoding (
+        :attr:`~cryptography.hazmat.primitives.serialization.Encoding.PEM` or
+        :attr:`~cryptography.hazmat.primitives.serialization.Encoding.DER`) and
+        format (
+        :attr:`~cryptography.hazmat.primitives.serialization.PublicFormat.SubjectPublicKeyInfo`
+        or
+        :attr:`~cryptography.hazmat.primitives.serialization.PublicFormat.PKCS1`)
+        are chosen to define the exact serialization.
+
+        :param encoding: A value from the
+            :class:`~cryptography.hazmat.primitives.serialization.Encoding` enum.
+
+        :param format: A value from the
+            :class:`~cryptography.hazmat.primitives.serialization.PublicFormat` enum.
+
+        :return bytes: Serialized key.
+
+
+.. class:: RSAPublicKeyWithSerialization
+
+    .. versionadded:: 0.8
+
+    Alias for :class:`RSAPublicKey`.
+
+
+.. _`RSA`: https://en.wikipedia.org/wiki/RSA_(cryptosystem)
+.. _`public-key`: https://en.wikipedia.org/wiki/Public-key_cryptography
+.. _`specific mathematical properties`: https://en.wikipedia.org/wiki/RSA_(cryptosystem)#Key_generation
+.. _`use 65537`: http://www.daemonology.net/blog/2009-06-11-cryptographic-right-answers.html
+.. _`at least 2048`: http://www.ecrypt.eu.org/ecrypt2/documents/D.SPA.20.pdf
+.. _`OpenPGP`: https://en.wikipedia.org/wiki/Pretty_Good_Privacy
+.. _`Chinese Remainder Theorem`: https://en.wikipedia.org/wiki/RSA_%28cryptosystem%29#Using_the_Chinese_remainder_algorithm
+.. _`security proof`: http://eprint.iacr.org/2001/062.pdf
+.. _`recommended padding algorithm`: http://www.daemonology.net/blog/2009-06-11-cryptographic-right-answers.html
+.. _`proven secure`: https://cseweb.ucsd.edu/~mihir/papers/oae.pdf
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/asymmetric/serialization.rst hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/asymmetric/serialization.rst
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/asymmetric/serialization.rst	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/asymmetric/serialization.rst	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,391 @@
+.. hazmat::
+
+Key Serialization
+=================
+
+.. module:: cryptography.hazmat.primitives.serialization
+
+.. testsetup::
+
+    import base64
+
+    pem_data = b"""
+    -----BEGIN RSA PRIVATE KEY-----
+    MIICXgIBAAKBgQDn09PV9KPE7Q+N5K5UtNLT1DLl8z/pKM2pP5tXqWx2OsEw00lC
+    kDHdHESwzS050s/8rtkERKKyusCzCm9+vC1pQzUlmtibfF4PQAQc1pJL6KHqlidg
+    Hw49atYmnC25CaeXt65pAYXoIacOZ8k5X7FW3Eagex8nG0iMw4ObOtg6CwIDAQAB
+    AoGBAL31l/4YYN1rNrSZLrQgGyUSGsbLxJHEKolFon95R3O1fzoH117gkstQb4TE
+    Cwv3jw/JIfBaYUq8tku/AE9D2Jx51x7kYaCuQIMTavKIgkXKfxTQCQDjSEfkvXMW
+    4WOIj5sYdSCNbzLbaeFsWG32bSsBTy/sSheDIlCEFnqDuqwBAkEA+wYfJEMDf5nS
+    VCQd9VKGM4HVeTWBioaWBFCflFdhc1Vb65dsNDp8iIMZgAHC2LEX5dMUmgqXk7AT
+    lwFlIeW4CwJBAOxsSfuIVMuPKyx1xQ6ebpC7zeVxIOdswcM8ain91MSGDdKZw6pF
+    ioFh3kUbKHw4yqqHbdRmUDAJ1mcgGJQOxgECQQCmQaGylKfmhWymyd0FtIip6J4I
+    z4ViyEznwrZOu6kRiEF/QiUqWmpMx/fFrmTsvC5Fy43jkIxgBsiSxRvEXa+NAkB+
+    5m0bhwTEslchKSGZhC6inzuYAQ4BSh4C1mXBnk5bIf0/Ymtk9KiwY8CzZS1o5+7Y
+    c5LfI/+8mTss5UxsBDYBAkEA6NqhcsNWndIJZiWUU4u+RjFUQXqH8WCyJmEDCNxs
+    7SGRS1DTUGX4Y70m9dQpguy6Zg+gpHC+o+ERZR06uEQr+w==
+    -----END RSA PRIVATE KEY-----
+    """.strip()
+    public_pem_data = b"""
+    -----BEGIN PUBLIC KEY-----
+    MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDn09PV9KPE7Q+N5K5UtNLT1DLl
+    8z/pKM2pP5tXqWx2OsEw00lCkDHdHESwzS050s/8rtkERKKyusCzCm9+vC1pQzUl
+    mtibfF4PQAQc1pJL6KHqlidgHw49atYmnC25CaeXt65pAYXoIacOZ8k5X7FW3Eag
+    ex8nG0iMw4ObOtg6CwIDAQAB
+    -----END PUBLIC KEY-----
+    """.strip()
+    der_data = base64.b64decode(
+        b"MIICdwIBADANBgkqhkiG9w0BAQEFAASCAmEwggJdAgEAAoGBALskegl+DrI3Msw5Z63x"
+        b"nj1rgoPR0KykwBi+jZgAwHv/B0TJyhy6NuEnaf+x442L7lepOqoWQzlUGXyuaSQU9mT/"
+        b"vHTGZ2xM8QJJaccr4eGho0MU9HePyNCFWjWVrGKpwSEAd6CLlzC0Wiy4kC9IoAUoS/IP"
+        b"jeyLTQNCddatgcARAgMBAAECgYAA/LlKJgeJUStTcpHgGD6mXjHvnAwWJELQKDP5+tA8"
+        b"VAQGwBX1G5qzJDGrPGtHQ7DSqdwF4YFZtgTpZmGq1wsAjz3lv6L4XiVsHiIPtP1B4gMx"
+        b"X9ogxcDzVQ7hyezXPioMAcp7Isus9Csn8HhftcL56BRabn6GvWqbIAy6zJcgEQJBAMlZ"
+        b"nymKW5/jKth+wkCfqEXlPhGNPO1uq87QZUbYxwdjtSM09J9+HMfH+WXR9ARCOL46DJ0I"
+        b"JfyjcdmuDDlh9IkCQQDt76up1Tmc7lkb/89IRBu2MudGJPMEf96VCG11nmcXulyk1OLi"
+        b"TXfO62YpxZbgYrvlrNxEYlSG7WQMztBgA51JAkBU2RhyJ+S+drsaaigvlVgSxCyotszi"
+        b"/Q0XZMgY18bfPUwanvkqsLkuEv3sw1HB7an9t3aTQdjIIpQad/acw8OJAkEAjvmnCK21"
+        b"KgTbjQShtQYgNNLPwImxcjG4OYvP4o6l2k9FHlNCZsQwSymOwWkXKYyK5g+CaKFBs7Zw"
+        b"mXWpJxjk6QJBAInqbm1w3yVfGD9I2mMQi/6oDJQP3pdWU4mU4h4sdDyRgTQLpkD4yypg"
+        b"jOACt4mTzxifSVT9fT+a79SkT8FFmZE="
+    )
+    public_der_data = base64.b64decode(
+        b"MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC7JHoJfg6yNzLMOWet8Z49a4KD0dCs"
+        b"pMAYvo2YAMB7/wdEycocujbhJ2n/seONi+5XqTqqFkM5VBl8rmkkFPZk/7x0xmdsTPEC"
+        b"SWnHK+HhoaNDFPR3j8jQhVo1laxiqcEhAHegi5cwtFosuJAvSKAFKEvyD43si00DQnXW"
+        b"rYHAEQIDAQAB"
+    )
+    message = b""
+
+    def sign_with_rsa_key(key, message):
+        return b""
+
+    def sign_with_dsa_key(key, message):
+        return b""
+
+There are several common schemes for serializing asymmetric private and public
+keys to bytes. They generally support encryption of private keys and additional
+key metadata.
+
+Many serialization formats support multiple different types of asymmetric keys
+and will return an instance of the appropriate type. You should check that
+the returned key matches the type your application expects when using these
+methods.
+
+    .. doctest::
+
+        >>> from cryptography.hazmat.backends import default_backend
+        >>> from cryptography.hazmat.primitives.asymmetric import dsa, rsa
+        >>> from cryptography.hazmat.primitives.serialization import load_pem_private_key
+        >>> key = load_pem_private_key(pem_data, password=None, backend=default_backend())
+        >>> if isinstance(key, rsa.RSAPrivateKey):
+        ...     signature = sign_with_rsa_key(key, message)
+        ... elif isinstance(key, dsa.DSAPrivateKey):
+        ...     signature = sign_with_dsa_key(key, message)
+        ... else:
+        ...     raise TypeError
+
+PEM
+~~~
+
+PEM is an encapsulation format, meaning keys in it can actually be any of
+several different key types. However these are all self-identifying, so you
+don't need to worry about this detail. PEM keys are recognizable because they
+all begin with ``-----BEGIN {format}-----`` and end with ``-----END
+{format}-----``.
+
+.. note::
+
+    A PEM block which starts with ``-----BEGIN CERTIFICATE-----`` is not a
+    public or private key, it's an :doc:`X.509 Certificate </x509/index>`. You
+    can load it using :func:`~cryptography.x509.load_pem_x509_certificate` and
+    extract the public key with
+    :meth:`Certificate.public_key <cryptography.x509.Certificate.public_key>`.
+
+.. function:: load_pem_private_key(data, password, backend)
+
+    .. versionadded:: 0.6
+
+    Deserialize a private key from PEM encoded data to one of the supported
+    asymmetric private key types.
+
+    :param bytes data: The PEM encoded key data.
+
+    :param bytes password: The password to use to decrypt the data. Should
+        be ``None`` if the private key is not encrypted.
+
+    :param backend: A
+        :class:`~cryptography.hazmat.backends.interfaces.PEMSerializationBackend`
+        provider.
+
+    :returns: A new instance of a private key.
+
+    :raises ValueError: If the PEM data could not be decrypted or if its
+        structure could not be decoded successfully.
+
+    :raises TypeError: If a ``password`` was given and the private key was
+        not encrypted. Or if the key was encrypted but no
+        password was supplied.
+
+    :raises cryptography.exceptions.UnsupportedAlgorithm: If the serialized key
+        is of a type that is not supported by the backend or if the key is
+        encrypted with a symmetric cipher that is not supported by the backend.
+
+.. function:: load_pem_public_key(data, backend)
+
+    .. versionadded:: 0.6
+
+    Deserialize a public key from PEM encoded data to one of the supported
+    asymmetric public key types.
+
+    .. doctest::
+
+        >>> from cryptography.hazmat.primitives.serialization import load_pem_public_key
+        >>> key = load_pem_public_key(public_pem_data, backend=default_backend())
+        >>> isinstance(key, rsa.RSAPublicKey)
+        True
+
+    :param bytes data: The PEM encoded key data.
+
+    :param backend: A
+        :class:`~cryptography.hazmat.backends.interfaces.PEMSerializationBackend`
+        provider.
+
+    :returns: A new instance of a public key.
+
+    :raises ValueError: If the PEM data's structure could not be decoded
+        successfully.
+
+    :raises cryptography.exceptions.UnsupportedAlgorithm: If the serialized key
+        is of a type that is not supported by the backend.
+
+DER
+~~~
+
+DER is an ASN.1 encoding type. There are no encapsulation boundaries and the
+data is binary. DER keys may be in a variety of formats, but as long as you
+know whether it is a public or private key the loading functions will handle
+the rest.
+
+.. function:: load_der_private_key(data, password, backend)
+
+    .. versionadded:: 0.8
+
+    Deserialize a private key from DER encoded data to one of the supported
+    asymmetric private key types.
+
+    :param bytes data: The DER encoded key data.
+
+    :param bytes password: The password to use to decrypt the data. Should
+        be ``None`` if the private key is not encrypted.
+
+    :param backend: A
+        :class:`~cryptography.hazmat.backends.interfaces.DERSerializationBackend`
+        provider.
+
+    :returns: A new instance of a private key.
+
+    :raises ValueError: If the DER data could not be decrypted or if its
+        structure could not be decoded successfully.
+
+    :raises TypeError: If a ``password`` was given and the private key was
+        not encrypted. Or if the key was encrypted but no
+        password was supplied.
+
+    :raises cryptography.exceptions.UnsupportedAlgorithm: If the serialized key is of a type that
+        is not supported by the backend or if the key is encrypted with a
+        symmetric cipher that is not supported by the backend.
+
+    .. doctest::
+
+        >>> from cryptography.hazmat.backends import default_backend
+        >>> from cryptography.hazmat.primitives.asymmetric import rsa
+        >>> from cryptography.hazmat.primitives.serialization import load_der_private_key
+        >>> key = load_der_private_key(der_data, password=None, backend=default_backend())
+        >>> isinstance(key, rsa.RSAPrivateKey)
+        True
+
+.. function:: load_der_public_key(data, backend)
+
+    .. versionadded:: 0.8
+
+    Deserialize a public key from DER encoded data to one of the supported
+    asymmetric public key types.
+
+    :param bytes data: The DER encoded key data.
+
+    :param backend: A
+        :class:`~cryptography.hazmat.backends.interfaces.DERSerializationBackend`
+        provider.
+
+    :returns: A new instance of a public key.
+
+    :raises ValueError: If the DER data's structure could not be decoded
+        successfully.
+
+    :raises cryptography.exceptions.UnsupportedAlgorithm: If the serialized key is of a type that
+        is not supported by the backend.
+
+    .. doctest::
+
+        >>> from cryptography.hazmat.backends import default_backend
+        >>> from cryptography.hazmat.primitives.asymmetric import rsa
+        >>> from cryptography.hazmat.primitives.serialization import load_der_public_key
+        >>> key = load_der_public_key(public_der_data, backend=default_backend())
+        >>> isinstance(key, rsa.RSAPublicKey)
+        True
+
+
+OpenSSH Public Key
+~~~~~~~~~~~~~~~~~~
+
+The format used by OpenSSH to store public keys, as specified in :rfc:`4253`.
+
+An example RSA key in OpenSSH format (line breaks added for formatting
+purposes)::
+
+    ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDDu/XRP1kyK6Cgt36gts9XAk
+    FiiuJLW6RU0j3KKVZSs1I7Z3UmU9/9aVh/rZV43WQG8jaR6kkcP4stOR0DEtll
+    PDA7ZRBnrfiHpSQYQ874AZaAoIjgkv7DBfsE6gcDQLub0PFjWyrYQUJhtOLQEK
+    vY/G0vt2iRL3juawWmCFdTK3W3XvwAdgGk71i6lHt+deOPNEPN2H58E4odrZ2f
+    sxn/adpDqfb2sM0kPwQs0aWvrrKGvUaustkivQE4XWiSFnB0oJB/lKK/CKVKuy
+    ///ImSCGHQRvhwariN2tvZ6CBNSLh3iQgeB0AkyJlng7MXB2qYq/Ci2FUOryCX
+    2MzHvnbv testkey@localhost
+
+DSA keys look almost identical but begin with ``ssh-dss`` rather than
+``ssh-rsa``. ECDSA keys have a slightly different format, they begin with
+``ecdsa-sha2-{curve}``.
+
+.. function:: load_ssh_public_key(data, backend)
+
+    .. versionadded:: 0.7
+
+    Deserialize a public key from OpenSSH (:rfc:`4253`) encoded data to an
+    instance of the public key type for the specified backend.
+
+    .. note::
+
+        Currently Ed25519 keys are not supported.
+
+    :param bytes data: The OpenSSH encoded key data.
+
+    :param backend: A backend providing
+        :class:`~cryptography.hazmat.backends.interfaces.RSABackend`,
+        :class:`~cryptography.hazmat.backends.interfaces.DSABackend`, or
+        :class:`~cryptography.hazmat.backends.interfaces.EllipticCurveBackend`
+        depending on the key's type.
+
+    :returns: A new instance of a public key type.
+
+    :raises ValueError: If the OpenSSH data could not be properly decoded or
+        if the key is not in the proper format.
+
+    :raises cryptography.exceptions.UnsupportedAlgorithm: If the serialized
+        key is of a type that is not supported.
+
+Serialization Formats
+~~~~~~~~~~~~~~~~~~~~~
+
+.. class:: PrivateFormat
+
+    .. versionadded:: 0.8
+
+    An enumeration for private key formats. Used with the ``private_bytes``
+    method available on
+    :class:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPrivateKeyWithSerialization`
+    ,
+    :class:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePrivateKeyWithSerialization`
+    and
+    :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPrivateKeyWithSerialization`.
+
+    .. attribute:: TraditionalOpenSSL
+
+        Frequently known as PKCS#1 format. Still a widely used format, but
+        generally considered legacy.
+
+    .. attribute:: PKCS8
+
+        A more modern format for serializing keys which allows for better
+        encryption. Choose this unless you have explicit legacy compatibility
+        requirements.
+
+.. class:: PublicFormat
+
+    .. versionadded:: 0.8
+
+    An enumeration for public key formats. Used with the ``public_bytes``
+    method available on
+    :class:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPublicKeyWithSerialization`
+    ,
+    :class:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePublicKeyWithSerialization`
+    , and
+    :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPublicKeyWithSerialization`.
+
+    .. attribute:: SubjectPublicKeyInfo
+
+        This is the typical public key format. It consists of an algorithm
+        identifier and the public key as a bit string. Choose this unless
+        you have specific needs.
+
+    .. attribute:: PKCS1
+
+        Just the public key elements (without the algorithm identifier). This
+        format is RSA only, but is used by some older systems.
+
+Serialization Encodings
+~~~~~~~~~~~~~~~~~~~~~~~
+
+.. class:: Encoding
+
+    An enumeration for encoding types. Used with the ``private_bytes`` method
+    available on
+    :class:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPrivateKeyWithSerialization`
+    ,
+    :class:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePrivateKeyWithSerialization`
+    and
+    :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPrivateKeyWithSerialization`
+    as well as ``public_bytes`` on
+    :class:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPublicKeyWithSerialization`
+    and
+    :class:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePublicKeyWithSerialization`.
+
+    .. attribute:: PEM
+
+        .. versionadded:: 0.8
+
+        For PEM format. This is a base64 format with delimiters.
+
+    .. attribute:: DER
+
+        .. versionadded:: 0.9
+
+        For DER format. This is a binary format.
+
+
+Serialization Encryption Types
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+.. class:: KeySerializationEncryption
+
+    Objects with this interface are usable as encryption types with methods
+    like ``private_bytes`` available on
+    :class:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPrivateKeyWithSerialization`
+    ,
+    :class:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePrivateKeyWithSerialization`
+    and
+    :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPrivateKeyWithSerialization`.
+    All other classes in this section represent the available choices for
+    encryption and have this interface. They are used with
+    :class:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPrivateKeyWithSerialization.private_bytes`.
+
+.. class:: BestAvailableEncryption(password)
+
+    Encrypt using the best available encryption for a given key's backend.
+    This is a curated encryption choice and the algorithm may change over
+    time.
+
+    :param bytes password: The password to use for encryption.
+
+.. class:: NoEncryption
+
+    Do not encrypt.
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/asymmetric/utils.rst hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/asymmetric/utils.rst
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/asymmetric/utils.rst	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/asymmetric/utils.rst	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,30 @@
+.. hazmat::
+
+Asymmetric Utilities
+====================
+
+.. currentmodule:: cryptography.hazmat.primitives.asymmetric.utils
+
+
+.. function:: decode_dss_signature(signature)
+
+    Takes in signatures generated by the DSA/ECDSA signers and returns a
+    tuple ``(r, s)``. These signatures are ASN.1 encoded ``Dss-Sig-Value``
+    sequences (as defined in :rfc:`3279`)
+
+    :param bytes signature: The signature to decode.
+
+    :returns: The decoded tuple ``(r, s)``.
+
+    :raises ValueError: Raised if the signature is malformed.
+
+.. function:: encode_dss_signature(r, s)
+
+    Creates an ASN.1 encoded ``Dss-Sig-Value`` (as defined in :rfc:`3279`) from
+    raw ``r`` and ``s`` values.
+
+    :param int r: The raw signature value ``r``.
+
+    :param int s: The raw signature value ``s``.
+
+    :return bytes: The encoded signature.
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/constant-time.rst hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/constant-time.rst
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/constant-time.rst	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/constant-time.rst	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,43 @@
+.. hazmat::
+
+Constant time functions
+=======================
+
+.. currentmodule:: cryptography.hazmat.primitives.constant_time
+
+This module contains functions for operating with secret data in a way that
+does not leak information about that data through how long it takes to perform
+the operation. These functions should be used whenever operating on secret data
+along with data that is user supplied.
+
+An example would be comparing a HMAC signature received from a client to the
+one generated by the server code for authentication purposes.
+
+For more information about this sort of issue, see `Coda Hale's blog post`_
+about the timing attacks on KeyCzar and Java's ``MessageDigest.isEqual()``.
+
+
+.. function:: bytes_eq(a, b)
+
+    Compares ``a`` and ``b`` with one another. If ``a`` and ``b`` have
+    different lengths, this returns ``False`` immediately. Otherwise it
+    compares them in a way that takes the same amount of time, regardless of
+    how many characters are the same between the two.
+
+    .. doctest::
+
+        >>> from cryptography.hazmat.primitives import constant_time
+        >>> constant_time.bytes_eq(b"foo", b"foo")
+        True
+        >>> constant_time.bytes_eq(b"foo", b"bar")
+        False
+
+    :param bytes a: The left-hand side.
+    :param bytes b: The right-hand side.
+    :returns bool: ``True`` if ``a`` has the same bytes as ``b``, otherwise
+                   ``False``.
+    :raises TypeError: This exception is raised if ``a`` or ``b`` is not
+                       ``bytes``.
+
+
+.. _`Coda Hale's blog post`: http://codahale.com/a-lesson-in-timing-attacks/
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/cryptographic-hashes.rst hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/cryptographic-hashes.rst
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/cryptographic-hashes.rst	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/cryptographic-hashes.rst	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,193 @@
+.. hazmat::
+
+Message digests
+===============
+
+.. module:: cryptography.hazmat.primitives.hashes
+
+.. class:: Hash(algorithm, backend)
+
+    A cryptographic hash function takes an arbitrary block of data and
+    calculates a fixed-size bit string (a digest), such that different data
+    results (with a high probability) in different digests.
+
+    This is an implementation of
+    :class:`~cryptography.hazmat.primitives.hashes.HashContext` meant to
+    be used with
+    :class:`~cryptography.hazmat.primitives.hashes.HashAlgorithm`
+    implementations to provide an incremental interface to calculating
+    various message digests.
+
+    .. doctest::
+
+        >>> from cryptography.hazmat.backends import default_backend
+        >>> from cryptography.hazmat.primitives import hashes
+        >>> digest = hashes.Hash(hashes.SHA256(), backend=default_backend())
+        >>> digest.update(b"abc")
+        >>> digest.update(b"123")
+        >>> digest.finalize()
+        'l\xa1=R\xcap\xc8\x83\xe0\xf0\xbb\x10\x1eBZ\x89\xe8bM\xe5\x1d\xb2\xd29%\x93\xafj\x84\x11\x80\x90'
+
+    If the backend doesn't support the requested ``algorithm`` an
+    :class:`~cryptography.exceptions.UnsupportedAlgorithm` exception will be
+    raised.
+
+    Keep in mind that attacks against cryptographic hashes only get stronger
+    with time, and that often algorithms that were once thought to be strong,
+    become broken. Because of this it's important to include a plan for
+    upgrading the hash algorithm you use over time. For more information, see
+    `Lifetimes of cryptographic hash functions`_.
+
+    :param algorithm: A
+        :class:`~cryptography.hazmat.primitives.hashes.HashAlgorithm`
+        provider such as those described in
+        :ref:`below <cryptographic-hash-algorithms>`.
+    :param backend: A
+        :class:`~cryptography.hazmat.backends.interfaces.HashBackend`
+        provider.
+
+    :raises cryptography.exceptions.UnsupportedAlgorithm: This is raised if the
+        provided ``backend`` does not implement
+        :class:`~cryptography.hazmat.backends.interfaces.HashBackend`
+
+    .. method:: update(data)
+
+        :param bytes data: The bytes to be hashed.
+        :raises cryptography.exceptions.AlreadyFinalized: See :meth:`finalize`.
+        :raises TypeError: This exception is raised if ``data`` is not ``bytes``.
+
+    .. method:: copy()
+
+        Copy this :class:`Hash` instance, usually so that you may call
+        :meth:`finalize` to get an intermediate digest value while we continue
+        to call :meth:`update` on the original instance.
+
+        :return: A new instance of :class:`Hash` that can be updated
+             and finalized independently of the original instance.
+        :raises cryptography.exceptions.AlreadyFinalized: See :meth:`finalize`.
+
+    .. method:: finalize()
+
+        Finalize the current context and return the message digest as bytes.
+
+        After ``finalize`` has been called this object can no longer be used
+        and :meth:`update`, :meth:`copy`, and :meth:`finalize` will raise an
+        :class:`~cryptography.exceptions.AlreadyFinalized` exception.
+
+        :return bytes: The message digest as bytes.
+
+
+.. _cryptographic-hash-algorithms:
+
+SHA-1
+~~~~~
+
+.. attention::
+
+    NIST has deprecated SHA-1 in favor of the SHA-2 variants. New applications
+    are strongly suggested to use SHA-2 over SHA-1.
+
+.. class:: SHA1()
+
+    SHA-1 is a cryptographic hash function standardized by NIST. It produces an
+    160-bit message digest.
+
+SHA-2 family
+~~~~~~~~~~~~
+
+.. class:: SHA224()
+
+    SHA-224 is a cryptographic hash function from the SHA-2 family and is
+    standardized by NIST. It produces a 224-bit message digest.
+
+.. class:: SHA256()
+
+    SHA-256 is a cryptographic hash function from the SHA-2 family and is
+    standardized by NIST. It produces a 256-bit message digest.
+
+.. class:: SHA384()
+
+    SHA-384 is a cryptographic hash function from the SHA-2 family and is
+    standardized by NIST. It produces a 384-bit message digest.
+
+.. class:: SHA512()
+
+    SHA-512 is a cryptographic hash function from the SHA-2 family and is
+    standardized by NIST. It produces a 512-bit message digest.
+
+RIPEMD160
+~~~~~~~~~
+
+.. class:: RIPEMD160()
+
+    RIPEMD160 is a cryptographic hash function that is part of ISO/IEC
+    10118-3:2004. It produces a 160-bit message digest.
+
+Whirlpool
+~~~~~~~~~
+
+.. class:: Whirlpool()
+
+    Whirlpool is a cryptographic hash function that is part of ISO/IEC
+    10118-3:2004. It produces a 512-bit message digest.
+
+MD5
+~~~
+
+.. warning::
+
+    MD5 is a deprecated hash algorithm that has practical known collision
+    attacks. You are strongly discouraged from using it. Existing applications
+    should strongly consider moving away.
+
+.. class:: MD5()
+
+    MD5 is a deprecated cryptographic hash function. It produces a 128-bit
+    message digest and has practical known collision attacks.
+
+
+Interfaces
+~~~~~~~~~~
+
+.. class:: HashAlgorithm
+
+    .. attribute:: name
+
+        :type: str
+
+        The standard name for the hash algorithm, for example: ``"sha256"`` or
+        ``"whirlpool"``.
+
+    .. attribute:: digest_size
+
+        :type: int
+
+        The size of the resulting digest in bytes.
+
+    .. attribute:: block_size
+
+        :type: int
+
+        The internal block size of the hash algorithm in bytes.
+
+
+.. class:: HashContext
+
+    .. attribute:: algorithm
+
+        A :class:`HashAlgorithm` that will be used by this context.
+
+    .. method:: update(data)
+
+        :param bytes data: The data you want to hash.
+
+    .. method:: finalize()
+
+        :return: The final digest as bytes.
+
+    .. method:: copy()
+
+        :return: A :class:`HashContext` that is a copy of the current context.
+
+
+.. _`Lifetimes of cryptographic hash functions`: http://valerieaurora.org/hash.html
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/index.rst hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/index.rst
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/index.rst	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/index.rst	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,18 @@
+.. hazmat::
+
+Primitives
+==========
+
+.. toctree::
+    :maxdepth: 1
+
+    cryptographic-hashes
+    mac/index
+    symmetric-encryption
+    padding
+    key-derivation-functions
+    keywrap
+    asymmetric/index
+    constant-time
+    interfaces
+    twofactor
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/interfaces.rst hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/interfaces.rst
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/interfaces.rst	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/interfaces.rst	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,80 @@
+.. hazmat::
+
+.. module:: cryptography.hazmat.primitives.interfaces
+
+Interfaces
+==========
+
+
+``cryptography`` uses `Abstract Base Classes`_ as interfaces to describe the
+properties and methods of most primitive constructs. Backends may also use
+this information to influence their operation. Interfaces should also be used
+to document argument and return types.
+
+.. _`Abstract Base Classes`: https://docs.python.org/3/library/abc.html
+
+
+Asymmetric interfaces
+---------------------
+
+In 0.8 the asymmetric signature and verification interfaces were moved to the
+:mod:`cryptography.hazmat.primitives.asymmetric` module.
+
+In 0.8 the asymmetric padding interface was moved to the
+:mod:`cryptography.hazmat.primitives.asymmetric.padding` module.
+
+DSA
+~~~
+
+In 0.8 the DSA key interfaces were moved to the
+:mod:`cryptography.hazmat.primitives.asymmetric.dsa` module.
+
+
+RSA
+~~~
+
+In 0.8 the RSA key interfaces were moved to the
+:mod:`cryptography.hazmat.primitives.asymmetric.rsa` module.
+
+
+Elliptic Curve
+~~~~~~~~~~~~~~
+
+In 0.8 the EC key interfaces were moved to the
+:mod:`cryptography.hazmat.primitives.asymmetric.ec` module.
+
+
+Key derivation functions
+------------------------
+
+In 0.8 the key derivation function interface was moved to the
+:mod:`cryptography.hazmat.primitives.kdf` module.
+
+
+.. class:: MACContext
+
+    .. versionadded:: 0.7
+
+    .. method:: update(data)
+
+        :param bytes data: The data you want to authenticate.
+
+    .. method:: finalize()
+
+        :return: The message authentication code.
+
+    .. method:: copy()
+
+        :return: A
+            :class:`~cryptography.hazmat.primitives.interfaces.MACContext` that
+            is a copy of the current context.
+
+    .. method:: verify(signature)
+
+        :param bytes signature: The signature to verify.
+
+        :raises cryptography.exceptions.InvalidSignature: This is raised when
+            the provided signature does not match the expected signature.
+
+
+.. _`CMAC`: https://en.wikipedia.org/wiki/CMAC
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/key-derivation-functions.rst hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/key-derivation-functions.rst
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/key-derivation-functions.rst	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/key-derivation-functions.rst	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,660 @@
+.. hazmat::
+
+Key derivation functions
+========================
+
+.. module:: cryptography.hazmat.primitives.kdf
+
+Key derivation functions derive bytes suitable for cryptographic operations
+from passwords or other data sources using a pseudo-random function (PRF).
+Different KDFs are suitable for different tasks such as:
+
+* Cryptographic key derivation
+
+    Deriving a key suitable for use as input to an encryption algorithm.
+    Typically this means taking a password and running it through an algorithm
+    such as :class:`~cryptography.hazmat.primitives.kdf.pbkdf2.PBKDF2HMAC` or
+    :class:`~cryptography.hazmat.primitives.kdf.hkdf.HKDF`.
+    This process is typically known as `key stretching`_.
+
+* Password storage
+
+    When storing passwords you want to use an algorithm that is computationally
+    intensive. Legitimate users will only need to compute it once (for example,
+    taking the user's password, running it through the KDF, then comparing it
+    to the stored value), while attackers will need to do it billions of times.
+    Ideal password storage KDFs will be demanding on both computational and
+    memory resources.
+
+.. currentmodule:: cryptography.hazmat.primitives.kdf.pbkdf2
+
+.. class:: PBKDF2HMAC(algorithm, length, salt, iterations, backend)
+
+    .. versionadded:: 0.2
+
+    `PBKDF2`_ (Password Based Key Derivation Function 2) is typically used for
+    deriving a cryptographic key from a password. It may also be used for
+    key storage, but an alternate key storage KDF such as `scrypt`_ is generally
+    considered a better solution.
+
+    This class conforms to the
+    :class:`~cryptography.hazmat.primitives.kdf.KeyDerivationFunction`
+    interface.
+
+    .. doctest::
+
+        >>> import os
+        >>> from cryptography.hazmat.primitives import hashes
+        >>> from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
+        >>> from cryptography.hazmat.backends import default_backend
+        >>> backend = default_backend()
+        >>> salt = os.urandom(16)
+        >>> # derive
+        >>> kdf = PBKDF2HMAC(
+        ...     algorithm=hashes.SHA256(),
+        ...     length=32,
+        ...     salt=salt,
+        ...     iterations=100000,
+        ...     backend=backend
+        ... )
+        >>> key = kdf.derive(b"my great password")
+        >>> # verify
+        >>> kdf = PBKDF2HMAC(
+        ...     algorithm=hashes.SHA256(),
+        ...     length=32,
+        ...     salt=salt,
+        ...     iterations=100000,
+        ...     backend=backend
+        ... )
+        >>> kdf.verify(b"my great password", key)
+
+    :param algorithm: An instance of a
+        :class:`~cryptography.hazmat.primitives.hashes.HashAlgorithm`
+        provider.
+    :param int length: The desired length of the derived key. Maximum is
+        (2\ :sup:`32` - 1) * ``algorithm.digest_size``.
+    :param bytes salt: A salt. `NIST SP 800-132`_ recommends 128-bits or
+        longer.
+    :param int iterations: The number of iterations to perform of the hash
+        function. This can be used to control the length of time the operation
+        takes. Higher numbers help mitigate brute force attacks against derived
+        keys. See OWASP's `Password Storage Cheat Sheet`_ for more
+        detailed recommendations if you intend to use this for password storage.
+    :param backend: A
+        :class:`~cryptography.hazmat.backends.interfaces.PBKDF2HMACBackend`
+        provider.
+
+    :raises cryptography.exceptions.UnsupportedAlgorithm: This is raised if the
+        provided ``backend`` does not implement
+        :class:`~cryptography.hazmat.backends.interfaces.PBKDF2HMACBackend`
+
+    :raises TypeError: This exception is raised if ``salt`` is not ``bytes``.
+
+    .. method:: derive(key_material)
+
+        :param bytes key_material: The input key material. For PBKDF2 this
+            should be a password.
+        :return bytes: the derived key.
+        :raises cryptography.exceptions.AlreadyFinalized: This is raised when
+                                                          :meth:`derive` or
+                                                          :meth:`verify` is
+                                                          called more than
+                                                          once.
+
+        :raises TypeError: This exception is raised if ``key_material`` is not
+                           ``bytes``.
+
+        This generates and returns a new key from the supplied password.
+
+    .. method:: verify(key_material, expected_key)
+
+        :param bytes key_material: The input key material. This is the same as
+                                   ``key_material`` in :meth:`derive`.
+        :param bytes expected_key: The expected result of deriving a new key,
+                                   this is the same as the return value of
+                                   :meth:`derive`.
+        :raises cryptography.exceptions.InvalidKey: This is raised when the
+                                                    derived key does not match
+                                                    the expected key.
+        :raises cryptography.exceptions.AlreadyFinalized: This is raised when
+                                                          :meth:`derive` or
+                                                          :meth:`verify` is
+                                                          called more than
+                                                          once.
+
+        This checks whether deriving a new key from the supplied
+        ``key_material`` generates the same key as the ``expected_key``, and
+        raises an exception if they do not match. This can be used for
+        checking whether the password a user provides matches the stored derived
+        key.
+
+
+.. currentmodule:: cryptography.hazmat.primitives.kdf.hkdf
+
+.. class:: HKDF(algorithm, length, salt, info, backend)
+
+    .. versionadded:: 0.2
+
+    `HKDF`_ (HMAC-based Extract-and-Expand Key Derivation Function) is suitable
+    for deriving keys of a fixed size used for other cryptographic operations.
+
+    .. warning::
+
+        HKDF should not be used for password storage.
+
+    .. doctest::
+
+        >>> import os
+        >>> from cryptography.hazmat.primitives import hashes
+        >>> from cryptography.hazmat.primitives.kdf.hkdf import HKDF
+        >>> from cryptography.hazmat.backends import default_backend
+        >>> backend = default_backend()
+        >>> salt = os.urandom(16)
+        >>> info = b"hkdf-example"
+        >>> hkdf = HKDF(
+        ...     algorithm=hashes.SHA256(),
+        ...     length=32,
+        ...     salt=salt,
+        ...     info=info,
+        ...     backend=backend
+        ... )
+        >>> key = hkdf.derive(b"input key")
+        >>> hkdf = HKDF(
+        ...     algorithm=hashes.SHA256(),
+        ...     length=32,
+        ...     salt=salt,
+        ...     info=info,
+        ...     backend=backend
+        ... )
+        >>> hkdf.verify(b"input key", key)
+
+    :param algorithm: An instance of a
+        :class:`~cryptography.hazmat.primitives.hashes.HashAlgorithm`
+        provider.
+
+    :param int length: The desired length of the derived key. Maximum is
+        ``255 * (algorithm.digest_size // 8)``.
+
+    :param bytes salt: A salt. Randomizes the KDF's output. Optional, but
+        highly recommended. Ideally as many bits of entropy as the security
+        level of the hash: often that means cryptographically random and as
+        long as the hash output. Worse (shorter, less entropy) salt values can
+        still meaningfully contribute to security. May be reused. Does not have
+        to be secret, but may cause stronger security guarantees if secret; see
+        `RFC 5869`_ and the `HKDF paper`_ for more details. If ``None`` is
+        explicitly passed a default salt of ``algorithm.digest_size // 8`` null
+        bytes will be used.
+
+    :param bytes info: Application specific context information.  If ``None``
+        is explicitly passed an empty byte string will be used.
+
+    :param backend: A
+        :class:`~cryptography.hazmat.backends.interfaces.HMACBackend`
+        provider.
+
+    :raises cryptography.exceptions.UnsupportedAlgorithm: This is raised if the
+        provided ``backend`` does not implement
+        :class:`~cryptography.hazmat.backends.interfaces.HMACBackend`
+
+    :raises TypeError: This exception is raised if ``salt`` or ``info`` is not
+                       ``bytes``.
+
+    .. method:: derive(key_material)
+
+        :param bytes key_material: The input key material.
+        :return bytes: The derived key.
+        :raises TypeError: This exception is raised if ``key_material`` is not
+                           ``bytes``.
+
+        Derives a new key from the input key material by performing both the
+        extract and expand operations.
+
+    .. method:: verify(key_material, expected_key)
+
+        :param bytes key_material: The input key material. This is the same as
+                                   ``key_material`` in :meth:`derive`.
+        :param bytes expected_key: The expected result of deriving a new key,
+                                   this is the same as the return value of
+                                   :meth:`derive`.
+        :raises cryptography.exceptions.InvalidKey: This is raised when the
+                                                    derived key does not match
+                                                    the expected key.
+        :raises cryptography.exceptions.AlreadyFinalized: This is raised when
+                                                          :meth:`derive` or
+                                                          :meth:`verify` is
+                                                          called more than
+                                                          once.
+
+        This checks whether deriving a new key from the supplied
+        ``key_material`` generates the same key as the ``expected_key``, and
+        raises an exception if they do not match.
+
+
+.. class:: HKDFExpand(algorithm, length, info, backend)
+
+    .. versionadded:: 0.5
+
+    HKDF consists of two stages, extract and expand. This class exposes an
+    expand only version of HKDF that is suitable when the key material is
+    already cryptographically strong.
+
+    .. warning::
+
+        HKDFExpand should only be used if the key material is
+        cryptographically strong. You should use
+        :class:`~cryptography.hazmat.primitives.kdf.hkdf.HKDF` if
+        you are unsure.
+
+    .. doctest::
+
+        >>> import os
+        >>> from cryptography.hazmat.primitives import hashes
+        >>> from cryptography.hazmat.primitives.kdf.hkdf import HKDFExpand
+        >>> from cryptography.hazmat.backends import default_backend
+        >>> backend = default_backend()
+        >>> info = b"hkdf-example"
+        >>> key_material = os.urandom(16)
+        >>> hkdf = HKDFExpand(
+        ...     algorithm=hashes.SHA256(),
+        ...     length=32,
+        ...     info=info,
+        ...     backend=backend
+        ... )
+        >>> key = hkdf.derive(key_material)
+        >>> hkdf = HKDFExpand(
+        ...     algorithm=hashes.SHA256(),
+        ...     length=32,
+        ...     info=info,
+        ...     backend=backend
+        ... )
+        >>> hkdf.verify(key_material, key)
+
+    :param algorithm: An instance of a
+        :class:`~cryptography.hazmat.primitives.hashes.HashAlgorithm`
+        provider.
+
+    :param int length: The desired length of the derived key. Maximum is
+        ``255 * (algorithm.digest_size // 8)``.
+
+    :param bytes info: Application specific context information.  If ``None``
+        is explicitly passed an empty byte string will be used.
+
+    :param backend: A
+        :class:`~cryptography.hazmat.backends.interfaces.HMACBackend`
+        provider.
+
+    :raises cryptography.exceptions.UnsupportedAlgorithm: This is raised if the
+        provided ``backend`` does not implement
+        :class:`~cryptography.hazmat.backends.interfaces.HMACBackend`
+    :raises TypeError: This is raised if the provided ``info`` is a unicode object
+    :raises TypeError: This exception is raised if ``info`` is not ``bytes``.
+
+    .. method:: derive(key_material)
+
+        :param bytes key_material: The input key material.
+        :return bytes: The derived key.
+
+        :raises TypeError: This is raised if the provided ``key_material`` is
+            a unicode object
+        :raises TypeError: This exception is raised if ``key_material`` is not
+                           ``bytes``.
+
+        Derives a new key from the input key material by performing both the
+        extract and expand operations.
+
+    .. method:: verify(key_material, expected_key)
+
+        :param bytes key_material: The input key material. This is the same as
+                                   ``key_material`` in :meth:`derive`.
+        :param bytes expected_key: The expected result of deriving a new key,
+                                   this is the same as the return value of
+                                   :meth:`derive`.
+        :raises cryptography.exceptions.InvalidKey: This is raised when the
+                                                    derived key does not match
+                                                    the expected key.
+        :raises cryptography.exceptions.AlreadyFinalized: This is raised when
+                                                          :meth:`derive` or
+                                                          :meth:`verify` is
+                                                          called more than
+                                                          once.
+        :raises TypeError: This is raised if the provided ``key_material`` is
+            a unicode object
+
+        This checks whether deriving a new key from the supplied
+        ``key_material`` generates the same key as the ``expected_key``, and
+        raises an exception if they do not match.
+
+.. currentmodule:: cryptography.hazmat.primitives.kdf.concatkdf
+
+.. class:: ConcatKDFHash(algorithm, length, otherinfo, backend)
+
+    .. versionadded:: 1.0
+
+    ConcatKDFHash (Concatenation Key Derivation Function) is defined by the
+    NIST Special Publication `NIST SP 800-56Ar2`_ document, to be used to
+    derive keys for use after a Key Exchange negotiation operation.
+
+    .. warning::
+
+        ConcatKDFHash should not be used for password storage.
+
+    .. doctest::
+
+        >>> import os
+        >>> from cryptography.hazmat.primitives import hashes
+        >>> from cryptography.hazmat.primitives.kdf.concatkdf import ConcatKDFHash
+        >>> from cryptography.hazmat.backends import default_backend
+        >>> backend = default_backend()
+        >>> otherinfo = b"concatkdf-example"
+        >>> ckdf = ConcatKDFHash(
+        ...     algorithm=hashes.SHA256(),
+        ...     length=256,
+        ...     otherinfo=otherinfo,
+        ...     backend=backend
+        ... )
+        >>> key = ckdf.derive(b"input key")
+        >>> ckdf = ConcatKDFHash(
+        ...     algorithm=hashes.SHA256(),
+        ...     length=256,
+        ...     otherinfo=otherinfo,
+        ...     backend=backend
+        ... )
+        >>> ckdf.verify(b"input key", key)
+
+    :param algorithm: An instance of a
+        :class:`~cryptography.hazmat.primitives.hashes.HashAlgorithm`
+        provider
+
+    :param int length: The desired length of the derived key in bytes.
+        Maximum is ``hashlen * (2^32 -1)``.
+
+    :param bytes otherinfo: Application specific context information.
+        If ``None`` is explicitly passed an empty byte string will be used.
+
+    :param backend: A
+        :class:`~cryptography.hazmat.backends.interfaces.HashBackend`
+        provider.
+
+    :raises cryptography.exceptions.UnsupportedAlgorithm: This is raised
+        if the provided ``backend`` does not implement
+        :class:`~cryptography.hazmat.backends.interfaces.HashBackend`
+
+    :raises TypeError: This exception is raised if ``otherinfo`` is not
+        ``bytes``.
+
+    .. method:: derive(key_material)
+
+        :param bytes key_material: The input key material.
+        :return bytes: The derived key.
+        :raises TypeError: This exception is raised if ``key_material`` is
+                            not ``bytes``.
+
+        Derives a new key from the input key material.
+
+    .. method:: verify(key_material, expected_key)
+
+        :param bytes key_material: The input key material. This is the same as
+                                   ``key_material`` in :meth:`derive`.
+        :param bytes expected_key: The expected result of deriving a new key,
+                                   this is the same as the return value of
+                                   :meth:`derive`.
+        :raises cryptography.exceptions.InvalidKey: This is raised when the
+                                                    derived key does not match
+                                                    the expected key.
+        :raises cryptography.exceptions.AlreadyFinalized: This is raised when
+                                                          :meth:`derive` or
+                                                          :meth:`verify` is
+                                                          called more than
+                                                          once.
+
+        This checks whether deriving a new key from the supplied
+        ``key_material`` generates the same key as the ``expected_key``, and
+        raises an exception if they do not match.
+
+
+.. class:: ConcatKDFHMAC(algorithm, length, salt, otherinfo, backend)
+
+    .. versionadded:: 1.0
+
+    Similar to ConcatKFDHash but uses an HMAC function instead.
+
+    .. warning::
+
+        ConcatKDFHMAC should not be used for password storage.
+
+    .. doctest::
+
+        >>> import os
+        >>> from cryptography.hazmat.primitives import hashes
+        >>> from cryptography.hazmat.primitives.kdf.concatkdf import ConcatKDFHMAC
+        >>> from cryptography.hazmat.backends import default_backend
+        >>> backend = default_backend()
+        >>> salt = os.urandom(16)
+        >>> otherinfo = b"concatkdf-example"
+        >>> ckdf = ConcatKDFHMAC(
+        ...     algorithm=hashes.SHA256(),
+        ...     length=256,
+        ...     salt=salt,
+        ...     otherinfo=otherinfo,
+        ...     backend=backend
+        ... )
+        >>> key = ckdf.derive(b"input key")
+        >>> ckdf = ConcatKDFHMAC(
+        ...     algorithm=hashes.SHA256(),
+        ...     length=256,
+        ...     salt=salt,
+        ...     otherinfo=otherinfo,
+        ...     backend=backend
+        ... )
+        >>> ckdf.verify(b"input key", key)
+
+    :param algorithm: An instance of a
+        :class:`~cryptography.hazmat.primitives.hashes.HashAlgorithm`
+        provider
+
+    :param int length: The desired length of the derived key in bytes. Maximum
+        is ``hashlen * (2^32 -1)``.
+
+    :param bytes salt: A salt. Randomizes the KDF's output. Optional, but
+        highly recommended. Ideally as many bits of entropy as the security
+        level of the hash: often that means cryptographically random and as
+        long as the hash output. Does not have to be secret, but may cause
+        stronger security guarantees if secret; If ``None`` is explicitly
+        passed a default salt of ``algorithm.block_size`` null bytes will be
+        used.
+
+    :param bytes otherinfo: Application specific context information.
+        If ``None`` is explicitly passed an empty byte string will be used.
+
+    :param backend: A
+        :class:`~cryptography.hazmat.backends.interfaces.HMACBackend`
+        provider.
+
+    :raises cryptography.exceptions.UnsupportedAlgorithm: This is raised if the
+        provided ``backend`` does not implement
+        :class:`~cryptography.hazmat.backends.interfaces.HMACBackend`
+
+    :raises TypeError: This exception is raised if ``salt`` or ``otherinfo``
+        is not ``bytes``.
+
+    .. method:: derive(key_material)
+
+        :param bytes key_material: The input key material.
+        :return bytes: The derived key.
+        :raises TypeError: This exception is raised if ``key_material`` is not
+                           ``bytes``.
+
+        Derives a new key from the input key material.
+
+    .. method:: verify(key_material, expected_key)
+
+        :param bytes key_material: The input key material. This is the same as
+                                   ``key_material`` in :meth:`derive`.
+        :param bytes expected_key: The expected result of deriving a new key,
+                                   this is the same as the return value of
+                                   :meth:`derive`.
+        :raises cryptography.exceptions.InvalidKey: This is raised when the
+                                                    derived key does not match
+                                                    the expected key.
+        :raises cryptography.exceptions.AlreadyFinalized: This is raised when
+                                                          :meth:`derive` or
+                                                          :meth:`verify` is
+                                                          called more than
+                                                          once.
+
+        This checks whether deriving a new key from the supplied
+        ``key_material`` generates the same key as the ``expected_key``, and
+        raises an exception if they do not match.
+
+.. currentmodule:: cryptography.hazmat.primitives.kdf.x963kdf
+
+.. class:: X963KDF(algorithm, length, otherinfo, backend)
+
+    .. versionadded:: 1.1
+
+    X963KDF (ANSI X9.63 Key Derivation Function) is defined by ANSI
+    in the `ANSI X9.63:2001`_ document, to be used to derive keys for use
+    after a Key Exchange negotiation operation.
+
+    SECG in `SEC 1 v2.0`_ recommends that
+    :class:`~cryptography.hazmat.primitives.kdf.concatkdf.ConcatKDFHash` be
+    used for new projects. This KDF should only be used for backwards
+    compatibility with pre-existing protocols.
+
+
+    .. warning::
+
+        X963KDF should not be used for password storage.
+
+    .. doctest::
+
+        >>> import os
+        >>> from cryptography.hazmat.primitives import hashes
+        >>> from cryptography.hazmat.primitives.kdf.x963kdf import X963KDF
+        >>> from cryptography.hazmat.backends import default_backend
+        >>> backend = default_backend()
+        >>> sharedinfo = b"ANSI X9.63 Example"
+        >>> xkdf = X963KDF(
+        ...     algorithm=hashes.SHA256(),
+        ...     length=256,
+        ...     sharedinfo=sharedinfo,
+        ...     backend=backend
+        ... )
+        >>> key = xkdf.derive(b"input key")
+        >>> xkdf = X963KDF(
+        ...     algorithm=hashes.SHA256(),
+        ...     length=256,
+        ...     sharedinfo=sharedinfo,
+        ...     backend=backend
+        ... )
+        >>> xkdf.verify(b"input key", key)
+
+    :param algorithm: An instance of a
+        :class:`~cryptography.hazmat.primitives.hashes.HashAlgorithm`
+        provider
+
+    :param int length: The desired length of the derived key in bytes.
+        Maximum is ``hashlen * (2^32 -1)``.
+
+    :param bytes sharedinfo: Application specific context information.
+        If ``None`` is explicitly passed an empty byte string will be used.
+
+    :param backend: A cryptography backend
+        :class:`~cryptography.hazmat.backends.interfaces.HashBackend`
+        provider.
+
+    :raises cryptography.exceptions.UnsupportedAlgorithm: This is raised
+        if the provided ``backend`` does not implement
+        :class:`~cryptography.hazmat.backends.interfaces.HashBackend`
+
+    :raises TypeError: This exception is raised if ``sharedinfo`` is not
+        ``bytes``.
+
+    .. method:: derive(key_material)
+
+        :param bytes key_material: The input key material.
+        :return bytes: The derived key.
+        :raises TypeError: This exception is raised if ``key_material`` is
+                            not ``bytes``.
+
+        Derives a new key from the input key material.
+
+    .. method:: verify(key_material, expected_key)
+
+        :param bytes key_material: The input key material. This is the same as
+                                   ``key_material`` in :meth:`derive`.
+        :param bytes expected_key: The expected result of deriving a new key,
+                                   this is the same as the return value of
+                                   :meth:`derive`.
+        :raises cryptography.exceptions.InvalidKey: This is raised when the
+                                                    derived key does not match
+                                                    the expected key.
+        :raises cryptography.exceptions.AlreadyFinalized: This is raised when
+                                                          :meth:`derive` or
+                                                          :meth:`verify` is
+                                                          called more than
+                                                          once.
+
+        This checks whether deriving a new key from the supplied
+        ``key_material`` generates the same key as the ``expected_key``, and
+        raises an exception if they do not match.
+
+
+Interface
+~~~~~~~~~
+
+.. currentmodule:: cryptography.hazmat.primitives.kdf
+
+.. class:: KeyDerivationFunction
+
+    .. versionadded:: 0.2
+
+    .. method:: derive(key_material)
+
+        :param bytes key_material: The input key material. Depending on what
+                                   key derivation function you are using this
+                                   could be either random bytes, or a user
+                                   supplied password.
+        :return: The new key.
+        :raises cryptography.exceptions.AlreadyFinalized: This is raised when
+                                                          :meth:`derive` or
+                                                          :meth:`verify` is
+                                                          called more than
+                                                          once.
+
+        This generates and returns a new key from the supplied key material.
+
+    .. method:: verify(key_material, expected_key)
+
+        :param bytes key_material: The input key material. This is the same as
+                                   ``key_material`` in :meth:`derive`.
+        :param bytes expected_key: The expected result of deriving a new key,
+                                   this is the same as the return value of
+                                   :meth:`derive`.
+        :raises cryptography.exceptions.InvalidKey: This is raised when the
+                                                    derived key does not match
+                                                    the expected key.
+        :raises cryptography.exceptions.AlreadyFinalized: This is raised when
+                                                          :meth:`derive` or
+                                                          :meth:`verify` is
+                                                          called more than
+                                                          once.
+
+        This checks whether deriving a new key from the supplied
+        ``key_material`` generates the same key as the ``expected_key``, and
+        raises an exception if they do not match. This can be used for
+        something like checking whether a user's password attempt matches the
+        stored derived key.
+
+
+.. _`NIST SP 800-132`: http://csrc.nist.gov/publications/nistpubs/800-132/nist-sp800-132.pdf
+.. _`NIST SP 800-56Ar2`: http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-56Ar2.pdf
+.. _`ANSI X9.63:2001`: https://webstore.ansi.org
+.. _`SEC 1 v2.0`: http://www.secg.org/sec1-v2.pdf
+.. _`Password Storage Cheat Sheet`: https://www.owasp.org/index.php/Password_Storage_Cheat_Sheet
+.. _`PBKDF2`: https://en.wikipedia.org/wiki/PBKDF2
+.. _`scrypt`: https://en.wikipedia.org/wiki/Scrypt
+.. _`key stretching`: https://en.wikipedia.org/wiki/Key_stretching
+.. _`HKDF`:
+.. _`RFC 5869`: https://tools.ietf.org/html/rfc5869
+.. _`HKDF paper`: https://eprint.iacr.org/2010/264
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/keywrap.rst hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/keywrap.rst
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/keywrap.rst	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/keywrap.rst	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,59 @@
+.. hazmat::
+
+.. module:: cryptography.hazmat.primitives.keywrap
+
+Key wrapping
+============
+
+Key wrapping is a cryptographic construct that uses symmetric encryption to
+encapsulate key material. Key wrapping algorithms are occasionally utilized
+to protect keys at rest or transmit them over insecure networks. Many of the
+protections offered by key wrapping are also offered by using authenticated
+:doc:`symmetric encryption </hazmat/primitives/symmetric-encryption>`.
+
+.. function:: aes_key_wrap(wrapping_key, key_to_wrap, backend)
+
+    .. versionadded:: 1.1
+
+    This function performs AES key wrap (without padding) as specified in
+    :rfc:`3394`.
+
+    :param bytes wrapping_key: The wrapping key.
+
+    :param bytes key_to_wrap: The key to wrap.
+
+    :param backend: A
+        :class:`~cryptography.hazmat.backends.interfaces.CipherBackend`
+        provider that supports
+        :class:`~cryptography.hazmat.primitives.ciphers.algorithms.AES`.
+
+    :return bytes: The wrapped key as bytes.
+
+.. function:: aes_key_unwrap(wrapping_key, wrapped_key, backend)
+
+    .. versionadded:: 1.1
+
+    This function performs AES key unwrap (without padding) as specified in
+    :rfc:`3394`.
+
+    :param bytes wrapping_key: The wrapping key.
+
+    :param bytes wrapped_key: The wrapped key.
+
+    :param backend: A
+        :class:`~cryptography.hazmat.backends.interfaces.CipherBackend`
+        provider that supports
+        :class:`~cryptography.hazmat.primitives.ciphers.algorithms.AES`.
+
+    :return bytes: The unwrapped key as bytes.
+
+    :raises cryptography.hazmat.primitives.keywrap.InvalidUnwrap: This is
+        raised if the key is not successfully unwrapped.
+
+Exceptions
+~~~~~~~~~~
+
+.. class:: InvalidUnwrap
+
+    This is raised when a wrapped key fails to unwrap. It can be caused by a
+    corrupted or invalid wrapped key or an invalid wrapping key.
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/mac/cmac.rst hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/mac/cmac.rst
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/mac/cmac.rst	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/mac/cmac.rst	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,112 @@
+.. hazmat::
+
+Cipher-based message authentication code
+========================================
+
+.. currentmodule:: cryptography.hazmat.primitives.cmac
+
+.. testsetup::
+
+    import binascii
+    key = binascii.unhexlify(b"0" * 32)
+
+`Cipher-based message authentication codes`_ (or CMACs) are a tool for
+calculating message authentication codes using a block cipher coupled with a
+secret key. You can use an CMAC to verify both the integrity and authenticity
+of a message.
+
+A subset of CMAC with the AES-128 algorithm is described in :rfc:`4493`.
+
+.. class:: CMAC(algorithm, backend)
+
+    .. versionadded:: 0.4
+
+    CMAC objects take a
+    :class:`~cryptography.hazmat.primitives.ciphers.BlockCipherAlgorithm` provider.
+
+    .. doctest::
+
+        >>> from cryptography.hazmat.backends import default_backend
+        >>> from cryptography.hazmat.primitives import cmac
+        >>> from cryptography.hazmat.primitives.ciphers import algorithms
+        >>> c = cmac.CMAC(algorithms.AES(key), backend=default_backend())
+        >>> c.update(b"message to authenticate")
+        >>> c.finalize()
+        'CT\x1d\xc8\x0e\x15\xbe4e\xdb\xb6\x84\xca\xd9Xk'
+
+    If the backend doesn't support the requested ``algorithm`` an
+    :class:`~cryptography.exceptions.UnsupportedAlgorithm` exception will be
+    raised.
+
+    If ``algorithm`` isn't a
+    :class:`~cryptography.hazmat.primitives.ciphers.BlockCipherAlgorithm`
+    provider then ``TypeError`` will be raised.
+
+    To check that a given signature is correct use the :meth:`verify` method.
+    You will receive an exception if the signature is wrong:
+
+    .. doctest::
+
+        >>> c = cmac.CMAC(algorithms.AES(key), backend=default_backend())
+        >>> c.update(b"message to authenticate")
+        >>> c.verify(b"an incorrect signature")
+        Traceback (most recent call last):
+        ...
+        cryptography.exceptions.InvalidSignature: Signature did not match digest.
+
+    :param algorithm: An
+        :class:`~cryptography.hazmat.primitives.ciphers.BlockCipherAlgorithm`
+        provider.
+    :param backend: An
+        :class:`~cryptography.hazmat.backends.interfaces.CMACBackend`
+        provider.
+    :raises TypeError: This is raised if the provided ``algorithm`` is not an instance of
+        :class:`~cryptography.hazmat.primitives.ciphers.BlockCipherAlgorithm`
+    :raises cryptography.exceptions.UnsupportedAlgorithm: This is raised if the
+        provided ``backend`` does not implement
+        :class:`~cryptography.hazmat.backends.interfaces.CMACBackend`
+
+    .. method:: update(data)
+
+        :param bytes data: The bytes to hash and authenticate.
+        :raises cryptography.exceptions.AlreadyFinalized: See :meth:`finalize`
+        :raises TypeError: This exception is raised if ``data`` is not ``bytes``.
+
+    .. method:: copy()
+
+        Copy this :class:`CMAC` instance, usually so that we may call
+        :meth:`finalize` to get an intermediate value while we continue
+        to call :meth:`update` on the original instance.
+
+        :return: A new instance of :class:`CMAC` that can be updated
+            and finalized independently of the original instance.
+        :raises cryptography.exceptions.AlreadyFinalized: See :meth:`finalize`
+
+    .. method:: verify(signature)
+
+        Finalize the current context and securely compare the MAC to
+        ``signature``.
+
+        :param bytes signature: The bytes to compare the current CMAC
+                against.
+        :raises cryptography.exceptions.AlreadyFinalized: See :meth:`finalize`
+        :raises cryptography.exceptions.InvalidSignature: If signature does not
+                                                                  match digest
+        :raises TypeError: This exception is raised if ``signature`` is not
+                           ``bytes``.
+
+        .. method:: finalize()
+
+        Finalize the current context and return the message authentication code
+        as bytes.
+
+        After ``finalize`` has been called this object can no longer be used
+        and :meth:`update`, :meth:`copy`, :meth:`verify` and :meth:`finalize`
+        will raise an :class:`~cryptography.exceptions.AlreadyFinalized`
+        exception.
+
+        :return bytes: The message authentication code as bytes.
+        :raises cryptography.exceptions.AlreadyFinalized:
+
+
+.. _`Cipher-based message authentication codes`: https://en.wikipedia.org/wiki/CMAC
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/mac/hmac.rst hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/mac/hmac.rst
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/mac/hmac.rst	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/mac/hmac.rst	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,109 @@
+.. hazmat::
+
+Hash-based message authentication codes
+=======================================
+
+.. currentmodule:: cryptography.hazmat.primitives.hmac
+
+.. testsetup::
+
+    import binascii
+    key = binascii.unhexlify(b"0" * 32)
+
+Hash-based message authentication codes (or HMACs) are a tool for calculating
+message authentication codes using a cryptographic hash function coupled with a
+secret key. You can use an HMAC to verify both the integrity and authenticity
+of a message.
+
+.. class:: HMAC(key, algorithm, backend)
+
+    HMAC objects take a ``key`` and a
+    :class:`~cryptography.hazmat.primitives.hashes.HashAlgorithm` provider.
+    The ``key`` should be :doc:`randomly generated bytes </random-numbers>` and
+    is recommended to be equal in length to the ``digest_size`` of the hash
+    function chosen. You must keep the ``key`` secret.
+
+    This is an implementation of :rfc:`2104`.
+
+    .. doctest::
+
+        >>> from cryptography.hazmat.backends import default_backend
+        >>> from cryptography.hazmat.primitives import hashes, hmac
+        >>> h = hmac.HMAC(key, hashes.SHA256(), backend=default_backend())
+        >>> h.update(b"message to hash")
+        >>> h.finalize()
+        '#F\xdaI\x8b"e\xc4\xf1\xbb\x9a\x8fc\xff\xf5\xdex.\xbc\xcd/+\x8a\x86\x1d\x84\'\xc3\xa6\x1d\xd8J'
+
+    If the backend doesn't support the requested ``algorithm`` an
+    :class:`~cryptography.exceptions.UnsupportedAlgorithm` exception will be
+    raised.
+
+    If ``algorithm`` isn't a
+    :class:`~cryptography.hazmat.primitives.hashes.HashAlgorithm` provider
+    then ``TypeError`` will be raised.
+
+    To check that a given signature is correct use the :meth:`verify` method.
+    You will receive an exception if the signature is wrong:
+
+    .. doctest::
+
+        >>> h = hmac.HMAC(key, hashes.SHA256(), backend=default_backend())
+        >>> h.update(b"message to hash")
+        >>> h.verify(b"an incorrect signature")
+        Traceback (most recent call last):
+        ...
+        cryptography.exceptions.InvalidSignature: Signature did not match digest.
+
+    :param bytes key: Secret key as ``bytes``.
+    :param algorithm: An
+        :class:`~cryptography.hazmat.primitives.hashes.HashAlgorithm`
+        provider such as those described in
+        :ref:`Cryptographic Hashes <cryptographic-hash-algorithms>`.
+    :param backend: An
+        :class:`~cryptography.hazmat.backends.interfaces.HMACBackend`
+        provider.
+
+    :raises cryptography.exceptions.UnsupportedAlgorithm: This is raised if the
+        provided ``backend`` does not implement
+        :class:`~cryptography.hazmat.backends.interfaces.HMACBackend`
+
+    .. method:: update(msg)
+
+        :param bytes msg: The bytes to hash and authenticate.
+        :raises cryptography.exceptions.AlreadyFinalized: See :meth:`finalize`
+        :raises TypeError: This exception is raised if ``msg`` is not ``bytes``.
+
+    .. method:: copy()
+
+        Copy this :class:`HMAC` instance, usually so that we may call
+        :meth:`finalize` to get an intermediate digest value while we continue
+        to call :meth:`update` on the original instance.
+
+        :return: A new instance of :class:`HMAC` that can be updated
+            and finalized independently of the original instance.
+        :raises cryptography.exceptions.AlreadyFinalized: See :meth:`finalize`
+
+    .. method:: verify(signature)
+
+        Finalize the current context and securely compare digest to
+        ``signature``.
+
+        :param bytes signature: The bytes to compare the current digest
+                                against.
+        :raises cryptography.exceptions.AlreadyFinalized: See :meth:`finalize`
+        :raises cryptography.exceptions.InvalidSignature: If signature does not
+                                                          match digest
+        :raises TypeError: This exception is raised if ``signature`` is not
+                           ``bytes``.
+
+    .. method:: finalize()
+
+        Finalize the current context and return the message digest as bytes.
+
+        After ``finalize`` has been called this object can no longer be used
+        and :meth:`update`, :meth:`copy`, :meth:`verify` and :meth:`finalize`
+        will raise an :class:`~cryptography.exceptions.AlreadyFinalized`
+        exception.
+
+        :return bytes: The message digest as bytes.
+        :raises cryptography.exceptions.AlreadyFinalized:
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/mac/index.rst hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/mac/index.rst
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/mac/index.rst	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/mac/index.rst	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,18 @@
+.. hazmat::
+
+Message authentication codes
+============================
+
+While cryptography supports both the CMAC and HMAC algorithms, we strongly
+recommend that HMAC should be used unless you have a good reason otherwise.
+
+For more information on why HMAC is preferred, see `Use cases for CMAC vs.
+HMAC?`_
+
+.. _`Use cases for CMAC vs. HMAC?`: https://crypto.stackexchange.com/questions/15721/use-cases-for-cmac-vs-hmac
+
+.. toctree::
+    :maxdepth: 1
+
+    cmac
+    hmac
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/padding.rst hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/padding.rst
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/padding.rst	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/padding.rst	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,84 @@
+.. hazmat::
+
+Padding
+=======
+
+.. module:: cryptography.hazmat.primitives.padding
+
+Padding is a way to take data that may or may not be a multiple of the block
+size for a cipher and extend it out so that it is. This is required for many
+block cipher modes as they require the data to be encrypted to be an exact
+multiple of the block size.
+
+
+.. class:: PKCS7(block_size)
+
+    PKCS7 padding is a generalization of PKCS5 padding (also known as standard
+    padding). PKCS7 padding works by appending ``N`` bytes with the value of
+    ``chr(N)``, where ``N`` is the number of bytes required to make the final
+    block of data the same size as the block size. A simple example of padding
+    is:
+
+    .. doctest::
+
+        >>> from cryptography.hazmat.primitives import padding
+        >>> padder = padding.PKCS7(128).padder()
+        >>> padded_data = padder.update(b"11111111111111112222222222")
+        >>> padded_data
+        '1111111111111111'
+        >>> padded_data += padder.finalize()
+        >>> padded_data
+        '11111111111111112222222222\x06\x06\x06\x06\x06\x06'
+        >>> unpadder = padding.PKCS7(128).unpadder()
+        >>> data = unpadder.update(padded_data)
+        >>> data
+        '1111111111111111'
+        >>> data + unpadder.finalize()
+        '11111111111111112222222222'
+
+    :param block_size: The size of the block in bits that the data is being
+                       padded to.
+    :raises ValueError: Raised if block size is not a multiple of 8 or is not
+        between 0 and 256.
+
+    .. method:: padder()
+
+        :returns: A padding
+            :class:`~cryptography.hazmat.primitives.padding.PaddingContext`
+            provider.
+
+    .. method:: unpadder()
+
+        :returns: An unpadding
+            :class:`~cryptography.hazmat.primitives.padding.PaddingContext`
+            provider.
+
+
+.. class:: PaddingContext
+
+    When calling ``padder()`` or ``unpadder()`` the result will conform to the
+    ``PaddingContext`` interface. You can then call ``update(data)`` with data
+    until you have fed everything into the context. Once that is done call
+    ``finalize()`` to finish the operation and obtain the remainder of the
+    data.
+
+    .. method:: update(data)
+
+        :param bytes data: The data you wish to pass into the context.
+        :return bytes: Returns the data that was padded or unpadded.
+        :raises TypeError: Raised if data is not bytes.
+        :raises cryptography.exceptions.AlreadyFinalized: See :meth:`finalize`.
+        :raises TypeError: This exception is raised if ``data`` is not ``bytes``.
+
+    .. method:: finalize()
+
+        Finalize the current context and return the rest of the data.
+
+        After ``finalize`` has been called this object can no longer be used;
+        :meth:`update` and :meth:`finalize` will raise an
+        :class:`~cryptography.exceptions.AlreadyFinalized` exception.
+
+        :return bytes: Returns the remainder of the data.
+        :raises TypeError: Raised if data is not bytes.
+        :raises ValueError: When trying to remove padding from incorrectly
+                            padded data.
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/symmetric-encryption.rst hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/symmetric-encryption.rst
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/symmetric-encryption.rst	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/symmetric-encryption.rst	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,613 @@
+.. hazmat:: /fernet
+
+
+Symmetric encryption
+====================
+
+.. module:: cryptography.hazmat.primitives.ciphers
+
+Symmetric encryption is a way to `encrypt`_ or hide the contents of material
+where the sender and receiver both use the same secret key. Note that symmetric
+encryption is **not** sufficient for most applications because it only
+provides secrecy but not authenticity. That means an attacker can't see the
+message but an attacker can create bogus messages and force the application to
+decrypt them.
+
+For this reason it is **strongly** recommended to combine encryption with a
+message authentication code, such as :doc:`HMAC </hazmat/primitives/mac/hmac>`,
+in an "encrypt-then-MAC" formulation as `described by Colin Percival`_.
+
+.. class:: Cipher(algorithm, mode, backend)
+
+    Cipher objects combine an algorithm such as
+    :class:`~cryptography.hazmat.primitives.ciphers.algorithms.AES` with a
+    mode like
+    :class:`~cryptography.hazmat.primitives.ciphers.modes.CBC` or
+    :class:`~cryptography.hazmat.primitives.ciphers.modes.CTR`. A simple
+    example of encrypting and then decrypting content with AES is:
+
+    .. doctest::
+
+        >>> import os
+        >>> from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
+        >>> from cryptography.hazmat.backends import default_backend
+        >>> backend = default_backend()
+        >>> key = os.urandom(32)
+        >>> iv = os.urandom(16)
+        >>> cipher = Cipher(algorithms.AES(key), modes.CBC(iv), backend=backend)
+        >>> encryptor = cipher.encryptor()
+        >>> ct = encryptor.update(b"a secret message") + encryptor.finalize()
+        >>> decryptor = cipher.decryptor()
+        >>> decryptor.update(ct) + decryptor.finalize()
+        'a secret message'
+
+    :param algorithms: A
+        :class:`~cryptography.hazmat.primitives.ciphers.CipherAlgorithm`
+        provider such as those described
+        :ref:`below <symmetric-encryption-algorithms>`.
+    :param mode: A :class:`~cryptography.hazmat.primitives.ciphers.modes.Mode`
+        provider such as those described
+        :ref:`below <symmetric-encryption-modes>`.
+    :param backend: A
+        :class:`~cryptography.hazmat.backends.interfaces.CipherBackend`
+        provider.
+
+    :raises cryptography.exceptions.UnsupportedAlgorithm: This is raised if the
+        provided ``backend`` does not implement
+        :class:`~cryptography.hazmat.backends.interfaces.CipherBackend`
+
+    .. method:: encryptor()
+
+        :return: An encrypting
+            :class:`~cryptography.hazmat.primitives.ciphers.CipherContext`
+            provider.
+
+        If the backend doesn't support the requested combination of ``cipher``
+        and ``mode`` an :class:`~cryptography.exceptions.UnsupportedAlgorithm`
+        exception will be raised.
+
+    .. method:: decryptor()
+
+        :return: A decrypting
+            :class:`~cryptography.hazmat.primitives.ciphers.CipherContext`
+            provider.
+
+        If the backend doesn't support the requested combination of ``cipher``
+        and ``mode`` an :class:`~cryptography.exceptions.UnsupportedAlgorithm`
+        exception will be raised.
+
+.. _symmetric-encryption-algorithms:
+
+Algorithms
+~~~~~~~~~~
+
+.. currentmodule:: cryptography.hazmat.primitives.ciphers.algorithms
+
+.. class:: AES(key)
+
+    AES (Advanced Encryption Standard) is a block cipher standardized by NIST.
+    AES is both fast, and cryptographically strong. It is a good default
+    choice for encryption.
+
+    :param bytes key: The secret key. This must be kept secret. Either ``128``,
+        ``192``, or ``256`` bits long.
+
+.. class:: Camellia(key)
+
+    Camellia is a block cipher approved for use by `CRYPTREC`_ and ISO/IEC.
+    It is considered to have comparable security and performance to AES but
+    is not as widely studied or deployed.
+
+    :param bytes key: The secret key. This must be kept secret. Either ``128``,
+        ``192``, or ``256`` bits long.
+
+.. class:: TripleDES(key)
+
+    Triple DES (Data Encryption Standard), sometimes referred to as 3DES, is a
+    block cipher standardized by NIST. Triple DES has known crypto-analytic
+    flaws, however none of them currently enable a practical attack.
+    Nonetheless, Triples DES is not recommended for new applications because it
+    is incredibly slow; old applications should consider moving away from it.
+
+    :param bytes key: The secret key. This must be kept secret. Either ``64``,
+        ``128``, or ``192`` bits long. DES only uses ``56``, ``112``, or ``168``
+        bits of the key as there is a parity byte in each component of the key.
+        Some writing refers to there being up to three separate keys that are each
+        ``56`` bits long, they can simply be concatenated to produce the full key.
+
+.. class:: CAST5(key)
+
+    .. versionadded:: 0.2
+
+    CAST5 (also known as CAST-128) is a block cipher approved for use in the
+    Canadian government by the `Communications Security Establishment`_. It is
+    a variable key length cipher and supports keys from 40-128 bits in length.
+
+    :param bytes key: The secret key, This must be kept secret. 40 to 128 bits
+        in length in increments of 8 bits.
+
+.. class:: SEED(key)
+
+    .. versionadded:: 0.4
+
+    SEED is a block cipher developed by the Korea Information Security Agency
+    (KISA). It is defined in :rfc:`4269` and is used broadly throughout South
+    Korean industry, but rarely found elsewhere.
+
+    :param bytes key: The secret key. This must be kept secret. ``128`` bits in
+        length.
+
+Weak ciphers
+------------
+
+.. warning::
+
+    These ciphers are considered weak for a variety of reasons. New
+    applications should avoid their use and existing applications should
+    strongly consider migrating away.
+
+.. class:: Blowfish(key)
+
+    Blowfish is a block cipher developed by Bruce Schneier. It is known to be
+    susceptible to attacks when using weak keys. The author has recommended
+    that users of Blowfish move to newer algorithms such as :class:`AES`.
+
+    :param bytes key: The secret key. This must be kept secret. 32 to 448 bits
+        in length in increments of 8 bits.
+
+.. class:: ARC4(key)
+
+    ARC4 (Alleged RC4) is a stream cipher with serious weaknesses in its
+    initial stream output. Its use is strongly discouraged. ARC4 does not use
+    mode constructions.
+
+    :param bytes key: The secret key. This must be kept secret. Either ``40``,
+        ``56``, ``64``, ``80``, ``128``, ``192``, or ``256`` bits in length.
+
+    .. doctest::
+
+        >>> from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
+        >>> from cryptography.hazmat.backends import default_backend
+        >>> algorithm = algorithms.ARC4(key)
+        >>> cipher = Cipher(algorithm, mode=None, backend=default_backend())
+        >>> encryptor = cipher.encryptor()
+        >>> ct = encryptor.update(b"a secret message")
+        >>> decryptor = cipher.decryptor()
+        >>> decryptor.update(ct)
+        'a secret message'
+
+.. class:: IDEA(key)
+
+    IDEA (`International Data Encryption Algorithm`_) is a block cipher created
+    in 1991. It is an optional component of the `OpenPGP`_ standard. This cipher
+    is susceptible to attacks when using weak keys. It is recommended that you
+    do not use this cipher for new applications.
+
+    :param bytes key: The secret key. This must be kept secret. ``128`` bits in
+        length.
+
+
+.. _symmetric-encryption-modes:
+
+Modes
+~~~~~
+
+.. module:: cryptography.hazmat.primitives.ciphers.modes
+
+.. class:: CBC(initialization_vector)
+
+    CBC (Cipher Block Chaining) is a mode of operation for block ciphers. It is
+    considered cryptographically strong.
+
+    **Padding is required when using this mode.**
+
+    :param bytes initialization_vector: Must be :doc:`random bytes
+        </random-numbers>`. They do not need to be kept secret and they can be
+        included in a transmitted message. Must be the same number of bytes as
+        the ``block_size`` of the cipher. Each time something is encrypted a
+        new ``initialization_vector`` should be generated. Do not reuse an
+        ``initialization_vector`` with a given ``key``, and particularly do not
+        use a constant ``initialization_vector``.
+
+    A good construction looks like:
+
+    .. doctest::
+
+        >>> import os
+        >>> from cryptography.hazmat.primitives.ciphers.modes import CBC
+        >>> iv = os.urandom(16)
+        >>> mode = CBC(iv)
+
+    While the following is bad and will leak information:
+
+    .. doctest::
+
+        >>> from cryptography.hazmat.primitives.ciphers.modes import CBC
+        >>> iv = "a" * 16
+        >>> mode = CBC(iv)
+
+
+.. class:: CTR(nonce)
+
+    .. warning::
+
+        Counter mode is not recommended for use with block ciphers that have a
+        block size of less than 128-bits.
+
+    CTR (Counter) is a mode of operation for block ciphers. It is considered
+    cryptographically strong. It transforms a block cipher into a stream
+    cipher.
+
+    **This mode does not require padding.**
+
+    :param bytes nonce: Should be unique, a :term:`nonce`. It is
+        critical to never reuse a ``nonce`` with a given key.  Any reuse of a
+        nonce with the same key compromises the security of every message
+        encrypted with that key. Must be the same number of bytes as the
+        ``block_size`` of the cipher with a given key. The nonce does not need
+        to be kept secret and may be included with the ciphertext.
+
+.. class:: OFB(initialization_vector)
+
+    OFB (Output Feedback) is a mode of operation for block ciphers. It
+    transforms a block cipher into a stream cipher.
+
+    **This mode does not require padding.**
+
+    :param bytes initialization_vector: Must be :doc:`random bytes
+        </random-numbers>`. They do not need to be kept secret and they can be
+        included in a transmitted message. Must be the same number of bytes as
+        the ``block_size`` of the cipher. Do not reuse an
+        ``initialization_vector`` with a given ``key``.
+
+.. class:: CFB(initialization_vector)
+
+    CFB (Cipher Feedback) is a mode of operation for block ciphers. It
+    transforms a block cipher into a stream cipher.
+
+    **This mode does not require padding.**
+
+    :param bytes initialization_vector: Must be :doc:`random bytes
+        </random-numbers>`. They do not need to be kept secret and they can be
+        included in a transmitted message. Must be the same number of bytes as
+        the ``block_size`` of the cipher. Do not reuse an
+        ``initialization_vector`` with a given ``key``.
+
+.. class:: CFB8(initialization_vector)
+
+    CFB (Cipher Feedback) is a mode of operation for block ciphers. It
+    transforms a block cipher into a stream cipher. The CFB8 variant uses an
+    8-bit shift register.
+
+    **This mode does not require padding.**
+
+    :param bytes initialization_vector: Must be :doc:`random bytes
+        </random-numbers>`. They do not need to be kept secret and they can be
+        included in a transmitted message. Must be the same number of bytes as
+        the ``block_size`` of the cipher. Do not reuse an
+        ``initialization_vector`` with a given ``key``.
+
+.. class:: GCM(initialization_vector, tag=None, min_tag_length=16)
+
+    .. danger::
+
+        When using this mode you **must** not use the decrypted data until
+        :meth:`~cryptography.hazmat.primitives.ciphers.CipherContext.finalize`
+        has been called. GCM provides **no** guarantees of ciphertext integrity
+        until decryption is complete.
+
+    GCM (Galois Counter Mode) is a mode of operation for block ciphers. An
+    AEAD (authenticated encryption with additional data) mode is a type of
+    block cipher mode that simultaneously encrypts the message as well as
+    authenticating it. Additional unencrypted data may also be authenticated.
+    Additional means of verifying integrity such as
+    :doc:`HMAC </hazmat/primitives/mac/hmac>` are not necessary.
+
+    **This mode does not require padding.**
+
+    :param bytes initialization_vector: Must be unique, a :term:`nonce`.
+        They do not need to be kept secret and they can be included in a
+        transmitted message. NIST `recommends a 96-bit IV length`_ for
+        performance critical situations but it can be up to 2\ :sup:`64` - 1
+        bits. Do not reuse an ``initialization_vector`` with a given ``key``.
+
+    .. note::
+
+        Cryptography will generate a 128-bit tag when finalizing encryption.
+        You can shorten a tag by truncating it to the desired length but this
+        is **not recommended** as it lowers the security margins of the
+        authentication (`NIST SP-800-38D`_ recommends 96-bits or greater).
+        Applications wishing to allow truncation must pass the
+        ``min_tag_length`` parameter.
+
+        .. versionchanged:: 0.5
+
+            The ``min_tag_length`` parameter was added in ``0.5``, previously
+            truncation down to ``4`` bytes was always allowed.
+
+    :param bytes tag: The tag bytes to verify during decryption. When
+        encrypting this must be ``None``.
+
+    :param bytes min_tag_length: The minimum length ``tag`` must be. By default
+        this is ``16``, meaning tag truncation is not allowed. Allowing tag
+        truncation is strongly discouraged for most applications.
+
+    :raises ValueError: This is raised if ``len(tag) < min_tag_length``.
+
+    .. testcode::
+
+        import os
+
+        from cryptography.hazmat.primitives.ciphers import (
+            Cipher, algorithms, modes
+        )
+
+        def encrypt(key, plaintext, associated_data):
+            # Generate a random 96-bit IV.
+            iv = os.urandom(12)
+
+            # Construct an AES-GCM Cipher object with the given key and a
+            # randomly generated IV.
+            encryptor = Cipher(
+                algorithms.AES(key),
+                modes.GCM(iv),
+                backend=default_backend()
+            ).encryptor()
+
+            # associated_data will be authenticated but not encrypted,
+            # it must also be passed in on decryption.
+            encryptor.authenticate_additional_data(associated_data)
+
+            # Encrypt the plaintext and get the associated ciphertext.
+            # GCM does not require padding.
+            ciphertext = encryptor.update(plaintext) + encryptor.finalize()
+
+            return (iv, ciphertext, encryptor.tag)
+
+        def decrypt(key, associated_data, iv, ciphertext, tag):
+            # Construct a Cipher object, with the key, iv, and additionally the
+            # GCM tag used for authenticating the message.
+            decryptor = Cipher(
+                algorithms.AES(key),
+                modes.GCM(iv, tag),
+                backend=default_backend()
+            ).decryptor()
+
+            # We put associated_data back in or the tag will fail to verify
+            # when we finalize the decryptor.
+            decryptor.authenticate_additional_data(associated_data)
+
+            # Decryption gets us the authenticated plaintext.
+            # If the tag does not match an InvalidTag exception will be raised.
+            return decryptor.update(ciphertext) + decryptor.finalize()
+
+        iv, ciphertext, tag = encrypt(
+            key,
+            b"a secret message!",
+            b"authenticated but not encrypted payload"
+        )
+
+        print(decrypt(
+            key,
+            b"authenticated but not encrypted payload",
+            iv,
+            ciphertext,
+            tag
+        ))
+
+    .. testoutput::
+
+        a secret message!
+
+
+Insecure modes
+--------------
+
+.. warning::
+
+    These modes are insecure. New applications should never make use of them,
+    and existing applications should strongly consider migrating away.
+
+
+.. class:: ECB()
+
+    ECB (Electronic Code Book) is the simplest mode of operation for block
+    ciphers. Each block of data is encrypted in the same way. This means
+    identical plaintext blocks will always result in identical ciphertext
+    blocks, which can leave `significant patterns in the output`_.
+
+    **Padding is required when using this mode.**
+
+Interfaces
+----------
+
+.. currentmodule:: cryptography.hazmat.primitives.ciphers
+
+.. class:: CipherContext
+
+    When calling ``encryptor()`` or ``decryptor()`` on a ``Cipher`` object
+    the result will conform to the ``CipherContext`` interface. You can then
+    call ``update(data)`` with data until you have fed everything into the
+    context. Once that is done call ``finalize()`` to finish the operation and
+    obtain the remainder of the data.
+
+    Block ciphers require that the plaintext or ciphertext always be a multiple
+    of their block size. Because of that **padding** is sometimes required to
+    make a message the correct size. ``CipherContext`` will not automatically
+    apply any padding; you'll need to add your own. For block ciphers the
+    recommended padding is
+    :class:`~cryptography.hazmat.primitives.padding.PKCS7`. If you are using a
+    stream cipher mode (such as
+    :class:`~cryptography.hazmat.primitives.ciphers.modes.CTR`) you don't have
+    to worry about this.
+
+    .. method:: update(data)
+
+        :param bytes data: The data you wish to pass into the context.
+        :return bytes: Returns the data that was encrypted or decrypted.
+        :raises cryptography.exceptions.AlreadyFinalized: See :meth:`finalize`
+
+        When the ``Cipher`` was constructed in a mode that turns it into a
+        stream cipher (e.g.
+        :class:`~cryptography.hazmat.primitives.ciphers.modes.CTR`), this will
+        return bytes immediately, however in other modes it will return chunks
+        whose size is determined by the cipher's block size.
+
+    .. method:: finalize()
+
+        :return bytes: Returns the remainder of the data.
+        :raises ValueError: This is raised when the data provided isn't
+            a multiple of the algorithm's block size.
+
+        Once ``finalize`` is called this object can no longer be used and
+        :meth:`update` and :meth:`finalize` will raise an
+        :class:`~cryptography.exceptions.AlreadyFinalized` exception.
+
+.. class:: AEADCipherContext
+
+    When calling ``encryptor`` or ``decryptor`` on a ``Cipher`` object
+    with an AEAD mode (e.g.
+    :class:`~cryptography.hazmat.primitives.ciphers.modes.GCM`) the result will
+    conform to the ``AEADCipherContext`` and ``CipherContext`` interfaces. If
+    it is an encryption context it will additionally be an
+    ``AEADEncryptionContext`` provider. ``AEADCipherContext`` contains an
+    additional method :meth:`authenticate_additional_data` for adding
+    additional authenticated but unencrypted data (see note below). You should
+    call this before calls to ``update``. When you are done call ``finalize``
+    to finish the operation.
+
+    .. note::
+
+        In AEAD modes all data passed to ``update()`` will be both encrypted
+        and authenticated. Do not pass encrypted data to the
+        ``authenticate_additional_data()`` method. It is meant solely for
+        additional data you may want to authenticate but leave unencrypted.
+
+    .. method:: authenticate_additional_data(data)
+
+        :param bytes data: Any data you wish to authenticate but not encrypt.
+        :raises: :class:`~cryptography.exceptions.AlreadyFinalized`
+
+.. class:: AEADEncryptionContext
+
+    When creating an encryption context using ``encryptor`` on a ``Cipher``
+    object with an AEAD mode such as
+    :class:`~cryptography.hazmat.primitives.ciphers.modes.GCM` an object
+    conforming to both the ``AEADEncryptionContext`` and ``AEADCipherContext``
+    interfaces will be returned.  This interface provides one
+    additional attribute ``tag``. ``tag`` can only be obtained after
+    ``finalize`` has been called.
+
+    .. attribute:: tag
+
+        :return bytes: Returns the tag value as bytes.
+        :raises: :class:`~cryptography.exceptions.NotYetFinalized` if called
+            before the context is finalized.
+
+.. class:: CipherAlgorithm
+
+    A named symmetric encryption algorithm.
+
+    .. attribute:: name
+
+        :type: str
+
+        The standard name for the mode, for example, "AES", "Camellia", or
+        "Blowfish".
+
+    .. attribute:: key_size
+
+        :type: int
+
+        The number of bits in the key being used.
+
+
+.. class:: BlockCipherAlgorithm
+
+    A block cipher algorithm.
+
+    .. attribute:: block_size
+
+        :type: int
+
+        The number of bits in a block.
+
+Interfaces used by the symmetric cipher modes described in
+:ref:`Symmetric Encryption Modes <symmetric-encryption-modes>`.
+
+.. currentmodule:: cryptography.hazmat.primitives.ciphers.modes
+
+.. class:: Mode
+
+    A named cipher mode.
+
+    .. attribute:: name
+
+        :type: str
+
+        This should be the standard shorthand name for the mode, for example
+        Cipher-Block Chaining mode is "CBC".
+
+        The name may be used by a backend to influence the operation of a
+        cipher in conjunction with the algorithm's name.
+
+    .. method:: validate_for_algorithm(algorithm)
+
+        :param cryptography.hazmat.primitives.ciphers.CipherAlgorithm algorithm:
+
+        Checks that the combination of this mode with the provided algorithm
+        meets any necessary invariants. This should raise an exception if they
+        are not met.
+
+        For example, the
+        :class:`~cryptography.hazmat.primitives.ciphers.modes.CBC` mode uses
+        this method to check that the provided initialization vector's length
+        matches the block size of the algorithm.
+
+
+.. class:: ModeWithInitializationVector
+
+    A cipher mode with an initialization vector.
+
+    .. attribute:: initialization_vector
+
+        :type: bytes
+
+        Exact requirements of the initialization are described by the
+        documentation of individual modes.
+
+
+.. class:: ModeWithNonce
+
+    A cipher mode with a nonce.
+
+    .. attribute:: nonce
+
+        :type: bytes
+
+        Exact requirements of the nonce are described by the documentation of
+        individual modes.
+
+
+.. class:: ModeWithAuthenticationTag
+
+    A cipher mode with an authentication tag.
+
+    .. attribute:: tag
+
+        :type: bytes
+
+        Exact requirements of the tag are described by the documentation of
+        individual modes.
+
+
+
+.. _`described by Colin Percival`: http://www.daemonology.net/blog/2009-06-11-cryptographic-right-answers.html
+.. _`recommends a 96-bit IV length`: http://csrc.nist.gov/groups/ST/toolkit/BCM/documents/proposedmodes/gcm/gcm-spec.pdf
+.. _`NIST SP-800-38D`: http://csrc.nist.gov/publications/nistpubs/800-38D/SP-800-38D.pdf
+.. _`Communications Security Establishment`: https://www.cse-cst.gc.ca
+.. _`encrypt`: https://ssd.eff.org/en/module/what-encryption
+.. _`CRYPTREC`: http://www.cryptrec.go.jp/english/
+.. _`significant patterns in the output`: https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Electronic_Codebook_.28ECB.29
+.. _`International Data Encryption Algorithm`: https://en.wikipedia.org/wiki/International_Data_Encryption_Algorithm
+.. _`OpenPGP`: http://www.openpgp.org
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/twofactor.rst hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/twofactor.rst
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/twofactor.rst	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/hazmat/primitives/twofactor.rst	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,224 @@
+.. hazmat::
+
+Two-factor authentication
+=========================
+
+.. currentmodule:: cryptography.hazmat.primitives.twofactor
+
+This module contains algorithms related to two-factor authentication.
+
+Currently, it contains an algorithm for generating and verifying
+one time password values based on Hash-based message authentication
+codes (HMAC).
+
+.. class:: InvalidToken
+
+    This is raised when the verify method of a one time password function's
+    computed token does not match the expected token.
+
+.. currentmodule:: cryptography.hazmat.primitives.twofactor.hotp
+
+.. class:: HOTP(key, length, algorithm, backend)
+
+    .. versionadded:: 0.3
+
+    HOTP objects take a ``key``, ``length`` and ``algorithm`` parameter. The
+    ``key`` should be :doc:`randomly generated bytes </random-numbers>` and is
+    recommended to be 160 bits in length. The ``length`` parameter controls the
+    length of the generated one time password and must be >= 6 and <= 8.
+
+    This is an implementation of :rfc:`4226`.
+
+    .. doctest::
+
+        >>> import os
+        >>> from cryptography.hazmat.backends import default_backend
+        >>> from cryptography.hazmat.primitives.twofactor.hotp import HOTP
+        >>> from cryptography.hazmat.primitives.hashes import SHA1
+        >>> key = os.urandom(16)
+        >>> hotp = HOTP(key, 6, SHA1(), backend=default_backend())
+        >>> hotp_value = hotp.generate(0)
+        >>> hotp.verify(hotp_value, 0)
+
+    :param bytes key: Per-user secret key. This value must be kept secret
+                      and be at least 128 bits. It is recommended that the
+                      key be 160 bits.
+    :param int length: Length of generated one time password as ``int``.
+    :param cryptography.hazmat.primitives.hashes.HashAlgorithm algorithm: A
+        :class:`~cryptography.hazmat.primitives.hashes`
+        provider.
+    :param backend: A
+        :class:`~cryptography.hazmat.backends.interfaces.HMACBackend`
+        provider.
+    :raises ValueError: This is raised if the provided ``key`` is shorter than
+        128 bits or if the ``length`` parameter is not 6, 7 or 8.
+    :raises TypeError: This is raised if the provided ``algorithm`` is not
+        :class:`~cryptography.hazmat.primitives.hashes.SHA1()`,
+        :class:`~cryptography.hazmat.primitives.hashes.SHA256()` or
+        :class:`~cryptography.hazmat.primitives.hashes.SHA512()` or if the
+        ``length`` parameter is not an integer.
+    :raises cryptography.exceptions.UnsupportedAlgorithm: This is raised if the
+        provided ``backend`` does not implement
+        :class:`~cryptography.hazmat.backends.interfaces.HMACBackend`
+
+    .. method:: generate(counter)
+
+        :param int counter: The counter value used to generate the one time
+            password.
+        :return bytes: A one time password value.
+
+    .. method:: verify(hotp, counter)
+
+        :param bytes hotp: The one time password value to validate.
+        :param int counter: The counter value to validate against.
+        :raises cryptography.hazmat.primitives.twofactor.InvalidToken: This
+             is raised when the supplied HOTP does not match the expected HOTP.
+
+    .. method:: get_provisioning_uri(account_name, counter, issuer)
+
+        .. versionadded:: 1.0
+
+        :param account_name: The display name of account, such as
+            ``'Alice Smith'`` or ``'alice@example.com'``.
+        :type account_name: :term:`text`
+        :param issuer: The optional display name of issuer. This is typically
+            the provider or service the user wants to access using the OTP
+            token.
+        :type issuer: :term:`text` or `None`
+        :param int counter: The current value of counter.
+        :return: A URI string.
+
+Throttling
+~~~~~~~~~~
+
+Due to the fact that the HOTP algorithm generates rather short tokens that are
+6 - 8 digits long, brute force attacks are possible. It is highly recommended
+that the server that validates the token implement a throttling scheme that
+locks out the account for a period of time after a number of failed attempts.
+The number of allowed attempts should be as low as possible while still
+ensuring that usability is not significantly impacted.
+
+Re-synchronization of the counter
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+The server's counter value should only be incremented on a successful HOTP
+authentication. However, the counter on the client is incremented every time a
+new HOTP value is requested. This can lead to the counter value being out of
+synchronization between the client and server.
+
+Due to this, it is highly recommended that the server sets a look-ahead window
+that allows the server to calculate the next ``x`` HOTP values and check them
+against the supplied HOTP value. This can be accomplished with something
+similar to the following code.
+
+.. code-block:: python
+
+    def verify(hotp, counter, look_ahead):
+        assert look_ahead >= 0
+        correct_counter = None
+
+        otp = HOTP(key, 6, default_backend())
+        for count in range(counter, counter + look_ahead):
+            try:
+                otp.verify(hotp, count)
+                correct_counter = count
+            except InvalidToken:
+                pass
+
+        return correct_counter
+
+.. currentmodule:: cryptography.hazmat.primitives.twofactor.totp
+
+.. class:: TOTP(key, length, algorithm, time_step, backend)
+
+    TOTP objects take a ``key``, ``length``, ``algorithm`` and ``time_step``
+    parameter. The ``key`` should be :doc:`randomly generated bytes
+    </random-numbers>` and is recommended to be as long as your hash function's
+    output (e.g 256-bit for SHA256). The ``length`` parameter controls the
+    length of the generated one time password and must be >= 6 and <= 8.
+
+    This is an implementation of :rfc:`6238`.
+
+    .. doctest::
+
+        >>> import os
+        >>> import time
+        >>> from cryptography.hazmat.backends import default_backend
+        >>> from cryptography.hazmat.primitives.twofactor.totp import TOTP
+        >>> from cryptography.hazmat.primitives.hashes import SHA1
+        >>> key = os.urandom(16)
+        >>> totp = TOTP(key, 8, SHA1(), 30, backend=default_backend())
+        >>> time_value = time.time()
+        >>> totp_value = totp.generate(time_value)
+        >>> totp.verify(totp_value, time_value)
+
+    :param bytes key: Per-user secret key. This value must be kept secret
+                      and be at least 128 bits. It is recommended that the
+                      key be 160 bits.
+    :param int length: Length of generated one time password as ``int``.
+    :param cryptography.hazmat.primitives.hashes.HashAlgorithm algorithm: A
+        :class:`~cryptography.hazmat.primitives.hashes`
+        provider.
+    :param int time_step: The time step size. The recommended size is 30.
+    :param backend: A
+        :class:`~cryptography.hazmat.backends.interfaces.HMACBackend`
+        provider.
+    :raises ValueError: This is raised if the provided ``key`` is shorter than
+        128 bits or if the ``length`` parameter is not 6, 7 or 8.
+    :raises TypeError: This is raised if the provided ``algorithm`` is not
+        :class:`~cryptography.hazmat.primitives.hashes.SHA1()`,
+        :class:`~cryptography.hazmat.primitives.hashes.SHA256()` or
+        :class:`~cryptography.hazmat.primitives.hashes.SHA512()` or if the
+        ``length`` parameter is not an integer.
+    :raises cryptography.exceptions.UnsupportedAlgorithm: This is raised if the
+        provided ``backend`` does not implement
+        :class:`~cryptography.hazmat.backends.interfaces.HMACBackend`
+
+    .. method:: generate(time)
+
+        :param int time: The time value used to generate the one time password.
+        :return bytes: A one time password value.
+
+    .. method:: verify(totp, time)
+
+        :param bytes totp: The one time password value to validate.
+        :param int time: The time value to validate against.
+        :raises cryptography.hazmat.primitives.twofactor.InvalidToken: This
+             is raised when the supplied TOTP does not match the expected TOTP.
+
+    .. method:: get_provisioning_uri(account_name, issuer)
+
+        .. versionadded:: 1.0
+
+        :param account_name: The display name of account, such as
+            ``'Alice Smith'`` or ``'alice@example.com'``.
+        :type: :term:`text`
+        :param issuer: The optional display name of issuer. This is typically
+            the provider or service the user wants to access using the OTP
+            token.
+        :type issuer: :term:`text` or `None`
+        :return: A URI string.
+
+Provisioning URI
+~~~~~~~~~~~~~~~~
+
+The provisioning URI of HOTP and TOTP is not actual the part of RFC 4226 and
+RFC 6238, but a `spec of Google Authenticator`_. It is widely supported by web
+sites and mobile applications which are using Two-Factor authentication.
+
+For generating a provisioning URI, you could use the ``get_provisioning_uri``
+method of HOTP/TOTP instances.
+
+.. code-block:: python
+
+    counter = 5
+    account_name = 'alice@example.com'
+    issuer_name = 'Example Inc'
+
+    hotp_uri = hotp.get_provisioning_uri(account_name, counter, issuer_name)
+    totp_uri = totp.get_provisioning_uri(account_name, issuer_name)
+
+A common usage is encoding the provisioning URI into QR code and guiding users
+to scan it with Two-Factor authentication applications in their mobile devices.
+
+.. _`spec of Google Authenticator`: https://github.com/google/google-authenticator/wiki/Key-Uri-Format
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/index.rst hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/index.rst
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/index.rst	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/index.rst	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,104 @@
+Welcome to ``cryptography``
+===========================
+
+``cryptography`` is a Python library which exposes cryptographic recipes and
+primitives. Our goal is for it to be your "cryptographic standard library". If
+you are interested in learning more about the field of cryptography, we
+recommend `Crypto 101, by Laurens Van Houtven`_.
+
+Installation
+------------
+You can install ``cryptography`` with ``pip``:
+
+.. code-block:: console
+
+    $ pip install cryptography
+
+See :doc:`Installation <installation>` for more information.
+
+Why a new crypto library for Python?
+------------------------------------
+
+If you've done cryptographic work in Python before, you've probably seen some
+other libraries in Python, such as *M2Crypto*, *PyCrypto*, or *PyOpenSSL*. In
+building ``cryptography`` we wanted to address a few issues we observed in the
+existing libraries:
+
+* Lack of PyPy and Python 3 support.
+* Lack of maintenance.
+* Use of poor implementations of algorithms (i.e. ones with known side-channel
+  attacks).
+* Lack of high level, "Cryptography for humans", APIs.
+* Absence of algorithms such as
+  :class:`AES-GCM <cryptography.hazmat.primitives.ciphers.modes.GCM>` and
+  :class:`~cryptography.hazmat.primitives.kdf.hkdf.HKDF`.
+* Poor introspectability, and thus poor testability.
+* Extremely error prone APIs, and bad defaults.
+
+
+.. _cryptography-layout:
+
+Layout
+------
+
+``cryptography`` is broadly divided into two levels. One with safe
+cryptographic recipes, "cryptography for humans" if you will. These are safe
+and easy to use and don't require developers to make many decisions.
+
+The other level is low-level cryptographic primitives. These are often
+dangerous and can be used incorrectly. They require making decisions and having
+an in-depth knowledge of the cryptographic concepts at work. Because of the
+potential danger in working at this level, this is referred to as the
+"hazardous materials" or "hazmat" layer. These live in the
+``cryptography.hazmat`` package, and their documentation will always contain an
+admonition at the top.
+
+We recommend using the recipes layer whenever possible, and falling back to the
+hazmat layer only when necessary.
+
+The recipes layer
+~~~~~~~~~~~~~~~~~
+
+.. toctree::
+    :maxdepth: 2
+
+    fernet
+    x509/index
+    random-numbers
+    exceptions
+    faq
+    glossary
+
+The hazardous materials layer
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+.. toctree::
+    :maxdepth: 2
+
+    hazmat/primitives/index
+    hazmat/backends/index
+    hazmat/bindings/index
+
+The ``cryptography`` open source project
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+.. toctree::
+    :maxdepth: 2
+
+    installation
+    development/index
+    security
+    limitations
+    api-stability
+    doing-a-release
+    changelog
+    community
+
+
+.. note::
+
+    ``cryptography`` has not been subjected to an external audit of its code or
+    documentation. If you're interested in discussing an audit please
+    :doc:`get in touch </community>`.
+
+.. _`Crypto 101, by Laurens Van Houtven`: https://www.crypto101.io/
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/installation.rst hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/installation.rst
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/installation.rst	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/installation.rst	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,259 @@
+Installation
+============
+
+You can install ``cryptography`` with ``pip``:
+
+.. code-block:: console
+
+    $ pip install cryptography
+
+Supported platforms
+-------------------
+
+Currently we test ``cryptography`` on Python 2.6, 2.7, 3.3, 3.4, 3.5, and PyPy
+2.6+ on these operating systems.
+
+* x86-64 CentOS 7.x, 6.4 and CentOS 5.x
+* x86-64 FreeBSD 10
+* OS X 10.11 El Capitan, 10.10 Yosemite, 10.9 Mavericks, 10.8 Mountain Lion,
+  and 10.7 Lion
+* x86-64 Ubuntu 12.04 LTS and Ubuntu 14.04 LTS
+* x86-64 Debian Wheezy (7.x), Jessie (8.x), and Debian Sid (unstable)
+* 32-bit and 64-bit Python on 64-bit Windows Server 2012
+
+We test compiling with ``clang`` as well as ``gcc`` and use the following
+OpenSSL releases:
+
+* ``OpenSSL 0.9.8e-fips-rhel5`` (``RHEL/CentOS 5``)
+* ``OpenSSL 0.9.8k``
+* ``OpenSSL 0.9.8-latest`` (The most recent 0.9.8 release)
+* ``OpenSSL 1.0.0-fips`` (``RHEL/CentOS 6.4``)
+* ``OpenSSL 1.0.1``
+* ``OpenSSL 1.0.1e-fips`` (``RHEL/CentOS 7``)
+* ``OpenSSL 1.0.1j-freebsd``
+* ``OpenSSL 1.0.1f``
+* ``OpenSSL 1.0.2-latest``
+
+On Windows
+----------
+
+The wheel package on Windows is a statically linked build (as of 0.5) so all
+dependencies are included. Just run
+
+.. code-block:: console
+
+    $ pip install cryptography
+
+If you prefer to compile it yourself you'll need to have OpenSSL installed.
+You can compile OpenSSL yourself as well or use the binaries we build for our
+release infrastructure (`openssl-release`_). Be sure to download the proper
+version for your architecture and Python (2010 works for Python 2.6, 2.7, 3.3,
+and 3.4 while 2015 is required for 3.5). Wherever you place your copy
+of OpenSSL you'll need to set the ``LIB`` and ``INCLUDE`` environment variables
+to include the proper locations. For example:
+
+.. code-block:: console
+
+    C:\> \path\to\vcvarsall.bat x86_amd64
+    C:\> set LIB=C:\OpenSSL-win64\lib;%LIB%
+    C:\> set INCLUDE=C:\OpenSSL-win64\include;%INCLUDE%
+    C:\> pip install cryptography
+
+
+.. _build-on-linux:
+
+Building cryptography on Linux
+------------------------------
+
+``cryptography`` should build very easily on Linux provided you have a C
+compiler, headers for Python (if you're not using ``pypy``), and headers for
+the OpenSSL and ``libffi`` libraries available on your system.
+
+For Debian and Ubuntu, the following command will ensure that the required
+dependencies are installed:
+
+.. code-block:: console
+
+    $ sudo apt-get install build-essential libssl-dev libffi-dev python-dev
+
+For Fedora and RHEL-derivatives, the following command will ensure that the
+required dependencies are installed:
+
+.. code-block:: console
+
+    $ sudo yum install gcc libffi-devel python-devel openssl-devel
+
+You should now be able to build and install cryptography with the usual
+
+.. code-block:: console
+
+    $ pip install cryptography
+
+
+Using your own OpenSSL on Linux
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+Python links to OpenSSL for its own purposes and this can sometimes cause
+problems when you wish to use a different version of OpenSSL with cryptography.
+If you want to use cryptography with your own build of OpenSSL you will need to
+make sure that the build is configured correctly so that your version of
+OpenSSL doesn't conflict with Python's.
+
+The options you need to add allow the linker to identify every symbol correctly
+even when multiple versions of the library are linked into the same program. If
+you are using your distribution's source packages these will probably be
+patched in for you already, otherwise you'll need to use options something like
+this when configuring OpenSSL:
+
+.. code-block:: console
+
+    $ ./config -Wl,--version-script=openssl.ld -Wl,-Bsymbolic-functions -fPIC shared
+
+You'll also need to generate your own ``openssl.ld`` file. For example::
+
+    OPENSSL_1.0.1F_CUSTOM {
+        global:
+            *;
+    };
+
+You should replace the version string on the first line as appropriate for your
+build.
+
+Static Wheels
+~~~~~~~~~~~~~
+
+Cryptography ships statically-linked wheels for OS X and Windows, ensuring that
+these platforms can always use the most-recent OpenSSL, regardless of what is
+shipped by default on those platforms. As a result of various difficulties
+around Linux binary linking, Cryptography cannot do the same on Linux.
+
+However, you can build your own statically-linked wheels that will work on your
+own systems. This will allow you to continue to use relatively old Linux
+distributions (such as LTS releases), while making sure you have the most
+recent OpenSSL available to your Python programs.
+
+To do so, you should find yourself a machine that is as similar as possible to
+your target environment (e.g. your production environment): for example, spin
+up a new cloud server running your target Linux distribution. On this machine,
+install the Cryptography dependencies as mentioned in :ref:`build-on-linux`.
+Please also make sure you have `virtualenv`_ installed: this should be
+available from your system package manager.
+
+Then, paste the following into a shell script. You'll need to populate the
+``OPENSSL_VERSION`` variable. To do that, visit `openssl.org`_ and find the
+latest non-FIPS release version number, then set the string appropriately. For
+example, for OpenSSL 1.0.2d, use ``OPENSSL_VERSION="1.0.2d"``.
+
+When this shell script is complete, you'll find a collection of wheel files in
+a directory called ``wheelhouse``. These wheels can be installed by a
+sufficiently-recent version of ``pip``. The Cryptography wheel in this
+directory contains a statically-linked OpenSSL binding, which ensures that you
+have access to the most-recent OpenSSL releases without corrupting your system
+dependencies.
+
+.. code-block:: console
+
+    set -e
+
+    OPENSSL_VERSION="VERSIONGOESHERE"
+    CWD=$(pwd)
+
+    virtualenv env
+    . env/bin/activate
+    pip install -U setuptools
+    pip install -U wheel pip
+    curl -O https://openssl.org/source/openssl-${OPENSSL_VERSION}.tar.gz
+    tar xvf openssl-${OPENSSL_VERSION}.tar.gz
+    cd openssl-${OPENSSL_VERSION}
+    ./config no-shared no-ssl2 -fPIC --prefix=${CWD}/openssl
+    make && make install
+    cd ..
+    CFLAGS="-I${CWD}/openssl/include" LDFLAGS="-L${CWD}/openssl/lib" pip wheel --no-use-wheel cryptography
+
+Building cryptography on OS X
+-----------------------------
+
+The wheel package on OS X is a statically linked build (as of 1.0.1) so for
+users on 10.10 (Yosemite) and above you only need one step:
+
+.. code-block:: console
+
+    $ pip install cryptography
+
+If you want to build cryptography yourself or are on an older OS X version
+cryptography requires the presence of a C compiler, development headers, and
+the proper libraries. On OS X much of this is provided by Apple's Xcode
+development tools.  To install the Xcode command line tools open a terminal
+window and run:
+
+.. code-block:: console
+
+    $ xcode-select --install
+
+This will install a compiler (clang) along with (most of) the required
+development headers.
+
+You'll also need OpenSSL, which you can obtain from `Homebrew`_ or `MacPorts`_.
+
+To build cryptography and dynamically link it:
+
+`Homebrew`_
+
+.. code-block:: console
+
+    $ brew install openssl
+    $ env LDFLAGS="-L$(brew --prefix openssl)/lib" CFLAGS="-I$(brew --prefix openssl)/include" pip install cryptography
+
+`MacPorts`_:
+
+.. code-block:: console
+
+    $ sudo port install openssl
+    $ env LDFLAGS="-L/opt/local/lib" CFLAGS="-I/opt/local/include" pip install cryptography
+
+You can also build cryptography statically:
+
+`Homebrew`_
+
+.. code-block:: console
+
+    $ brew install openssl
+    $ env CRYPTOGRAPHY_OSX_NO_LINK_FLAGS=1 LDFLAGS="$(brew --prefix openssl)/lib/libssl.a $(brew --prefix openssl)/lib/libcrypto.a" CFLAGS="-I$(brew --prefix openssl)/include" pip install cryptography
+
+`MacPorts`_:
+
+.. code-block:: console
+
+    $ sudo port install openssl
+    $ env CRYPTOGRAPHY_OSX_NO_LINK_FLAGS=1 LDFLAGS="/opt/local/lib/libssl.a /opt/local/lib/libcrypto.a" CFLAGS="-I/opt/local/include" pip install cryptography
+
+Building cryptography with conda
+--------------------------------
+
+Because of a `bug in conda`_, attempting to install cryptography out of the box
+will result in an error. This can be resolved by setting the library path
+environment variable for your platform.
+
+On OS X:
+
+.. code-block:: console
+
+    $ env DYLD_LIBRARY_PATH="$HOME/anaconda/lib" pip install cryptography
+
+and on Linux:
+
+.. code-block:: console
+
+    $ env LD_LIBRARY_PATH="$HOME/anaconda/lib" pip install cryptography
+
+You will need to set this variable every time you start Python. For more
+information, consult `Greg Wilson's blog post`_ on the subject.
+
+
+.. _`Homebrew`: http://brew.sh
+.. _`MacPorts`: https://www.macports.org
+.. _`openssl-release`: https://jenkins.cryptography.io/job/openssl-release/
+.. _`bug in conda`: https://github.com/conda/conda-recipes/issues/110
+.. _`Greg Wilson's blog post`: http://software-carpentry.org/blog/2014/04/mr-biczo-was-right.html
+.. _virtualenv: https://virtualenv.pypa.io/en/latest/
+.. _openssl.org: https://openssl.org/source/
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/limitations.rst hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/limitations.rst
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/limitations.rst	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/limitations.rst	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,19 @@
+Known security limitations
+--------------------------
+
+Lack of secure memory wiping
+============================
+
+`Memory wiping`_ is used to protect secret data or key material from attackers
+with access to uninitialized memory. This can be either because the attacker
+has some kind of local user access or because of how other software uses
+uninitialized memory.
+
+Python exposes no API for us to implement this reliably and as such almost all
+software in Python is potentially vulnerable to this attack. The
+`CERT secure coding guidelines`_ assesses this issue as "Severity: medium,
+Likelihood: unlikely, Remediation Cost: expensive to repair" and we do not
+consider this a high risk for most users.
+
+.. _`Memory wiping`:  http://blogs.msdn.com/b/oldnewthing/archive/2013/05/29/10421912.aspx
+.. _`CERT secure coding guidelines`: https://www.securecoding.cert.org/confluence/display/c/MEM03-C.+Clear+sensitive+information+stored+in+reusable+resources
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/make.bat hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/make.bat
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/make.bat	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/make.bat	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,190 @@
+@ECHO OFF
+
+REM Command file for Sphinx documentation
+
+if "%SPHINXBUILD%" == "" (
+	set SPHINXBUILD=sphinx-build
+)
+set BUILDDIR=_build
+set ALLSPHINXOPTS=-d %BUILDDIR%/doctrees %SPHINXOPTS% .
+set I18NSPHINXOPTS=%SPHINXOPTS% .
+if NOT "%PAPER%" == "" (
+	set ALLSPHINXOPTS=-D latex_paper_size=%PAPER% %ALLSPHINXOPTS%
+	set I18NSPHINXOPTS=-D latex_paper_size=%PAPER% %I18NSPHINXOPTS%
+)
+
+if "%1" == "" goto help
+
+if "%1" == "help" (
+	:help
+	echo.Please use `make ^<target^>` where ^<target^> is one of
+	echo.  html       to make standalone HTML files
+	echo.  dirhtml    to make HTML files named index.html in directories
+	echo.  singlehtml to make a single large HTML file
+	echo.  pickle     to make pickle files
+	echo.  json       to make JSON files
+	echo.  htmlhelp   to make HTML files and a HTML help project
+	echo.  qthelp     to make HTML files and a qthelp project
+	echo.  devhelp    to make HTML files and a Devhelp project
+	echo.  epub       to make an epub
+	echo.  latex      to make LaTeX files, you can set PAPER=a4 or PAPER=letter
+	echo.  text       to make text files
+	echo.  man        to make manual pages
+	echo.  texinfo    to make Texinfo files
+	echo.  gettext    to make PO message catalogs
+	echo.  changes    to make an overview over all changed/added/deprecated items
+	echo.  linkcheck  to check all external links for integrity
+	echo.  doctest    to run all doctests embedded in the documentation if enabled
+	goto end
+)
+
+if "%1" == "clean" (
+	for /d %%i in (%BUILDDIR%\*) do rmdir /q /s %%i
+	del /q /s %BUILDDIR%\*
+	goto end
+)
+
+if "%1" == "html" (
+	%SPHINXBUILD% -b html %ALLSPHINXOPTS% %BUILDDIR%/html
+	if errorlevel 1 exit /b 1
+	echo.
+	echo.Build finished. The HTML pages are in %BUILDDIR%/html.
+	goto end
+)
+
+if "%1" == "dirhtml" (
+	%SPHINXBUILD% -b dirhtml %ALLSPHINXOPTS% %BUILDDIR%/dirhtml
+	if errorlevel 1 exit /b 1
+	echo.
+	echo.Build finished. The HTML pages are in %BUILDDIR%/dirhtml.
+	goto end
+)
+
+if "%1" == "singlehtml" (
+	%SPHINXBUILD% -b singlehtml %ALLSPHINXOPTS% %BUILDDIR%/singlehtml
+	if errorlevel 1 exit /b 1
+	echo.
+	echo.Build finished. The HTML pages are in %BUILDDIR%/singlehtml.
+	goto end
+)
+
+if "%1" == "pickle" (
+	%SPHINXBUILD% -b pickle %ALLSPHINXOPTS% %BUILDDIR%/pickle
+	if errorlevel 1 exit /b 1
+	echo.
+	echo.Build finished; now you can process the pickle files.
+	goto end
+)
+
+if "%1" == "json" (
+	%SPHINXBUILD% -b json %ALLSPHINXOPTS% %BUILDDIR%/json
+	if errorlevel 1 exit /b 1
+	echo.
+	echo.Build finished; now you can process the JSON files.
+	goto end
+)
+
+if "%1" == "htmlhelp" (
+	%SPHINXBUILD% -b htmlhelp %ALLSPHINXOPTS% %BUILDDIR%/htmlhelp
+	if errorlevel 1 exit /b 1
+	echo.
+	echo.Build finished; now you can run HTML Help Workshop with the ^
+.hhp project file in %BUILDDIR%/htmlhelp.
+	goto end
+)
+
+if "%1" == "qthelp" (
+	%SPHINXBUILD% -b qthelp %ALLSPHINXOPTS% %BUILDDIR%/qthelp
+	if errorlevel 1 exit /b 1
+	echo.
+	echo.Build finished; now you can run "qcollectiongenerator" with the ^
+.qhcp project file in %BUILDDIR%/qthelp, like this:
+	echo.^> qcollectiongenerator %BUILDDIR%\qthelp\Cryptography.qhcp
+	echo.To view the help file:
+	echo.^> assistant -collectionFile %BUILDDIR%\qthelp\Cryptography.ghc
+	goto end
+)
+
+if "%1" == "devhelp" (
+	%SPHINXBUILD% -b devhelp %ALLSPHINXOPTS% %BUILDDIR%/devhelp
+	if errorlevel 1 exit /b 1
+	echo.
+	echo.Build finished.
+	goto end
+)
+
+if "%1" == "epub" (
+	%SPHINXBUILD% -b epub %ALLSPHINXOPTS% %BUILDDIR%/epub
+	if errorlevel 1 exit /b 1
+	echo.
+	echo.Build finished. The epub file is in %BUILDDIR%/epub.
+	goto end
+)
+
+if "%1" == "latex" (
+	%SPHINXBUILD% -b latex %ALLSPHINXOPTS% %BUILDDIR%/latex
+	if errorlevel 1 exit /b 1
+	echo.
+	echo.Build finished; the LaTeX files are in %BUILDDIR%/latex.
+	goto end
+)
+
+if "%1" == "text" (
+	%SPHINXBUILD% -b text %ALLSPHINXOPTS% %BUILDDIR%/text
+	if errorlevel 1 exit /b 1
+	echo.
+	echo.Build finished. The text files are in %BUILDDIR%/text.
+	goto end
+)
+
+if "%1" == "man" (
+	%SPHINXBUILD% -b man %ALLSPHINXOPTS% %BUILDDIR%/man
+	if errorlevel 1 exit /b 1
+	echo.
+	echo.Build finished. The manual pages are in %BUILDDIR%/man.
+	goto end
+)
+
+if "%1" == "texinfo" (
+	%SPHINXBUILD% -b texinfo %ALLSPHINXOPTS% %BUILDDIR%/texinfo
+	if errorlevel 1 exit /b 1
+	echo.
+	echo.Build finished. The Texinfo files are in %BUILDDIR%/texinfo.
+	goto end
+)
+
+if "%1" == "gettext" (
+	%SPHINXBUILD% -b gettext %I18NSPHINXOPTS% %BUILDDIR%/locale
+	if errorlevel 1 exit /b 1
+	echo.
+	echo.Build finished. The message catalogs are in %BUILDDIR%/locale.
+	goto end
+)
+
+if "%1" == "changes" (
+	%SPHINXBUILD% -b changes %ALLSPHINXOPTS% %BUILDDIR%/changes
+	if errorlevel 1 exit /b 1
+	echo.
+	echo.The overview file is in %BUILDDIR%/changes.
+	goto end
+)
+
+if "%1" == "linkcheck" (
+	%SPHINXBUILD% -b linkcheck %ALLSPHINXOPTS% %BUILDDIR%/linkcheck
+	if errorlevel 1 exit /b 1
+	echo.
+	echo.Link check complete; look for any errors in the above output ^
+or in %BUILDDIR%/linkcheck/output.txt.
+	goto end
+)
+
+if "%1" == "doctest" (
+	%SPHINXBUILD% -b doctest %ALLSPHINXOPTS% %BUILDDIR%/doctest
+	if errorlevel 1 exit /b 1
+	echo.
+	echo.Testing of doctests in the sources finished, look at the ^
+results in %BUILDDIR%/doctest/output.txt.
+	goto end
+)
+
+:end
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/Makefile hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/Makefile
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/Makefile	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,153 @@
+# Makefile for Sphinx documentation
+#
+
+# You can set these variables from the command line.
+SPHINXOPTS    =
+SPHINXBUILD   = sphinx-build
+PAPER         =
+BUILDDIR      = _build
+
+# Internal variables.
+PAPEROPT_a4     = -D latex_paper_size=a4
+PAPEROPT_letter = -D latex_paper_size=letter
+ALLSPHINXOPTS   = -d $(BUILDDIR)/doctrees $(PAPEROPT_$(PAPER)) $(SPHINXOPTS) .
+# the i18n builder cannot share the environment and doctrees with the others
+I18NSPHINXOPTS  = $(PAPEROPT_$(PAPER)) $(SPHINXOPTS) .
+
+.PHONY: help clean html dirhtml singlehtml pickle json htmlhelp qthelp devhelp epub latex latexpdf text man changes linkcheck doctest gettext
+
+help:
+	@echo "Please use \`make <target>' where <target> is one of"
+	@echo "  html       to make standalone HTML files"
+	@echo "  dirhtml    to make HTML files named index.html in directories"
+	@echo "  singlehtml to make a single large HTML file"
+	@echo "  pickle     to make pickle files"
+	@echo "  json       to make JSON files"
+	@echo "  htmlhelp   to make HTML files and a HTML help project"
+	@echo "  qthelp     to make HTML files and a qthelp project"
+	@echo "  devhelp    to make HTML files and a Devhelp project"
+	@echo "  epub       to make an epub"
+	@echo "  latex      to make LaTeX files, you can set PAPER=a4 or PAPER=letter"
+	@echo "  latexpdf   to make LaTeX files and run them through pdflatex"
+	@echo "  text       to make text files"
+	@echo "  man        to make manual pages"
+	@echo "  texinfo    to make Texinfo files"
+	@echo "  info       to make Texinfo files and run them through makeinfo"
+	@echo "  gettext    to make PO message catalogs"
+	@echo "  changes    to make an overview of all changed/added/deprecated items"
+	@echo "  linkcheck  to check all external links for integrity"
+	@echo "  doctest    to run all doctests embedded in the documentation (if enabled)"
+
+clean:
+	-rm -rf $(BUILDDIR)/*
+
+html:
+	$(SPHINXBUILD) -b html $(ALLSPHINXOPTS) $(BUILDDIR)/html
+	@echo
+	@echo "Build finished. The HTML pages are in $(BUILDDIR)/html."
+
+dirhtml:
+	$(SPHINXBUILD) -b dirhtml $(ALLSPHINXOPTS) $(BUILDDIR)/dirhtml
+	@echo
+	@echo "Build finished. The HTML pages are in $(BUILDDIR)/dirhtml."
+
+singlehtml:
+	$(SPHINXBUILD) -b singlehtml $(ALLSPHINXOPTS) $(BUILDDIR)/singlehtml
+	@echo
+	@echo "Build finished. The HTML page is in $(BUILDDIR)/singlehtml."
+
+pickle:
+	$(SPHINXBUILD) -b pickle $(ALLSPHINXOPTS) $(BUILDDIR)/pickle
+	@echo
+	@echo "Build finished; now you can process the pickle files."
+
+json:
+	$(SPHINXBUILD) -b json $(ALLSPHINXOPTS) $(BUILDDIR)/json
+	@echo
+	@echo "Build finished; now you can process the JSON files."
+
+htmlhelp:
+	$(SPHINXBUILD) -b htmlhelp $(ALLSPHINXOPTS) $(BUILDDIR)/htmlhelp
+	@echo
+	@echo "Build finished; now you can run HTML Help Workshop with the" \
+	      ".hhp project file in $(BUILDDIR)/htmlhelp."
+
+qthelp:
+	$(SPHINXBUILD) -b qthelp $(ALLSPHINXOPTS) $(BUILDDIR)/qthelp
+	@echo
+	@echo "Build finished; now you can run "qcollectiongenerator" with the" \
+	      ".qhcp project file in $(BUILDDIR)/qthelp, like this:"
+	@echo "# qcollectiongenerator $(BUILDDIR)/qthelp/Cryptography.qhcp"
+	@echo "To view the help file:"
+	@echo "# assistant -collectionFile $(BUILDDIR)/qthelp/Cryptography.qhc"
+
+devhelp:
+	$(SPHINXBUILD) -b devhelp $(ALLSPHINXOPTS) $(BUILDDIR)/devhelp
+	@echo
+	@echo "Build finished."
+	@echo "To view the help file:"
+	@echo "# mkdir -p $$HOME/.local/share/devhelp/Cryptography"
+	@echo "# ln -s $(BUILDDIR)/devhelp $$HOME/.local/share/devhelp/Cryptography"
+	@echo "# devhelp"
+
+epub:
+	$(SPHINXBUILD) -b epub $(ALLSPHINXOPTS) $(BUILDDIR)/epub
+	@echo
+	@echo "Build finished. The epub file is in $(BUILDDIR)/epub."
+
+latex:
+	$(SPHINXBUILD) -b latex $(ALLSPHINXOPTS) $(BUILDDIR)/latex
+	@echo
+	@echo "Build finished; the LaTeX files are in $(BUILDDIR)/latex."
+	@echo "Run \`make' in that directory to run these through (pdf)latex" \
+	      "(use \`make latexpdf' here to do that automatically)."
+
+latexpdf:
+	$(SPHINXBUILD) -b latex $(ALLSPHINXOPTS) $(BUILDDIR)/latex
+	@echo "Running LaTeX files through pdflatex..."
+	$(MAKE) -C $(BUILDDIR)/latex all-pdf
+	@echo "pdflatex finished; the PDF files are in $(BUILDDIR)/latex."
+
+text:
+	$(SPHINXBUILD) -b text $(ALLSPHINXOPTS) $(BUILDDIR)/text
+	@echo
+	@echo "Build finished. The text files are in $(BUILDDIR)/text."
+
+man:
+	$(SPHINXBUILD) -b man $(ALLSPHINXOPTS) $(BUILDDIR)/man
+	@echo
+	@echo "Build finished. The manual pages are in $(BUILDDIR)/man."
+
+texinfo:
+	$(SPHINXBUILD) -b texinfo $(ALLSPHINXOPTS) $(BUILDDIR)/texinfo
+	@echo
+	@echo "Build finished. The Texinfo files are in $(BUILDDIR)/texinfo."
+	@echo "Run \`make' in that directory to run these through makeinfo" \
+	      "(use \`make info' here to do that automatically)."
+
+info:
+	$(SPHINXBUILD) -b texinfo $(ALLSPHINXOPTS) $(BUILDDIR)/texinfo
+	@echo "Running Texinfo files through makeinfo..."
+	make -C $(BUILDDIR)/texinfo info
+	@echo "makeinfo finished; the Info files are in $(BUILDDIR)/texinfo."
+
+gettext:
+	$(SPHINXBUILD) -b gettext $(I18NSPHINXOPTS) $(BUILDDIR)/locale
+	@echo
+	@echo "Build finished. The message catalogs are in $(BUILDDIR)/locale."
+
+changes:
+	$(SPHINXBUILD) -b changes $(ALLSPHINXOPTS) $(BUILDDIR)/changes
+	@echo
+	@echo "The overview file is in $(BUILDDIR)/changes."
+
+linkcheck:
+	$(SPHINXBUILD) -b linkcheck $(ALLSPHINXOPTS) $(BUILDDIR)/linkcheck
+	@echo
+	@echo "Link check complete; look for any errors in the above output " \
+	      "or in $(BUILDDIR)/linkcheck/output.txt."
+
+doctest:
+	$(SPHINXBUILD) -b doctest $(ALLSPHINXOPTS) $(BUILDDIR)/doctest
+	@echo "Testing of doctests in the sources finished, look at the " \
+	      "results in $(BUILDDIR)/doctest/output.txt."
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/random-numbers.rst hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/random-numbers.rst
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/random-numbers.rst	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/random-numbers.rst	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,32 @@
+Random number generation
+========================
+
+When generating random data for use in cryptographic operations, such as an
+initialization vector for encryption in
+:class:`~cryptography.hazmat.primitives.ciphers.modes.CBC` mode, you do not
+want to use the standard :mod:`random` module APIs. This is because they do not
+provide a cryptographically secure random number generator, which can result in
+major security issues depending on the algorithms in use.
+
+Therefore, it is our recommendation to `always use your operating system's
+provided random number generator`_, which is available as :func:`os.urandom`.
+For example, if you need 16 bytes of random data for an initialization vector,
+you can obtain them with:
+
+.. doctest::
+
+    >>> import os
+    >>> iv = os.urandom(16)
+
+This will use ``/dev/urandom`` on UNIX platforms, and ``CryptGenRandom`` on
+Windows.
+
+If you need your random number as an integer (for example, for
+:meth:`~cryptography.x509.CertificateBuilder.serial_number`), you can use
+``int.from_bytes`` to convert the result of ``os.urandom``:
+
+.. code-block:: pycon
+
+    >>> serial = int.from_bytes(os.urandom(20), byteorder="big")
+
+.. _`always use your operating system's provided random number generator`: http://sockpuppet.org/blog/2014/02/25/safely-generate-random-numbers/
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/security.rst hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/security.rst
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/security.rst	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/security.rst	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,82 @@
+Security
+========
+
+We take the security of ``cryptography`` seriously. The following are a set of
+policies we have adopted to ensure that security issues are addressed in a
+timely fashion.
+
+Reporting a security issue
+--------------------------
+
+We ask that you do not report security issues to our normal GitHub issue
+tracker.
+
+If you believe you've identified a security issue with ``cryptography``, please
+report it to ``alex.gaynor@gmail.com``. Messages may be optionally encrypted
+with PGP using key fingerprint
+``E27D 4AA0 1651 72CB C5D2  AF2B 125F 5C67 DFE9 4084`` (this public key is
+available from most commonly-used key servers).
+
+Once you've submitted an issue via email, you should receive an acknowledgment
+within 48 hours, and depending on the action to be taken, you may receive
+further follow-up emails.
+
+Supported Versions
+------------------
+
+At any given time, we will provide security support for the `master`_ branch
+as well as the 2 most recent releases.
+
+New releases for OpenSSL updates
+--------------------------------
+
+As of version 0.5, ``cryptography`` statically links OpenSSL on Windows, and as
+of version 1.0.1 on OS X, to ease installation. Due to this, ``cryptography``
+will release a new version whenever OpenSSL has a security or bug fix release to
+avoid shipping insecure software.
+
+Like all our other releases, this will be announced on the mailing list and we
+strongly recommend that you upgrade as soon as possible.
+
+Disclosure Process
+------------------
+
+Our process for taking a security issue from private discussion to public
+disclosure involves multiple steps.
+
+Approximately one week before full public disclosure, we will send advance
+notification of the issue to a list of people and organizations, primarily
+composed of operating-system vendors and other distributors of
+``cryptography``.  This notification will consist of an email message
+containing:
+
+* A full description of the issue and the affected versions of
+  ``cryptography``.
+* The steps we will be taking to remedy the issue.
+* The patches, if any, that will be applied to ``cryptography``.
+* The date on which the ``cryptography`` team will apply these patches, issue
+  new releases, and publicly disclose the issue.
+
+Simultaneously, the reporter of the issue will receive notification of the date
+on which we plan to take the issue public.
+
+On the day of disclosure, we will take the following steps:
+
+* Apply the relevant patches to the ``cryptography`` repository. The commit
+  messages for these patches will indicate that they are for security issues,
+  but will not describe the issue in any detail; instead, they will warn of
+  upcoming disclosure.
+* Issue the relevant releases.
+* Post a notice to the cryptography mailing list that describes the issue in
+  detail, point to the new release and crediting the reporter of the issue.
+
+If a reported issue is believed to be particularly time-sensitive â due to a
+known exploit in the wild, for example â the time between advance notification
+and public disclosure may be shortened considerably.
+
+The list of people and organizations who receives advanced notification of
+security issues is not and will not be made public. This list generally
+consists of high profile downstream distributors and is entirely at the
+discretion of the ``cryptography`` team.
+
+.. _`master`: https://github.com/pyca/cryptography
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/spelling_wordlist.txt hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/spelling_wordlist.txt
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/spelling_wordlist.txt	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/spelling_wordlist.txt	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,72 @@
+affine
+backend
+backends
+bcrypt
+Backends
+Blowfish
+boolean
+Botan
+Capitan
+Changelog
+ciphertext
+committer
+committers
+conda
+crypto
+cryptographic
+cryptographically
+Debian
+Diffie
+decrypt
+decrypted
+decrypting
+deserialize
+deserialized
+Diffie
+Docstrings
+Django
+Encodings
+fernet
+Fernet
+FIPS
+hazmat
+hostname
+indistinguishability
+initialisms
+interoperable
+introspectability
+invariants
+iOS
+iterable
+Koblitz
+Lange
+metadata
+multi
+naÃ¯ve
+namespace
+namespaces
+Nonces
+online
+paddings
+pickleable
+plaintext
+pre
+preprocessor
+preprocessors
+pseudorandom
+pyOpenSSL
+relicensed
+Schneier
+scrypt
+Serializers
+serializer
+Solaris
+Tanja
+testability
+Ubuntu
+unencrypted
+unpadded
+unpadding
+Verisign
+wildcard
+Xcode
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/x509/index.rst hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/x509/index.rst
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/x509/index.rst	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/x509/index.rst	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,15 @@
+X.509
+=====
+
+X.509 is an ITU-T standard for a `public key infrastructure`_. X.509v3 is
+defined in :rfc:`5280` (which obsoletes :rfc:`2459` and :rfc:`3280`). X.509
+certificates are commonly used in protocols like `TLS`_.
+
+.. toctree::
+    :maxdepth: 2
+
+    tutorial
+    reference
+
+.. _`public key infrastructure`: https://en.wikipedia.org/wiki/Public_key_infrastructure
+.. _`TLS`: https://en.wikipedia.org/wiki/Transport_Layer_Security
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/x509/reference.rst hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/x509/reference.rst
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/x509/reference.rst	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/x509/reference.rst	2015-11-19 05:01:40.000000000 +0100
@@ -0,0 +1,2077 @@
+X.509 Reference
+===============
+
+.. currentmodule:: cryptography.x509
+
+.. testsetup::
+
+    pem_crl_data = b"""
+    -----BEGIN X509 CRL-----
+    MIIBtDCBnQIBAjANBgkqhkiG9w0BAQsFADAnMQswCQYDVQQGEwJVUzEYMBYGA1UE
+    AwwPY3J5cHRvZ3JhcGh5LmlvGA8yMDE1MDEwMTAwMDAwMFoYDzIwMTYwMTAxMDAw
+    MDAwWjA+MDwCAQAYDzIwMTUwMTAxMDAwMDAwWjAmMBgGA1UdGAQRGA8yMDE1MDEw
+    MTAwMDAwMFowCgYDVR0VBAMKAQEwDQYJKoZIhvcNAQELBQADggEBABRA4ww50Lz5
+    zk1j2+aluC4HPHqb7o06h4pTDcCGeXUKXIGeP5ntGGmIoxa26sNoLeOr8+5b43Gf
+    yWraHertllOwaOpNFEe+YZFaE9femtoDbf+GLMvRx/0wDfd3KxPoXnXKMXb2d1w4
+    RCLgmkYx6JyvS+5ciuLQVIKC+l7jwIUeZFLJMUJ8msM4pFYoGameeZmtjMbd/TNg
+    cVBfmZxNMHuLladJxvSo2esARo0TYPhYsgrREKoHwhpzSxdynjn4bOVkILfguwsN
+    qtEEMZFEv5Kb0GqRp2+Iagv2S6dg9JGvxVdsoGjaB6EbYSZ3Psx4aODasIn11uwo
+    X4B9vUQNXqc=
+    -----END X509 CRL-----
+    """.strip()
+
+    pem_req_data = b"""
+    -----BEGIN CERTIFICATE REQUEST-----
+    MIIC0zCCAbsCAQAwWTELMAkGA1UEBhMCVVMxETAPBgNVBAgMCElsbGlub2lzMRAw
+    DgYDVQQHDAdDaGljYWdvMREwDwYDVQQKDAhyNTA5IExMQzESMBAGA1UEAwwJaGVs
+    bG8uY29tMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAqhZx+Mo9VRd9
+    vsnWWa6NBCws21rZ0+1B/JGgB4hDsZS7iDE4Bj5z4idheFRtl8bBbdjPknq7BfoF
+    8v15Zq/Zv7i2xMSDL+LUrTBZezRd4bRTGqCm6YJ5EYkhqdcqeZleHCFImguHoq1J
+    Fh0+kObQrTHXw3ZP57a3o1IvyIUA3nNoCBL0QQhwBXaDXOojMKNR+bqB5ve8GS1y
+    Elr0AM/+cJsfaIahNQUgFKx3Eu3GeEOMKYOAG1lycgdQdmTUybLrT3U7vkClTseM
+    xHg1r5En7ALjONIhqRuq3rddYahrP8HXozb3zUy3cJ7P6IeaosuvNzvMXOX9P6HD
+    Ha9urDAJ1wIDAQABoDUwMwYJKoZIhvcNAQkOMSYwJDAiBgNVHREEGzAZggl3b3Js
+    ZC5jb22CDHdoYXRldmVyLmNvbTANBgkqhkiG9w0BAQUFAAOCAQEAS4Ro6h+z52SK
+    YSLCYARpnEu/rmh4jdqndt8naqcNb6uLx9mlKZ2W9on9XDjnSdQD9q+ZP5aZfESw
+    R0+rJhW9ZrNa/g1pt6M24ihclHYDAxYMWxT1z/TXXGM3TmZZ6gfYlNE1kkBuODHa
+    UYsR/1Ht1E1EsmmUimt2n+zQR2K8T9Coa+boaUW/GsTEuz1aaJAkj5ZvTDiIhRG4
+    AOCqFZOLAQmCCNgJnnspD9hDz/Ons085LF5wnYjN4/Nsk5tS6AGs3xjZ3jPoOGGn
+    82WQ9m4dBGoVDZXsobVTaN592JEYwN5iu72zRn7Einb4V4H5y3yD2dD4yWPlt4pk
+    5wFkeYsZEA==
+    -----END CERTIFICATE REQUEST-----
+    """.strip()
+
+    pem_data = b"""
+    -----BEGIN CERTIFICATE-----
+    MIIDfDCCAmSgAwIBAgIBAjANBgkqhkiG9w0BAQsFADBFMQswCQYDVQQGEwJVUzEf
+    MB0GA1UEChMWVGVzdCBDZXJ0aWZpY2F0ZXMgMjAxMTEVMBMGA1UEAxMMVHJ1c3Qg
+    QW5jaG9yMB4XDTEwMDEwMTA4MzAwMFoXDTMwMTIzMTA4MzAwMFowQDELMAkGA1UE
+    BhMCVVMxHzAdBgNVBAoTFlRlc3QgQ2VydGlmaWNhdGVzIDIwMTExEDAOBgNVBAMT
+    B0dvb2QgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCQWJpHYo37
+    Xfb7oJSPe+WvfTlzIG21WQ7MyMbGtK/m8mejCzR6c+f/pJhEH/OcDSMsXq8h5kXa
+    BGqWK+vSwD/Pzp5OYGptXmGPcthDtAwlrafkGOS4GqIJ8+k9XGKs+vQUXJKsOk47
+    RuzD6PZupq4s16xaLVqYbUC26UcY08GpnoLNHJZS/EmXw1ZZ3d4YZjNlpIpWFNHn
+    UGmdiGKXUPX/9H0fVjIAaQwjnGAbpgyCumWgzIwPpX+ElFOUr3z7BoVnFKhIXze+
+    VmQGSWxZxvWDUN90Ul0tLEpLgk3OVxUB4VUGuf15OJOpgo1xibINPmWt14Vda2N9
+    yrNKloJGZNqLAgMBAAGjfDB6MB8GA1UdIwQYMBaAFOR9X9FclYYILAWuvnW2ZafZ
+    XahmMB0GA1UdDgQWBBRYAYQkG7wrUpRKPaUQchRR9a86yTAOBgNVHQ8BAf8EBAMC
+    AQYwFwYDVR0gBBAwDjAMBgpghkgBZQMCATABMA8GA1UdEwEB/wQFMAMBAf8wDQYJ
+    KoZIhvcNAQELBQADggEBADWHlxbmdTXNwBL/llwhQqwnazK7CC2WsXBBqgNPWj7m
+    tvQ+aLG8/50Qc2Sun7o2VnwF9D18UUe8Gj3uPUYH+oSI1vDdyKcjmMbKRU4rk0eo
+    3UHNDXwqIVc9CQS9smyV+x1HCwL4TTrq+LXLKx/qVij0Yqk+UJfAtrg2jnYKXsCu
+    FMBQQnWCGrwa1g1TphRp/RmYHnMynYFmZrXtzFz+U9XEA7C+gPq4kqDI/iVfIT1s
+    6lBtdB50lrDVwl2oYfAvW/6sC2se2QleZidUmrziVNP4oEeXINokU6T6p//HM1FG
+    QYw2jOvpKcKtWCSAnegEbgsGYzATKjmPJPJ0npHFqzM=
+    -----END CERTIFICATE-----
+    """.strip()
+
+    cryptography_cert_pem = b"""
+    -----BEGIN CERTIFICATE-----
+    MIIFvTCCBKWgAwIBAgICPyAwDQYJKoZIhvcNAQELBQAwRzELMAkGA1UEBhMCVVMx
+    FjAUBgNVBAoTDUdlb1RydXN0IEluYy4xIDAeBgNVBAMTF1JhcGlkU1NMIFNIQTI1
+    NiBDQSAtIEczMB4XDTE0MTAxNTEyMDkzMloXDTE4MTExNjAxMTUwM1owgZcxEzAR
+    BgNVBAsTCkdUNDg3NDI5NjUxMTAvBgNVBAsTKFNlZSB3d3cucmFwaWRzc2wuY29t
+    L3Jlc291cmNlcy9jcHMgKGMpMTQxLzAtBgNVBAsTJkRvbWFpbiBDb250cm9sIFZh
+    bGlkYXRlZCAtIFJhcGlkU1NMKFIpMRwwGgYDVQQDExN3d3cuY3J5cHRvZ3JhcGh5
+    LmlvMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAom/FebKJIot7Sp3s
+    itG1sicpe3thCssjI+g1JDAS7I3GLVNmbms1DOdIIqwf01gZkzzXBN2+9sOnyRaR
+    PPfCe1jTr3dk2y6rPE559vPa1nZQkhlzlhMhlPyjaT+S7g4Tio4qV2sCBZU01DZJ
+    CaksfohN+5BNVWoJzTbOcrHOEJ+M8B484KlBCiSxqf9cyNQKru4W3bHaCVNVJ8eu
+    6i6KyhzLa0L7yK3LXwwXVs583C0/vwFhccGWsFODqD/9xHUzsBIshE8HKjdjDi7Y
+    3BFQzVUQFjBB50NSZfAA/jcdt1blxJouc7z9T8Oklh+V5DDBowgAsrT4b6Z2Fq6/
+    r7D1GqivLK/ypUQmxq2WXWAUBb/Q6xHgxASxI4Br+CByIUQJsm8L2jzc7k+mF4hW
+    ltAIUkbo8fGiVnat0505YJgxWEDKOLc4Gda6d/7GVd5AvKrz242bUqeaWo6e4MTx
+    diku2Ma3rhdcr044Qvfh9hGyjqNjvhWY/I+VRWgihU7JrYvgwFdJqsQ5eiKT4OHi
+    gsejvWwkZzDtiQ+aQTrzM1FsY2swJBJsLSX4ofohlVRlIJCn/ME+XErj553431Lu
+    YQ5SzMd3nXzN78Vj6qzTfMUUY72UoT1/AcFiUMobgIqrrmwuNxfrkbVE2b6Bga74
+    FsJX63prvrJ41kuHK/16RQBM7fcCAwEAAaOCAWAwggFcMB8GA1UdIwQYMBaAFMOc
+    8/zTRgg0u85Gf6B8W/PiCMtZMFcGCCsGAQUFBwEBBEswSTAfBggrBgEFBQcwAYYT
+    aHR0cDovL2d2LnN5bWNkLmNvbTAmBggrBgEFBQcwAoYaaHR0cDovL2d2LnN5bWNi
+    LmNvbS9ndi5jcnQwDgYDVR0PAQH/BAQDAgWgMB0GA1UdJQQWMBQGCCsGAQUFBwMB
+    BggrBgEFBQcDAjAvBgNVHREEKDAmghN3d3cuY3J5cHRvZ3JhcGh5Lmlvgg9jcnlw
+    dG9ncmFwaHkuaW8wKwYDVR0fBCQwIjAgoB6gHIYaaHR0cDovL2d2LnN5bWNiLmNv
+    bS9ndi5jcmwwDAYDVR0TAQH/BAIwADBFBgNVHSAEPjA8MDoGCmCGSAGG+EUBBzYw
+    LDAqBggrBgEFBQcCARYeaHR0cHM6Ly93d3cucmFwaWRzc2wuY29tL2xlZ2FsMA0G
+    CSqGSIb3DQEBCwUAA4IBAQAzIYO2jx7h17FBT74tJ2zbV9OKqGb7QF8y3wUtP4xc
+    dH80vprI/Cfji8s86kr77aAvAqjDjaVjHn7UzebhSUivvRPmfzRgyWBacomnXTSt
+    Xlt2dp2nDQuwGyK2vB7dMfKnQAkxwq1sYUXznB8i0IhhCAoXp01QGPKq51YoIlnF
+    7DRMk6iEaL1SJbkIrLsCQyZFDf0xtfW9DqXugMMLoxeCsBhZJQzNyS2ryirrv9LH
+    aK3+6IZjrcyy9bkpz/gzJucyhU+75c4My/mnRCrtItRbCQuiI5pd5poDowm+HH9i
+    GVI9+0lAFwxOUnOnwsoI40iOoxjLMGB+CgFLKCGUcWxP
+    -----END CERTIFICATE-----
+    """.strip()
+
+Loading Certificates
+~~~~~~~~~~~~~~~~~~~~
+
+.. function:: load_pem_x509_certificate(data, backend)
+
+    .. versionadded:: 0.7
+
+    Deserialize a certificate from PEM encoded data. PEM certificates are
+    base64 decoded and have delimiters that look like
+    ``-----BEGIN CERTIFICATE-----``.
+
+    :param bytes data: The PEM encoded certificate data.
+
+    :param backend: A backend supporting the
+        :class:`~cryptography.hazmat.backends.interfaces.X509Backend`
+        interface.
+
+    :returns: An instance of :class:`~cryptography.x509.Certificate`.
+
+.. function:: load_der_x509_certificate(data, backend)
+
+    .. versionadded:: 0.7
+
+    Deserialize a certificate from DER encoded data. DER is a binary format
+    and is commonly found in files with the ``.cer`` extension (although file
+    extensions are not a guarantee of encoding type).
+
+    :param bytes data: The DER encoded certificate data.
+
+    :param backend: A backend supporting the
+        :class:`~cryptography.hazmat.backends.interfaces.X509Backend`
+        interface.
+
+    :returns: An instance of :class:`~cryptography.x509.Certificate`.
+
+.. doctest::
+
+    >>> from cryptography import x509
+    >>> from cryptography.hazmat.backends import default_backend
+    >>> cert = x509.load_pem_x509_certificate(pem_data, default_backend())
+    >>> cert.serial
+    2
+
+Loading Certificate Revocation Lists
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+.. function:: load_pem_x509_crl(data, backend)
+
+    .. versionadded:: 1.1
+
+    Deserialize a certificate revocation list (CRL) from PEM encoded data. PEM
+    requests are base64 decoded and have delimiters that look like
+    ``-----BEGIN X509 CRL-----``.
+
+    :param bytes data: The PEM encoded request data.
+
+    :param backend: A backend supporting the
+        :class:`~cryptography.hazmat.backends.interfaces.X509Backend`
+        interface.
+
+    :returns: An instance of
+        :class:`~cryptography.x509.CertificateRevocationList`.
+
+.. function:: load_der_x509_crl(data, backend)
+
+    .. versionadded:: 1.1
+
+    Deserialize a certificate revocation list (CRL) from DER encoded data. DER
+    is a binary format.
+
+    :param bytes data: The DER encoded request data.
+
+    :param backend: A backend supporting the
+        :class:`~cryptography.hazmat.backends.interfaces.X509Backend`
+        interface.
+
+    :returns: An instance of
+        :class:`~cryptography.x509.CertificateRevocationList`.
+
+.. doctest::
+
+    >>> from cryptography import x509
+    >>> from cryptography.hazmat.backends import default_backend
+    >>> from cryptography.hazmat.primitives import hashes
+    >>> crl = x509.load_pem_x509_crl(pem_crl_data, default_backend())
+    >>> isinstance(crl.signature_hash_algorithm, hashes.SHA256)
+    True
+
+Loading Certificate Signing Requests
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+.. function:: load_pem_x509_csr(data, backend)
+
+    .. versionadded:: 0.9
+
+    Deserialize a certificate signing request (CSR) from PEM encoded data. PEM
+    requests are base64 decoded and have delimiters that look like
+    ``-----BEGIN CERTIFICATE REQUEST-----``. This format is also known as
+    PKCS#10.
+
+    :param bytes data: The PEM encoded request data.
+
+    :param backend: A backend supporting the
+        :class:`~cryptography.hazmat.backends.interfaces.X509Backend`
+        interface.
+
+    :returns: An instance of
+        :class:`~cryptography.x509.CertificateSigningRequest`.
+
+.. function:: load_der_x509_csr(data, backend)
+
+    .. versionadded:: 0.9
+
+    Deserialize a certificate signing request (CSR) from DER encoded data. DER
+    is a binary format and is not commonly used with CSRs.
+
+    :param bytes data: The DER encoded request data.
+
+    :param backend: A backend supporting the
+        :class:`~cryptography.hazmat.backends.interfaces.X509Backend`
+        interface.
+
+    :returns: An instance of
+        :class:`~cryptography.x509.CertificateSigningRequest`.
+
+.. doctest::
+
+    >>> from cryptography import x509
+    >>> from cryptography.hazmat.backends import default_backend
+    >>> from cryptography.hazmat.primitives import hashes
+    >>> csr = x509.load_pem_x509_csr(pem_req_data, default_backend())
+    >>> isinstance(csr.signature_hash_algorithm, hashes.SHA1)
+    True
+
+X.509 Certificate Object
+~~~~~~~~~~~~~~~~~~~~~~~~
+
+.. class:: Certificate
+
+    .. versionadded:: 0.7
+
+    .. attribute:: version
+
+        :type: :class:`~cryptography.x509.Version`
+
+        The certificate version as an enumeration. Version 3 certificates are
+        the latest version and also the only type you should see in practice.
+
+        :raises cryptography.x509.InvalidVersion: If the version in the
+            certificate is not a known
+            :class:`X.509 version <cryptography.x509.Version>`.
+
+        .. doctest::
+
+            >>> cert.version
+            <Version.v3: 2>
+
+    .. method:: fingerprint(algorithm)
+
+        :param algorithm: The
+            :class:`~cryptography.hazmat.primitives.hashes.HashAlgorithm`
+            that will be used to generate the fingerprint.
+
+        :return bytes: The fingerprint using the supplied hash algorithm, as
+            bytes.
+
+        .. doctest::
+
+            >>> from cryptography.hazmat.primitives import hashes
+            >>> cert.fingerprint(hashes.SHA256())
+            '\x86\xd2\x187Gc\xfc\xe7}[+E9\x8d\xb4\x8f\x10\xe5S\xda\x18u\xbe}a\x03\x08[\xac\xa04?'
+
+    .. attribute:: serial
+
+        :type: int
+
+        The serial as a Python integer.
+
+        .. doctest::
+
+            >>> cert.serial
+            2
+
+    .. method:: public_key()
+
+        The public key associated with the certificate.
+
+        :returns:
+            :class:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPublicKey` or
+            :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPublicKey` or
+            :class:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePublicKey`
+
+        .. doctest::
+
+            >>> from cryptography.hazmat.primitives.asymmetric import rsa
+            >>> public_key = cert.public_key()
+            >>> isinstance(public_key, rsa.RSAPublicKey)
+            True
+
+    .. attribute:: not_valid_before
+
+        :type: :class:`datetime.datetime`
+
+        A naÃ¯ve datetime representing the beginning of the validity period for
+        the certificate in UTC. This value is inclusive.
+
+        .. doctest::
+
+            >>> cert.not_valid_before
+            datetime.datetime(2010, 1, 1, 8, 30)
+
+    .. attribute:: not_valid_after
+
+        :type: :class:`datetime.datetime`
+
+        A naÃ¯ve datetime representing the end of the validity period for the
+        certificate in UTC. This value is inclusive.
+
+        .. doctest::
+
+            >>> cert.not_valid_after
+            datetime.datetime(2030, 12, 31, 8, 30)
+
+    .. attribute:: issuer
+
+        .. versionadded:: 0.8
+
+        :type: :class:`Name`
+
+        The :class:`Name` of the issuer.
+
+    .. attribute:: subject
+
+        .. versionadded:: 0.8
+
+        :type: :class:`Name`
+
+        The :class:`Name` of the subject.
+
+    .. attribute:: signature_hash_algorithm
+
+        :type: :class:`~cryptography.hazmat.primitives.hashes.HashAlgorithm`
+
+        Returns the
+        :class:`~cryptography.hazmat.primitives.hashes.HashAlgorithm` which
+        was used in signing this certificate.
+
+        .. doctest::
+
+            >>> from cryptography.hazmat.primitives import hashes
+            >>> isinstance(cert.signature_hash_algorithm, hashes.SHA256)
+            True
+
+    .. attribute:: extensions
+
+        :type: :class:`Extensions`
+
+        The extensions encoded in the certificate.
+
+        :raises cryptography.x509.DuplicateExtension: If more than one
+            extension of the same type is found within the certificate.
+
+        :raises cryptography.x509.UnsupportedExtension: If the certificate
+            contains an extension that is not supported.
+
+        :raises cryptography.x509.UnsupportedGeneralNameType: If an extension
+            contains a general name that is not supported.
+
+        :raises UnicodeError: If an extension contains IDNA encoding that is
+            invalid or not compliant with IDNA 2008.
+
+        .. doctest::
+
+            >>> for ext in cert.extensions:
+            ...     print(ext)
+            <Extension(oid=<ObjectIdentifier(oid=2.5.29.35, name=authorityKeyIdentifier)>, critical=False, value=<AuthorityKeyIdentifier(key_identifier='\xe4}_\xd1\\\x95\x86\x08,\x05\xae\xbeu\xb6e\xa7\xd9]\xa8f', authority_cert_issuer=None, authority_cert_serial_number=None)>)>
+            <Extension(oid=<ObjectIdentifier(oid=2.5.29.14, name=subjectKeyIdentifier)>, critical=False, value=<SubjectKeyIdentifier(digest='X\x01\x84$\x1b\xbc+R\x94J=\xa5\x10r\x14Q\xf5\xaf:\xc9')>)>
+            <Extension(oid=<ObjectIdentifier(oid=2.5.29.15, name=keyUsage)>, critical=True, value=<KeyUsage(digital_signature=False, content_commitment=False, key_encipherment=False, data_encipherment=False, key_agreement=False, key_cert_sign=True, crl_sign=True, encipher_only=None, decipher_only=None)>)>
+            <Extension(oid=<ObjectIdentifier(oid=2.5.29.32, name=certificatePolicies)>, critical=False, value=<CertificatePolicies([<PolicyInformation(policy_identifier=<ObjectIdentifier(oid=2.16.840.1.101.3.2.1.48.1, name=Unknown OID)>, policy_qualifiers=None)>])>)>
+            <Extension(oid=<ObjectIdentifier(oid=2.5.29.19, name=basicConstraints)>, critical=True, value=<BasicConstraints(ca=True, path_length=None)>)>
+
+    .. method:: public_bytes(encoding)
+
+        .. versionadded:: 1.0
+
+        :param encoding: The
+            :class:`~cryptography.hazmat.primitives.serialization.Encoding`
+            that will be used to serialize the certificate.
+
+        :return bytes: The data that can be written to a file or sent
+            over the network to be verified by clients.
+
+X.509 CRL (Certificate Revocation List) Object
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+.. class:: CertificateRevocationList
+
+    .. versionadded:: 1.0
+
+    A CertificateRevocationList is an object representing a list of revoked
+    certificates. The object is iterable and will yield the RevokedCertificate
+    objects stored in this CRL.
+
+    .. doctest::
+
+            >>> len(crl)
+            1
+            >>> revoked_certificate = crl[0]
+            >>> type(revoked_certificate)
+            <class 'cryptography.hazmat.backends.openssl.x509._RevokedCertificate'>
+            >>> for r in crl:
+            ...     print(r.serial_number)
+            0
+
+    .. method:: fingerprint(algorithm)
+
+        :param algorithm: The
+            :class:`~cryptography.hazmat.primitives.hashes.HashAlgorithm`
+            that will be used to generate the fingerprint.
+
+        :return bytes: The fingerprint using the supplied hash algorithm, as
+            bytes.
+
+        .. doctest::
+
+            >>> from cryptography.hazmat.primitives import hashes
+            >>> crl.fingerprint(hashes.SHA256())
+            'e\xcf.\xc4:\x83?1\xdc\xf3\xfc\x95\xd7\xb3\x87\xb3\x8e\xf8\xb93!\x87\x07\x9d\x1b\xb4!\xb9\xe4W\xf4\x1f'
+
+    .. attribute:: signature_hash_algorithm
+
+        :type: :class:`~cryptography.hazmat.primitives.hashes.HashAlgorithm`
+
+        Returns the
+        :class:`~cryptography.hazmat.primitives.hashes.HashAlgorithm` which
+        was used in signing this CRL.
+
+        .. doctest::
+
+            >>> from cryptography.hazmat.primitives import hashes
+            >>> isinstance(crl.signature_hash_algorithm, hashes.SHA256)
+            True
+
+    .. attribute:: issuer
+
+        :type: :class:`Name`
+
+        The :class:`Name` of the issuer.
+
+        .. doctest::
+
+            >>> crl.issuer
+            <Name([<NameAttribute(oid=<ObjectIdentifier(oid=2.5.4.6, name=countryName)>, value=u'US')>, <NameAttribute(oid=<ObjectIdentifier(oid=2.5.4.3, name=commonName)>, value=u'cryptography.io')>])>
+
+    .. attribute:: next_update
+
+        :type: :class:`datetime.datetime`
+
+        A naÃ¯ve datetime representing when the next update to this CRL is
+        expected.
+
+        .. doctest::
+
+            >>> crl.next_update
+            datetime.datetime(2016, 1, 1, 0, 0)
+
+    .. attribute:: last_update
+
+        :type: :class:`datetime.datetime`
+
+        A naÃ¯ve datetime representing when the this CRL was last updated.
+
+        .. doctest::
+
+            >>> crl.last_update
+            datetime.datetime(2015, 1, 1, 0, 0)
+
+    .. attribute:: extensions
+
+        :type: :class:`Extensions`
+
+        The extensions encoded in the CRL.
+
+X.509 Certificate Builder
+~~~~~~~~~~~~~~~~~~~~~~~~~
+
+.. class:: CertificateBuilder
+
+    .. versionadded:: 1.0
+
+    .. doctest::
+
+        >>> from cryptography import x509
+        >>> from cryptography.hazmat.backends import default_backend
+        >>> from cryptography.hazmat.primitives import hashes
+        >>> from cryptography.hazmat.primitives.asymmetric import rsa
+        >>> from cryptography.x509.oid import NameOID
+        >>> import datetime
+        >>> import uuid
+        >>> one_day = datetime.timedelta(1, 0, 0)
+        >>> private_key = rsa.generate_private_key(
+        ...     public_exponent=65537,
+        ...     key_size=2048,
+        ...     backend=default_backend()
+        ... )
+        >>> public_key = rsa.generate_private_key(
+        ...     public_exponent=65537,
+        ...     key_size=2048,
+        ...     backend=default_backend()
+        ... ).public_key()
+        >>> builder = x509.CertificateBuilder()
+        >>> builder = builder.subject_name(x509.Name([
+        ...     x509.NameAttribute(NameOID.COMMON_NAME, u'cryptography.io'),
+        ... ]))
+        >>> builder = builder.issuer_name(x509.Name([
+        ...     x509.NameAttribute(NameOID.COMMON_NAME, u'cryptography.io'),
+        ... ]))
+        >>> builder = builder.not_valid_before(datetime.datetime.today() - one_day)
+        >>> builder = builder.not_valid_after(datetime.datetime(2018, 8, 2))
+        >>> builder = builder.serial_number(int(uuid.uuid4()))
+        >>> builder = builder.public_key(public_key)
+        >>> builder = builder.add_extension(
+        ...     x509.BasicConstraints(ca=False, path_length=None), critical=True,
+        ... )
+        >>> certificate = builder.sign(
+        ...     private_key=private_key, algorithm=hashes.SHA256(),
+        ...     backend=default_backend()
+        ... )
+        >>> isinstance(certificate, x509.Certificate)
+        True
+
+    .. method:: issuer_name(name)
+
+        Sets the issuer's distinguished name.
+
+        :param name: The :class:`~cryptography.x509.Name` that describes the
+            issuer (CA).
+
+    .. method:: subject_name(name)
+
+        Sets the subject's distinguished name.
+
+        :param name: The :class:`~cryptography.x509.Name` that describes the
+            subject.
+
+    .. method:: public_key(public_key)
+
+        Sets the subject's public key.
+
+        :param public_key: The subject's public key. This can be one of
+            :class:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPublicKey`,
+            :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPublicKey` or
+            :class:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePublicKey`
+
+    .. method:: serial_number(serial_number)
+
+        Sets the certificate's serial number (an integer).  The CA's policy
+        determines how it attributes serial numbers to certificates.  The only
+        requirement is that this number uniquely identify the certificate given
+        the issuer.
+
+        :param serial_number: Integer number that will be used by the CA to
+            identify this certificate (most notably during certificate
+            revocation checking). Users are encouraged to use a method of
+            generating 20 bytes of entropy, e.g., UUID4. For more information
+            on secure random number generation, see :doc:`/random-numbers`.
+
+    .. method:: not_valid_before(time)
+
+        Sets the certificate's activation time.  This is the time from which
+        clients can start trusting the certificate.  It may be different from
+        the time at which the certificate was created.
+
+        :param time: The :class:`datetime.datetime` object (in UTC) that marks the
+            activation time for the certificate.  The certificate may not be
+            trusted clients if it is used before this time.
+
+    .. method:: not_valid_after(time)
+
+        Sets the certificate's expiration time.  This is the time from which
+        clients should no longer trust the certificate.  The CA's policy will
+        determine how long the certificate should remain in use.
+
+        :param time: The :class:`datetime.datetime` object (in UTC) that marks the
+            expiration time for the certificate.  The certificate may not be
+            trusted clients if it is used after this time.
+
+    .. method:: add_extension(extension, critical)
+
+        Adds an X.509 extension to the certificate.
+
+        :param extension: An extension conforming to the
+            :class:`~cryptography.x509.ExtensionType` interface.
+
+        :param critical: Set to ``True`` if the extension must be understood and
+             handled by whoever reads the certificate.
+
+    .. method:: sign(private_key, algorithm, backend)
+
+        Sign the certificate using the CA's private key.
+
+        :param private_key: The
+            :class:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPrivateKey`,
+            :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPrivateKey` or
+            :class:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePrivateKey`
+            that will be used to sign the certificate.
+
+        :param algorithm: The
+            :class:`~cryptography.hazmat.primitives.hashes.HashAlgorithm` that
+            will be used to generate the signature.
+
+        :param backend: Backend that will be used to build the certificate.
+            Must support the
+            :class:`~cryptography.hazmat.backends.interfaces.X509Backend`
+            interface.
+
+        :returns: :class:`~cryptography.x509.Certificate`
+
+
+X.509 CSR (Certificate Signing Request) Object
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+.. class:: CertificateSigningRequest
+
+    .. versionadded:: 0.9
+
+    .. method:: public_key()
+
+        The public key associated with the request.
+
+        :returns:
+            :class:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPublicKey` or
+            :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPublicKey` or
+            :class:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePublicKey`
+
+        .. doctest::
+
+            >>> from cryptography.hazmat.primitives.asymmetric import rsa
+            >>> public_key = csr.public_key()
+            >>> isinstance(public_key, rsa.RSAPublicKey)
+            True
+
+    .. attribute:: subject
+
+        :type: :class:`Name`
+
+        The :class:`Name` of the subject.
+
+    .. attribute:: signature_hash_algorithm
+
+        :type: :class:`~cryptography.hazmat.primitives.hashes.HashAlgorithm`
+
+        Returns the
+        :class:`~cryptography.hazmat.primitives.hashes.HashAlgorithm` which
+        was used in signing this request.
+
+        .. doctest::
+
+            >>> from cryptography.hazmat.primitives import hashes
+            >>> isinstance(csr.signature_hash_algorithm, hashes.SHA1)
+            True
+
+    .. attribute:: extensions
+
+        :type: :class:`Extensions`
+
+        The extensions encoded in the certificate signing request.
+
+        :raises cryptography.x509.DuplicateExtension: If more than one
+            extension of the same type is found within the certificate signing request.
+
+        :raises cryptography.x509.UnsupportedExtension: If the certificate signing request
+            contains an extension that is not supported.
+
+        :raises cryptography.x509.UnsupportedGeneralNameType: If an extension
+            contains a general name that is not supported.
+
+        :raises UnicodeError: If an extension contains IDNA encoding that is
+            invalid or not compliant with IDNA 2008.
+
+
+    .. method:: public_bytes(encoding)
+
+        .. versionadded:: 1.0
+
+        :param encoding: The
+            :class:`~cryptography.hazmat.primitives.serialization.Encoding`
+            that will be used to serialize the certificate request.
+
+        :return bytes: The data that can be written to a file or sent
+            over the network to be signed by the certificate
+            authority.
+
+X.509 Revoked Certificate Object
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+.. class:: RevokedCertificate
+
+    .. versionadded:: 1.0
+
+    .. attribute:: serial_number
+
+        :type: :class:`int`
+
+        An integer representing the serial number of the revoked certificate.
+
+        .. doctest::
+
+            >>> revoked_certificate.serial_number
+            0
+
+    .. attribute:: revocation_date
+
+        :type: :class:`datetime.datetime`
+
+        A naÃ¯ve datetime representing the date this certificates was revoked.
+
+        .. doctest::
+
+            >>> revoked_certificate.revocation_date
+            datetime.datetime(2015, 1, 1, 0, 0)
+
+    .. attribute:: extensions
+
+        :type: :class:`Extensions`
+
+        The extensions encoded in the revoked certificate.
+
+        .. doctest::
+
+            >>> for ext in revoked_certificate.extensions:
+            ...     print(ext)
+            <Extension(oid=<ObjectIdentifier(oid=2.5.29.24, name=invalidityDate)>, critical=False, value=2015-01-01 00:00:00)>
+            <Extension(oid=<ObjectIdentifier(oid=2.5.29.21, name=cRLReason)>, critical=False, value=ReasonFlags.key_compromise)>
+
+X.509 CSR (Certificate Signing Request) Builder Object
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+.. class:: CertificateSigningRequestBuilder
+
+    .. versionadded:: 1.0
+
+    .. doctest::
+
+        >>> from cryptography import x509
+        >>> from cryptography.hazmat.backends import default_backend
+        >>> from cryptography.hazmat.primitives import hashes
+        >>> from cryptography.hazmat.primitives.asymmetric import rsa
+        >>> from cryptography.x509.oid import NameOID
+        >>> private_key = rsa.generate_private_key(
+        ...     public_exponent=65537,
+        ...     key_size=2048,
+        ...     backend=default_backend()
+        ... )
+        >>> builder = x509.CertificateSigningRequestBuilder()
+        >>> builder = builder.subject_name(x509.Name([
+        ...     x509.NameAttribute(NameOID.COMMON_NAME, u'cryptography.io'),
+        ... ]))
+        >>> builder = builder.add_extension(
+        ...     x509.BasicConstraints(ca=False, path_length=None), critical=True,
+        ... )
+        >>> request = builder.sign(
+        ...     private_key, hashes.SHA256(), default_backend()
+        ... )
+        >>> isinstance(request, x509.CertificateSigningRequest)
+        True
+
+    .. method:: subject_name(name)
+
+        :param name: The :class:`~cryptography.x509.Name` of the certificate
+            subject.
+        :returns: A new
+            :class:`~cryptography.x509.CertificateSigningRequestBuilder`.
+
+    .. method:: add_extension(extension, critical)
+
+        :param extension: An extension conforming to the
+            :class:`~cryptography.x509.ExtensionType` interface.
+        :param critical: Set to `True` if the extension must be understood and
+             handled by whoever reads the certificate.
+        :returns: A new
+            :class:`~cryptography.x509.CertificateSigningRequestBuilder`.
+
+    .. method:: sign(private_key, algorithm, backend)
+
+        :param backend: Backend that will be used to sign the request.
+            Must support the
+            :class:`~cryptography.hazmat.backends.interfaces.X509Backend`
+            interface.
+
+        :param private_key: The
+            :class:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPrivateKey`,
+            :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPrivateKey` or
+            :class:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePrivateKey`
+            that will be used to sign the request.  When the request is
+            signed by a certificate authority, the private key's associated
+            public key will be stored in the resulting certificate.
+
+        :param algorithm: The
+            :class:`~cryptography.hazmat.primitives.hashes.HashAlgorithm`
+            that will be used to generate the request signature.
+
+        :returns: A new
+            :class:`~cryptography.x509.CertificateSigningRequest`.
+
+
+.. class:: Name
+
+    .. versionadded:: 0.8
+
+    An X509 Name is an ordered list of attributes. The object is iterable to
+    get every attribute or you can use :meth:`Name.get_attributes_for_oid` to
+    obtain the specific type you want. Names are sometimes represented as a
+    slash or comma delimited string (e.g. ``/CN=mydomain.com/O=My Org/C=US`` or
+    ``CN=mydomain.com, O=My Org, C=US``).
+
+    .. doctest::
+
+        >>> len(cert.subject)
+        3
+        >>> for attribute in cert.subject:
+        ...     print(attribute)
+        <NameAttribute(oid=<ObjectIdentifier(oid=2.5.4.6, name=countryName)>, value=u'US')>
+        <NameAttribute(oid=<ObjectIdentifier(oid=2.5.4.10, name=organizationName)>, value=u'Test Certificates 2011')>
+        <NameAttribute(oid=<ObjectIdentifier(oid=2.5.4.3, name=commonName)>, value=u'Good CA')>
+
+    .. method:: get_attributes_for_oid(oid)
+
+        :param oid: An :class:`ObjectIdentifier` instance.
+
+        :returns: A list of :class:`NameAttribute` instances that match the
+            OID provided. If nothing matches an empty list will be returned.
+
+        .. doctest::
+
+            >>> cert.subject.get_attributes_for_oid(NameOID.COMMON_NAME)
+            [<NameAttribute(oid=<ObjectIdentifier(oid=2.5.4.3, name=commonName)>, value=u'Good CA')>]
+
+.. class:: Version
+
+    .. versionadded:: 0.7
+
+    An enumeration for X.509 versions.
+
+    .. attribute:: v1
+
+        For version 1 X.509 certificates.
+
+    .. attribute:: v3
+
+        For version 3 X.509 certificates.
+
+.. class:: NameAttribute
+
+    .. versionadded:: 0.8
+
+    An X.509 name consists of a list of NameAttribute instances.
+
+    .. attribute:: oid
+
+        :type: :class:`ObjectIdentifier`
+
+        The attribute OID.
+
+    .. attribute:: value
+
+        :type: :term:`text`
+
+        The value of the attribute.
+
+.. class:: ObjectIdentifier
+
+    .. versionadded:: 0.8
+
+    Object identifiers (frequently seen abbreviated as OID) identify the type
+    of a value (see: :class:`NameAttribute`).
+
+    .. attribute:: dotted_string
+
+        :type: :class:`str`
+
+        The dotted string value of the OID (e.g. ``"2.5.4.3"``)
+
+.. _general_name_classes:
+
+General Name Classes
+~~~~~~~~~~~~~~~~~~~~
+
+.. class:: GeneralName
+
+    .. versionadded:: 0.9
+
+    This is the generic interface that all the following classes are registered
+    against.
+
+.. class:: RFC822Name(value)
+
+    .. versionadded:: 0.9
+
+    This corresponds to an email address. For example, ``user@example.com``.
+
+    .. attribute:: value
+
+        :type: :term:`text`
+
+.. class:: DNSName(value)
+
+    .. versionadded:: 0.9
+
+    This corresponds to a domain name. For example, ``cryptography.io``.
+
+    .. attribute:: value
+
+        :type: :term:`text`
+
+.. class:: DirectoryName(value)
+
+    .. versionadded:: 0.9
+
+    This corresponds to a directory name.
+
+    .. attribute:: value
+
+        :type: :class:`Name`
+
+.. class:: UniformResourceIdentifier(value)
+
+    .. versionadded:: 0.9
+
+    This corresponds to a uniform resource identifier.  For example,
+    ``https://cryptography.io``. The URI is parsed and IDNA decoded (see
+    :rfc:`5895`).
+
+    .. note::
+
+        URIs that do not contain ``://`` in them will not be decoded.
+
+    .. attribute:: value
+
+        :type: :term:`text`
+
+.. class:: IPAddress(value)
+
+    .. versionadded:: 0.9
+
+    This corresponds to an IP address.
+
+    .. attribute:: value
+
+        :type: :class:`~ipaddress.IPv4Address`,
+            :class:`~ipaddress.IPv6Address`,  :class:`~ipaddress.IPv4Network`,
+            or :class:`~ipaddress.IPv6Network`.
+
+.. class:: RegisteredID(value)
+
+    .. versionadded:: 0.9
+
+    This corresponds to a registered ID.
+
+    .. attribute:: value
+
+        :type: :class:`ObjectIdentifier`
+
+.. class:: OtherName(type_id, value)
+
+    .. versionadded:: 1.0
+
+    This corresponds to an ``otherName.``  An ``otherName`` has a type identifier and a value represented in binary DER format.
+
+    .. attribute:: type_id
+
+        :type: :class:`ObjectIdentifier`
+
+    .. attribute:: value
+
+        :type: `bytes`
+
+X.509 Extensions
+~~~~~~~~~~~~~~~~
+
+.. class:: Extensions
+
+    .. versionadded:: 0.9
+
+    An X.509 Extensions instance is an ordered list of extensions.  The object
+    is iterable to get every extension.
+
+    .. method:: get_extension_for_oid(oid)
+
+        :param oid: An :class:`ObjectIdentifier` instance.
+
+        :returns: An instance of the extension class.
+
+        :raises cryptography.x509.ExtensionNotFound: If the certificate does
+            not have the extension requested.
+
+        .. doctest::
+
+            >>> from cryptography.x509.oid import ExtensionOID
+            >>> cert.extensions.get_extension_for_oid(ExtensionOID.BASIC_CONSTRAINTS)
+            <Extension(oid=<ObjectIdentifier(oid=2.5.29.19, name=basicConstraints)>, critical=True, value=<BasicConstraints(ca=True, path_length=None)>)>
+
+    .. method:: get_extension_for_class(extclass)
+
+        .. versionadded:: 1.1
+
+        :param extclass: An extension class.
+
+        :returns: An instance of the extension class.
+
+        :raises cryptography.x509.ExtensionNotFound: If the certificate does
+            not have the extension requested.
+
+        .. doctest::
+
+            >>> from cryptography import x509
+            >>> cert.extensions.get_extension_for_class(x509.BasicConstraints)
+            <Extension(oid=<ObjectIdentifier(oid=2.5.29.19, name=basicConstraints)>, critical=True, value=<BasicConstraints(ca=True, path_length=None)>)>
+
+.. class:: Extension
+
+    .. versionadded:: 0.9
+
+    .. attribute:: oid
+
+        :type: :class:`ObjectIdentifier`
+
+        One of the :class:`~cryptography.x509.oid.ExtensionOID` OIDs.
+
+    .. attribute:: critical
+
+        :type: bool
+
+        Determines whether a given extension is critical or not. :rfc:`5280`
+        requires that "A certificate-using system MUST reject the certificate
+        if it encounters a critical extension it does not recognize or a
+        critical extension that contains information that it cannot process".
+
+    .. attribute:: value
+
+        Returns an instance of the extension type corresponding to the OID.
+
+.. class:: ExtensionType
+
+    .. versionadded:: 1.0
+
+    This is the interface against which all the following extension types are
+    registered.
+
+.. class:: KeyUsage(digital_signature, content_commitment, key_encipherment, data_encipherment, key_agreement, key_cert_sign, crl_sign, encipher_only, decipher_only)
+
+    .. versionadded:: 0.9
+
+    The key usage extension defines the purpose of the key contained in the
+    certificate.  The usage restriction might be employed when a key that could
+    be used for more than one operation is to be restricted.
+
+    .. attribute:: oid
+
+        .. versionadded:: 1.0
+
+        :type: :class:`ObjectIdentifier`
+
+        Returns :attr:`~cryptography.x509.oid.ExtensionOID.KEY_USAGE`.
+
+    .. attribute:: digital_signature
+
+        :type: bool
+
+        This purpose is set to true when the subject public key is used for verifying
+        digital signatures, other than signatures on certificates
+        (``key_cert_sign``) and CRLs (``crl_sign``).
+
+    .. attribute:: content_commitment
+
+        :type: bool
+
+        This purpose is set to true when the subject public key is used for verifying
+        digital signatures, other than signatures on certificates
+        (``key_cert_sign``) and CRLs (``crl_sign``). It is used to provide a
+        non-repudiation service that protects against the signing entity
+        falsely denying some action. In the case of later conflict, a
+        reliable third party may determine the authenticity of the signed
+        data. This was called ``non_repudiation`` in older revisions of the
+        X.509 specification.
+
+    .. attribute:: key_encipherment
+
+        :type: bool
+
+        This purpose is set to true when the subject public key is used for
+        enciphering private or secret keys.
+
+    .. attribute:: data_encipherment
+
+        :type: bool
+
+        This purpose is set to true when the subject public key is used for
+        directly enciphering raw user data without the use of an intermediate
+        symmetric cipher.
+
+    .. attribute:: key_agreement
+
+        :type: bool
+
+        This purpose is set to true when the subject public key is used for key
+        agreement.  For example, when a Diffie-Hellman key is to be used for
+        key management, then this purpose is set to true.
+
+    .. attribute:: key_cert_sign
+
+        :type: bool
+
+        This purpose is set to true when the subject public key is used for
+        verifying signatures on public key certificates. If this purpose is set
+        to true then ``ca`` must be true in the :class:`BasicConstraints`
+        extension.
+
+    .. attribute:: crl_sign
+
+        :type: bool
+
+        This purpose is set to true when the subject public key is used for
+        verifying signatures on certificate revocation lists.
+
+    .. attribute:: encipher_only
+
+        :type: bool
+
+        When this purposes is set to true and the ``key_agreement`` purpose is
+        also set, the subject public key may be used only for enciphering data
+        while performing key agreement.
+
+        :raises ValueError: This is raised if accessed when ``key_agreement``
+            is false.
+
+    .. attribute:: decipher_only
+
+        :type: bool
+
+        When this purposes is set to true and the ``key_agreement`` purpose is
+        also set, the subject public key may be used only for deciphering data
+        while performing key agreement.
+
+        :raises ValueError: This is raised if accessed when ``key_agreement``
+            is false.
+
+
+.. class:: BasicConstraints(ca, path_length)
+
+    .. versionadded:: 0.9
+
+    Basic constraints is an X.509 extension type that defines whether a given
+    certificate is allowed to sign additional certificates and what path
+    length restrictions may exist.
+
+    .. attribute:: oid
+
+        .. versionadded:: 1.0
+
+        :type: :class:`ObjectIdentifier`
+
+        Returns :attr:`~cryptography.x509.oid.ExtensionOID.BASIC_CONSTRAINTS`.
+
+    .. attribute:: ca
+
+        :type: bool
+
+        Whether the certificate can sign certificates.
+
+    .. attribute:: path_length
+
+        :type: int or None
+
+        The maximum path length for certificates subordinate to this
+        certificate. This attribute only has meaning if ``ca`` is true.
+        If ``ca`` is true then a path length of None means there's no
+        restriction on the number of subordinate CAs in the certificate chain.
+        If it is zero or greater then it defines the maximum length for a
+        subordinate CA's certificate chain. For example, a ``path_length`` of 1
+        means the certificate can sign a subordinate CA, but the subordinate CA
+        is not allowed to create subordinates with ``ca`` set to true.
+
+.. class:: ExtendedKeyUsage(usages)
+
+    .. versionadded:: 0.9
+
+    This extension indicates one or more purposes for which the certified
+    public key may be used, in addition to or in place of the basic
+    purposes indicated in the key usage extension. The object is
+    iterable to obtain the list of
+    :class:`~cryptography.x509.oid.ExtendedKeyUsageOID` OIDs present.
+
+    :param list usages: A list of
+        :class:`~cryptography.x509.oid.ExtendedKeyUsageOID` OIDs.
+
+    .. attribute:: oid
+
+        .. versionadded:: 1.0
+
+        :type: :class:`ObjectIdentifier`
+
+        Returns :attr:`~cryptography.x509.oid.ExtensionOID.EXTENDED_KEY_USAGE`.
+
+
+.. class:: OCSPNoCheck()
+
+    .. versionadded:: 1.0
+
+    This presence of this extension indicates that an OCSP client can trust a
+    responder for the lifetime of the responder's certificate. CAs issuing
+    such a certificate should realize that a compromise of the responder's key
+    is as serious as the compromise of a CA key used to sign CRLs, at least for
+    the validity period of this certificate. CA's may choose to issue this type
+    of certificate with a very short lifetime and renew it frequently. This
+    extension is only relevant when the certificate is an authorized OCSP
+    responder.
+
+    .. attribute:: oid
+
+        .. versionadded:: 1.0
+
+        :type: :class:`ObjectIdentifier`
+
+        Returns :attr:`~cryptography.x509.oid.ExtensionOID.OCSP_NO_CHECK`.
+
+.. class:: NameConstraints(permitted_subtrees, excluded_subtrees)
+
+    .. versionadded:: 1.0
+
+    The name constraints extension, which only has meaning in a CA certificate,
+    defines a name space within which all subject names in certificates issued
+    beneath the CA certificate must (or must not) be in. For specific details
+    on the way this extension should be processed see :rfc:`5280`.
+
+    .. attribute:: oid
+
+        .. versionadded:: 1.0
+
+        :type: :class:`ObjectIdentifier`
+
+        Returns :attr:`~cryptography.x509.oid.ExtensionOID.NAME_CONSTRAINTS`.
+
+    .. attribute:: permitted_subtrees
+
+        :type: list of :class:`GeneralName` objects or None
+
+        The set of permitted name patterns. If a name matches this and an
+        element in ``excluded_subtrees`` it is invalid. At least one of
+        ``permitted_subtrees`` and ``excluded_subtrees`` will be non-None.
+
+    .. attribute:: excluded_subtrees
+
+        :type: list of :class:`GeneralName` objects or None
+
+        Any name matching a restriction in the ``excluded_subtrees`` field is
+        invalid regardless of information appearing in the
+        ``permitted_subtrees``. At least one of ``permitted_subtrees`` and
+        ``excluded_subtrees`` will be non-None.
+
+.. class:: AuthorityKeyIdentifier(key_identifier, authority_cert_issuer, authority_cert_serial_number)
+
+    .. versionadded:: 0.9
+
+    The authority key identifier extension provides a means of identifying the
+    public key corresponding to the private key used to sign a certificate.
+    This extension is typically used to assist in determining the appropriate
+    certificate chain. For more information about generation and use of this
+    extension see `RFC 5280 section 4.2.1.1`_.
+
+    .. attribute:: oid
+
+        .. versionadded:: 1.0
+
+        :type: :class:`ObjectIdentifier`
+
+        Returns
+        :attr:`~cryptography.x509.oid.ExtensionOID.AUTHORITY_KEY_IDENTIFIER`.
+
+    .. attribute:: key_identifier
+
+        :type: bytes
+
+        A value derived from the public key used to verify the certificate's
+        signature.
+
+    .. attribute:: authority_cert_issuer
+
+        :type: :class:`Name` or None
+
+        The :class:`Name` of the issuer's issuer.
+
+    .. attribute:: authority_cert_serial_number
+
+        :type: int or None
+
+        The serial number of the issuer's issuer.
+
+    .. classmethod:: from_issuer_public_key(public_key)
+
+        .. versionadded:: 1.0
+
+        Creates a new AuthorityKeyIdentifier instance using the public key
+        provided to generate the appropriate digest. This should be the
+        **issuer's public key**. The resulting object will contain
+        :attr:`~cryptography.x509.AuthorityKeyIdentifier.key_identifier`, but
+        :attr:`~cryptography.x509.AuthorityKeyIdentifier.authority_cert_issuer`
+        and
+        :attr:`~cryptography.x509.AuthorityKeyIdentifier.authority_cert_serial_number`
+        will be None.
+        The generated ``key_identifier`` is the SHA1 hash of the ``subjectPublicKey``
+        ASN.1 bit string. This is the first recommendation in :rfc:`5280`
+        section 4.2.1.2.
+
+        :param public_key: One of
+            :class:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPublicKey`
+            ,
+            :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPublicKey`
+            , or
+            :class:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePublicKey`.
+
+        .. doctest::
+
+            >>> from cryptography import x509
+            >>> from cryptography.hazmat.backends import default_backend
+            >>> issuer_cert = x509.load_pem_x509_certificate(pem_data, default_backend())
+            >>> x509.AuthorityKeyIdentifier.from_issuer_public_key(issuer_cert.public_key())
+            <AuthorityKeyIdentifier(key_identifier='X\x01\x84$\x1b\xbc+R\x94J=\xa5\x10r\x14Q\xf5\xaf:\xc9', authority_cert_issuer=None, authority_cert_serial_number=None)>
+
+.. class:: SubjectKeyIdentifier(digest)
+
+    .. versionadded:: 0.9
+
+    The subject key identifier extension provides a means of identifying
+    certificates that contain a particular public key.
+
+    .. attribute:: oid
+
+        .. versionadded:: 1.0
+
+        :type: :class:`ObjectIdentifier`
+
+        Returns
+        :attr:`~cryptography.x509.oid.ExtensionOID.SUBJECT_KEY_IDENTIFIER`.
+
+    .. attribute:: digest
+
+        :type: bytes
+
+        The binary value of the identifier.
+
+    .. classmethod:: from_public_key(public_key)
+
+        .. versionadded:: 1.0
+
+        Creates a new SubjectKeyIdentifier instance using the public key
+        provided to generate the appropriate digest. This should be the public
+        key that is in the certificate. The generated digest is the SHA1 hash
+        of the ``subjectPublicKey`` ASN.1 bit string. This is the first
+        recommendation in :rfc:`5280` section 4.2.1.2.
+
+        :param public_key: One of
+            :class:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPublicKey`
+            ,
+            :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPublicKey`
+            , or
+            :class:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePublicKey`.
+
+        .. doctest::
+
+            >>> from cryptography import x509
+            >>> from cryptography.hazmat.backends import default_backend
+            >>> csr = x509.load_pem_x509_csr(pem_req_data, default_backend())
+            >>> x509.SubjectKeyIdentifier.from_public_key(csr.public_key())
+            <SubjectKeyIdentifier(digest='\xdb\xaa\xf0\x06\x11\xdbD\xfe\xbf\x93\x03\x8av\x88WP7\xa6\x91\xf7')>
+
+.. class:: SubjectAlternativeName(general_names)
+
+    .. versionadded:: 0.9
+
+    Subject alternative name is an X.509 extension that provides a list of
+    :ref:`general name <general_name_classes>` instances that provide a set
+    of identities for which the certificate is valid. The object is iterable to
+    get every element.
+
+    :param list general_names: A list of :class:`GeneralName` instances.
+
+    .. attribute:: oid
+
+        .. versionadded:: 1.0
+
+        :type: :class:`ObjectIdentifier`
+
+        Returns
+        :attr:`~cryptography.x509.oid.ExtensionOID.SUBJECT_ALTERNATIVE_NAME`.
+
+    .. method:: get_values_for_type(type)
+
+        :param type: A :class:`GeneralName` provider. This is one of the
+            :ref:`general name classes <general_name_classes>`.
+
+        :returns: A list of values extracted from the matched general names.
+            The type of the returned values depends on the :class:`GeneralName`.
+
+        .. doctest::
+
+            >>> from cryptography import x509
+            >>> from cryptography.hazmat.backends import default_backend
+            >>> from cryptography.hazmat.primitives import hashes
+            >>> cert = x509.load_pem_x509_certificate(cryptography_cert_pem, default_backend())
+            >>> # Get the subjectAltName extension from the certificate
+            >>> ext = cert.extensions.get_extension_for_oid(ExtensionOID.SUBJECT_ALTERNATIVE_NAME)
+            >>> # Get the dNSName entries from the SAN extension
+            >>> ext.value.get_values_for_type(x509.DNSName)
+            [u'www.cryptography.io', u'cryptography.io']
+
+
+.. class:: IssuerAlternativeName(general_names)
+
+    .. versionadded:: 1.0
+
+    Issuer alternative name is an X.509 extension that provides a list of
+    :ref:`general name <general_name_classes>` instances that provide a set
+    of identities for the certificate issuer. The object is iterable to
+    get every element.
+
+    :param list general_names: A list of :class:`GeneralName` instances.
+
+    .. attribute:: oid
+
+        .. versionadded:: 1.0
+
+        :type: :class:`ObjectIdentifier`
+
+        Returns
+        :attr:`~cryptography.x509.oid.ExtensionOID.ISSUER_ALTERNATIVE_NAME`.
+
+    .. method:: get_values_for_type(type)
+
+        :param type: A :class:`GeneralName` provider. This is one of the
+            :ref:`general name classes <general_name_classes>`.
+
+        :returns: A list of values extracted from the matched general names.
+
+
+.. class:: AuthorityInformationAccess(descriptions)
+
+    .. versionadded:: 0.9
+
+    The authority information access extension indicates how to access
+    information and services for the issuer of the certificate in which
+    the extension appears. Information and services may include online
+    validation services (such as OCSP) and issuer data. It is an iterable,
+    containing one or more :class:`~cryptography.x509.AccessDescription`
+    instances.
+
+    :param list descriptions: A list of :class:`AccessDescription` objects.
+
+    .. attribute:: oid
+
+        .. versionadded:: 1.0
+
+        :type: :class:`ObjectIdentifier`
+
+        Returns
+        :attr:`~cryptography.x509.oid.ExtensionOID.AUTHORITY_INFORMATION_ACCESS`.
+
+
+.. class:: AccessDescription(access_method, access_location)
+
+    .. versionadded:: 0.9
+
+    .. attribute:: access_method
+
+        :type: :class:`ObjectIdentifier`
+
+        The access method defines what the ``access_location`` means. It must
+        be either
+        :attr:`~cryptography.x509.oid.AuthorityInformationAccessOID.OCSP` or
+        :attr:`~cryptography.x509.oid.AuthorityInformationAccessOID.CA_ISSUERS`.
+        If it is
+        :attr:`~cryptography.x509.oid.AuthorityInformationAccessOID.OCSP`
+        the access location will be where to obtain OCSP
+        information for the certificate. If it is
+        :attr:`~cryptography.x509.oid.AuthorityInformationAccessOID.CA_ISSUERS`
+        the access location will provide additional information about the
+        issuing certificate.
+
+    .. attribute:: access_location
+
+        :type: :class:`GeneralName`
+
+        Where to access the information defined by the access method.
+
+.. class:: CRLDistributionPoints(distribution_points)
+
+    .. versionadded:: 0.9
+
+    The CRL distribution points extension identifies how CRL information is
+    obtained. It is an iterable, containing one or more
+    :class:`DistributionPoint` instances.
+
+    :param list distribution_points: A list of :class:`DistributionPoint`
+        instances.
+
+    .. attribute:: oid
+
+        .. versionadded:: 1.0
+
+        :type: :class:`ObjectIdentifier`
+
+        Returns
+        :attr:`~cryptography.x509.oid.ExtensionOID.CRL_DISTRIBUTION_POINTS`.
+
+.. class:: DistributionPoint(full_name, relative_name, reasons, crl_issuer)
+
+    .. versionadded:: 0.9
+
+    .. attribute:: full_name
+
+        :type: list of :class:`GeneralName` instances or None
+
+        This field describes methods to retrieve the CRL. At most one of
+        ``full_name`` or ``relative_name`` will be non-None.
+
+    .. attribute:: relative_name
+
+        :type: :class:`Name` or None
+
+        This field describes methods to retrieve the CRL relative to the CRL
+        issuer. At most one of ``full_name`` or ``relative_name`` will be
+        non-None.
+
+    .. attribute:: crl_issuer
+
+        :type: list of :class:`GeneralName` instances or None
+
+        Information about the issuer of the CRL.
+
+    .. attribute:: reasons
+
+        :type: frozenset of :class:`ReasonFlags` or None
+
+        The reasons a given distribution point may be used for when performing
+        revocation checks.
+
+.. class:: ReasonFlags
+
+    .. versionadded:: 0.9
+
+    An enumeration for CRL reasons.
+
+    .. attribute:: unspecified
+
+        It is unspecified why the certificate was revoked. This reason cannot
+        be used as a reason flag in a :class:`DistributionPoint`.
+
+    .. attribute:: key_compromise
+
+        This reason indicates that the private key was compromised.
+
+    .. attribute:: ca_compromise
+
+        This reason indicates that the CA issuing the certificate was
+        compromised.
+
+    .. attribute:: affiliation_changed
+
+        This reason indicates that the subject's name or other information has
+        changed.
+
+    .. attribute:: superseded
+
+        This reason indicates that a certificate has been superseded.
+
+    .. attribute:: cessation_of_operation
+
+        This reason indicates that the certificate is no longer required.
+
+    .. attribute:: certificate_hold
+
+        This reason indicates that the certificate is on hold.
+
+    .. attribute:: privilege_withdrawn
+
+        This reason indicates that the privilege granted by this certificate
+        have been withdrawn.
+
+    .. attribute:: aa_compromise
+
+        When an attribute authority has been compromised.
+
+    .. attribute:: remove_from_crl
+
+        This reason indicates that the certificate was on hold and should be
+        removed from the CRL. This reason cannot be used as a reason flag
+        in a :class:`DistributionPoint`.
+
+.. class:: InhibitAnyPolicy(skip_certs)
+
+    .. versionadded:: 1.0
+
+    The inhibit ``anyPolicy`` extension indicates that the special OID
+    :attr:`~cryptography.x509.oid.CertificatePoliciesOID.ANY_POLICY`, is not
+    considered an explicit match for other :class:`CertificatePolicies` except
+    when it appears in an intermediate self-issued CA certificate.  The value
+    indicates the number of additional non-self-issued certificates that may
+    appear in the path before
+    :attr:`~cryptography.x509.oid.CertificatePoliciesOID.ANY_POLICY` is no
+    longer permitted.  For example, a value of one indicates that
+    :attr:`~cryptography.x509.oid.CertificatePoliciesOID.ANY_POLICY` may be
+    processed in certificates issued by the subject of this certificate, but
+    not in additional certificates in the path.
+
+    .. attribute:: oid
+
+        .. versionadded:: 1.0
+
+        :type: :class:`ObjectIdentifier`
+
+        Returns
+        :attr:`~cryptography.x509.oid.ExtensionOID.INHIBIT_ANY_POLICY`.
+
+    .. attribute:: skip_certs
+
+        :type: int
+
+.. class:: CertificatePolicies(policies)
+
+    .. versionadded:: 0.9
+
+    The certificate policies extension is an iterable, containing one or more
+    :class:`PolicyInformation` instances.
+
+    :param list policies: A list of :class:`PolicyInformation` instances.
+
+    .. attribute:: oid
+
+        .. versionadded:: 1.0
+
+        :type: :class:`ObjectIdentifier`
+
+        Returns
+        :attr:`~cryptography.x509.oid.ExtensionOID.CERTIFICATE_POLICIES`.
+
+Certificate Policies Classes
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+These classes may be present within a :class:`CertificatePolicies` instance.
+
+.. class:: PolicyInformation(policy_identifier, policy_qualifiers)
+
+    .. versionadded:: 0.9
+
+    Contains a policy identifier and an optional list of qualifiers.
+
+    .. attribute:: policy_identifier
+
+        :type: :class:`ObjectIdentifier`
+
+    .. attribute:: policy_qualifiers
+
+        :type: list
+
+        A list consisting of :term:`text` and/or :class:`UserNotice` objects.
+        If the value is text it is a pointer to the practice statement
+        published by the certificate authority. If it is a user notice it is
+        meant for display to the relying party when the certificate is
+        used.
+
+.. class:: UserNotice(notice_reference, explicit_text)
+
+    .. versionadded:: 0.9
+
+    User notices are intended for display to a relying party when a certificate
+    is used. In practice, few if any UIs expose this data and it is a rarely
+    encoded component.
+
+    .. attribute:: notice_reference
+
+        :type: :class:`NoticeReference` or None
+
+        The notice reference field names an organization and identifies,
+        by number, a particular statement prepared by that organization.
+
+    .. attribute:: explicit_text
+
+        This field includes an arbitrary textual statement directly in the
+        certificate.
+
+        :type: :term:`text`
+
+.. class:: NoticeReference(organization, notice_numbers)
+
+    Notice reference can name an organization and provide information about
+    notices related to the certificate. For example, it might identify the
+    organization name and notice number 1. Application software could
+    have a notice file containing the current set of notices for the named
+    organization; the application would then extract the notice text from the
+    file and display it. In practice this is rarely seen.
+
+    .. versionadded:: 0.9
+
+    .. attribute:: organization
+
+        :type: :term:`text`
+
+    .. attribute:: notice_numbers
+
+        :type: list
+
+        A list of integers.
+
+Object Identifiers
+~~~~~~~~~~~~~~~~~~
+
+X.509 elements are frequently identified by :class:`ObjectIdentifier`
+instances. The following common OIDs are available as constants.
+
+.. currentmodule:: cryptography.x509.oid
+
+.. class:: NameOID
+
+    These OIDs are typically seen in X.509 names.
+
+    .. versionadded:: 1.0
+
+    .. attribute:: COMMON_NAME
+
+        Corresponds to the dotted string ``"2.5.4.3"``. Historically the domain
+        name would be encoded here for server certificates. :rfc:`2818`
+        deprecates this practice and names of that type should now be located
+        in a :class:`~cryptography.x509.SubjectAlternativeName` extension.
+
+    .. attribute:: COUNTRY_NAME
+
+        Corresponds to the dotted string ``"2.5.4.6"``.
+
+    .. attribute:: LOCALITY_NAME
+
+        Corresponds to the dotted string ``"2.5.4.7"``.
+
+    .. attribute:: STATE_OR_PROVINCE_NAME
+
+        Corresponds to the dotted string ``"2.5.4.8"``.
+
+    .. attribute:: ORGANIZATION_NAME
+
+        Corresponds to the dotted string ``"2.5.4.10"``.
+
+    .. attribute:: ORGANIZATIONAL_UNIT_NAME
+
+        Corresponds to the dotted string ``"2.5.4.11"``.
+
+    .. attribute:: SERIAL_NUMBER
+
+        Corresponds to the dotted string ``"2.5.4.5"``. This is distinct from
+        the serial number of the certificate itself (which can be obtained with
+        :func:`~cryptography.x509.Certificate.serial`).
+
+    .. attribute:: SURNAME
+
+        Corresponds to the dotted string ``"2.5.4.4"``.
+
+    .. attribute:: GIVEN_NAME
+
+        Corresponds to the dotted string ``"2.5.4.42"``.
+
+    .. attribute:: TITLE
+
+        Corresponds to the dotted string ``"2.5.4.12"``.
+
+    .. attribute:: GENERATION_QUALIFIER
+
+        Corresponds to the dotted string ``"2.5.4.44"``.
+
+    .. attribute:: DN_QUALIFIER
+
+        Corresponds to the dotted string ``"2.5.4.46"``. This specifies
+        disambiguating information to add to the relative distinguished name of an
+        entry. See :rfc:`2256`.
+
+    .. attribute:: PSEUDONYM
+
+        Corresponds to the dotted string ``"2.5.4.65"``.
+
+    .. attribute:: DOMAIN_COMPONENT
+
+        Corresponds to the dotted string ``"0.9.2342.19200300.100.1.25"``. A string
+        holding one component of a domain name. See :rfc:`4519`.
+
+    .. attribute:: EMAIL_ADDRESS
+
+        Corresponds to the dotted string ``"1.2.840.113549.1.9.1"``.
+
+
+.. class:: SignatureAlgorithmOID
+
+    .. versionadded:: 1.0
+
+    .. attribute:: RSA_WITH_MD5
+
+        Corresponds to the dotted string ``"1.2.840.113549.1.1.4"``. This is
+        an MD5 digest signed by an RSA key.
+
+    .. attribute:: RSA_WITH_SHA1
+
+        Corresponds to the dotted string ``"1.2.840.113549.1.1.5"``. This is
+        a SHA1 digest signed by an RSA key.
+
+    .. attribute:: RSA_WITH_SHA224
+
+        Corresponds to the dotted string ``"1.2.840.113549.1.1.14"``. This is
+        a SHA224 digest signed by an RSA key.
+
+    .. attribute:: RSA_WITH_SHA256
+
+        Corresponds to the dotted string ``"1.2.840.113549.1.1.11"``. This is
+        a SHA256 digest signed by an RSA key.
+
+    .. attribute:: RSA_WITH_SHA384
+
+        Corresponds to the dotted string ``"1.2.840.113549.1.1.12"``. This is
+        a SHA384 digest signed by an RSA key.
+
+    .. attribute:: RSA_WITH_SHA512
+
+        Corresponds to the dotted string ``"1.2.840.113549.1.1.13"``. This is
+        a SHA512 digest signed by an RSA key.
+
+    .. attribute:: ECDSA_WITH_SHA1
+
+        Corresponds to the dotted string ``"1.2.840.10045.4.1"``. This is a SHA1
+        digest signed by an ECDSA key.
+
+    .. attribute:: ECDSA_WITH_SHA224
+
+        Corresponds to the dotted string ``"1.2.840.10045.4.3.1"``. This is
+        a SHA224 digest signed by an ECDSA key.
+
+    .. attribute:: ECDSA_WITH_SHA256
+
+        Corresponds to the dotted string ``"1.2.840.10045.4.3.2"``. This is
+        a SHA256 digest signed by an ECDSA key.
+
+    .. attribute:: ECDSA_WITH_SHA384
+
+        Corresponds to the dotted string ``"1.2.840.10045.4.3.3"``. This is
+        a SHA384 digest signed by an ECDSA key.
+
+    .. attribute:: ECDSA_WITH_SHA512
+
+        Corresponds to the dotted string ``"1.2.840.10045.4.3.4"``. This is
+        a SHA512 digest signed by an ECDSA key.
+
+    .. attribute:: DSA_WITH_SHA1
+
+        Corresponds to the dotted string ``"1.2.840.10040.4.3"``. This is
+        a SHA1 digest signed by a DSA key.
+
+    .. attribute:: DSA_WITH_SHA224
+
+        Corresponds to the dotted string ``"2.16.840.1.101.3.4.3.1"``. This is
+        a SHA224 digest signed by a DSA key.
+
+    .. attribute:: DSA_WITH_SHA256
+
+        Corresponds to the dotted string ``"2.16.840.1.101.3.4.3.2"``. This is
+        a SHA256 digest signed by a DSA key.
+
+
+.. class:: ExtendedKeyUsageOID
+
+    .. versionadded:: 1.0
+
+    .. attribute:: SERVER_AUTH
+
+        Corresponds to the dotted string ``"1.3.6.1.5.5.7.3.1"``. This is used
+        to denote that a certificate may be used for TLS web server
+        authentication.
+
+    .. attribute:: CLIENT_AUTH
+
+        Corresponds to the dotted string ``"1.3.6.1.5.5.7.3.2"``. This is used
+        to denote that a certificate may be used for TLS web client
+        authentication.
+
+    .. attribute:: CODE_SIGNING
+
+        Corresponds to the dotted string ``"1.3.6.1.5.5.7.3.3"``. This is used
+        to denote that a certificate may be used for code signing.
+
+    .. attribute:: EMAIL_PROTECTION
+
+        Corresponds to the dotted string ``"1.3.6.1.5.5.7.3.4"``. This is used
+        to denote that a certificate may be used for email protection.
+
+    .. attribute:: TIME_STAMPING
+
+        Corresponds to the dotted string ``"1.3.6.1.5.5.7.3.8"``. This is used
+        to denote that a certificate may be used for time stamping.
+
+    .. attribute:: OCSP_SIGNING
+
+        Corresponds to the dotted string ``"1.3.6.1.5.5.7.3.9"``. This is used
+        to denote that a certificate may be used for signing OCSP responses.
+
+
+.. class:: AuthorityInformationAccessOID
+
+    .. versionadded:: 1.0
+
+    .. attribute:: OCSP
+
+        Corresponds to the dotted string ``"1.3.6.1.5.5.7.48.1"``. Used as the
+        identifier for OCSP data in
+        :class:`~cryptography.x509.AccessDescription` objects.
+
+    .. attribute:: CA_ISSUERS
+
+        Corresponds to the dotted string ``"1.3.6.1.5.5.7.48.2"``. Used as the
+        identifier for CA issuer data in
+        :class:`~cryptography.x509.AccessDescription` objects.
+
+
+.. class:: CertificatePoliciesOID
+
+    .. versionadded:: 1.0
+
+    .. attribute:: CPS_QUALIFIER
+
+        Corresponds to the dotted string ``"1.3.6.1.5.5.7.2.1"``.
+
+    .. attribute:: CPS_USER_NOTICE
+
+        Corresponds to the dotted string ``"1.3.6.1.5.5.7.2.2"``.
+
+    .. attribute:: ANY_POLICY
+
+        Corresponds to the dotted string ``"2.5.29.32.0"``.
+
+
+.. class:: ExtensionOID
+
+    .. versionadded:: 1.0
+
+    .. attribute:: BASIC_CONSTRAINTS
+
+        Corresponds to the dotted string ``"2.5.29.19"``. The identifier for the
+        :class:`~cryptography.x509.BasicConstraints` extension type.
+
+    .. attribute:: KEY_USAGE
+
+        Corresponds to the dotted string ``"2.5.29.15"``. The identifier for the
+        :class:`~cryptography.x509.KeyUsage` extension type.
+
+    .. attribute:: SUBJECT_ALTERNATIVE_NAME
+
+        Corresponds to the dotted string ``"2.5.29.17"``. The identifier for the
+        :class:`~cryptography.x509.SubjectAlternativeName` extension type.
+
+    .. attribute:: ISSUER_ALTERNATIVE_NAME
+
+        Corresponds to the dotted string ``"2.5.29.18"``. The identifier for the
+        :class:`~cryptography.x509.IssuerAlternativeName` extension type.
+
+    .. attribute:: SUBJECT_KEY_IDENTIFIER
+
+        Corresponds to the dotted string ``"2.5.29.14"``. The identifier for the
+        :class:`~cryptography.x509.SubjectKeyIdentifier` extension type.
+
+    .. attribute:: NAME_CONSTRAINTS
+
+        Corresponds to the dotted string ``"2.5.29.30"``. The identifier for the
+        :class:`~cryptography.x509.NameConstraints` extension type.
+
+    .. attribute:: CRL_DISTRIBUTION_POINTS
+
+        Corresponds to the dotted string ``"2.5.29.31"``. The identifier for the
+        :class:`~cryptography.x509.CRLDistributionPoints` extension type.
+
+    .. attribute:: CERTIFICATE_POLICIES
+
+        Corresponds to the dotted string ``"2.5.29.32"``. The identifier for the
+        :class:`~cryptography.x509.CertificatePolicies` extension type.
+
+    .. attribute:: AUTHORITY_KEY_IDENTIFIER
+
+        Corresponds to the dotted string ``"2.5.29.35"``. The identifier for the
+        :class:`~cryptography.x509.AuthorityKeyIdentifier` extension type.
+
+    .. attribute:: EXTENDED_KEY_USAGE
+
+        Corresponds to the dotted string ``"2.5.29.37"``. The identifier for the
+        :class:`~cryptography.x509.ExtendedKeyUsage` extension type.
+
+    .. attribute:: AUTHORITY_INFORMATION_ACCESS
+
+        Corresponds to the dotted string ``"1.3.6.1.5.5.7.1.1"``. The identifier
+        for the :class:`~cryptography.x509.AuthorityInformationAccess` extension
+        type.
+
+    .. attribute:: INHIBIT_ANY_POLICY
+
+        Corresponds to the dotted string ``"2.5.29.54"``. The identifier
+        for the :class:`~cryptography.x509.InhibitAnyPolicy` extension type.
+
+    .. attribute:: OCSP_NO_CHECK
+
+        Corresponds to the dotted string ``"1.3.6.1.5.5.7.48.1.5"``. The
+        identifier for the :class:`~cryptography.x509.OCSPNoCheck` extension
+        type.
+
+Exceptions
+~~~~~~~~~~
+.. currentmodule:: cryptography.x509
+
+.. class:: InvalidVersion
+
+    This is raised when an X.509 certificate has an invalid version number.
+
+    .. attribute:: parsed_version
+
+        :type: int
+
+        Returns the raw version that was parsed from the certificate.
+
+.. class:: DuplicateExtension
+
+    This is raised when more than one X.509 extension of the same type is
+    found within a certificate.
+
+    .. attribute:: oid
+
+        :type: :class:`ObjectIdentifier`
+
+        Returns the OID.
+
+.. class:: UnsupportedExtension
+
+    This is raised when a certificate contains an unsupported extension type.
+
+    .. attribute:: oid
+
+        :type: :class:`ObjectIdentifier`
+
+        Returns the OID.
+
+.. class:: ExtensionNotFound
+
+    This is raised when calling :meth:`Extensions.get_extension_for_oid` with
+    an extension OID that is not present in the certificate.
+
+    .. attribute:: oid
+
+        :type: :class:`ObjectIdentifier`
+
+        Returns the OID.
+
+.. class:: UnsupportedGeneralNameType
+
+    This is raised when a certificate contains an unsupported general name
+    type in an extension.
+
+    .. attribute:: type
+
+        :type: int
+
+        The integer value of the unsupported type. The complete list of
+        types can be found in `RFC 5280 section 4.2.1.6`_.
+
+
+.. _`RFC 5280 section 4.2.1.1`: https://tools.ietf.org/html/rfc5280#section-4.2.1.1
+.. _`RFC 5280 section 4.2.1.6`: https://tools.ietf.org/html/rfc5280#section-4.2.1.6
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/x509/tutorial.rst hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/x509/tutorial.rst
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/docs/x509/tutorial.rst	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/docs/x509/tutorial.rst	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,84 @@
+Tutorial
+========
+
+X.509 certificates are used to authenticate clients on servers. The most common
+use case is for web servers using HTTPS.
+
+Creating a Certificate Signing Request (CSR)
+--------------------------------------------
+
+When obtaining a certificate from a certificate authority (CA), the usual
+flow is:
+
+1. You generate a private/public key pair.
+2. You create a request for a certificate, which is signed by your key (to
+   prove that you own that key).
+3. You give your CSR to a CA (but *not* the private key).
+4. The CA validates that you own the resource (e.g. domain) you want a
+   certificate for.
+5. The CA gives you a certificate, signed by them, which identifies your public
+   key, and the resource you are authenticated for.
+6. You configure your server to use that certificate, combined with your
+   private key, to server traffic.
+
+If you want to obtain a certificate from a typical commercial CA, here's how.
+First, you'll need to generate a private key, we'll generate an RSA key (these
+are the most common types of keys on the web right now):
+
+.. code-block:: pycon
+
+    >>> from cryptography.hazmat.backends import default_backend
+    >>> from cryptography.hazmat.primitives import serialization
+    >>> from cryptography.hazmat.primitives.asymmetric import rsa
+    >>> # Generate our key
+    >>> key = rsa.generate_private_key(
+    ...     public_exponent=65537,
+    ...     key_size=2048,
+    ...     backend=default_backend()
+    ... )
+    >>> # Write our key to disk for safe keeping
+    >>> with open("path/to/store/key.pem", "wb") as f:
+    ...     f.write(key.private_bytes(
+    ...         encoding=serialization.Encoding.PEM,
+    ...         format=serialization.PrivateFormat.TraditionalOpenSSL,
+    ...         encryption_algorithm=serialization.BestAvailableEncryption(b"passphrase"),
+    ...     ))
+
+If you've already generated a key you can load it with
+:func:`~cryptography.hazmat.primitives.serialization.load_pem_private_key`.
+
+Next we need to generate a certificate signing request. A typical CSR contains
+a few details:
+
+* Information about our public key (including a signature of the entire body).
+* Information about who *we* are.
+* Information about what domains this certificate is for.
+
+.. code-block:: pycon
+
+    >>> from cryptography import x509
+    >>> from cryptography.x509.oid import NameOID
+    >>> from cryptography.hazmat.primitives import hashes
+    >>> # Generate a CSR
+    >>> csr = x509.CertificateSigningRequestBuilder().subject_name(x509.Name([
+    ...     # Provide various details about who we are.
+    ...     x509.NameAttribute(NameOID.COUNTRY_NAME, u"US"),
+    ...     x509.NameAttribute(NameOID.STATE_OR_PROVINCE_NAME, u"CA"),
+    ...     x509.NameAttribute(NameOID.LOCALITY_NAME, u"San Francisco"),
+    ...     x509.NameAttribute(NameOID.ORGANIZATION_NAME, u"My Company"),
+    ...     x509.NameAttribute(NameOID.COMMON_NAME, u"mysite.com"),
+    ... ])).add_extension(
+    ...     x509.SubjectAlternativeName([
+    ...         # Describe what sites we want this certificate for.
+    ...         x509.DNSName(u"mysite.com"),
+    ...         x509.DNSName(u"www.mysite.com"),
+    ...         x509.DNSName(u"subdomain.mysite.com"),
+    ...     ]),
+    ...     critical=False,
+    ... # Sign the CSR with our private key.
+    ... ).sign(key, hashes.SHA256(), default_backend())
+    >>> # Write our CSR out to disk.
+    >>> with open("path/to/csr.pem", "wb") as f:
+    ...     f.write(csr.public_bytes(serialization.Encoding.PEM))
+
+Now we can give our CSR to a CA, who will give a certificate to us in return.
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/LICENSE hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/LICENSE
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/LICENSE	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/LICENSE	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,3 @@
+This software is made available under the terms of *either* of the licenses
+found in LICENSE.APACHE or LICENSE.BSD. Contributions to cryptography are made
+under the terms of *both* these licenses.
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/LICENSE.APACHE hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/LICENSE.APACHE
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/LICENSE.APACHE	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/LICENSE.APACHE	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,202 @@
+
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
+   APPENDIX: How to apply the Apache License to your work.
+
+      To apply the Apache License to your work, attach the following
+      boilerplate notice, with the fields enclosed by brackets "[]"
+      replaced with your own identifying information. (Don't include
+      the brackets!)  The text should be enclosed in the appropriate
+      comment syntax for the file format. We also recommend that a
+      file or class name and description of purpose be included on the
+      same "printed page" as the copyright notice for easier
+      identification within third-party archives.
+
+   Copyright [yyyy] [name of copyright owner]
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/LICENSE.BSD hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/LICENSE.BSD
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/LICENSE.BSD	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/LICENSE.BSD	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,27 @@
+Copyright (c) Individual contributors.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+    1. Redistributions of source code must retain the above copyright notice,
+       this list of conditions and the following disclaimer.
+
+    2. Redistributions in binary form must reproduce the above copyright
+       notice, this list of conditions and the following disclaimer in the
+       documentation and/or other materials provided with the distribution.
+
+    3. Neither the name of PyCA Cryptography nor the names of its contributors
+       may be used to endorse or promote products derived from this software
+       without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/MANIFEST.in hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/MANIFEST.in
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/MANIFEST.in	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/MANIFEST.in	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,13 @@
+include AUTHORS.rst
+include CHANGELOG.rst
+include CONTRIBUTING.rst
+include LICENSE
+include LICENSE.APACHE
+include LICENSE.BSD
+include README.rst
+
+recursive-include docs *
+recursive-include src/_cffi_src *.py *.c *.h
+prune docs/_build
+recursive-include tests *.py
+recursive-exclude vectors *
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/PKG-INFO hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/PKG-INFO
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/PKG-INFO	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/PKG-INFO	2015-11-19 05:02:01.000000000 +0100
@@ -0,0 +1,85 @@
+Metadata-Version: 1.1
+Name: cryptography
+Version: 1.1.1
+Summary: cryptography is a package which provides cryptographic recipes and primitives to Python developers.
+Home-page: https://github.com/pyca/cryptography
+Author: The cryptography developers
+Author-email: cryptography-dev@python.org
+License: BSD or Apache License, Version 2.0
+Description: Cryptography
+        ============
+        
+        .. image:: https://img.shields.io/pypi/v/cryptography.svg
+            :target: https://pypi.python.org/pypi/cryptography/
+            :alt: Latest Version
+        
+        .. image:: https://readthedocs.org/projects/cryptography/badge/?version=latest
+            :target: https://cryptography.io
+            :alt: Latest Docs
+        
+        .. image:: https://travis-ci.org/pyca/cryptography.svg?branch=master
+            :target: https://travis-ci.org/pyca/cryptography
+        
+        .. image:: https://codecov.io/github/pyca/cryptography/coverage.svg?branch=master
+            :target: https://codecov.io/github/pyca/cryptography?branch=master
+        
+        
+        ``cryptography`` is a package which provides cryptographic recipes and
+        primitives to Python developers.  Our goal is for it to be your "cryptographic
+        standard library". It supports Python 2.6-2.7, Python 3.3+, and PyPy 2.6+.
+        
+        ``cryptography`` includes both high level recipes, and low level interfaces to
+        common cryptographic algorithms such as symmetric ciphers, message digests and
+        key derivation functions. For example, to encrypt something with
+        ``cryptography``'s high level symmetric encryption recipe:
+        
+        .. code-block:: pycon
+        
+            >>> from cryptography.fernet import Fernet
+            >>> # Put this somewhere safe!
+            >>> key = Fernet.generate_key()
+            >>> f = Fernet(key)
+            >>> token = f.encrypt(b"A really secret message. Not for prying eyes.")
+            >>> token
+            '...'
+            >>> f.decrypt(token)
+            'A really secret message. Not for prying eyes.'
+        
+        You can find more information in the `documentation`_.
+        
+        Discussion
+        ~~~~~~~~~~
+        
+        If you run into bugs, you can file them in our `issue tracker`_.
+        
+        We maintain a `cryptography-dev`_ mailing list for development discussion.
+        
+        You can also join ``#cryptography-dev`` on Freenode to ask questions or get
+        involved.
+        
+        
+        .. _`documentation`: https://cryptography.io/
+        .. _`issue tracker`: https://github.com/pyca/cryptography/issues
+        .. _`cryptography-dev`: https://mail.python.org/mailman/listinfo/cryptography-dev
+        
+Platform: UNKNOWN
+Classifier: Intended Audience :: Developers
+Classifier: License :: OSI Approved :: Apache Software License
+Classifier: License :: OSI Approved :: BSD License
+Classifier: Natural Language :: English
+Classifier: Operating System :: MacOS :: MacOS X
+Classifier: Operating System :: POSIX
+Classifier: Operating System :: POSIX :: BSD
+Classifier: Operating System :: POSIX :: Linux
+Classifier: Operating System :: Microsoft :: Windows
+Classifier: Programming Language :: Python
+Classifier: Programming Language :: Python :: 2
+Classifier: Programming Language :: Python :: 2.6
+Classifier: Programming Language :: Python :: 2.7
+Classifier: Programming Language :: Python :: 3
+Classifier: Programming Language :: Python :: 3.3
+Classifier: Programming Language :: Python :: 3.4
+Classifier: Programming Language :: Python :: 3.5
+Classifier: Programming Language :: Python :: Implementation :: CPython
+Classifier: Programming Language :: Python :: Implementation :: PyPy
+Classifier: Topic :: Security :: Cryptography
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/README.rst hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/README.rst
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/README.rst	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/README.rst	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,55 @@
+Cryptography
+============
+
+.. image:: https://img.shields.io/pypi/v/cryptography.svg
+    :target: https://pypi.python.org/pypi/cryptography/
+    :alt: Latest Version
+
+.. image:: https://readthedocs.org/projects/cryptography/badge/?version=latest
+    :target: https://cryptography.io
+    :alt: Latest Docs
+
+.. image:: https://travis-ci.org/pyca/cryptography.svg?branch=master
+    :target: https://travis-ci.org/pyca/cryptography
+
+.. image:: https://codecov.io/github/pyca/cryptography/coverage.svg?branch=master
+    :target: https://codecov.io/github/pyca/cryptography?branch=master
+
+
+``cryptography`` is a package which provides cryptographic recipes and
+primitives to Python developers.  Our goal is for it to be your "cryptographic
+standard library". It supports Python 2.6-2.7, Python 3.3+, and PyPy 2.6+.
+
+``cryptography`` includes both high level recipes, and low level interfaces to
+common cryptographic algorithms such as symmetric ciphers, message digests and
+key derivation functions. For example, to encrypt something with
+``cryptography``'s high level symmetric encryption recipe:
+
+.. code-block:: pycon
+
+    >>> from cryptography.fernet import Fernet
+    >>> # Put this somewhere safe!
+    >>> key = Fernet.generate_key()
+    >>> f = Fernet(key)
+    >>> token = f.encrypt(b"A really secret message. Not for prying eyes.")
+    >>> token
+    '...'
+    >>> f.decrypt(token)
+    'A really secret message. Not for prying eyes.'
+
+You can find more information in the `documentation`_.
+
+Discussion
+~~~~~~~~~~
+
+If you run into bugs, you can file them in our `issue tracker`_.
+
+We maintain a `cryptography-dev`_ mailing list for development discussion.
+
+You can also join ``#cryptography-dev`` on Freenode to ask questions or get
+involved.
+
+
+.. _`documentation`: https://cryptography.io/
+.. _`issue tracker`: https://github.com/pyca/cryptography/issues
+.. _`cryptography-dev`: https://mail.python.org/mailman/listinfo/cryptography-dev
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/setup.cfg hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/setup.cfg
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/setup.cfg	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/setup.cfg	2015-11-19 05:02:01.000000000 +0100
@@ -0,0 +1,5 @@
+[egg_info]
+tag_build = 
+tag_date = 0
+tag_svn_revision = 0
+
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/setup.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/setup.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/setup.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/setup.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,319 @@
+#!/usr/bin/env python
+
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import os
+import platform
+import subprocess
+import sys
+from distutils.command.build import build
+
+import pkg_resources
+
+from setuptools import find_packages, setup
+from setuptools.command.install import install
+from setuptools.command.test import test
+
+
+base_dir = os.path.dirname(__file__)
+src_dir = os.path.join(base_dir, "src")
+
+# When executing the setup.py, we need to be able to import ourselves, this
+# means that we need to add the src/ directory to the sys.path.
+sys.path.insert(0, src_dir)
+
+about = {}
+with open(os.path.join(src_dir, "cryptography", "__about__.py")) as f:
+    exec(f.read(), about)
+
+
+VECTORS_DEPENDENCY = "cryptography_vectors=={0}".format(about['__version__'])
+
+requirements = [
+    "idna>=2.0",
+    "pyasn1>=0.1.8",
+    "six>=1.4.1",
+    "setuptools",
+]
+setup_requirements = []
+
+if sys.version_info < (3, 4):
+    requirements.append("enum34")
+
+if sys.version_info < (3, 3):
+    requirements.append("ipaddress")
+
+if platform.python_implementation() == "PyPy":
+    if sys.pypy_version_info < (2, 6):
+        raise RuntimeError(
+            "cryptography 1.0 is not compatible with PyPy < 2.6. Please "
+            "upgrade PyPy to use this library."
+        )
+else:
+    requirements.append("cffi>=1.1.0")
+    setup_requirements.append("cffi>=1.1.0")
+
+# If you add a new dep here you probably need to add it in the tox.ini as well
+test_requirements = [
+    "pytest",
+    "pretend",
+    "iso8601",
+    "hypothesis",
+    "pyasn1_modules",
+]
+
+# If there's no vectors locally that probably means we are in a tarball and
+# need to go and get the matching vectors package from PyPi
+if not os.path.exists(os.path.join(base_dir, "vectors/setup.py")):
+    test_requirements.append(VECTORS_DEPENDENCY)
+
+
+def cc_is_available():
+    return sys.platform == "darwin" and list(map(
+        int, platform.mac_ver()[0].split("."))) >= [10, 8, 0]
+
+
+backends = [
+    "openssl = cryptography.hazmat.backends.openssl:backend"
+]
+
+if cc_is_available():
+    backends.append(
+        "commoncrypto = cryptography.hazmat.backends.commoncrypto:backend",
+    )
+
+
+class PyTest(test):
+    def finalize_options(self):
+        test.finalize_options(self)
+        self.test_args = []
+        self.test_suite = True
+
+        # This means there's a vectors/ folder with the package in here.
+        # cd into it, install the vectors package and then refresh sys.path
+        if VECTORS_DEPENDENCY not in test_requirements:
+            subprocess.check_call(
+                [sys.executable, "setup.py", "install"], cwd="vectors"
+            )
+            pkg_resources.get_distribution("cryptography_vectors").activate()
+
+    def run_tests(self):
+        # Import here because in module scope the eggs are not loaded.
+        import pytest
+        test_args = [os.path.join(base_dir, "tests")]
+        errno = pytest.main(test_args)
+        sys.exit(errno)
+
+
+def keywords_with_side_effects(argv):
+    """
+    Get a dictionary with setup keywords that (can) have side effects.
+
+    :param argv: A list of strings with command line arguments.
+    :returns: A dictionary with keyword arguments for the ``setup()`` function.
+
+    This setup.py script uses the setuptools 'setup_requires' feature because
+    this is required by the cffi package to compile extension modules. The
+    purpose of ``keywords_with_side_effects()`` is to avoid triggering the cffi
+    build process as a result of setup.py invocations that don't need the cffi
+    module to be built (setup.py serves the dual purpose of exposing package
+    metadata).
+
+    All of the options listed by ``python setup.py --help`` that print
+    information should be recognized here. The commands ``clean``,
+    ``egg_info``, ``register``, ``sdist`` and ``upload`` are also recognized.
+    Any combination of these options and commands is also supported.
+
+    This function was originally based on the `setup.py script`_ of SciPy (see
+    also the discussion in `pip issue #25`_).
+
+    .. _pip issue #25: https://github.com/pypa/pip/issues/25
+    .. _setup.py script: https://github.com/scipy/scipy/blob/master/setup.py
+    """
+    no_setup_requires_arguments = (
+        '-h', '--help',
+        '-n', '--dry-run',
+        '-q', '--quiet',
+        '-v', '--verbose',
+        '-V', '--version',
+        '--author',
+        '--author-email',
+        '--classifiers',
+        '--contact',
+        '--contact-email',
+        '--description',
+        '--egg-base',
+        '--fullname',
+        '--help-commands',
+        '--keywords',
+        '--licence',
+        '--license',
+        '--long-description',
+        '--maintainer',
+        '--maintainer-email',
+        '--name',
+        '--no-user-cfg',
+        '--obsoletes',
+        '--platforms',
+        '--provides',
+        '--requires',
+        '--url',
+        'clean',
+        'egg_info',
+        'register',
+        'sdist',
+        'upload',
+    )
+
+    def is_short_option(argument):
+        """Check whether a command line argument is a short option."""
+        return len(argument) >= 2 and argument[0] == '-' and argument[1] != '-'
+
+    def expand_short_options(argument):
+        """Expand combined short options into canonical short options."""
+        return ('-' + char for char in argument[1:])
+
+    def argument_without_setup_requirements(argv, i):
+        """Check whether a command line argument needs setup requirements."""
+        if argv[i] in no_setup_requires_arguments:
+            # Simple case: An argument which is either an option or a command
+            # which doesn't need setup requirements.
+            return True
+        elif (is_short_option(argv[i]) and
+              all(option in no_setup_requires_arguments
+                  for option in expand_short_options(argv[i]))):
+            # Not so simple case: Combined short options none of which need
+            # setup requirements.
+            return True
+        elif argv[i - 1:i] == ['--egg-base']:
+            # Tricky case: --egg-info takes an argument which should not make
+            # us use setup_requires (defeating the purpose of this code).
+            return True
+        else:
+            return False
+
+    if all(argument_without_setup_requirements(argv, i)
+           for i in range(1, len(argv))):
+        return {
+            "cmdclass": {
+                "build": DummyBuild,
+                "install": DummyInstall,
+                "test": DummyPyTest,
+            }
+        }
+    else:
+        cffi_modules = [
+            "src/_cffi_src/build_openssl.py:ffi",
+            "src/_cffi_src/build_constant_time.py:ffi",
+            "src/_cffi_src/build_padding.py:ffi",
+        ]
+        if cc_is_available():
+            cffi_modules.append("src/_cffi_src/build_commoncrypto.py:ffi")
+
+        return {
+            "setup_requires": setup_requirements,
+            "cmdclass": {
+                "test": PyTest,
+            },
+            "cffi_modules": cffi_modules
+        }
+
+
+setup_requires_error = ("Requested setup command that needs 'setup_requires' "
+                        "while command line arguments implied a side effect "
+                        "free command or option.")
+
+
+class DummyBuild(build):
+    """
+    This class makes it very obvious when ``keywords_with_side_effects()`` has
+    incorrectly interpreted the command line arguments to ``setup.py build`` as
+    one of the 'side effect free' commands or options.
+    """
+
+    def run(self):
+        raise RuntimeError(setup_requires_error)
+
+
+class DummyInstall(install):
+    """
+    This class makes it very obvious when ``keywords_with_side_effects()`` has
+    incorrectly interpreted the command line arguments to ``setup.py install``
+    as one of the 'side effect free' commands or options.
+    """
+
+    def run(self):
+        raise RuntimeError(setup_requires_error)
+
+
+class DummyPyTest(test):
+    """
+    This class makes it very obvious when ``keywords_with_side_effects()`` has
+    incorrectly interpreted the command line arguments to ``setup.py test`` as
+    one of the 'side effect free' commands or options.
+    """
+
+    def run_tests(self):
+        raise RuntimeError(setup_requires_error)
+
+
+with open(os.path.join(base_dir, "README.rst")) as f:
+    long_description = f.read()
+
+
+setup(
+    name=about["__title__"],
+    version=about["__version__"],
+
+    description=about["__summary__"],
+    long_description=long_description,
+    license=about["__license__"],
+    url=about["__uri__"],
+
+    author=about["__author__"],
+    author_email=about["__email__"],
+
+    classifiers=[
+        "Intended Audience :: Developers",
+        "License :: OSI Approved :: Apache Software License",
+        "License :: OSI Approved :: BSD License",
+        "Natural Language :: English",
+        "Operating System :: MacOS :: MacOS X",
+        "Operating System :: POSIX",
+        "Operating System :: POSIX :: BSD",
+        "Operating System :: POSIX :: Linux",
+        "Operating System :: Microsoft :: Windows",
+        "Programming Language :: Python",
+        "Programming Language :: Python :: 2",
+        "Programming Language :: Python :: 2.6",
+        "Programming Language :: Python :: 2.7",
+        "Programming Language :: Python :: 3",
+        "Programming Language :: Python :: 3.3",
+        "Programming Language :: Python :: 3.4",
+        "Programming Language :: Python :: 3.5",
+        "Programming Language :: Python :: Implementation :: CPython",
+        "Programming Language :: Python :: Implementation :: PyPy",
+        "Topic :: Security :: Cryptography",
+    ],
+
+    package_dir={"": "src"},
+    packages=find_packages(
+        where="src", exclude=["_cffi_src", "_cffi_src.*", "tests", "tests.*"]
+    ),
+    include_package_data=True,
+
+    install_requires=requirements,
+    tests_require=test_requirements,
+
+    # for cffi
+    zip_safe=False,
+    ext_package="cryptography.hazmat.bindings",
+    entry_points={
+        "cryptography.backends": backends,
+    },
+    **keywords_with_side_effects(sys.argv)
+)
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/build_commoncrypto.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/build_commoncrypto.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/build_commoncrypto.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/build_commoncrypto.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,29 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+from _cffi_src.utils import build_ffi_for_binding
+
+
+ffi = build_ffi_for_binding(
+    module_name="_commoncrypto",
+    module_prefix="_cffi_src.commoncrypto.",
+    modules=[
+        "cf",
+        "common_digest",
+        "common_hmac",
+        "common_key_derivation",
+        "common_cryptor",
+        "common_symmetric_key_wrap",
+        "secimport",
+        "secitem",
+        "seckey",
+        "seckeychain",
+        "sectransform",
+    ],
+    extra_link_args=[
+        "-framework", "Security", "-framework", "CoreFoundation"
+    ],
+)
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/build_constant_time.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/build_constant_time.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/build_constant_time.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/build_constant_time.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,28 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import os
+import sys
+
+from _cffi_src.utils import build_ffi, extra_link_args
+
+
+with open(os.path.join(
+    os.path.dirname(__file__), "hazmat_src/constant_time.h"
+)) as f:
+    types = f.read()
+
+with open(os.path.join(
+    os.path.dirname(__file__), "hazmat_src/constant_time.c"
+)) as f:
+    functions = f.read()
+
+ffi = build_ffi(
+    module_name="_constant_time",
+    cdef_source=types,
+    verify_source=functions,
+    extra_link_args=extra_link_args(sys.platform),
+)
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/build_openssl.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/build_openssl.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/build_openssl.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/build_openssl.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,96 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import os
+import sys
+
+from _cffi_src.utils import build_ffi_for_binding, extra_link_args
+
+
+def _get_openssl_libraries(platform):
+    # OpenSSL goes by a different library name on different operating systems.
+    if platform == "darwin":
+        return _osx_libraries(
+            os.environ.get("CRYPTOGRAPHY_OSX_NO_LINK_FLAGS")
+        )
+    elif platform == "win32":
+        return ["libeay32", "ssleay32", "advapi32",
+                "crypt32", "gdi32", "user32", "ws2_32"]
+    else:
+        # In some circumstances, the order in which these libs are
+        # specified on the linker command-line is significant;
+        # libssl must come before libcrypto
+        # (http://marc.info/?l=openssl-users&m=135361825921871)
+        return ["ssl", "crypto"]
+
+
+def _osx_libraries(build_static):
+    # For building statically we don't want to pass the -lssl or -lcrypto flags
+    if build_static == "1":
+        return []
+    else:
+        return ["ssl", "crypto"]
+
+
+_OSX_PRE_INCLUDE = """
+#ifdef __APPLE__
+#include <AvailabilityMacros.h>
+#define __ORIG_DEPRECATED_IN_MAC_OS_X_VERSION_10_7_AND_LATER \
+    DEPRECATED_IN_MAC_OS_X_VERSION_10_7_AND_LATER
+#undef DEPRECATED_IN_MAC_OS_X_VERSION_10_7_AND_LATER
+#define DEPRECATED_IN_MAC_OS_X_VERSION_10_7_AND_LATER
+#endif
+"""
+
+_OSX_POST_INCLUDE = """
+#ifdef __APPLE__
+#undef DEPRECATED_IN_MAC_OS_X_VERSION_10_7_AND_LATER
+#define DEPRECATED_IN_MAC_OS_X_VERSION_10_7_AND_LATER \
+    __ORIG_DEPRECATED_IN_MAC_OS_X_VERSION_10_7_AND_LATER
+#endif
+"""
+
+
+ffi = build_ffi_for_binding(
+    module_name="_openssl",
+    module_prefix="_cffi_src.openssl.",
+    modules=[
+        "aes",
+        "asn1",
+        "bignum",
+        "bio",
+        "cmac",
+        "cms",
+        "conf",
+        "crypto",
+        "dh",
+        "dsa",
+        "ec",
+        "ecdh",
+        "ecdsa",
+        "engine",
+        "err",
+        "evp",
+        "hmac",
+        "nid",
+        "objects",
+        "opensslv",
+        "pem",
+        "pkcs12",
+        "rand",
+        "rsa",
+        "ssl",
+        "x509",
+        "x509name",
+        "x509v3",
+        "x509_vfy",
+        "pkcs7",
+    ],
+    pre_include=_OSX_PRE_INCLUDE,
+    post_include=_OSX_POST_INCLUDE,
+    libraries=_get_openssl_libraries(sys.platform),
+    extra_link_args=extra_link_args(sys.platform),
+)
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/build_padding.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/build_padding.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/build_padding.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/build_padding.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,28 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import os
+import sys
+
+from _cffi_src.utils import build_ffi, extra_link_args
+
+
+with open(os.path.join(
+    os.path.dirname(__file__), "hazmat_src/padding.h"
+)) as f:
+    types = f.read()
+
+with open(os.path.join(
+    os.path.dirname(__file__), "hazmat_src/padding.c"
+)) as f:
+    functions = f.read()
+
+ffi = build_ffi(
+    module_name="_padding",
+    cdef_source=types,
+    verify_source=functions,
+    extra_link_args=extra_link_args(sys.platform),
+)
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/commoncrypto/cf.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/commoncrypto/cf.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/commoncrypto/cf.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/commoncrypto/cf.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,103 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+INCLUDES = """
+#include <CoreFoundation/CoreFoundation.h>
+"""
+
+TYPES = """
+typedef bool Boolean;
+typedef signed long OSStatus;
+typedef unsigned char UInt8;
+typedef uint32_t UInt32;
+
+typedef const void * CFAllocatorRef;
+const CFAllocatorRef kCFAllocatorDefault;
+typedef ... *CFDataRef;
+typedef signed long long CFIndex;
+typedef ... *CFStringRef;
+typedef ... *CFArrayRef;
+typedef ... *CFBooleanRef;
+typedef ... *CFErrorRef;
+typedef ... *CFNumberRef;
+typedef ... *CFTypeRef;
+typedef ... *CFDictionaryRef;
+typedef ... *CFMutableDictionaryRef;
+typedef struct {
+    ...;
+} CFDictionaryKeyCallBacks;
+typedef struct {
+    ...;
+} CFDictionaryValueCallBacks;
+typedef struct {
+    ...;
+} CFRange;
+
+typedef UInt32 CFStringEncoding;
+enum {
+    kCFStringEncodingASCII = 0x0600
+};
+
+enum {
+   kCFNumberSInt8Type = 1,
+   kCFNumberSInt16Type = 2,
+   kCFNumberSInt32Type = 3,
+   kCFNumberSInt64Type = 4,
+   kCFNumberFloat32Type = 5,
+   kCFNumberFloat64Type = 6,
+   kCFNumberCharType = 7,
+   kCFNumberShortType = 8,
+   kCFNumberIntType = 9,
+   kCFNumberLongType = 10,
+   kCFNumberLongLongType = 11,
+   kCFNumberFloatType = 12,
+   kCFNumberDoubleType = 13,
+   kCFNumberCFIndexType = 14,
+   kCFNumberNSIntegerType = 15,
+   kCFNumberCGFloatType = 16,
+   kCFNumberMaxType = 16
+};
+typedef int CFNumberType;
+
+const CFDictionaryKeyCallBacks kCFTypeDictionaryKeyCallBacks;
+const CFDictionaryValueCallBacks kCFTypeDictionaryValueCallBacks;
+
+const CFBooleanRef kCFBooleanTrue;
+const CFBooleanRef kCFBooleanFalse;
+"""
+
+FUNCTIONS = """
+CFDataRef CFDataCreate(CFAllocatorRef, const UInt8 *, CFIndex);
+CFStringRef CFStringCreateWithCString(CFAllocatorRef, const char *,
+                                      CFStringEncoding);
+CFDictionaryRef CFDictionaryCreate(CFAllocatorRef, const void **,
+                                   const void **, CFIndex,
+                                   const CFDictionaryKeyCallBacks *,
+                                   const CFDictionaryValueCallBacks *);
+CFMutableDictionaryRef CFDictionaryCreateMutable(
+    CFAllocatorRef,
+    CFIndex,
+    const CFDictionaryKeyCallBacks *,
+    const CFDictionaryValueCallBacks *
+);
+void CFDictionarySetValue(CFMutableDictionaryRef, const void *, const void *);
+CFIndex CFArrayGetCount(CFArrayRef);
+const void *CFArrayGetValueAtIndex(CFArrayRef, CFIndex);
+CFIndex CFDataGetLength(CFDataRef);
+void CFDataGetBytes(CFDataRef, CFRange, UInt8 *);
+CFRange CFRangeMake(CFIndex, CFIndex);
+void CFShow(CFTypeRef);
+Boolean CFBooleanGetValue(CFBooleanRef);
+CFNumberRef CFNumberCreate(CFAllocatorRef, CFNumberType, const void *);
+void CFRelease(CFTypeRef);
+CFTypeRef CFRetain(CFTypeRef);
+"""
+
+MACROS = """
+"""
+
+CUSTOMIZATIONS = """
+"""
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/commoncrypto/common_cryptor.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/commoncrypto/common_cryptor.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/commoncrypto/common_cryptor.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/commoncrypto/common_cryptor.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,99 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+INCLUDES = """
+#include <CommonCrypto/CommonCryptor.h>
+"""
+
+TYPES = """
+enum {
+    kCCAlgorithmAES128 = 0,
+    kCCAlgorithmDES,
+    kCCAlgorithm3DES,
+    kCCAlgorithmCAST,
+    kCCAlgorithmRC4,
+    kCCAlgorithmRC2,
+    kCCAlgorithmBlowfish
+};
+typedef uint32_t CCAlgorithm;
+enum {
+    kCCSuccess = 0,
+    kCCParamError = -4300,
+    kCCBufferTooSmall = -4301,
+    kCCMemoryFailure = -4302,
+    kCCAlignmentError = -4303,
+    kCCDecodeError = -4304,
+    kCCUnimplemented = -4305
+};
+typedef int32_t CCCryptorStatus;
+typedef uint32_t CCOptions;
+enum {
+    kCCEncrypt = 0,
+    kCCDecrypt,
+};
+typedef uint32_t CCOperation;
+typedef ... *CCCryptorRef;
+
+enum {
+    kCCModeOptionCTR_LE = 0x0001,
+    kCCModeOptionCTR_BE = 0x0002
+};
+
+typedef uint32_t CCModeOptions;
+
+enum {
+    kCCModeECB = 1,
+    kCCModeCBC = 2,
+    kCCModeCFB = 3,
+    kCCModeCTR = 4,
+    kCCModeF8 = 5,
+    kCCModeLRW = 6,
+    kCCModeOFB = 7,
+    kCCModeXTS = 8,
+    kCCModeRC4 = 9,
+    kCCModeCFB8 = 10,
+    kCCModeGCM = 11
+};
+typedef uint32_t CCMode;
+enum {
+    ccNoPadding = 0,
+    ccPKCS7Padding = 1,
+};
+typedef uint32_t CCPadding;
+"""
+
+FUNCTIONS = """
+CCCryptorStatus CCCryptorCreateWithMode(CCOperation, CCMode, CCAlgorithm,
+                                        CCPadding, const void *, const void *,
+                                        size_t, const void *, size_t, int,
+                                        CCModeOptions, CCCryptorRef *);
+CCCryptorStatus CCCryptorCreate(CCOperation, CCAlgorithm, CCOptions,
+                                const void *, size_t, const void *,
+                                CCCryptorRef *);
+CCCryptorStatus CCCryptorUpdate(CCCryptorRef, const void *, size_t, void *,
+                                size_t, size_t *);
+CCCryptorStatus CCCryptorFinal(CCCryptorRef, void *, size_t, size_t *);
+CCCryptorStatus CCCryptorRelease(CCCryptorRef);
+
+CCCryptorStatus CCCryptorGCMAddIV(CCCryptorRef, const void *, size_t);
+CCCryptorStatus CCCryptorGCMAddAAD(CCCryptorRef, const void *, size_t);
+CCCryptorStatus CCCryptorGCMEncrypt(CCCryptorRef, const void *, size_t,
+                                    void *);
+CCCryptorStatus CCCryptorGCMDecrypt(CCCryptorRef, const void *, size_t,
+                                    void *);
+CCCryptorStatus CCCryptorGCMFinal(CCCryptorRef, const void *, size_t *);
+CCCryptorStatus CCCryptorGCMReset(CCCryptorRef);
+"""
+
+MACROS = """
+"""
+
+CUSTOMIZATIONS = """
+/* Not defined in the public header */
+enum {
+    kCCModeGCM = 11
+};
+"""
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/commoncrypto/common_digest.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/commoncrypto/common_digest.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/commoncrypto/common_digest.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/commoncrypto/common_digest.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,58 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+INCLUDES = """
+#include <CommonCrypto/CommonDigest.h>
+"""
+
+TYPES = """
+typedef uint32_t CC_LONG;
+typedef uint64_t CC_LONG64;
+typedef struct CC_MD5state_st {
+    ...;
+} CC_MD5_CTX;
+typedef struct CC_SHA1state_st {
+    ...;
+} CC_SHA1_CTX;
+typedef struct CC_SHA256state_st {
+    ...;
+} CC_SHA256_CTX;
+typedef struct CC_SHA512state_st {
+    ...;
+} CC_SHA512_CTX;
+"""
+
+FUNCTIONS = """
+int CC_MD5_Init(CC_MD5_CTX *);
+int CC_MD5_Update(CC_MD5_CTX *, const void *, CC_LONG);
+int CC_MD5_Final(unsigned char *, CC_MD5_CTX *);
+
+int CC_SHA1_Init(CC_SHA1_CTX *);
+int CC_SHA1_Update(CC_SHA1_CTX *, const void *, CC_LONG);
+int CC_SHA1_Final(unsigned char *, CC_SHA1_CTX *);
+
+int CC_SHA224_Init(CC_SHA256_CTX *);
+int CC_SHA224_Update(CC_SHA256_CTX *, const void *, CC_LONG);
+int CC_SHA224_Final(unsigned char *, CC_SHA256_CTX *);
+
+int CC_SHA256_Init(CC_SHA256_CTX *);
+int CC_SHA256_Update(CC_SHA256_CTX *, const void *, CC_LONG);
+int CC_SHA256_Final(unsigned char *, CC_SHA256_CTX *);
+
+int CC_SHA384_Init(CC_SHA512_CTX *);
+int CC_SHA384_Update(CC_SHA512_CTX *, const void *, CC_LONG);
+int CC_SHA384_Final(unsigned char *, CC_SHA512_CTX *);
+
+int CC_SHA512_Init(CC_SHA512_CTX *);
+int CC_SHA512_Update(CC_SHA512_CTX *, const void *, CC_LONG);
+int CC_SHA512_Final(unsigned char *, CC_SHA512_CTX *);
+"""
+
+MACROS = """
+"""
+
+CUSTOMIZATIONS = """
+"""
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/commoncrypto/common_hmac.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/commoncrypto/common_hmac.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/commoncrypto/common_hmac.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/commoncrypto/common_hmac.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,37 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+INCLUDES = """
+#include <CommonCrypto/CommonHMAC.h>
+"""
+
+TYPES = """
+typedef struct {
+    ...;
+} CCHmacContext;
+enum {
+    kCCHmacAlgSHA1,
+    kCCHmacAlgMD5,
+    kCCHmacAlgSHA256,
+    kCCHmacAlgSHA384,
+    kCCHmacAlgSHA512,
+    kCCHmacAlgSHA224
+};
+typedef uint32_t CCHmacAlgorithm;
+"""
+
+FUNCTIONS = """
+void CCHmacInit(CCHmacContext *, CCHmacAlgorithm, const void *, size_t);
+void CCHmacUpdate(CCHmacContext *, const void *, size_t);
+void CCHmacFinal(CCHmacContext *, void *);
+
+"""
+
+MACROS = """
+"""
+
+CUSTOMIZATIONS = """
+"""
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/commoncrypto/common_key_derivation.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/commoncrypto/common_key_derivation.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/commoncrypto/common_key_derivation.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/commoncrypto/common_key_derivation.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,39 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+INCLUDES = """
+#include <CommonCrypto/CommonKeyDerivation.h>
+"""
+
+TYPES = """
+enum {
+    kCCPBKDF2 = 2,
+};
+typedef uint32_t CCPBKDFAlgorithm;
+enum {
+    kCCPRFHmacAlgSHA1 = 1,
+    kCCPRFHmacAlgSHA224 = 2,
+    kCCPRFHmacAlgSHA256 = 3,
+    kCCPRFHmacAlgSHA384 = 4,
+    kCCPRFHmacAlgSHA512 = 5,
+};
+typedef uint32_t CCPseudoRandomAlgorithm;
+typedef unsigned int uint;
+"""
+
+FUNCTIONS = """
+int CCKeyDerivationPBKDF(CCPBKDFAlgorithm, const char *, size_t,
+                         const uint8_t *, size_t, CCPseudoRandomAlgorithm,
+                         uint, uint8_t *, size_t);
+uint CCCalibratePBKDF(CCPBKDFAlgorithm, size_t, size_t,
+                      CCPseudoRandomAlgorithm, size_t, uint32_t);
+"""
+
+MACROS = """
+"""
+
+CUSTOMIZATIONS = """
+"""
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/commoncrypto/common_symmetric_key_wrap.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/commoncrypto/common_symmetric_key_wrap.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/commoncrypto/common_symmetric_key_wrap.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/commoncrypto/common_symmetric_key_wrap.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,35 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+INCLUDES = """
+#include <CommonCrypto/CommonSymmetricKeywrap.h>
+"""
+
+TYPES = """
+enum {
+    kCCWRAPAES = 1,
+};
+
+typedef uint32_t CCWrappingAlgorithm;
+"""
+
+FUNCTIONS = """
+int CCSymmetricKeyWrap(CCWrappingAlgorithm, const uint8_t *, const size_t,
+                        const uint8_t *, size_t, const uint8_t *, size_t,
+                        uint8_t *, size_t *);
+int CCSymmetricKeyUnwrap(CCWrappingAlgorithm algorithm, const uint8_t *,
+                         const size_t, const uint8_t *, size_t,
+                         const uint8_t *, size_t, uint8_t *, size_t *);
+size_t CCSymmetricWrappedSize(CCWrappingAlgorithm, size_t);
+size_t CCSymmetricUnwrappedSize(CCWrappingAlgorithm, size_t);
+
+"""
+
+MACROS = """
+"""
+
+CUSTOMIZATIONS = """
+"""
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/commoncrypto/__init__.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/commoncrypto/__init__.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/commoncrypto/__init__.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/commoncrypto/__init__.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,5 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/commoncrypto/secimport.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/commoncrypto/secimport.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/commoncrypto/secimport.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/commoncrypto/secimport.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,86 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+INCLUDES = """
+#include <Security/SecImportExport.h>
+"""
+
+TYPES = """
+typedef ... *SecAccessRef;
+
+CFStringRef kSecImportExportPassphrase;
+CFStringRef kSecImportExportKeychain;
+CFStringRef kSecImportExportAccess;
+
+typedef uint32_t SecExternalItemType;
+enum {
+    kSecItemTypeUnknown,
+    kSecItemTypePrivateKey,
+    kSecItemTypePublicKey,
+    kSecItemTypeSessionKey,
+    kSecItemTypeCertificate,
+    kSecItemTypeAggregate
+};
+
+
+typedef uint32_t SecExternalFormat;
+enum {
+    kSecFormatUnknown = 0,
+    kSecFormatOpenSSL,
+    kSecFormatSSH,
+    kSecFormatBSAFE,
+    kSecFormatRawKey,
+    kSecFormatWrappedPKCS8,
+    kSecFormatWrappedOpenSSL,
+    kSecFormatWrappedSSH,
+    kSecFormatWrappedLSH,
+    kSecFormatX509Cert,
+    kSecFormatPEMSequence,
+    kSecFormatPKCS7,
+    kSecFormatPKCS12,
+    kSecFormatNetscapeCertSequence,
+    kSecFormatSSHv2
+};
+
+typedef uint32_t SecItemImportExportFlags;
+enum {
+    kSecKeyImportOnlyOne        = 0x00000001,
+    kSecKeySecurePassphrase     = 0x00000002,
+    kSecKeyNoAccessControl      = 0x00000004
+};
+typedef uint32_t SecKeyImportExportFlags;
+
+typedef struct {
+    /* for import and export */
+    uint32_t version;
+    SecKeyImportExportFlags  flags;
+    CFTypeRef                passphrase;
+    CFStringRef              alertTitle;
+    CFStringRef              alertPrompt;
+
+    /* for import only */
+    SecAccessRef             accessRef;
+    CFArrayRef               keyUsage;
+
+    CFArrayRef               keyAttributes;
+} SecItemImportExportKeyParameters;
+"""
+
+FUNCTIONS = """
+OSStatus SecItemImport(CFDataRef, CFStringRef, SecExternalFormat *,
+                       SecExternalItemType *, SecItemImportExportFlags,
+                       const SecItemImportExportKeyParameters *,
+                       SecKeychainRef, CFArrayRef *);
+OSStatus SecPKCS12Import(CFDataRef, CFDictionaryRef, CFArrayRef *);
+OSStatus SecItemExport(CFTypeRef, SecExternalFormat, SecItemImportExportFlags,
+                       const SecItemImportExportKeyParameters *, CFDataRef *);
+"""
+
+MACROS = """
+"""
+
+CUSTOMIZATIONS = """
+"""
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/commoncrypto/secitem.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/commoncrypto/secitem.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/commoncrypto/secitem.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/commoncrypto/secitem.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,27 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+INCLUDES = """
+#include <Security/SecItem.h>
+"""
+
+TYPES = """
+const CFTypeRef kSecAttrKeyType;
+const CFTypeRef kSecAttrKeySizeInBits;
+const CFTypeRef kSecAttrIsPermanent;
+const CFTypeRef kSecAttrKeyTypeRSA;
+const CFTypeRef kSecAttrKeyTypeDSA;
+const CFTypeRef kSecUseKeychain;
+"""
+
+FUNCTIONS = """
+"""
+
+MACROS = """
+"""
+
+CUSTOMIZATIONS = """
+"""
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/commoncrypto/seckeychain.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/commoncrypto/seckeychain.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/commoncrypto/seckeychain.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/commoncrypto/seckeychain.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,25 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+INCLUDES = """
+#include <Security/SecKeychain.h>
+"""
+
+TYPES = """
+typedef ... *SecKeychainRef;
+"""
+
+FUNCTIONS = """
+OSStatus SecKeychainCreate(const char *, UInt32, const void *, Boolean,
+                           SecAccessRef, SecKeychainRef *);
+OSStatus SecKeychainDelete(SecKeychainRef);
+"""
+
+MACROS = """
+"""
+
+CUSTOMIZATIONS = """
+"""
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/commoncrypto/seckey.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/commoncrypto/seckey.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/commoncrypto/seckey.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/commoncrypto/seckey.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,24 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+INCLUDES = """
+#include <Security/SecKey.h>
+"""
+
+TYPES = """
+typedef ... *SecKeyRef;
+"""
+
+FUNCTIONS = """
+OSStatus SecKeyGeneratePair(CFDictionaryRef, SecKeyRef *, SecKeyRef *);
+size_t SecKeyGetBlockSize(SecKeyRef);
+"""
+
+MACROS = """
+"""
+
+CUSTOMIZATIONS = """
+"""
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/commoncrypto/sectransform.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/commoncrypto/sectransform.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/commoncrypto/sectransform.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/commoncrypto/sectransform.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,68 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+INCLUDES = """
+#include <Security/SecDigestTransform.h>
+#include <Security/SecSignVerifyTransform.h>
+#include <Security/SecEncryptTransform.h>
+"""
+
+TYPES = """
+typedef ... *SecTransformRef;
+
+CFStringRef kSecImportExportPassphrase;
+CFStringRef kSecImportExportKeychain;
+CFStringRef kSecImportExportAccess;
+
+CFStringRef kSecEncryptionMode;
+CFStringRef kSecEncryptKey;
+CFStringRef kSecIVKey;
+CFStringRef kSecModeCBCKey;
+CFStringRef kSecModeCFBKey;
+CFStringRef kSecModeECBKey;
+CFStringRef kSecModeNoneKey;
+CFStringRef kSecModeOFBKey;
+CFStringRef kSecOAEPEncodingParametersAttributeName;
+CFStringRef kSecPaddingKey;
+CFStringRef kSecPaddingNoneKey;
+CFStringRef kSecPaddingOAEPKey;
+CFStringRef kSecPaddingPKCS1Key;
+CFStringRef kSecPaddingPKCS5Key;
+CFStringRef kSecPaddingPKCS7Key;
+
+const CFStringRef kSecTransformInputAttributeName;
+const CFStringRef kSecTransformOutputAttributeName;
+const CFStringRef kSecTransformDebugAttributeName;
+const CFStringRef kSecTransformTransformName;
+const CFStringRef kSecTransformAbortAttributeName;
+
+CFStringRef kSecInputIsAttributeName;
+CFStringRef kSecInputIsPlainText;
+CFStringRef kSecInputIsDigest;
+CFStringRef kSecInputIsRaw;
+
+const CFStringRef kSecDigestTypeAttribute;
+const CFStringRef kSecDigestLengthAttribute;
+const CFStringRef kSecDigestMD5;
+const CFStringRef kSecDigestSHA1;
+const CFStringRef kSecDigestSHA2;
+"""
+
+FUNCTIONS = """
+Boolean SecTransformSetAttribute(SecTransformRef, CFStringRef, CFTypeRef,
+                                 CFErrorRef *);
+SecTransformRef SecDecryptTransformCreate(SecKeyRef, CFErrorRef *);
+SecTransformRef SecEncryptTransformCreate(SecKeyRef, CFErrorRef *);
+SecTransformRef SecVerifyTransformCreate(SecKeyRef, CFDataRef, CFErrorRef *);
+SecTransformRef SecSignTransformCreate(SecKeyRef, CFErrorRef *) ;
+CFTypeRef SecTransformExecute(SecTransformRef, CFErrorRef *);
+"""
+
+MACROS = """
+"""
+
+CUSTOMIZATIONS = """
+"""
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/hazmat_src/constant_time.c hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/hazmat_src/constant_time.c
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/hazmat_src/constant_time.c	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/hazmat_src/constant_time.c	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,22 @@
+// This file is dual licensed under the terms of the Apache License, Version
+// 2.0, and the BSD License. See the LICENSE file in the root of this
+// repository for complete details.
+
+uint8_t Cryptography_constant_time_bytes_eq(uint8_t *a, size_t len_a,
+                                            uint8_t *b, size_t len_b) {
+    size_t i = 0;
+    uint8_t mismatch = 0;
+    if (len_a != len_b) {
+        return 0;
+    }
+    for (i = 0; i < len_a; i++) {
+        mismatch |= a[i] ^ b[i];
+    }
+
+    /* Make sure any bits set are copied to the lowest bit */
+    mismatch |= mismatch >> 4;
+    mismatch |= mismatch >> 2;
+    mismatch |= mismatch >> 1;
+    /* Now check the low bit to see if it's set */
+    return (mismatch & 1) == 0;
+}
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/hazmat_src/constant_time.h hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/hazmat_src/constant_time.h
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/hazmat_src/constant_time.h	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/hazmat_src/constant_time.h	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,6 @@
+// This file is dual licensed under the terms of the Apache License, Version
+// 2.0, and the BSD License. See the LICENSE file in the root of this
+// repository for complete details.
+
+uint8_t Cryptography_constant_time_bytes_eq(uint8_t *, size_t, uint8_t *,
+                                            size_t);
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/hazmat_src/padding.c hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/hazmat_src/padding.c
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/hazmat_src/padding.c	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/hazmat_src/padding.c	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,39 @@
+// This file is dual licensed under the terms of the Apache License, Version
+// 2.0, and the BSD License. See the LICENSE file in the root of this
+// repository for complete details.
+
+/* Returns the value of the input with the most-significant-bit copied to all
+   of the bits. */
+static uint8_t Cryptography_DUPLICATE_MSB_TO_ALL(uint8_t a) {
+    return (1 - (a >> (sizeof(uint8_t) * 8 - 1))) - 1;
+}
+
+/* This returns 0xFF if a < b else 0x00, but does so in a constant time
+   fashion */
+static uint8_t Cryptography_constant_time_lt(uint8_t a, uint8_t b) {
+    a -= b;
+    return Cryptography_DUPLICATE_MSB_TO_ALL(a);
+}
+
+uint8_t Cryptography_check_pkcs7_padding(const uint8_t *data,
+                                         uint8_t block_len) {
+    uint8_t i;
+    uint8_t pad_size = data[block_len - 1];
+    uint8_t mismatch = 0;
+    for (i = 0; i < block_len; i++) {
+        unsigned int mask = Cryptography_constant_time_lt(i, pad_size);
+        uint8_t b = data[block_len - 1 - i];
+        mismatch |= (mask & (pad_size ^ b));
+    }
+
+    /* Check to make sure the pad_size was within the valid range. */
+    mismatch |= ~Cryptography_constant_time_lt(0, pad_size);
+    mismatch |= Cryptography_constant_time_lt(block_len, pad_size);
+
+    /* Make sure any bits set are copied to the lowest bit */
+    mismatch |= mismatch >> 4;
+    mismatch |= mismatch >> 2;
+    mismatch |= mismatch >> 1;
+    /* Now check the low bit to see if it's set */
+    return (mismatch & 1) == 0;
+}
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/hazmat_src/padding.h hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/hazmat_src/padding.h
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/hazmat_src/padding.h	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/hazmat_src/padding.h	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,5 @@
+// This file is dual licensed under the terms of the Apache License, Version
+// 2.0, and the BSD License. See the LICENSE file in the root of this
+// repository for complete details.
+
+uint8_t Cryptography_check_pkcs7_padding(const uint8_t *, uint8_t);
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/aes.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/aes.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/aes.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/aes.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,54 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+INCLUDES = """
+#include <openssl/aes.h>
+"""
+
+TYPES = """
+static const int Cryptography_HAS_AES_WRAP;
+
+struct aes_key_st {
+    ...;
+};
+typedef struct aes_key_st AES_KEY;
+"""
+
+FUNCTIONS = """
+int AES_set_encrypt_key(const unsigned char *, const int, AES_KEY *);
+int AES_set_decrypt_key(const unsigned char *, const int, AES_KEY *);
+"""
+
+MACROS = """
+/* these can be moved back to FUNCTIONS once we drop support for 0.9.8h.
+   This should be when we drop RHEL/CentOS 5, which is on 0.9.8e. */
+int AES_wrap_key(AES_KEY *, const unsigned char *, unsigned char *,
+                 const unsigned char *, unsigned int);
+int AES_unwrap_key(AES_KEY *, const unsigned char *, unsigned char *,
+                   const unsigned char *, unsigned int);
+
+/* The ctr128_encrypt function is only useful in 0.9.8. You should use EVP for
+   this in 1.0.0+. It is defined in macros because the function signature
+   changed after 0.9.8 */
+void AES_ctr128_encrypt(const unsigned char *, unsigned char *,
+                        const size_t, const AES_KEY *,
+                        unsigned char[], unsigned char[], unsigned int *);
+
+"""
+
+CUSTOMIZATIONS = """
+/* OpenSSL 0.9.8h+ */
+#if OPENSSL_VERSION_NUMBER >= 0x0090808fL
+static const long Cryptography_HAS_AES_WRAP = 1;
+#else
+static const long Cryptography_HAS_AES_WRAP = 0;
+int (*AES_wrap_key)(AES_KEY *, const unsigned char *, unsigned char *,
+                    const unsigned char *, unsigned int) = NULL;
+int (*AES_unwrap_key)(AES_KEY *, const unsigned char *, unsigned char *,
+                      const unsigned char *, unsigned int) = NULL;
+#endif
+
+"""
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/asn1.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/asn1.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/asn1.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/asn1.py	2015-11-19 05:01:40.000000000 +0100
@@ -0,0 +1,155 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+INCLUDES = """
+#include <openssl/asn1.h>
+"""
+
+TYPES = """
+typedef int... time_t;
+
+typedef int ASN1_BOOLEAN;
+typedef ... ASN1_INTEGER;
+
+struct asn1_string_st {
+    int length;
+    int type;
+    unsigned char *data;
+    long flags;
+};
+
+typedef struct asn1_string_st ASN1_OCTET_STRING;
+typedef struct asn1_string_st ASN1_IA5STRING;
+typedef ... ASN1_BIT_STRING;
+typedef ... ASN1_OBJECT;
+typedef struct asn1_string_st ASN1_STRING;
+typedef struct asn1_string_st ASN1_UTF8STRING;
+typedef ... ASN1_TYPE;
+typedef ... ASN1_GENERALIZEDTIME;
+typedef ... ASN1_ENUMERATED;
+typedef ... ASN1_ITEM;
+typedef ... ASN1_VALUE;
+
+typedef struct {
+    ...;
+} ASN1_TIME;
+typedef ... ASN1_ITEM_EXP;
+
+typedef ... ASN1_UTCTIME;
+
+static const int V_ASN1_GENERALIZEDTIME;
+
+static const int MBSTRING_FLAG;
+static const int MBSTRING_ASC;
+static const int MBSTRING_BMP;
+static const int MBSTRING_UTF8;
+static const int MBSTRING_UNIV;
+"""
+
+FUNCTIONS = """
+ASN1_OBJECT *ASN1_OBJECT_new(void);
+void ASN1_OBJECT_free(ASN1_OBJECT *);
+
+/*  ASN1 OBJECT IDENTIFIER */
+ASN1_OBJECT *d2i_ASN1_OBJECT(ASN1_OBJECT **, const unsigned char **, long);
+int i2d_ASN1_OBJECT(ASN1_OBJECT *, unsigned char **);
+
+/*  ASN1 STRING */
+ASN1_STRING *ASN1_STRING_new(void);
+ASN1_STRING *ASN1_STRING_type_new(int);
+void ASN1_STRING_free(ASN1_STRING *);
+unsigned char *ASN1_STRING_data(ASN1_STRING *);
+int ASN1_STRING_set(ASN1_STRING *, const void *, int);
+int ASN1_STRING_type(ASN1_STRING *);
+int ASN1_STRING_to_UTF8(unsigned char **, ASN1_STRING *);
+
+/*  ASN1 OCTET STRING */
+ASN1_OCTET_STRING *ASN1_OCTET_STRING_new(void);
+void ASN1_OCTET_STRING_free(ASN1_OCTET_STRING *);
+int ASN1_OCTET_STRING_set(ASN1_OCTET_STRING *, const unsigned char *, int);
+
+/* ASN1 IA5STRING */
+ASN1_IA5STRING *ASN1_IA5STRING_new(void);
+
+/*  ASN1 INTEGER */
+ASN1_INTEGER *ASN1_INTEGER_new(void);
+void ASN1_INTEGER_free(ASN1_INTEGER *);
+int ASN1_INTEGER_set(ASN1_INTEGER *, long);
+int i2a_ASN1_INTEGER(BIO *, ASN1_INTEGER *);
+
+/*  ASN1 TIME */
+ASN1_TIME *ASN1_TIME_new(void);
+void ASN1_TIME_free(ASN1_TIME *);
+ASN1_GENERALIZEDTIME *ASN1_TIME_to_generalizedtime(ASN1_TIME *,
+                                                   ASN1_GENERALIZEDTIME **);
+ASN1_TIME *ASN1_TIME_set(ASN1_TIME *, time_t);
+
+/*  ASN1 UTCTIME */
+ASN1_UTCTIME *ASN1_UTCTIME_new(void);
+void ASN1_UTCTIME_free(ASN1_UTCTIME *);
+int ASN1_UTCTIME_cmp_time_t(const ASN1_UTCTIME *, time_t);
+ASN1_UTCTIME *ASN1_UTCTIME_set(ASN1_UTCTIME *, time_t);
+
+/*  ASN1 GENERALIZEDTIME */
+int ASN1_GENERALIZEDTIME_set_string(ASN1_GENERALIZEDTIME *, const char *);
+void ASN1_GENERALIZEDTIME_free(ASN1_GENERALIZEDTIME *);
+
+/*  ASN1 ENUMERATED */
+ASN1_ENUMERATED *ASN1_ENUMERATED_new(void);
+void ASN1_ENUMERATED_free(ASN1_ENUMERATED *);
+int ASN1_ENUMERATED_set(ASN1_ENUMERATED *, long);
+long ASN1_ENUMERATED_get(ASN1_ENUMERATED *);
+
+ASN1_VALUE *ASN1_item_d2i(ASN1_VALUE **, const unsigned char **, long,
+                          const ASN1_ITEM *);
+int ASN1_BIT_STRING_set_bit(ASN1_BIT_STRING *, int, int);
+"""
+
+MACROS = """
+ASN1_UTF8STRING *ASN1_UTF8STRING_new(void);
+void ASN1_UTF8STRING_free(ASN1_UTF8STRING *);
+
+ASN1_BIT_STRING *ASN1_BIT_STRING_new(void);
+void ASN1_BIT_STRING_free(ASN1_BIT_STRING *);
+int i2d_ASN1_BIT_STRING(ASN1_BIT_STRING *, unsigned char **);
+int i2d_ASN1_OCTET_STRING(ASN1_OCTET_STRING *, unsigned char **);
+int i2d_ASN1_INTEGER(ASN1_INTEGER *, unsigned char **);
+/* This is not a macro, but is const on some versions of OpenSSL */
+int ASN1_BIT_STRING_get_bit(ASN1_BIT_STRING *, int);
+ASN1_TIME *M_ASN1_TIME_dup(void *);
+const ASN1_ITEM *ASN1_ITEM_ptr(ASN1_ITEM_EXP *);
+
+/* These aren't macros these arguments are all const X on openssl > 1.0.x */
+
+int ASN1_TIME_print(BIO *, ASN1_TIME *);
+int ASN1_STRING_length(ASN1_STRING *);
+ASN1_STRING *ASN1_STRING_dup(ASN1_STRING *);
+int ASN1_STRING_cmp(ASN1_STRING *, ASN1_STRING *);
+int ASN1_UTCTIME_print(BIO *, ASN1_UTCTIME *);
+
+ASN1_OCTET_STRING *ASN1_OCTET_STRING_dup(ASN1_OCTET_STRING *);
+int ASN1_OCTET_STRING_cmp(ASN1_OCTET_STRING *, ASN1_OCTET_STRING *);
+
+ASN1_INTEGER *ASN1_INTEGER_dup(ASN1_INTEGER *);
+int ASN1_INTEGER_cmp(ASN1_INTEGER *, ASN1_INTEGER *);
+long ASN1_INTEGER_get(ASN1_INTEGER *);
+
+BIGNUM *ASN1_INTEGER_to_BN(ASN1_INTEGER *, BIGNUM *);
+ASN1_INTEGER *BN_to_ASN1_INTEGER(BIGNUM *, ASN1_INTEGER *);
+
+/* These isn't a macro the arg is const on openssl 1.0.2+ */
+int ASN1_GENERALIZEDTIME_check(ASN1_GENERALIZEDTIME *);
+int ASN1_UTCTIME_check(ASN1_UTCTIME *);
+
+/* Not a macro, const on openssl 1.0 */
+int ASN1_STRING_set_default_mask_asc(char *);
+
+int i2d_ASN1_TYPE(ASN1_TYPE *, unsigned char **);
+ASN1_TYPE *d2i_ASN1_TYPE(ASN1_TYPE **, const unsigned char **, long);
+"""
+
+CUSTOMIZATIONS = """
+"""
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/bignum.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/bignum.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/bignum.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/bignum.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,86 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+INCLUDES = """
+#include <openssl/bn.h>
+"""
+
+TYPES = """
+typedef ... BN_CTX;
+typedef ... BIGNUM;
+typedef int... BN_ULONG;
+"""
+
+FUNCTIONS = """
+BIGNUM *BN_new(void);
+void BN_free(BIGNUM *);
+
+BN_CTX *BN_CTX_new(void);
+void BN_CTX_free(BN_CTX *);
+
+void BN_CTX_start(BN_CTX *);
+BIGNUM *BN_CTX_get(BN_CTX *);
+void BN_CTX_end(BN_CTX *);
+
+BIGNUM *BN_copy(BIGNUM *, const BIGNUM *);
+BIGNUM *BN_dup(const BIGNUM *);
+
+int BN_set_word(BIGNUM *, BN_ULONG);
+BN_ULONG BN_get_word(const BIGNUM *);
+
+const BIGNUM *BN_value_one(void);
+
+char *BN_bn2hex(const BIGNUM *);
+int BN_hex2bn(BIGNUM **, const char *);
+int BN_dec2bn(BIGNUM **, const char *);
+
+int BN_bn2bin(const BIGNUM *, unsigned char *);
+BIGNUM *BN_bin2bn(const unsigned char *, int, BIGNUM *);
+
+int BN_num_bits(const BIGNUM *);
+
+int BN_cmp(const BIGNUM *, const BIGNUM *);
+int BN_add(BIGNUM *, const BIGNUM *, const BIGNUM *);
+int BN_sub(BIGNUM *, const BIGNUM *, const BIGNUM *);
+int BN_mul(BIGNUM *, const BIGNUM *, const BIGNUM *, BN_CTX *);
+int BN_sqr(BIGNUM *, const BIGNUM *, BN_CTX *);
+int BN_div(BIGNUM *, BIGNUM *, const BIGNUM *, const BIGNUM *, BN_CTX *);
+int BN_nnmod(BIGNUM *, const BIGNUM *, const BIGNUM *, BN_CTX *);
+int BN_mod_add(BIGNUM *, const BIGNUM *, const BIGNUM *, const BIGNUM *,
+               BN_CTX *);
+int BN_mod_sub(BIGNUM *, const BIGNUM *, const BIGNUM *, const BIGNUM *,
+               BN_CTX *);
+int BN_mod_mul(BIGNUM *, const BIGNUM *, const BIGNUM *, const BIGNUM *,
+               BN_CTX *);
+int BN_mod_sqr(BIGNUM *, const BIGNUM *, const BIGNUM *, BN_CTX *);
+int BN_exp(BIGNUM *, const BIGNUM *, const BIGNUM *, BN_CTX *);
+int BN_mod_exp(BIGNUM *, const BIGNUM *, const BIGNUM *, const BIGNUM *,
+               BN_CTX *);
+int BN_gcd(BIGNUM *, const BIGNUM *, const BIGNUM *, BN_CTX *);
+BIGNUM *BN_mod_inverse(BIGNUM *, const BIGNUM *, const BIGNUM *, BN_CTX *);
+
+int BN_set_bit(BIGNUM *, int);
+int BN_clear_bit(BIGNUM *, int);
+
+int BN_is_bit_set(const BIGNUM *, int);
+
+int BN_mask_bits(BIGNUM *, int);
+"""
+
+MACROS = """
+int BN_zero(BIGNUM *);
+int BN_one(BIGNUM *);
+int BN_mod(BIGNUM *, const BIGNUM *, const BIGNUM *, BN_CTX *);
+
+int BN_lshift(BIGNUM *, const BIGNUM *, int);
+int BN_lshift1(BIGNUM *, BIGNUM *);
+
+int BN_rshift(BIGNUM *, BIGNUM *, int);
+int BN_rshift1(BIGNUM *, BIGNUM *);
+"""
+
+CUSTOMIZATIONS = """
+"""
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/bio.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/bio.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/bio.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/bio.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,170 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+INCLUDES = """
+#include <openssl/bio.h>
+"""
+
+TYPES = """
+typedef struct bio_st BIO;
+typedef void bio_info_cb(BIO *, int, const char *, int, long, long);
+struct bio_method_st {
+    int type;
+    const char *name;
+    int (*bwrite)(BIO *, const char *, int);
+    int (*bread)(BIO *, char *, int);
+    int (*bputs)(BIO *, const char *);
+    int (*bgets)(BIO *, char *, int);
+    long (*ctrl)(BIO *, int, long, void *);
+    int (*create)(BIO *);
+    int (*destroy)(BIO *);
+    long (*callback_ctrl)(BIO *, int, bio_info_cb *);
+    ...;
+};
+typedef struct bio_method_st BIO_METHOD;
+struct bio_st {
+    BIO_METHOD *method;
+    long (*callback)(struct bio_st *, int, const char *, int, long, long);
+    char *cb_arg;
+    int init;
+    int shutdown;
+    int flags;
+    int retry_reason;
+    int num;
+    void *ptr;
+    struct bio_st *next_bio;
+    struct bio_st *prev_bio;
+    int references;
+    unsigned long num_read;
+    unsigned long num_write;
+    ...;
+};
+typedef ... BUF_MEM;
+
+static const int BIO_TYPE_MEM;
+static const int BIO_TYPE_FILE;
+static const int BIO_TYPE_FD;
+static const int BIO_TYPE_SOCKET;
+static const int BIO_TYPE_CONNECT;
+static const int BIO_TYPE_ACCEPT;
+static const int BIO_TYPE_NULL;
+static const int BIO_CLOSE;
+static const int BIO_NOCLOSE;
+static const int BIO_TYPE_SOURCE_SINK;
+static const int BIO_CTRL_RESET;
+static const int BIO_CTRL_EOF;
+static const int BIO_CTRL_SET;
+static const int BIO_CTRL_SET_CLOSE;
+static const int BIO_CTRL_FLUSH;
+static const int BIO_CTRL_DUP;
+static const int BIO_CTRL_GET_CLOSE;
+static const int BIO_CTRL_INFO;
+static const int BIO_CTRL_GET;
+static const int BIO_CTRL_PENDING;
+static const int BIO_CTRL_WPENDING;
+static const int BIO_C_FILE_SEEK;
+static const int BIO_C_FILE_TELL;
+static const int BIO_TYPE_NONE;
+static const int BIO_TYPE_PROXY_CLIENT;
+static const int BIO_TYPE_PROXY_SERVER;
+static const int BIO_TYPE_NBIO_TEST;
+static const int BIO_TYPE_BER;
+static const int BIO_TYPE_BIO;
+static const int BIO_TYPE_DESCRIPTOR;
+static const int BIO_FLAGS_READ;
+static const int BIO_FLAGS_WRITE;
+static const int BIO_FLAGS_IO_SPECIAL;
+static const int BIO_FLAGS_RWS;
+static const int BIO_FLAGS_SHOULD_RETRY;
+static const int BIO_TYPE_NULL_FILTER;
+static const int BIO_TYPE_SSL;
+static const int BIO_TYPE_MD;
+static const int BIO_TYPE_BUFFER;
+static const int BIO_TYPE_CIPHER;
+static const int BIO_TYPE_BASE64;
+static const int BIO_TYPE_FILTER;
+"""
+
+FUNCTIONS = """
+BIO *BIO_new(BIO_METHOD *);
+int BIO_set(BIO *, BIO_METHOD *);
+int BIO_free(BIO *);
+void BIO_vfree(BIO *);
+void BIO_free_all(BIO *);
+BIO *BIO_push(BIO *, BIO *);
+BIO *BIO_pop(BIO *);
+BIO *BIO_next(BIO *);
+BIO *BIO_find_type(BIO *, int);
+BIO_METHOD *BIO_s_mem(void);
+BIO *BIO_new_mem_buf(void *, int);
+BIO_METHOD *BIO_s_file(void);
+BIO *BIO_new_file(const char *, const char *);
+BIO *BIO_new_fp(FILE *, int);
+BIO_METHOD *BIO_s_fd(void);
+BIO *BIO_new_fd(int, int);
+BIO_METHOD *BIO_s_socket(void);
+BIO *BIO_new_socket(int, int);
+BIO_METHOD *BIO_s_null(void);
+long BIO_ctrl(BIO *, int, long, void *);
+long BIO_callback_ctrl(
+    BIO *,
+    int,
+    void (*)(struct bio_st *, int, const char *, int, long, long)
+);
+char *BIO_ptr_ctrl(BIO *, int, long);
+long BIO_int_ctrl(BIO *, int, long, int);
+size_t BIO_ctrl_pending(BIO *);
+size_t BIO_ctrl_wpending(BIO *);
+int BIO_read(BIO *, void *, int);
+int BIO_gets(BIO *, char *, int);
+int BIO_write(BIO *, const void *, int);
+int BIO_puts(BIO *, const char *);
+BIO_METHOD *BIO_f_null(void);
+BIO_METHOD *BIO_f_buffer(void);
+"""
+
+MACROS = """
+long BIO_set_fd(BIO *, long, int);
+long BIO_get_fd(BIO *, char *);
+long BIO_set_mem_eof_return(BIO *, int);
+long BIO_get_mem_data(BIO *, char **);
+long BIO_set_mem_buf(BIO *, BUF_MEM *, int);
+long BIO_get_mem_ptr(BIO *, BUF_MEM **);
+long BIO_set_fp(BIO *, FILE *, int);
+long BIO_get_fp(BIO *, FILE **);
+long BIO_read_filename(BIO *, char *);
+long BIO_write_filename(BIO *, char *);
+long BIO_append_filename(BIO *, char *);
+long BIO_rw_filename(BIO *, char *);
+int BIO_should_read(BIO *);
+int BIO_should_write(BIO *);
+int BIO_should_io_special(BIO *);
+int BIO_retry_type(BIO *);
+int BIO_should_retry(BIO *);
+int BIO_reset(BIO *);
+int BIO_seek(BIO *, int);
+int BIO_tell(BIO *);
+int BIO_flush(BIO *);
+int BIO_eof(BIO *);
+int BIO_set_close(BIO *,long);
+int BIO_get_close(BIO *);
+int BIO_pending(BIO *);
+int BIO_wpending(BIO *);
+int BIO_get_info_callback(BIO *, bio_info_cb **);
+int BIO_set_info_callback(BIO *, bio_info_cb *);
+long BIO_get_buffer_num_lines(BIO *);
+long BIO_set_read_buffer_size(BIO *, long);
+long BIO_set_write_buffer_size(BIO *, long);
+long BIO_set_buffer_size(BIO *, long);
+long BIO_set_buffer_read_data(BIO *, void *, long);
+
+/* The following was a macro in 0.9.8e. Once we drop support for RHEL/CentOS 5
+   we should move this back to FUNCTIONS. */
+int BIO_method_type(const BIO *);
+"""
+
+CUSTOMIZATIONS = """
+"""
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/cmac.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/cmac.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/cmac.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/cmac.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,45 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+INCLUDES = """
+#if OPENSSL_VERSION_NUMBER >= 0x10001000L
+#include <openssl/cmac.h>
+#endif
+"""
+
+TYPES = """
+static const int Cryptography_HAS_CMAC;
+typedef ... CMAC_CTX;
+"""
+
+FUNCTIONS = """
+"""
+
+MACROS = """
+CMAC_CTX *CMAC_CTX_new(void);
+int CMAC_Init(CMAC_CTX *, const void *, size_t, const EVP_CIPHER *, ENGINE *);
+int CMAC_Update(CMAC_CTX *, const void *, size_t);
+int CMAC_Final(CMAC_CTX *, unsigned char *, size_t *);
+int CMAC_CTX_copy(CMAC_CTX *, const CMAC_CTX *);
+void CMAC_CTX_free(CMAC_CTX *);
+"""
+
+CUSTOMIZATIONS = """
+#if OPENSSL_VERSION_NUMBER < 0x10001000L
+
+static const long Cryptography_HAS_CMAC = 0;
+typedef void CMAC_CTX;
+CMAC_CTX *(*CMAC_CTX_new)(void) = NULL;
+int (*CMAC_Init)(CMAC_CTX *, const void *, size_t, const EVP_CIPHER *,
+    ENGINE *) = NULL;
+int (*CMAC_Update)(CMAC_CTX *, const void *, size_t) = NULL;
+int (*CMAC_Final)(CMAC_CTX *, unsigned char *, size_t *) = NULL;
+int (*CMAC_CTX_copy)(CMAC_CTX *, const CMAC_CTX *) = NULL;
+void (*CMAC_CTX_free)(CMAC_CTX *) = NULL;
+#else
+static const long Cryptography_HAS_CMAC = 1;
+#endif
+"""
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/cms.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/cms.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/cms.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/cms.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,129 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+INCLUDES = """
+#if !defined(OPENSSL_NO_CMS) && OPENSSL_VERSION_NUMBER >= 0x0090808fL
+/* The next define should really be in the OpenSSL header, but it is missing.
+   Failing to include this on Windows causes compilation failures. */
+#if defined(OPENSSL_SYS_WINDOWS)
+#include <windows.h>
+#endif
+#include <openssl/cms.h>
+#endif
+"""
+
+TYPES = """
+static const long Cryptography_HAS_CMS;
+static const long Cryptography_HAS_CMS_BIO_FUNCTIONS;
+
+typedef ... CMS_ContentInfo;
+typedef ... CMS_SignerInfo;
+typedef ... CMS_CertificateChoices;
+typedef ... CMS_RevocationInfoChoice;
+typedef ... CMS_RecipientInfo;
+typedef ... CMS_ReceiptRequest;
+typedef ... CMS_Receipt;
+
+static const int CMS_TEXT;
+static const int CMS_NOCERTS;
+static const int CMS_NO_CONTENT_VERIFY;
+static const int CMS_NO_ATTR_VERIFY;
+static const int CMS_NOSIGS;
+static const int CMS_NOINTERN;
+static const int CMS_NO_SIGNER_CERT_VERIFY;
+static const int CMS_NOVERIFY;
+static const int CMS_DETACHED;
+static const int CMS_BINARY;
+static const int CMS_NOATTR;
+static const int CMS_NOSMIMECAP;
+static const int CMS_NOOLDMIMETYPE;
+static const int CMS_CRLFEOL;
+static const int CMS_STREAM;
+static const int CMS_NOCRL;
+static const int CMS_PARTIAL;
+static const int CMS_REUSE_DIGEST;
+static const int CMS_USE_KEYID;
+static const int CMS_DEBUG_DECRYPT;
+"""
+
+FUNCTIONS = """
+"""
+
+MACROS = """
+BIO *BIO_new_CMS(BIO *, CMS_ContentInfo *);
+int i2d_CMS_bio_stream(BIO *, CMS_ContentInfo *, BIO *, int);
+int PEM_write_bio_CMS_stream(BIO *, CMS_ContentInfo *, BIO *, int);
+int CMS_final(CMS_ContentInfo *, BIO *, BIO *, unsigned int);
+CMS_ContentInfo *CMS_sign(X509 *, EVP_PKEY *, Cryptography_STACK_OF_X509 *,
+                          BIO *, unsigned int);
+int CMS_verify(CMS_ContentInfo *, Cryptography_STACK_OF_X509 *, X509_STORE *,
+               BIO *, BIO *, unsigned int);
+CMS_ContentInfo *CMS_encrypt(Cryptography_STACK_OF_X509 *, BIO *,
+                             const EVP_CIPHER *, unsigned int);
+int CMS_decrypt(CMS_ContentInfo *, EVP_PKEY *, X509 *, BIO *, BIO *,
+                unsigned int);
+CMS_SignerInfo *CMS_add1_signer(CMS_ContentInfo *, X509 *, EVP_PKEY *,
+                                const EVP_MD *, unsigned int);
+"""
+
+CUSTOMIZATIONS = """
+#if !defined(OPENSSL_NO_CMS) && OPENSSL_VERSION_NUMBER >= 0x0090808fL
+static const long Cryptography_HAS_CMS = 1;
+#if OPENSSL_VERSION_NUMBER < 0x10000000L
+static const long Cryptography_HAS_CMS_BIO_FUNCTIONS = 0;
+/* These functions were added in 1.0.0 */
+BIO *(*BIO_new_CMS)(BIO *, CMS_ContentInfo *) = NULL;
+int (*i2d_CMS_bio_stream)(BIO *, CMS_ContentInfo *, BIO *, int) = NULL;
+int (*PEM_write_bio_CMS_stream)(BIO *, CMS_ContentInfo *, BIO *, int) = NULL;
+#else
+static const long Cryptography_HAS_CMS_BIO_FUNCTIONS = 1;
+#endif
+#else
+static const long Cryptography_HAS_CMS = 0;
+static const long Cryptography_HAS_CMS_BIO_FUNCTIONS = 0;
+typedef void CMS_ContentInfo;
+typedef void CMS_SignerInfo;
+typedef void CMS_CertificateChoices;
+typedef void CMS_RevocationInfoChoice;
+typedef void CMS_RecipientInfo;
+typedef void CMS_ReceiptRequest;
+typedef void CMS_Receipt;
+const long CMS_TEXT = 0;
+const long CMS_NOCERTS = 0;
+const long CMS_NO_CONTENT_VERIFY = 0;
+const long CMS_NO_ATTR_VERIFY = 0;
+const long CMS_NOSIGS = 0;
+const long CMS_NOINTERN = 0;
+const long CMS_NO_SIGNER_CERT_VERIFY = 0;
+const long CMS_NOVERIFY = 0;
+const long CMS_DETACHED = 0;
+const long CMS_BINARY = 0;
+const long CMS_NOATTR = 0;
+const long CMS_NOSMIMECAP = 0;
+const long CMS_NOOLDMIMETYPE = 0;
+const long CMS_CRLFEOL = 0;
+const long CMS_STREAM = 0;
+const long CMS_NOCRL = 0;
+const long CMS_PARTIAL = 0;
+const long CMS_REUSE_DIGEST = 0;
+const long CMS_USE_KEYID = 0;
+const long CMS_DEBUG_DECRYPT = 0;
+BIO *(*BIO_new_CMS)(BIO *, CMS_ContentInfo *) = NULL;
+int (*i2d_CMS_bio_stream)(BIO *, CMS_ContentInfo *, BIO *, int) = NULL;
+int (*PEM_write_bio_CMS_stream)(BIO *, CMS_ContentInfo *, BIO *, int) = NULL;
+int (*CMS_final)(CMS_ContentInfo *, BIO *, BIO *, unsigned int) = NULL;
+CMS_ContentInfo *(*CMS_sign)(X509 *, EVP_PKEY *, Cryptography_STACK_OF_X509 *,
+                             BIO *, unsigned int) = NULL;
+int (*CMS_verify)(CMS_ContentInfo *, Cryptography_STACK_OF_X509 *,
+                  X509_STORE *, BIO *, BIO *, unsigned int) = NULL;
+CMS_ContentInfo *(*CMS_encrypt)(Cryptography_STACK_OF_X509 *, BIO *,
+                                const EVP_CIPHER *, unsigned int) = NULL;
+int (*CMS_decrypt)(CMS_ContentInfo *, EVP_PKEY *, X509 *, BIO *, BIO *,
+                   unsigned int) = NULL;
+CMS_SignerInfo *(*CMS_add1_signer)(CMS_ContentInfo *, X509 *, EVP_PKEY *,
+                                   const EVP_MD *, unsigned int) = NULL;
+#endif
+"""
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/conf.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/conf.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/conf.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/conf.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,24 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+INCLUDES = """
+#include <openssl/conf.h>
+"""
+
+TYPES = """
+typedef ... CONF;
+"""
+
+FUNCTIONS = """
+void OPENSSL_config(const char *);
+void OPENSSL_no_config(void);
+"""
+
+MACROS = """
+"""
+
+CUSTOMIZATIONS = """
+"""
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/crypto.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/crypto.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/crypto.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/crypto.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,55 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+INCLUDES = """
+#include <openssl/crypto.h>
+"""
+
+TYPES = """
+typedef ... CRYPTO_THREADID;
+
+static const int SSLEAY_VERSION;
+static const int SSLEAY_CFLAGS;
+static const int SSLEAY_PLATFORM;
+static const int SSLEAY_DIR;
+static const int SSLEAY_BUILT_ON;
+static const int CRYPTO_MEM_CHECK_ON;
+static const int CRYPTO_MEM_CHECK_OFF;
+static const int CRYPTO_MEM_CHECK_ENABLE;
+static const int CRYPTO_MEM_CHECK_DISABLE;
+static const int CRYPTO_LOCK;
+static const int CRYPTO_UNLOCK;
+static const int CRYPTO_READ;
+static const int CRYPTO_WRITE;
+static const int CRYPTO_LOCK_SSL;
+"""
+
+FUNCTIONS = """
+unsigned long SSLeay(void);
+const char *SSLeay_version(int);
+
+void CRYPTO_free(void *);
+int CRYPTO_mem_ctrl(int);
+int CRYPTO_is_mem_check_on(void);
+void CRYPTO_mem_leaks(struct bio_st *);
+void CRYPTO_cleanup_all_ex_data(void);
+int CRYPTO_num_locks(void);
+void CRYPTO_set_locking_callback(void(*)(int, int, const char *, int));
+void CRYPTO_set_id_callback(unsigned long (*)(void));
+unsigned long (*CRYPTO_get_id_callback(void))(void);
+void (*CRYPTO_get_locking_callback(void))(int, int, const char *, int);
+void CRYPTO_lock(int, int, const char *, int);
+
+void OPENSSL_free(void *);
+"""
+
+MACROS = """
+void CRYPTO_add(int *, int, int);
+void CRYPTO_malloc_init(void);
+"""
+
+CUSTOMIZATIONS = """
+"""
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/dh.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/dh.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/dh.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/dh.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,50 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+INCLUDES = """
+#include <openssl/dh.h>
+"""
+
+TYPES = """
+typedef struct dh_st {
+    /* Prime number (shared) */
+    BIGNUM *p;
+    /* Generator of Z_p (shared) */
+    BIGNUM *g;
+    /* Private DH value x */
+    BIGNUM *priv_key;
+    /* Public DH value g^x */
+    BIGNUM *pub_key;
+    /* X9.42/RFC 2631 */
+    BIGNUM *q;
+    BIGNUM *j;
+    ...;
+} DH;
+"""
+
+FUNCTIONS = """
+DH *DH_new(void);
+void DH_free(DH *);
+int DH_size(const DH *);
+DH *DH_generate_parameters(int, int, void (*)(int, int, void *), void *);
+int DH_check(const DH *, int *);
+int DH_check_pub_key(const DH *, const BIGNUM *, int *);
+int DH_generate_key(DH *);
+int DH_compute_key(unsigned char *, const BIGNUM *, DH *);
+int DH_set_ex_data(DH *, int, void *);
+void *DH_get_ex_data(DH *, int);
+DH *d2i_DHparams(DH **, const unsigned char **, long);
+int i2d_DHparams(const DH *, unsigned char **);
+int DHparams_print_fp(FILE *, const DH *);
+int DHparams_print(BIO *, const DH *);
+"""
+
+MACROS = """
+int DH_generate_parameters_ex(DH *, int, int, BN_GENCB *);
+"""
+
+CUSTOMIZATIONS = """
+"""
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/dsa.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/dsa.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/dsa.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/dsa.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,54 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+INCLUDES = """
+#include <openssl/dsa.h>
+"""
+
+TYPES = """
+typedef struct dsa_st {
+    /* Prime number (public) */
+    BIGNUM *p;
+    /* Subprime (160-bit, q | p-1, public) */
+    BIGNUM *q;
+    /* Generator of subgroup (public) */
+    BIGNUM *g;
+    /* Private key x */
+    BIGNUM *priv_key;
+    /* Public key y = g^x */
+    BIGNUM *pub_key;
+    ...;
+} DSA;
+typedef struct {
+    BIGNUM *r;
+    BIGNUM *s;
+} DSA_SIG;
+"""
+
+FUNCTIONS = """
+DSA *DSA_generate_parameters(int, unsigned char *, int, int *, unsigned long *,
+                             void (*)(int, int, void *), void *);
+int DSA_generate_key(DSA *);
+DSA *DSA_new(void);
+void DSA_free(DSA *);
+DSA_SIG *DSA_SIG_new(void);
+void DSA_SIG_free(DSA_SIG *);
+int i2d_DSA_SIG(const DSA_SIG *, unsigned char **);
+DSA_SIG *d2i_DSA_SIG(DSA_SIG **, const unsigned char **, long);
+int DSA_size(const DSA *);
+int DSA_sign(int, const unsigned char *, int, unsigned char *, unsigned int *,
+             DSA *);
+int DSA_verify(int, const unsigned char *, int, const unsigned char *, int,
+               DSA *);
+"""
+
+MACROS = """
+int DSA_generate_parameters_ex(DSA *, int, unsigned char *, int,
+                               int *, unsigned long *, BN_GENCB *);
+"""
+
+CUSTOMIZATIONS = """
+"""
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/ecdh.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/ecdh.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/ecdh.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/ecdh.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,50 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+INCLUDES = """
+#ifndef OPENSSL_NO_ECDH
+#include <openssl/ecdh.h>
+#endif
+"""
+
+TYPES = """
+static const int Cryptography_HAS_ECDH;
+"""
+
+FUNCTIONS = """
+"""
+
+MACROS = """
+int ECDH_compute_key(void *, size_t, const EC_POINT *, EC_KEY *,
+                     void *(*)(const void *, size_t, void *, size_t *));
+
+int ECDH_get_ex_new_index(long, void *, CRYPTO_EX_new *, CRYPTO_EX_dup *,
+                          CRYPTO_EX_free *);
+
+int ECDH_set_ex_data(EC_KEY *, int, void *);
+
+void *ECDH_get_ex_data(EC_KEY *, int);
+"""
+
+CUSTOMIZATIONS = """
+#ifdef OPENSSL_NO_ECDH
+static const long Cryptography_HAS_ECDH = 0;
+
+int (*ECDH_compute_key)(void *, size_t, const EC_POINT *, EC_KEY *,
+                        void *(*)(const void *, size_t, void *,
+                        size_t *)) = NULL;
+
+int (*ECDH_get_ex_new_index)(long, void *, CRYPTO_EX_new *, CRYPTO_EX_dup *,
+                             CRYPTO_EX_free *) = NULL;
+
+int (*ECDH_set_ex_data)(EC_KEY *, int, void *) = NULL;
+
+void *(*ECDH_get_ex_data)(EC_KEY *, int) = NULL;
+
+#else
+static const long Cryptography_HAS_ECDH = 1;
+#endif
+"""
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/ecdsa.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/ecdsa.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/ecdsa.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/ecdsa.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,97 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+INCLUDES = """
+#ifndef OPENSSL_NO_ECDSA
+#include <openssl/ecdsa.h>
+#endif
+"""
+
+TYPES = """
+static const int Cryptography_HAS_ECDSA;
+
+typedef struct {
+    BIGNUM *r;
+    BIGNUM *s;
+} ECDSA_SIG;
+
+typedef ... CRYPTO_EX_new;
+typedef ... CRYPTO_EX_dup;
+typedef ... CRYPTO_EX_free;
+"""
+
+FUNCTIONS = """
+"""
+
+MACROS = """
+ECDSA_SIG *ECDSA_SIG_new();
+void ECDSA_SIG_free(ECDSA_SIG *);
+int i2d_ECDSA_SIG(const ECDSA_SIG *, unsigned char **);
+ECDSA_SIG *d2i_ECDSA_SIG(ECDSA_SIG **s, const unsigned char **, long);
+ECDSA_SIG *ECDSA_do_sign(const unsigned char *, int, EC_KEY *);
+ECDSA_SIG *ECDSA_do_sign_ex(const unsigned char *, int, const BIGNUM *,
+                            const BIGNUM *, EC_KEY *);
+int ECDSA_do_verify(const unsigned char *, int, const ECDSA_SIG *, EC_KEY *);
+int ECDSA_sign_setup(EC_KEY *, BN_CTX *, BIGNUM **, BIGNUM **);
+int ECDSA_sign(int, const unsigned char *, int, unsigned char *,
+               unsigned int *, EC_KEY *);
+int ECDSA_sign_ex(int, const unsigned char *, int dgstlen, unsigned char *,
+                  unsigned int *, const BIGNUM *, const BIGNUM *, EC_KEY *);
+int ECDSA_verify(int, const unsigned char *, int, const unsigned char *, int,
+                 EC_KEY *);
+int ECDSA_size(const EC_KEY *);
+
+const ECDSA_METHOD *ECDSA_OpenSSL();
+void ECDSA_set_default_method(const ECDSA_METHOD *);
+const ECDSA_METHOD *ECDSA_get_default_method();
+int ECDSA_get_ex_new_index(long, void *, CRYPTO_EX_new *,
+                           CRYPTO_EX_dup *, CRYPTO_EX_free *);
+int ECDSA_set_method(EC_KEY *, const ECDSA_METHOD *);
+int ECDSA_set_ex_data(EC_KEY *, int, void *);
+void *ECDSA_get_ex_data(EC_KEY *, int);
+"""
+
+CUSTOMIZATIONS = """
+#ifdef OPENSSL_NO_ECDSA
+static const long Cryptography_HAS_ECDSA = 0;
+
+typedef struct {
+    BIGNUM *r;
+    BIGNUM *s;
+} ECDSA_SIG;
+
+ECDSA_SIG* (*ECDSA_SIG_new)() = NULL;
+void (*ECDSA_SIG_free)(ECDSA_SIG *) = NULL;
+int (*i2d_ECDSA_SIG)(const ECDSA_SIG *, unsigned char **) = NULL;
+ECDSA_SIG* (*d2i_ECDSA_SIG)(ECDSA_SIG **s, const unsigned char **,
+                            long) = NULL;
+ECDSA_SIG* (*ECDSA_do_sign)(const unsigned char *, int, EC_KEY *eckey) = NULL;
+ECDSA_SIG* (*ECDSA_do_sign_ex)(const unsigned char *, int, const BIGNUM *,
+                               const BIGNUM *, EC_KEY *) = NULL;
+int (*ECDSA_do_verify)(const unsigned char *, int, const ECDSA_SIG *,
+                       EC_KEY *) = NULL;
+int (*ECDSA_sign_setup)(EC_KEY *, BN_CTX *, BIGNUM **, BIGNUM **) = NULL;
+int (*ECDSA_sign)(int, const unsigned char *, int, unsigned char *,
+                  unsigned int *, EC_KEY *) = NULL;
+int (*ECDSA_sign_ex)(int, const unsigned char *, int dgstlen, unsigned char *,
+                     unsigned int *, const BIGNUM *, const BIGNUM *,
+                     EC_KEY *) = NULL;
+int (*ECDSA_verify)(int, const unsigned char *, int, const unsigned char *,
+                    int, EC_KEY *) = NULL;
+int (*ECDSA_size)(const EC_KEY *) = NULL;
+
+const ECDSA_METHOD* (*ECDSA_OpenSSL)() = NULL;
+void (*ECDSA_set_default_method)(const ECDSA_METHOD *) = NULL;
+const ECDSA_METHOD* (*ECDSA_get_default_method)() = NULL;
+int (*ECDSA_set_method)(EC_KEY *, const ECDSA_METHOD *) = NULL;
+int (*ECDSA_get_ex_new_index)(long, void *, CRYPTO_EX_new *,
+                              CRYPTO_EX_dup *, CRYPTO_EX_free *) = NULL;
+int (*ECDSA_set_ex_data)(EC_KEY *, int, void *) = NULL;
+void* (*ECDSA_get_ex_data)(EC_KEY *, int) = NULL;
+#else
+static const long Cryptography_HAS_ECDSA = 1;
+#endif
+"""
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/ec.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/ec.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/ec.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/ec.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,406 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+INCLUDES = """
+#ifndef OPENSSL_NO_EC
+#include <openssl/ec.h>
+#endif
+
+#include <openssl/obj_mac.h>
+"""
+
+TYPES = """
+static const int Cryptography_HAS_EC;
+static const int Cryptography_HAS_EC_1_0_1;
+static const int Cryptography_HAS_EC_NISTP_64_GCC_128;
+static const int Cryptography_HAS_EC2M;
+static const int Cryptography_HAS_EC_1_0_2;
+
+static const int OPENSSL_EC_NAMED_CURVE;
+
+typedef ... EC_KEY;
+typedef ... EC_GROUP;
+typedef ... EC_POINT;
+typedef ... EC_METHOD;
+typedef struct {
+    int nid;
+    const char *comment;
+} EC_builtin_curve;
+typedef enum { ... } point_conversion_form_t;
+"""
+
+FUNCTIONS = """
+"""
+
+MACROS = """
+EC_GROUP *EC_GROUP_new(const EC_METHOD *);
+void EC_GROUP_free(EC_GROUP *);
+void EC_GROUP_clear_free(EC_GROUP *);
+
+EC_GROUP *EC_GROUP_new_curve_GFp(
+    const BIGNUM *, const BIGNUM *, const BIGNUM *, BN_CTX *);
+EC_GROUP *EC_GROUP_new_curve_GF2m(
+    const BIGNUM *, const BIGNUM *, const BIGNUM *, BN_CTX *);
+EC_GROUP *EC_GROUP_new_by_curve_name(int);
+
+int EC_GROUP_set_curve_GFp(
+    EC_GROUP *, const BIGNUM *, const BIGNUM *, const BIGNUM *, BN_CTX *);
+int EC_GROUP_get_curve_GFp(
+    const EC_GROUP *, BIGNUM *, BIGNUM *, BIGNUM *, BN_CTX *);
+int EC_GROUP_set_curve_GF2m(
+    EC_GROUP *, const BIGNUM *, const BIGNUM *, const BIGNUM *, BN_CTX *);
+int EC_GROUP_get_curve_GF2m(
+    const EC_GROUP *, BIGNUM *, BIGNUM *, BIGNUM *, BN_CTX *);
+
+int EC_GROUP_get_degree(const EC_GROUP *);
+void EC_GROUP_set_asn1_flag(EC_GROUP *, int);
+void EC_GROUP_set_point_conversion_form(EC_GROUP *, point_conversion_form_t);
+
+const EC_METHOD *EC_GROUP_method_of(const EC_GROUP *);
+const EC_POINT *EC_GROUP_get0_generator(const EC_GROUP *);
+int EC_GROUP_get_curve_name(const EC_GROUP *);
+
+size_t EC_get_builtin_curves(EC_builtin_curve *, size_t);
+
+EC_KEY *EC_KEY_new(void);
+void EC_KEY_free(EC_KEY *);
+
+int EC_KEY_get_flags(const EC_KEY *);
+void EC_KEY_set_flags(EC_KEY *, int);
+void EC_KEY_clear_flags(EC_KEY *, int);
+EC_KEY *EC_KEY_new_by_curve_name(int);
+EC_KEY *EC_KEY_copy(EC_KEY *, const EC_KEY *);
+EC_KEY *EC_KEY_dup(const EC_KEY *);
+int EC_KEY_up_ref(EC_KEY *);
+const EC_GROUP *EC_KEY_get0_group(const EC_KEY *);
+int EC_GROUP_get_order(const EC_GROUP *, BIGNUM *, BN_CTX *);
+int EC_KEY_set_group(EC_KEY *, const EC_GROUP *);
+const BIGNUM *EC_KEY_get0_private_key(const EC_KEY *);
+int EC_KEY_set_private_key(EC_KEY *, const BIGNUM *);
+const EC_POINT *EC_KEY_get0_public_key(const EC_KEY *);
+int EC_KEY_set_public_key(EC_KEY *, const EC_POINT *);
+unsigned int EC_KEY_get_enc_flags(const EC_KEY *);
+void EC_KEY_set_enc_flags(EC_KEY *eckey, unsigned int);
+point_conversion_form_t EC_KEY_get_conv_form(const EC_KEY *);
+void EC_KEY_set_conv_form(EC_KEY *, point_conversion_form_t);
+void *EC_KEY_get_key_method_data(
+    EC_KEY *,
+    void *(*)(void *),
+    void (*)(void *),
+    void (*)(void *)
+);
+void EC_KEY_insert_key_method_data(
+    EC_KEY *,
+    void *,
+    void *(*)(void *),
+    void (*)(void *),
+    void (*)(void *)
+);
+void EC_KEY_set_asn1_flag(EC_KEY *, int);
+int EC_KEY_precompute_mult(EC_KEY *, BN_CTX *);
+int EC_KEY_generate_key(EC_KEY *);
+int EC_KEY_check_key(const EC_KEY *);
+int EC_KEY_set_public_key_affine_coordinates(EC_KEY *, BIGNUM *, BIGNUM *);
+
+EC_POINT *EC_POINT_new(const EC_GROUP *);
+void EC_POINT_free(EC_POINT *);
+void EC_POINT_clear_free(EC_POINT *);
+int EC_POINT_copy(EC_POINT *, const EC_POINT *);
+EC_POINT *EC_POINT_dup(const EC_POINT *, const EC_GROUP *);
+const EC_METHOD *EC_POINT_method_of(const EC_POINT *);
+
+int EC_POINT_set_to_infinity(const EC_GROUP *, EC_POINT *);
+
+int EC_POINT_set_Jprojective_coordinates_GFp(const EC_GROUP *, EC_POINT *,
+    const BIGNUM *, const BIGNUM *, const BIGNUM *, BN_CTX *);
+
+int EC_POINT_get_Jprojective_coordinates_GFp(const EC_GROUP *,
+    const EC_POINT *, BIGNUM *, BIGNUM *, BIGNUM *, BN_CTX *);
+
+int EC_POINT_set_affine_coordinates_GFp(const EC_GROUP *, EC_POINT *,
+    const BIGNUM *, const BIGNUM *, BN_CTX *);
+
+int EC_POINT_get_affine_coordinates_GFp(const EC_GROUP *,
+    const EC_POINT *, BIGNUM *, BIGNUM *, BN_CTX *);
+
+int EC_POINT_set_compressed_coordinates_GFp(const EC_GROUP *, EC_POINT *,
+    const BIGNUM *, int, BN_CTX *);
+
+int EC_POINT_set_affine_coordinates_GF2m(const EC_GROUP *, EC_POINT *,
+    const BIGNUM *, const BIGNUM *, BN_CTX *);
+
+int EC_POINT_get_affine_coordinates_GF2m(const EC_GROUP *,
+    const EC_POINT *, BIGNUM *, BIGNUM *, BN_CTX *);
+
+int EC_POINT_set_compressed_coordinates_GF2m(const EC_GROUP *, EC_POINT *,
+    const BIGNUM *, int, BN_CTX *);
+
+size_t EC_POINT_point2oct(const EC_GROUP *, const EC_POINT *,
+    point_conversion_form_t,
+    unsigned char *, size_t, BN_CTX *);
+
+int EC_POINT_oct2point(const EC_GROUP *, EC_POINT *,
+    const unsigned char *, size_t, BN_CTX *);
+
+BIGNUM *EC_POINT_point2bn(const EC_GROUP *, const EC_POINT *,
+    point_conversion_form_t form, BIGNUM *, BN_CTX *);
+
+EC_POINT *EC_POINT_bn2point(const EC_GROUP *, const BIGNUM *,
+    EC_POINT *, BN_CTX *);
+
+char *EC_POINT_point2hex(const EC_GROUP *, const EC_POINT *,
+    point_conversion_form_t form, BN_CTX *);
+
+EC_POINT *EC_POINT_hex2point(const EC_GROUP *, const char *,
+    EC_POINT *, BN_CTX *);
+
+int EC_POINT_add(const EC_GROUP *, EC_POINT *, const EC_POINT *,
+    const EC_POINT *, BN_CTX *);
+
+int EC_POINT_dbl(const EC_GROUP *, EC_POINT *, const EC_POINT *, BN_CTX *);
+int EC_POINT_invert(const EC_GROUP *, EC_POINT *, BN_CTX *);
+int EC_POINT_is_at_infinity(const EC_GROUP *, const EC_POINT *);
+int EC_POINT_is_on_curve(const EC_GROUP *, const EC_POINT *, BN_CTX *);
+
+int EC_POINT_cmp(
+    const EC_GROUP *, const EC_POINT *, const EC_POINT *, BN_CTX *);
+
+int EC_POINT_make_affine(const EC_GROUP *, EC_POINT *, BN_CTX *);
+int EC_POINTs_make_affine(const EC_GROUP *, size_t, EC_POINT *[], BN_CTX *);
+
+int EC_POINTs_mul(
+    const EC_GROUP *, EC_POINT *, const BIGNUM *,
+    size_t, const EC_POINT *[], const BIGNUM *[], BN_CTX *);
+
+int EC_POINT_mul(const EC_GROUP *, EC_POINT *, const BIGNUM *,
+    const EC_POINT *, const BIGNUM *, BN_CTX *);
+
+int EC_GROUP_precompute_mult(EC_GROUP *, BN_CTX *);
+int EC_GROUP_have_precompute_mult(const EC_GROUP *);
+
+const EC_METHOD *EC_GFp_simple_method();
+const EC_METHOD *EC_GFp_mont_method();
+const EC_METHOD *EC_GFp_nist_method();
+
+const EC_METHOD *EC_GFp_nistp224_method();
+const EC_METHOD *EC_GFp_nistp256_method();
+const EC_METHOD *EC_GFp_nistp521_method();
+
+const EC_METHOD *EC_GF2m_simple_method();
+
+int EC_METHOD_get_field_type(const EC_METHOD *);
+
+const char *EC_curve_nid2nist(int);
+"""
+
+CUSTOMIZATIONS = """
+#ifdef OPENSSL_NO_EC
+static const long Cryptography_HAS_EC = 0;
+
+typedef void EC_KEY;
+typedef void EC_GROUP;
+typedef void EC_POINT;
+typedef void EC_METHOD;
+typedef struct {
+    int nid;
+    const char *comment;
+} EC_builtin_curve;
+typedef long point_conversion_form_t;
+
+static const int OPENSSL_EC_NAMED_CURVE = 0;
+
+void (*EC_KEY_free)(EC_KEY *) = NULL;
+EC_KEY *(*EC_KEY_new)(void) = NULL;
+size_t (*EC_get_builtin_curves)(EC_builtin_curve *, size_t) = NULL;
+EC_KEY *(*EC_KEY_new_by_curve_name)(int) = NULL;
+EC_KEY *(*EC_KEY_copy)(EC_KEY *, const EC_KEY *) = NULL;
+EC_KEY *(*EC_KEY_dup)(const EC_KEY *) = NULL;
+int (*EC_KEY_up_ref)(EC_KEY *) = NULL;
+const EC_GROUP *(*EC_KEY_get0_group)(const EC_KEY *) = NULL;
+int (*EC_GROUP_get_order)(const EC_GROUP *, BIGNUM *, BN_CTX *) = NULL;
+int (*EC_KEY_set_group)(EC_KEY *, const EC_GROUP *) = NULL;
+void (*EC_GROUP_set_asn1_flag)(EC_GROUP *, int) = NULL;
+void (*EC_GROUP_set_point_conversion_form)(EC_GROUP *,
+                                           point_conversion_form_t) = NULL;
+const BIGNUM *(*EC_KEY_get0_private_key)(const EC_KEY *) = NULL;
+int (*EC_KEY_set_private_key)(EC_KEY *, const BIGNUM *) = NULL;
+const EC_POINT *(*EC_KEY_get0_public_key)(const EC_KEY *) = NULL;
+int (*EC_KEY_set_public_key)(EC_KEY *, const EC_POINT *) = NULL;
+unsigned int (*EC_KEY_get_enc_flags)(const EC_KEY *) = NULL;
+void (*EC_KEY_set_enc_flags)(EC_KEY *eckey, unsigned int) = NULL;
+point_conversion_form_t (*EC_KEY_get_conv_form)(const EC_KEY *) = NULL;
+void (*EC_KEY_set_conv_form)(EC_KEY *, point_conversion_form_t) = NULL;
+void *(*EC_KEY_get_key_method_data)(
+    EC_KEY *, void *(*)(void *), void (*)(void *), void (*)(void *)) = NULL;
+void (*EC_KEY_insert_key_method_data)(
+    EC_KEY *, void *,
+    void *(*)(void *), void (*)(void *), void (*)(void *)) = NULL;
+void (*EC_KEY_set_asn1_flag)(EC_KEY *, int) = NULL;
+int (*EC_KEY_precompute_mult)(EC_KEY *, BN_CTX *) = NULL;
+int (*EC_KEY_generate_key)(EC_KEY *) = NULL;
+int (*EC_KEY_check_key)(const EC_KEY *) = NULL;
+
+EC_GROUP *(*EC_GROUP_new)(const EC_METHOD *);
+void (*EC_GROUP_free)(EC_GROUP *);
+void (*EC_GROUP_clear_free)(EC_GROUP *);
+
+EC_GROUP *(*EC_GROUP_new_curve_GFp)(
+    const BIGNUM *, const BIGNUM *, const BIGNUM *, BN_CTX *);
+
+EC_GROUP *(*EC_GROUP_new_by_curve_name)(int);
+
+int (*EC_GROUP_set_curve_GFp)(
+    EC_GROUP *, const BIGNUM *, const BIGNUM *, const BIGNUM *, BN_CTX *);
+
+int (*EC_GROUP_get_curve_GFp)(
+    const EC_GROUP *, BIGNUM *, BIGNUM *, BIGNUM *, BN_CTX *);
+
+int (*EC_GROUP_get_degree)(const EC_GROUP *) = NULL;
+
+const EC_METHOD *(*EC_GROUP_method_of)(const EC_GROUP *) = NULL;
+const EC_POINT *(*EC_GROUP_get0_generator)(const EC_GROUP *) = NULL;
+int (*EC_GROUP_get_curve_name)(const EC_GROUP *) = NULL;
+
+EC_POINT *(*EC_POINT_new)(const EC_GROUP *) = NULL;
+void (*EC_POINT_free)(EC_POINT *) = NULL;
+void (*EC_POINT_clear_free)(EC_POINT *) = NULL;
+int (*EC_POINT_copy)(EC_POINT *, const EC_POINT *) = NULL;
+EC_POINT *(*EC_POINT_dup)(const EC_POINT *, const EC_GROUP *) = NULL;
+const EC_METHOD *(*EC_POINT_method_of)(const EC_POINT *) = NULL;
+int (*EC_POINT_set_to_infinity)(const EC_GROUP *, EC_POINT *) = NULL;
+int (*EC_POINT_set_Jprojective_coordinates_GFp)(const EC_GROUP *, EC_POINT *,
+    const BIGNUM *, const BIGNUM *, const BIGNUM *, BN_CTX *) = NULL;
+
+int (*EC_POINT_get_Jprojective_coordinates_GFp)(const EC_GROUP *,
+    const EC_POINT *, BIGNUM *, BIGNUM *, BIGNUM *, BN_CTX *) = NULL;
+
+int (*EC_POINT_set_affine_coordinates_GFp)(const EC_GROUP *, EC_POINT *,
+    const BIGNUM *, const BIGNUM *, BN_CTX *) = NULL;
+
+int (*EC_POINT_get_affine_coordinates_GFp)(const EC_GROUP *,
+    const EC_POINT *, BIGNUM *, BIGNUM *, BN_CTX *) = NULL;
+
+int (*EC_POINT_set_compressed_coordinates_GFp)(const EC_GROUP *, EC_POINT *,
+    const BIGNUM *, int, BN_CTX *) = NULL;
+
+size_t (*EC_POINT_point2oct)(const EC_GROUP *, const EC_POINT *,
+    point_conversion_form_t,
+    unsigned char *, size_t, BN_CTX *) = NULL;
+
+int (*EC_POINT_oct2point)(const EC_GROUP *, EC_POINT *,
+    const unsigned char *, size_t, BN_CTX *) = NULL;
+
+BIGNUM *(*EC_POINT_point2bn)(const EC_GROUP *, const EC_POINT *,
+    point_conversion_form_t form, BIGNUM *, BN_CTX *) = NULL;
+
+EC_POINT *(*EC_POINT_bn2point)(const EC_GROUP *, const BIGNUM *,
+    EC_POINT *, BN_CTX *) = NULL;
+
+char *(*EC_POINT_point2hex)(const EC_GROUP *, const EC_POINT *,
+    point_conversion_form_t form, BN_CTX *) = NULL;
+
+EC_POINT *(*EC_POINT_hex2point)(const EC_GROUP *, const char *,
+    EC_POINT *, BN_CTX *) = NULL;
+
+int (*EC_POINT_add)(const EC_GROUP *, EC_POINT *, const EC_POINT *,
+    const EC_POINT *, BN_CTX *) = NULL;
+
+int (*EC_POINT_dbl)(const EC_GROUP *, EC_POINT *, const EC_POINT *,
+    BN_CTX *) = NULL;
+
+int (*EC_POINT_invert)(const EC_GROUP *, EC_POINT *, BN_CTX *) = NULL;
+int (*EC_POINT_is_at_infinity)(const EC_GROUP *, const EC_POINT *) = NULL;
+
+int (*EC_POINT_is_on_curve)(const EC_GROUP *, const EC_POINT *,
+    BN_CTX *) = NULL;
+
+int (*EC_POINT_cmp)(
+    const EC_GROUP *, const EC_POINT *, const EC_POINT *, BN_CTX *) = NULL;
+
+int (*EC_POINT_make_affine)(const EC_GROUP *, EC_POINT *, BN_CTX *) = NULL;
+
+int (*EC_POINTs_make_affine)(const EC_GROUP *, size_t, EC_POINT *[],
+    BN_CTX *) = NULL;
+
+int (*EC_POINTs_mul)(
+    const EC_GROUP *, EC_POINT *, const BIGNUM *,
+    size_t, const EC_POINT *[], const BIGNUM *[], BN_CTX *) = NULL;
+
+int (*EC_POINT_mul)(const EC_GROUP *, EC_POINT *, const BIGNUM *,
+    const EC_POINT *, const BIGNUM *, BN_CTX *) = NULL;
+
+int (*EC_GROUP_precompute_mult)(EC_GROUP *, BN_CTX *) = NULL;
+int (*EC_GROUP_have_precompute_mult)(const EC_GROUP *) = NULL;
+
+const EC_METHOD *(*EC_GFp_simple_method)() = NULL;
+const EC_METHOD *(*EC_GFp_mont_method)() = NULL;
+const EC_METHOD *(*EC_GFp_nist_method)() = NULL;
+
+int (*EC_METHOD_get_field_type)(const EC_METHOD *) = NULL;
+
+#else
+static const long Cryptography_HAS_EC = 1;
+#endif
+
+#if defined(OPENSSL_NO_EC) || OPENSSL_VERSION_NUMBER < 0x1000100f
+static const long Cryptography_HAS_EC_1_0_1 = 0;
+
+int (*EC_KEY_get_flags)(const EC_KEY *) = NULL;
+void (*EC_KEY_set_flags)(EC_KEY *, int) = NULL;
+void (*EC_KEY_clear_flags)(EC_KEY *, int) = NULL;
+
+int (*EC_KEY_set_public_key_affine_coordinates)(
+    EC_KEY *, BIGNUM *, BIGNUM *) = NULL;
+#else
+static const long Cryptography_HAS_EC_1_0_1 = 1;
+#endif
+
+
+#if defined(OPENSSL_NO_EC) || OPENSSL_VERSION_NUMBER < 0x1000100f || \
+    defined(OPENSSL_NO_EC_NISTP_64_GCC_128)
+static const long Cryptography_HAS_EC_NISTP_64_GCC_128 = 0;
+
+const EC_METHOD *(*EC_GFp_nistp224_method)(void) = NULL;
+const EC_METHOD *(*EC_GFp_nistp256_method)(void) = NULL;
+const EC_METHOD *(*EC_GFp_nistp521_method)(void) = NULL;
+#else
+static const long Cryptography_HAS_EC_NISTP_64_GCC_128 = 1;
+#endif
+
+#if defined(OPENSSL_NO_EC) || defined(OPENSSL_NO_EC2M)
+static const long Cryptography_HAS_EC2M = 0;
+
+const EC_METHOD *(*EC_GF2m_simple_method)() = NULL;
+
+int (*EC_POINT_set_affine_coordinates_GF2m)(const EC_GROUP *, EC_POINT *,
+    const BIGNUM *, const BIGNUM *, BN_CTX *) = NULL;
+
+int (*EC_POINT_get_affine_coordinates_GF2m)(const EC_GROUP *,
+    const EC_POINT *, BIGNUM *, BIGNUM *, BN_CTX *) = NULL;
+
+int (*EC_POINT_set_compressed_coordinates_GF2m)(const EC_GROUP *, EC_POINT *,
+    const BIGNUM *, int, BN_CTX *) = NULL;
+
+int (*EC_GROUP_set_curve_GF2m)(
+    EC_GROUP *, const BIGNUM *, const BIGNUM *, const BIGNUM *, BN_CTX *);
+
+int (*EC_GROUP_get_curve_GF2m)(
+    const EC_GROUP *, BIGNUM *, BIGNUM *, BIGNUM *, BN_CTX *);
+
+EC_GROUP *(*EC_GROUP_new_curve_GF2m)(
+    const BIGNUM *, const BIGNUM *, const BIGNUM *, BN_CTX *);
+#else
+static const long Cryptography_HAS_EC2M = 1;
+#endif
+
+#if defined(OPENSSL_NO_EC) || OPENSSL_VERSION_NUMBER < 0x1000200f || \
+    defined(LIBRESSL_VERSION_NUMBER) && LIBRESSL_VERSION_NUMBER < 0x20020002L
+static const long Cryptography_HAS_EC_1_0_2 = 0;
+const char *(*EC_curve_nid2nist)(int) = NULL;
+#else
+static const long Cryptography_HAS_EC_1_0_2 = 1;
+#endif
+"""
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/engine.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/engine.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/engine.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/engine.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,171 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+INCLUDES = """
+#include <openssl/engine.h>
+"""
+
+TYPES = """
+static const long Cryptography_HAS_ENGINE_CRYPTODEV;
+
+typedef ... ENGINE;
+typedef ... RSA_METHOD;
+typedef ... DSA_METHOD;
+typedef ... ECDH_METHOD;
+typedef ... ECDSA_METHOD;
+typedef ... DH_METHOD;
+typedef struct {
+    void (*seed)(const void *, int);
+    int (*bytes)(unsigned char *, int);
+    void (*cleanup)();
+    void (*add)(const void *, int, double);
+    int (*pseudorand)(unsigned char *, int);
+    int (*status)();
+} RAND_METHOD;
+typedef ... STORE_METHOD;
+typedef int (*ENGINE_GEN_INT_FUNC_PTR)(ENGINE *);
+typedef ... *ENGINE_CTRL_FUNC_PTR;
+typedef ... *ENGINE_LOAD_KEY_PTR;
+typedef ... *ENGINE_CIPHERS_PTR;
+typedef ... *ENGINE_DIGESTS_PTR;
+typedef ... ENGINE_CMD_DEFN;
+typedef ... UI_METHOD;
+
+static const unsigned int ENGINE_METHOD_RSA;
+static const unsigned int ENGINE_METHOD_DSA;
+static const unsigned int ENGINE_METHOD_RAND;
+static const unsigned int ENGINE_METHOD_ECDH;
+static const unsigned int ENGINE_METHOD_ECDSA;
+static const unsigned int ENGINE_METHOD_CIPHERS;
+static const unsigned int ENGINE_METHOD_DIGESTS;
+static const unsigned int ENGINE_METHOD_STORE;
+static const unsigned int ENGINE_METHOD_ALL;
+static const unsigned int ENGINE_METHOD_NONE;
+
+static const int ENGINE_R_CONFLICTING_ENGINE_ID;
+"""
+
+FUNCTIONS = """
+ENGINE *ENGINE_get_first(void);
+ENGINE *ENGINE_get_last(void);
+ENGINE *ENGINE_get_next(ENGINE *);
+ENGINE *ENGINE_get_prev(ENGINE *);
+int ENGINE_add(ENGINE *);
+int ENGINE_remove(ENGINE *);
+ENGINE *ENGINE_by_id(const char *);
+int ENGINE_init(ENGINE *);
+int ENGINE_finish(ENGINE *);
+void ENGINE_load_openssl(void);
+void ENGINE_load_dynamic(void);
+void ENGINE_load_builtin_engines(void);
+void ENGINE_cleanup(void);
+ENGINE *ENGINE_get_default_RSA(void);
+ENGINE *ENGINE_get_default_DSA(void);
+ENGINE *ENGINE_get_default_ECDH(void);
+ENGINE *ENGINE_get_default_ECDSA(void);
+ENGINE *ENGINE_get_default_DH(void);
+ENGINE *ENGINE_get_default_RAND(void);
+ENGINE *ENGINE_get_cipher_engine(int);
+ENGINE *ENGINE_get_digest_engine(int);
+int ENGINE_set_default_RSA(ENGINE *);
+int ENGINE_set_default_DSA(ENGINE *);
+int ENGINE_set_default_ECDH(ENGINE *);
+int ENGINE_set_default_ECDSA(ENGINE *);
+int ENGINE_set_default_DH(ENGINE *);
+int ENGINE_set_default_RAND(ENGINE *);
+int ENGINE_set_default_ciphers(ENGINE *);
+int ENGINE_set_default_digests(ENGINE *);
+int ENGINE_set_default_string(ENGINE *, const char *);
+int ENGINE_set_default(ENGINE *, unsigned int);
+unsigned int ENGINE_get_table_flags(void);
+void ENGINE_set_table_flags(unsigned int);
+int ENGINE_register_RSA(ENGINE *);
+void ENGINE_unregister_RSA(ENGINE *);
+void ENGINE_register_all_RSA(void);
+int ENGINE_register_DSA(ENGINE *);
+void ENGINE_unregister_DSA(ENGINE *);
+void ENGINE_register_all_DSA(void);
+int ENGINE_register_ECDH(ENGINE *);
+void ENGINE_unregister_ECDH(ENGINE *);
+void ENGINE_register_all_ECDH(void);
+int ENGINE_register_ECDSA(ENGINE *);
+void ENGINE_unregister_ECDSA(ENGINE *);
+void ENGINE_register_all_ECDSA(void);
+int ENGINE_register_DH(ENGINE *);
+void ENGINE_unregister_DH(ENGINE *);
+void ENGINE_register_all_DH(void);
+int ENGINE_register_RAND(ENGINE *);
+void ENGINE_unregister_RAND(ENGINE *);
+void ENGINE_register_all_RAND(void);
+int ENGINE_register_STORE(ENGINE *);
+void ENGINE_unregister_STORE(ENGINE *);
+void ENGINE_register_all_STORE(void);
+int ENGINE_register_ciphers(ENGINE *);
+void ENGINE_unregister_ciphers(ENGINE *);
+void ENGINE_register_all_ciphers(void);
+int ENGINE_register_digests(ENGINE *);
+void ENGINE_unregister_digests(ENGINE *);
+void ENGINE_register_all_digests(void);
+int ENGINE_register_complete(ENGINE *);
+int ENGINE_register_all_complete(void);
+int ENGINE_ctrl(ENGINE *, int, long, void *, void (*)(void));
+int ENGINE_cmd_is_executable(ENGINE *, int);
+int ENGINE_ctrl_cmd(ENGINE *, const char *, long, void *, void (*)(void), int);
+int ENGINE_ctrl_cmd_string(ENGINE *, const char *, const char *, int);
+
+ENGINE *ENGINE_new(void);
+int ENGINE_free(ENGINE *);
+int ENGINE_up_ref(ENGINE *);
+int ENGINE_set_id(ENGINE *, const char *);
+int ENGINE_set_name(ENGINE *, const char *);
+int ENGINE_set_RSA(ENGINE *, const RSA_METHOD *);
+int ENGINE_set_DSA(ENGINE *, const DSA_METHOD *);
+int ENGINE_set_ECDH(ENGINE *, const ECDH_METHOD *);
+int ENGINE_set_ECDSA(ENGINE *, const ECDSA_METHOD *);
+int ENGINE_set_DH(ENGINE *, const DH_METHOD *);
+int ENGINE_set_RAND(ENGINE *, const RAND_METHOD *);
+int ENGINE_set_STORE(ENGINE *, const STORE_METHOD *);
+int ENGINE_set_destroy_function(ENGINE *, ENGINE_GEN_INT_FUNC_PTR);
+int ENGINE_set_init_function(ENGINE *, ENGINE_GEN_INT_FUNC_PTR);
+int ENGINE_set_finish_function(ENGINE *, ENGINE_GEN_INT_FUNC_PTR);
+int ENGINE_set_ctrl_function(ENGINE *, ENGINE_CTRL_FUNC_PTR);
+int ENGINE_set_load_privkey_function(ENGINE *, ENGINE_LOAD_KEY_PTR);
+int ENGINE_set_load_pubkey_function(ENGINE *, ENGINE_LOAD_KEY_PTR);
+int ENGINE_set_ciphers(ENGINE *, ENGINE_CIPHERS_PTR);
+int ENGINE_set_digests(ENGINE *, ENGINE_DIGESTS_PTR);
+int ENGINE_set_flags(ENGINE *, int);
+int ENGINE_set_cmd_defns(ENGINE *, const ENGINE_CMD_DEFN *);
+const char *ENGINE_get_id(const ENGINE *);
+const char *ENGINE_get_name(const ENGINE *);
+const RSA_METHOD *ENGINE_get_RSA(const ENGINE *);
+const DSA_METHOD *ENGINE_get_DSA(const ENGINE *);
+const ECDH_METHOD *ENGINE_get_ECDH(const ENGINE *);
+const ECDSA_METHOD *ENGINE_get_ECDSA(const ENGINE *);
+const DH_METHOD *ENGINE_get_DH(const ENGINE *);
+const RAND_METHOD *ENGINE_get_RAND(const ENGINE *);
+const STORE_METHOD *ENGINE_get_STORE(const ENGINE *);
+
+const EVP_CIPHER *ENGINE_get_cipher(ENGINE *, int);
+const EVP_MD *ENGINE_get_digest(ENGINE *, int);
+int ENGINE_get_flags(const ENGINE *);
+const ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *);
+EVP_PKEY *ENGINE_load_private_key(ENGINE *, const char *, UI_METHOD *, void *);
+EVP_PKEY *ENGINE_load_public_key(ENGINE *, const char *, UI_METHOD *, void *);
+void ENGINE_add_conf_module(void);
+"""
+
+MACROS = """
+void ENGINE_load_cryptodev(void);
+"""
+
+CUSTOMIZATIONS = """
+#if defined(LIBRESSL_VERSION_NUMBER)
+static const long Cryptography_HAS_ENGINE_CRYPTODEV = 0;
+void (*ENGINE_load_cryptodev)(void) = NULL;
+#else
+static const long Cryptography_HAS_ENGINE_CRYPTODEV = 1;
+#endif
+"""
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/err.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/err.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/err.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/err.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,337 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+INCLUDES = """
+#include <openssl/err.h>
+"""
+
+TYPES = """
+static const int Cryptography_HAS_REMOVE_THREAD_STATE;
+static const int Cryptography_HAS_098H_ERROR_CODES;
+static const int Cryptography_HAS_098C_CAMELLIA_CODES;
+static const int Cryptography_HAS_EC_CODES;
+static const int Cryptography_HAS_RSA_R_PKCS_DECODING_ERROR;
+
+struct ERR_string_data_st {
+    unsigned long error;
+    const char *string;
+};
+typedef struct ERR_string_data_st ERR_STRING_DATA;
+
+static const int ERR_LIB_DH;
+static const int ERR_LIB_EVP;
+static const int ERR_LIB_EC;
+static const int ERR_LIB_PEM;
+static const int ERR_LIB_ASN1;
+static const int ERR_LIB_RSA;
+static const int ERR_LIB_PKCS12;
+
+static const int ASN1_F_ASN1_ENUMERATED_TO_BN;
+static const int ASN1_F_ASN1_EX_C2I;
+static const int ASN1_F_ASN1_FIND_END;
+static const int ASN1_F_ASN1_GENERALIZEDTIME_SET;
+static const int ASN1_F_ASN1_GENERATE_V3;
+static const int ASN1_F_ASN1_GET_OBJECT;
+static const int ASN1_F_ASN1_ITEM_I2D_FP;
+static const int ASN1_F_ASN1_ITEM_PACK;
+static const int ASN1_F_ASN1_ITEM_SIGN;
+static const int ASN1_F_ASN1_ITEM_UNPACK;
+static const int ASN1_F_ASN1_ITEM_VERIFY;
+static const int ASN1_F_ASN1_MBSTRING_NCOPY;
+static const int ASN1_F_ASN1_TEMPLATE_EX_D2I;
+static const int ASN1_F_ASN1_TEMPLATE_NEW;
+static const int ASN1_F_ASN1_TEMPLATE_NOEXP_D2I;
+static const int ASN1_F_ASN1_TIME_SET;
+static const int ASN1_F_ASN1_TYPE_GET_INT_OCTETSTRING;
+static const int ASN1_F_ASN1_TYPE_GET_OCTETSTRING;
+static const int ASN1_F_ASN1_UNPACK_STRING;
+static const int ASN1_F_ASN1_UTCTIME_SET;
+static const int ASN1_F_ASN1_VERIFY;
+static const int ASN1_F_BITSTR_CB;
+static const int ASN1_F_BN_TO_ASN1_ENUMERATED;
+static const int ASN1_F_BN_TO_ASN1_INTEGER;
+static const int ASN1_F_D2I_ASN1_TYPE_BYTES;
+static const int ASN1_F_D2I_ASN1_UINTEGER;
+static const int ASN1_F_D2I_ASN1_UTCTIME;
+static const int ASN1_F_D2I_NETSCAPE_RSA;
+static const int ASN1_F_D2I_NETSCAPE_RSA_2;
+static const int ASN1_F_D2I_PRIVATEKEY;
+static const int ASN1_F_D2I_X509;
+static const int ASN1_F_D2I_X509_CINF;
+static const int ASN1_F_D2I_X509_PKEY;
+static const int ASN1_F_I2D_ASN1_SET;
+static const int ASN1_F_I2D_ASN1_TIME;
+static const int ASN1_F_I2D_DSA_PUBKEY;
+static const int ASN1_F_LONG_C2I;
+static const int ASN1_F_OID_MODULE_INIT;
+static const int ASN1_F_PARSE_TAGGING;
+static const int ASN1_F_PKCS5_PBE_SET;
+static const int ASN1_F_X509_CINF_NEW;
+
+static const int ASN1_R_BOOLEAN_IS_WRONG_LENGTH;
+static const int ASN1_R_BUFFER_TOO_SMALL;
+static const int ASN1_R_CIPHER_HAS_NO_OBJECT_IDENTIFIER;
+static const int ASN1_R_DATA_IS_WRONG;
+static const int ASN1_R_DECODE_ERROR;
+static const int ASN1_R_DECODING_ERROR;
+static const int ASN1_R_DEPTH_EXCEEDED;
+static const int ASN1_R_ENCODE_ERROR;
+static const int ASN1_R_ERROR_GETTING_TIME;
+static const int ASN1_R_ERROR_LOADING_SECTION;
+static const int ASN1_R_MSTRING_WRONG_TAG;
+static const int ASN1_R_NESTED_ASN1_STRING;
+static const int ASN1_R_NO_MATCHING_CHOICE_TYPE;
+static const int ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM;
+static const int ASN1_R_UNKNOWN_OBJECT_TYPE;
+static const int ASN1_R_UNKNOWN_PUBLIC_KEY_TYPE;
+static const int ASN1_R_UNKNOWN_TAG;
+static const int ASN1_R_UNKOWN_FORMAT;
+static const int ASN1_R_UNSUPPORTED_ANY_DEFINED_BY_TYPE;
+static const int ASN1_R_UNSUPPORTED_ENCRYPTION_ALGORITHM;
+static const int ASN1_R_UNSUPPORTED_PUBLIC_KEY_TYPE;
+static const int ASN1_R_UNSUPPORTED_TYPE;
+static const int ASN1_R_WRONG_TAG;
+static const int ASN1_R_WRONG_TYPE;
+
+static const int DH_F_COMPUTE_KEY;
+
+static const int DH_R_INVALID_PUBKEY;
+
+static const int EVP_F_AES_INIT_KEY;
+static const int EVP_F_D2I_PKEY;
+static const int EVP_F_DSA_PKEY2PKCS8;
+static const int EVP_F_DSAPKEY2PKCS8;
+static const int EVP_F_ECDSA_PKEY2PKCS8;
+static const int EVP_F_ECKEY_PKEY2PKCS8;
+static const int EVP_F_EVP_CIPHER_CTX_CTRL;
+static const int EVP_F_EVP_CIPHER_CTX_SET_KEY_LENGTH;
+static const int EVP_F_EVP_CIPHERINIT_EX;
+static const int EVP_F_EVP_DECRYPTFINAL_EX;
+static const int EVP_F_EVP_DIGESTINIT_EX;
+static const int EVP_F_EVP_ENCRYPTFINAL_EX;
+static const int EVP_F_EVP_MD_CTX_COPY_EX;
+static const int EVP_F_EVP_OPENINIT;
+static const int EVP_F_EVP_PBE_ALG_ADD;
+static const int EVP_F_EVP_PBE_CIPHERINIT;
+static const int EVP_F_EVP_PKCS82PKEY;
+static const int EVP_F_EVP_PKEY2PKCS8_BROKEN;
+static const int EVP_F_EVP_PKEY_COPY_PARAMETERS;
+static const int EVP_F_EVP_PKEY_DECRYPT;
+static const int EVP_F_EVP_PKEY_ENCRYPT;
+static const int EVP_F_EVP_PKEY_GET1_DH;
+static const int EVP_F_EVP_PKEY_GET1_DSA;
+static const int EVP_F_EVP_PKEY_GET1_ECDSA;
+static const int EVP_F_EVP_PKEY_GET1_EC_KEY;
+static const int EVP_F_EVP_PKEY_GET1_RSA;
+static const int EVP_F_EVP_PKEY_NEW;
+static const int EVP_F_EVP_RIJNDAEL;
+static const int EVP_F_EVP_SIGNFINAL;
+static const int EVP_F_EVP_VERIFYFINAL;
+static const int EVP_F_PKCS5_PBE_KEYIVGEN;
+static const int EVP_F_PKCS5_V2_PBE_KEYIVGEN;
+static const int EVP_F_PKCS8_SET_BROKEN;
+static const int EVP_F_RC2_MAGIC_TO_METH;
+static const int EVP_F_RC5_CTRL;
+
+static const int EVP_R_AES_KEY_SETUP_FAILED;
+static const int EVP_R_ASN1_LIB;
+static const int EVP_R_BAD_BLOCK_LENGTH;
+static const int EVP_R_BAD_DECRYPT;
+static const int EVP_R_BAD_KEY_LENGTH;
+static const int EVP_R_BN_DECODE_ERROR;
+static const int EVP_R_BN_PUBKEY_ERROR;
+static const int EVP_R_CIPHER_PARAMETER_ERROR;
+static const int EVP_R_CTRL_NOT_IMPLEMENTED;
+static const int EVP_R_CTRL_OPERATION_NOT_IMPLEMENTED;
+static const int EVP_R_DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH;
+static const int EVP_R_DECODE_ERROR;
+static const int EVP_R_DIFFERENT_KEY_TYPES;
+static const int EVP_R_ENCODE_ERROR;
+static const int EVP_R_INITIALIZATION_ERROR;
+static const int EVP_R_INPUT_NOT_INITIALIZED;
+static const int EVP_R_INVALID_KEY_LENGTH;
+static const int EVP_R_IV_TOO_LARGE;
+static const int EVP_R_KEYGEN_FAILURE;
+static const int EVP_R_MISSING_PARAMETERS;
+static const int EVP_R_NO_CIPHER_SET;
+static const int EVP_R_NO_DIGEST_SET;
+static const int EVP_R_NO_DSA_PARAMETERS;
+static const int EVP_R_NO_SIGN_FUNCTION_CONFIGURED;
+static const int EVP_R_NO_VERIFY_FUNCTION_CONFIGURED;
+static const int EVP_R_PKCS8_UNKNOWN_BROKEN_TYPE;
+static const int EVP_R_PUBLIC_KEY_NOT_RSA;
+static const int EVP_R_UNKNOWN_PBE_ALGORITHM;
+static const int EVP_R_UNSUPORTED_NUMBER_OF_ROUNDS;
+static const int EVP_R_UNSUPPORTED_CIPHER;
+static const int EVP_R_UNSUPPORTED_KEY_DERIVATION_FUNCTION;
+static const int EVP_R_UNSUPPORTED_KEYLENGTH;
+static const int EVP_R_UNSUPPORTED_SALT_TYPE;
+static const int EVP_R_UNSUPPORTED_PRIVATE_KEY_ALGORITHM;
+static const int EVP_R_WRONG_FINAL_BLOCK_LENGTH;
+static const int EVP_R_WRONG_PUBLIC_KEY_TYPE;
+
+static const int EC_F_EC_GROUP_NEW_BY_CURVE_NAME;
+
+static const int EC_R_UNKNOWN_GROUP;
+
+static const int PEM_F_D2I_PKCS8PRIVATEKEY_BIO;
+static const int PEM_F_D2I_PKCS8PRIVATEKEY_FP;
+static const int PEM_F_DO_PK8PKEY;
+static const int PEM_F_DO_PK8PKEY_FP;
+static const int PEM_F_LOAD_IV;
+static const int PEM_F_PEM_ASN1_READ;
+static const int PEM_F_PEM_ASN1_READ_BIO;
+static const int PEM_F_PEM_ASN1_WRITE;
+static const int PEM_F_PEM_ASN1_WRITE_BIO;
+static const int PEM_F_PEM_DEF_CALLBACK;
+static const int PEM_F_PEM_DO_HEADER;
+static const int PEM_F_PEM_F_PEM_WRITE_PKCS8PRIVATEKEY;
+static const int PEM_F_PEM_GET_EVP_CIPHER_INFO;
+static const int PEM_F_PEM_PK8PKEY;
+static const int PEM_F_PEM_READ;
+static const int PEM_F_PEM_READ_BIO;
+static const int PEM_F_PEM_READ_BIO_PRIVATEKEY;
+static const int PEM_F_PEM_READ_PRIVATEKEY;
+static const int PEM_F_PEM_SEALFINAL;
+static const int PEM_F_PEM_SEALINIT;
+static const int PEM_F_PEM_SIGNFINAL;
+static const int PEM_F_PEM_WRITE;
+static const int PEM_F_PEM_WRITE_BIO;
+static const int PEM_F_PEM_X509_INFO_READ;
+static const int PEM_F_PEM_X509_INFO_READ_BIO;
+static const int PEM_F_PEM_X509_INFO_WRITE_BIO;
+
+static const int PEM_R_BAD_BASE64_DECODE;
+static const int PEM_R_BAD_DECRYPT;
+static const int PEM_R_BAD_END_LINE;
+static const int PEM_R_BAD_IV_CHARS;
+static const int PEM_R_BAD_PASSWORD_READ;
+static const int PEM_R_ERROR_CONVERTING_PRIVATE_KEY;
+static const int PEM_R_NO_START_LINE;
+static const int PEM_R_NOT_DEK_INFO;
+static const int PEM_R_NOT_ENCRYPTED;
+static const int PEM_R_NOT_PROC_TYPE;
+static const int PEM_R_PROBLEMS_GETTING_PASSWORD;
+static const int PEM_R_PUBLIC_KEY_NO_RSA;
+static const int PEM_R_READ_KEY;
+static const int PEM_R_SHORT_HEADER;
+static const int PEM_R_UNSUPPORTED_CIPHER;
+static const int PEM_R_UNSUPPORTED_ENCRYPTION;
+
+static const int PKCS12_F_PKCS12_PBE_CRYPT;
+
+static const int PKCS12_R_PKCS12_CIPHERFINAL_ERROR;
+
+static const int RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE;
+static const int RSA_R_DIGEST_TOO_BIG_FOR_RSA_KEY;
+static const int RSA_R_BLOCK_TYPE_IS_NOT_01;
+static const int RSA_R_BLOCK_TYPE_IS_NOT_02;
+static const int RSA_R_PKCS_DECODING_ERROR;
+static const int RSA_F_RSA_SIGN;
+"""
+
+FUNCTIONS = """
+void ERR_load_crypto_strings(void);
+void ERR_load_SSL_strings(void);
+void ERR_free_strings(void);
+char *ERR_error_string(unsigned long, char *);
+void ERR_error_string_n(unsigned long, char *, size_t);
+const char *ERR_lib_error_string(unsigned long);
+const char *ERR_func_error_string(unsigned long);
+const char *ERR_reason_error_string(unsigned long);
+void ERR_print_errors(BIO *);
+void ERR_print_errors_fp(FILE *);
+unsigned long ERR_get_error(void);
+unsigned long ERR_peek_error(void);
+unsigned long ERR_peek_last_error(void);
+unsigned long ERR_get_error_line(const char **, int *);
+unsigned long ERR_peek_error_line(const char **, int *);
+unsigned long ERR_peek_last_error_line(const char **, int *);
+unsigned long ERR_get_error_line_data(const char **, int *,
+                                      const char **, int *);
+void ERR_clear_error(void);
+unsigned long ERR_peek_error_line_data(const char **,
+                                       int *, const char **, int *);
+unsigned long ERR_peek_last_error_line_data(const char **,
+                                            int *, const char **, int *);
+void ERR_put_error(int, int, int, const char *, int);
+void ERR_add_error_data(int, ...);
+int ERR_get_next_error_library(void);
+"""
+
+MACROS = """
+unsigned long ERR_PACK(int, int, int);
+int ERR_GET_LIB(unsigned long);
+int ERR_GET_FUNC(unsigned long);
+int ERR_GET_REASON(unsigned long);
+int ERR_FATAL_ERROR(unsigned long);
+/* introduced in 1.0.0 so we have to handle this specially to continue
+ * supporting 0.9.8
+ */
+void ERR_remove_thread_state(const CRYPTO_THREADID *);
+
+/* These were added in OpenSSL 0.9.8h. When we drop support for RHEL/CentOS 5
+   we should be able to move these back to TYPES. */
+static const int ASN1_F_B64_READ_ASN1;
+static const int ASN1_F_B64_WRITE_ASN1;
+static const int ASN1_F_SMIME_READ_ASN1;
+static const int ASN1_F_SMIME_TEXT;
+static const int ASN1_R_NO_CONTENT_TYPE;
+static const int ASN1_R_NO_MULTIPART_BODY_FAILURE;
+static const int ASN1_R_NO_MULTIPART_BOUNDARY;
+/* These were added in OpenSSL 0.9.8c. */
+static const int EVP_F_CAMELLIA_INIT_KEY;
+static const int EVP_R_CAMELLIA_KEY_SETUP_FAILED;
+"""
+
+CUSTOMIZATIONS = """
+#if OPENSSL_VERSION_NUMBER >= 0x10000000L
+static const long Cryptography_HAS_REMOVE_THREAD_STATE = 1;
+#else
+static const long Cryptography_HAS_REMOVE_THREAD_STATE = 0;
+typedef uint32_t CRYPTO_THREADID;
+void (*ERR_remove_thread_state)(const CRYPTO_THREADID *) = NULL;
+#endif
+
+/* OpenSSL 0.9.8h+ */
+#if OPENSSL_VERSION_NUMBER >= 0x0090808fL
+static const long Cryptography_HAS_098H_ERROR_CODES = 1;
+#else
+static const long Cryptography_HAS_098H_ERROR_CODES = 0;
+static const int ASN1_F_B64_READ_ASN1 = 0;
+static const int ASN1_F_B64_WRITE_ASN1 = 0;
+static const int ASN1_F_SMIME_READ_ASN1 = 0;
+static const int ASN1_F_SMIME_TEXT = 0;
+static const int ASN1_R_NO_CONTENT_TYPE = 0;
+static const int ASN1_R_NO_MULTIPART_BODY_FAILURE = 0;
+static const int ASN1_R_NO_MULTIPART_BOUNDARY = 0;
+#endif
+
+/* OpenSSL 0.9.8c+ */
+#ifdef EVP_F_CAMELLIA_INIT_KEY
+static const long Cryptography_HAS_098C_CAMELLIA_CODES = 1;
+#else
+static const long Cryptography_HAS_098C_CAMELLIA_CODES = 0;
+static const int EVP_F_CAMELLIA_INIT_KEY = 0;
+static const int EVP_R_CAMELLIA_KEY_SETUP_FAILED = 0;
+#endif
+
+// OpenSSL without EC. e.g. RHEL
+#ifndef OPENSSL_NO_EC
+static const long Cryptography_HAS_EC_CODES = 1;
+#else
+static const long Cryptography_HAS_EC_CODES = 0;
+static const int EC_R_UNKNOWN_GROUP = 0;
+static const int EC_F_EC_GROUP_NEW_BY_CURVE_NAME = 0;
+#endif
+
+#ifdef RSA_R_PKCS_DECODING_ERROR
+static const long Cryptography_HAS_RSA_R_PKCS_DECODING_ERROR = 1;
+#else
+static const long Cryptography_HAS_RSA_R_PKCS_DECODING_ERROR = 0;
+static const long RSA_R_PKCS_DECODING_ERROR = 0;
+#endif
+"""
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/evp.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/evp.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/evp.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/evp.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,233 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+INCLUDES = """
+#include <openssl/evp.h>
+"""
+
+TYPES = """
+typedef ... EVP_CIPHER;
+typedef struct {
+    const EVP_CIPHER *cipher;
+    ENGINE *engine;
+    int encrypt;
+    ...;
+} EVP_CIPHER_CTX;
+typedef ... EVP_MD;
+typedef struct env_md_ctx_st {
+    ...;
+} EVP_MD_CTX;
+
+typedef struct evp_pkey_st {
+    int type;
+    ...;
+} EVP_PKEY;
+typedef ... EVP_PKEY_CTX;
+static const int EVP_PKEY_RSA;
+static const int EVP_PKEY_DSA;
+static const int EVP_PKEY_DH;
+static const int EVP_PKEY_EC;
+static const int EVP_MAX_MD_SIZE;
+static const int EVP_CTRL_GCM_SET_IVLEN;
+static const int EVP_CTRL_GCM_GET_TAG;
+static const int EVP_CTRL_GCM_SET_TAG;
+
+static const int Cryptography_HAS_GCM;
+static const int Cryptography_HAS_PBKDF2_HMAC;
+static const int Cryptography_HAS_PKEY_CTX;
+"""
+
+FUNCTIONS = """
+const EVP_CIPHER *EVP_get_cipherbyname(const char *);
+int EVP_EncryptInit_ex(EVP_CIPHER_CTX *, const EVP_CIPHER *, ENGINE *,
+                       const unsigned char *, const unsigned char *);
+int EVP_CIPHER_CTX_set_padding(EVP_CIPHER_CTX *, int);
+int EVP_EncryptUpdate(EVP_CIPHER_CTX *, unsigned char *, int *,
+                      const unsigned char *, int);
+int EVP_EncryptFinal_ex(EVP_CIPHER_CTX *, unsigned char *, int *);
+int EVP_DecryptInit_ex(EVP_CIPHER_CTX *, const EVP_CIPHER *, ENGINE *,
+                       const unsigned char *, const unsigned char *);
+int EVP_DecryptUpdate(EVP_CIPHER_CTX *, unsigned char *, int *,
+                      const unsigned char *, int);
+int EVP_DecryptFinal_ex(EVP_CIPHER_CTX *, unsigned char *, int *);
+int EVP_CipherInit_ex(EVP_CIPHER_CTX *, const EVP_CIPHER *, ENGINE *,
+                      const unsigned char *, const unsigned char *, int);
+int EVP_CipherUpdate(EVP_CIPHER_CTX *, unsigned char *, int *,
+                     const unsigned char *, int);
+int EVP_CipherFinal_ex(EVP_CIPHER_CTX *, unsigned char *, int *);
+int EVP_CIPHER_CTX_cleanup(EVP_CIPHER_CTX *);
+void EVP_CIPHER_CTX_init(EVP_CIPHER_CTX *);
+EVP_CIPHER_CTX *EVP_CIPHER_CTX_new(void);
+void EVP_CIPHER_CTX_free(EVP_CIPHER_CTX *);
+int EVP_CIPHER_CTX_set_key_length(EVP_CIPHER_CTX *, int);
+
+EVP_MD_CTX *EVP_MD_CTX_create(void);
+int EVP_MD_CTX_copy_ex(EVP_MD_CTX *, const EVP_MD_CTX *);
+int EVP_DigestInit_ex(EVP_MD_CTX *, const EVP_MD *, ENGINE *);
+int EVP_DigestUpdate(EVP_MD_CTX *, const void *, size_t);
+int EVP_DigestFinal_ex(EVP_MD_CTX *, unsigned char *, unsigned int *);
+int EVP_MD_CTX_cleanup(EVP_MD_CTX *);
+void EVP_MD_CTX_destroy(EVP_MD_CTX *);
+const EVP_MD *EVP_get_digestbyname(const char *);
+
+EVP_PKEY *EVP_PKEY_new(void);
+void EVP_PKEY_free(EVP_PKEY *);
+int EVP_PKEY_type(int);
+int EVP_PKEY_bits(EVP_PKEY *);
+int EVP_PKEY_size(EVP_PKEY *);
+RSA *EVP_PKEY_get1_RSA(EVP_PKEY *);
+DSA *EVP_PKEY_get1_DSA(EVP_PKEY *);
+DH *EVP_PKEY_get1_DH(EVP_PKEY *);
+
+int EVP_SignInit(EVP_MD_CTX *, const EVP_MD *);
+int EVP_SignUpdate(EVP_MD_CTX *, const void *, size_t);
+int EVP_SignFinal(EVP_MD_CTX *, unsigned char *, unsigned int *, EVP_PKEY *);
+
+int EVP_VerifyInit(EVP_MD_CTX *, const EVP_MD *);
+int EVP_VerifyUpdate(EVP_MD_CTX *, const void *, size_t);
+int EVP_VerifyFinal(EVP_MD_CTX *, const unsigned char *, unsigned int,
+                    EVP_PKEY *);
+
+const EVP_MD *EVP_md5(void);
+const EVP_MD *EVP_sha1(void);
+const EVP_MD *EVP_ripemd160(void);
+const EVP_MD *EVP_sha224(void);
+const EVP_MD *EVP_sha256(void);
+const EVP_MD *EVP_sha384(void);
+const EVP_MD *EVP_sha512(void);
+
+int PKCS5_PBKDF2_HMAC_SHA1(const char *, int, const unsigned char *, int, int,
+                           int, unsigned char *);
+
+int EVP_PKEY_set1_RSA(EVP_PKEY *, struct rsa_st *);
+int EVP_PKEY_set1_DSA(EVP_PKEY *, struct dsa_st *);
+int EVP_PKEY_set1_DH(EVP_PKEY *, DH *);
+
+int EVP_PKEY_get_attr_count(const EVP_PKEY *);
+int EVP_PKEY_get_attr_by_NID(const EVP_PKEY *, int, int);
+int EVP_PKEY_get_attr_by_OBJ(const EVP_PKEY *, ASN1_OBJECT *, int);
+X509_ATTRIBUTE *EVP_PKEY_get_attr(const EVP_PKEY *, int);
+X509_ATTRIBUTE *EVP_PKEY_delete_attr(EVP_PKEY *, int);
+int EVP_PKEY_add1_attr(EVP_PKEY *, X509_ATTRIBUTE *);
+int EVP_PKEY_add1_attr_by_OBJ(EVP_PKEY *, const ASN1_OBJECT *, int,
+                              const unsigned char *, int);
+int EVP_PKEY_add1_attr_by_NID(EVP_PKEY *, int, int,
+                              const unsigned char *, int);
+int EVP_PKEY_add1_attr_by_txt(EVP_PKEY *, const char *, int,
+                              const unsigned char *, int);
+
+int EVP_PKEY_cmp(const EVP_PKEY *, const EVP_PKEY *);
+
+EVP_PKEY *EVP_PKCS82PKEY(PKCS8_PRIV_KEY_INFO *);
+"""
+
+MACROS = """
+void OpenSSL_add_all_algorithms(void);
+int EVP_PKEY_assign_RSA(EVP_PKEY *, RSA *);
+int EVP_PKEY_assign_DSA(EVP_PKEY *, DSA *);
+
+int EVP_PKEY_assign_EC_KEY(EVP_PKEY *, EC_KEY *);
+EC_KEY *EVP_PKEY_get1_EC_KEY(EVP_PKEY *);
+int EVP_PKEY_set1_EC_KEY(EVP_PKEY *, EC_KEY *);
+
+int EVP_CIPHER_CTX_block_size(const EVP_CIPHER_CTX *);
+int EVP_CIPHER_CTX_ctrl(EVP_CIPHER_CTX *, int, int, void *);
+
+int PKCS5_PBKDF2_HMAC(const char *, int, const unsigned char *, int, int,
+                      const EVP_MD *, int, unsigned char *);
+
+int EVP_PKEY_CTX_set_signature_md(EVP_PKEY_CTX *, const EVP_MD *);
+
+/* These aren't macros, but must be in this section because they're not
+   available in 0.9.8. */
+EVP_PKEY_CTX *EVP_PKEY_CTX_new(EVP_PKEY *, ENGINE *);
+EVP_PKEY_CTX *EVP_PKEY_CTX_new_id(int, ENGINE *);
+EVP_PKEY_CTX *EVP_PKEY_CTX_dup(EVP_PKEY_CTX *);
+void EVP_PKEY_CTX_free(EVP_PKEY_CTX *);
+int EVP_PKEY_sign_init(EVP_PKEY_CTX *);
+int EVP_PKEY_sign(EVP_PKEY_CTX *, unsigned char *, size_t *,
+                  const unsigned char *, size_t);
+int EVP_PKEY_verify_init(EVP_PKEY_CTX *);
+int EVP_PKEY_verify(EVP_PKEY_CTX *, const unsigned char *, size_t,
+                    const unsigned char *, size_t);
+int EVP_PKEY_encrypt_init(EVP_PKEY_CTX *);
+int EVP_PKEY_decrypt_init(EVP_PKEY_CTX *);
+int EVP_PKEY_id(const EVP_PKEY *);
+
+/* The following were macros in 0.9.8e. Once we drop support for RHEL/CentOS 5
+   we should move these back to FUNCTIONS. */
+const EVP_CIPHER *EVP_CIPHER_CTX_cipher(const EVP_CIPHER_CTX *);
+int EVP_CIPHER_block_size(const EVP_CIPHER *);
+const EVP_MD *EVP_MD_CTX_md(const EVP_MD_CTX *);
+int EVP_MD_size(const EVP_MD *);
+
+/* Must be in macros because EVP_PKEY_CTX is undefined in 0.9.8 */
+int Cryptography_EVP_PKEY_encrypt(EVP_PKEY_CTX *ctx, unsigned char *out,
+                                  size_t *outlen, const unsigned char *in,
+                                  size_t inlen);
+int Cryptography_EVP_PKEY_decrypt(EVP_PKEY_CTX *ctx, unsigned char *out,
+                                  size_t *outlen, const unsigned char *in,
+                                  size_t inlen);
+"""
+
+CUSTOMIZATIONS = """
+#ifdef EVP_CTRL_GCM_SET_TAG
+const long Cryptography_HAS_GCM = 1;
+#else
+const long Cryptography_HAS_GCM = 0;
+const long EVP_CTRL_GCM_GET_TAG = -1;
+const long EVP_CTRL_GCM_SET_TAG = -1;
+const long EVP_CTRL_GCM_SET_IVLEN = -1;
+#endif
+#if OPENSSL_VERSION_NUMBER >= 0x10000000L
+const long Cryptography_HAS_PBKDF2_HMAC = 1;
+const long Cryptography_HAS_PKEY_CTX = 1;
+
+/* OpenSSL 0.9.8 defines EVP_PKEY_encrypt and EVP_PKEY_decrypt functions,
+   but they are a completely different signature from the ones in 1.0.0+.
+   These wrapper functions allows us to safely declare them on any version and
+   conditionally remove them on 0.9.8. */
+int Cryptography_EVP_PKEY_encrypt(EVP_PKEY_CTX *ctx, unsigned char *out,
+                                  size_t *outlen, const unsigned char *in,
+                                  size_t inlen) {
+    return EVP_PKEY_encrypt(ctx, out, outlen, in, inlen);
+}
+int Cryptography_EVP_PKEY_decrypt(EVP_PKEY_CTX *ctx, unsigned char *out,
+                                  size_t *outlen, const unsigned char *in,
+                                  size_t inlen) {
+    return EVP_PKEY_decrypt(ctx, out, outlen, in, inlen);
+}
+#else
+const long Cryptography_HAS_PBKDF2_HMAC = 0;
+int (*PKCS5_PBKDF2_HMAC)(const char *, int, const unsigned char *, int, int,
+                         const EVP_MD *, int, unsigned char *) = NULL;
+const long Cryptography_HAS_PKEY_CTX = 0;
+typedef void EVP_PKEY_CTX;
+int (*EVP_PKEY_CTX_set_signature_md)(EVP_PKEY_CTX *, const EVP_MD *) = NULL;
+int (*EVP_PKEY_sign_init)(EVP_PKEY_CTX *) = NULL;
+int (*EVP_PKEY_sign)(EVP_PKEY_CTX *, unsigned char *, size_t *,
+                     const unsigned char *, size_t) = NULL;
+int (*EVP_PKEY_verify_init)(EVP_PKEY_CTX *) = NULL;
+int (*EVP_PKEY_verify)(EVP_PKEY_CTX *, const unsigned char *, size_t,
+                       const unsigned char *, size_t) = NULL;
+EVP_PKEY_CTX *(*EVP_PKEY_CTX_new)(EVP_PKEY *, ENGINE *) = NULL;
+EVP_PKEY_CTX *(*EVP_PKEY_CTX_new_id)(int, ENGINE *) = NULL;
+EVP_PKEY_CTX *(*EVP_PKEY_CTX_dup)(EVP_PKEY_CTX *) = NULL;
+void (*EVP_PKEY_CTX_free)(EVP_PKEY_CTX *) = NULL;
+int (*EVP_PKEY_encrypt_init)(EVP_PKEY_CTX *) = NULL;
+int (*EVP_PKEY_decrypt_init)(EVP_PKEY_CTX *) = NULL;
+int (*Cryptography_EVP_PKEY_encrypt)(EVP_PKEY_CTX *, unsigned char *, size_t *,
+                                     const unsigned char *, size_t) = NULL;
+int (*Cryptography_EVP_PKEY_decrypt)(EVP_PKEY_CTX *, unsigned char *, size_t *,
+                                     const unsigned char *, size_t) = NULL;
+int (*EVP_PKEY_id)(const EVP_PKEY *) = NULL;
+#endif
+#ifdef OPENSSL_NO_EC
+int (*EVP_PKEY_assign_EC_KEY)(EVP_PKEY *, EC_KEY *) = NULL;
+EC_KEY *(*EVP_PKEY_get1_EC_KEY)(EVP_PKEY *) = NULL;
+int (*EVP_PKEY_set1_EC_KEY)(EVP_PKEY *, EC_KEY *) = NULL;
+#endif
+"""
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/hmac.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/hmac.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/hmac.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/hmac.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,83 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+INCLUDES = """
+#include <openssl/hmac.h>
+"""
+
+TYPES = """
+typedef struct { ...; } HMAC_CTX;
+"""
+
+FUNCTIONS = """
+void HMAC_CTX_init(HMAC_CTX *);
+void HMAC_CTX_cleanup(HMAC_CTX *);
+
+int Cryptography_HMAC_Init_ex(HMAC_CTX *, const void *, int, const EVP_MD *,
+                              ENGINE *);
+int Cryptography_HMAC_Update(HMAC_CTX *, const unsigned char *, size_t);
+int Cryptography_HMAC_Final(HMAC_CTX *, unsigned char *, unsigned int *);
+int Cryptography_HMAC_CTX_copy(HMAC_CTX *, HMAC_CTX *);
+"""
+
+MACROS = """
+"""
+
+CUSTOMIZATIONS = """
+int Cryptography_HMAC_Init_ex(HMAC_CTX *ctx, const void *key, int key_len,
+                              const EVP_MD *md, ENGINE *impl) {
+#if OPENSSL_VERSION_NUMBER >= 0x010000000
+    return HMAC_Init_ex(ctx, key, key_len, md, impl);
+#else
+    HMAC_Init_ex(ctx, key, key_len, md, impl);
+    return 1;
+#endif
+}
+
+int Cryptography_HMAC_Update(HMAC_CTX *ctx, const unsigned char *data,
+                             size_t data_len) {
+#if OPENSSL_VERSION_NUMBER >= 0x010000000
+    return HMAC_Update(ctx, data, data_len);
+#else
+    HMAC_Update(ctx, data, data_len);
+    return 1;
+#endif
+}
+
+int Cryptography_HMAC_Final(HMAC_CTX *ctx, unsigned char *digest,
+    unsigned int *outlen) {
+#if OPENSSL_VERSION_NUMBER >= 0x010000000
+    return HMAC_Final(ctx, digest, outlen);
+#else
+    HMAC_Final(ctx, digest, outlen);
+    return 1;
+#endif
+}
+
+int Cryptography_HMAC_CTX_copy(HMAC_CTX *dst_ctx, HMAC_CTX *src_ctx) {
+#if OPENSSL_VERSION_NUMBER >= 0x010000000
+    return HMAC_CTX_copy(dst_ctx, src_ctx);
+#else
+    HMAC_CTX_init(dst_ctx);
+    if (!EVP_MD_CTX_copy_ex(&dst_ctx->i_ctx, &src_ctx->i_ctx)) {
+        goto err;
+    }
+    if (!EVP_MD_CTX_copy_ex(&dst_ctx->o_ctx, &src_ctx->o_ctx)) {
+        goto err;
+    }
+    if (!EVP_MD_CTX_copy_ex(&dst_ctx->md_ctx, &src_ctx->md_ctx)) {
+        goto err;
+    }
+    memcpy(dst_ctx->key, src_ctx->key, HMAC_MAX_MD_CBLOCK);
+    dst_ctx->key_length = src_ctx->key_length;
+    dst_ctx->md = src_ctx->md;
+    return 1;
+
+    err:
+        return 0;
+#endif
+}
+"""
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/__init__.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/__init__.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/__init__.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/__init__.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,5 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/nid.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/nid.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/nid.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/nid.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,239 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+INCLUDES = """
+#include <openssl/obj_mac.h>
+"""
+
+TYPES = """
+static const int Cryptography_HAS_ECDSA_SHA2_NIDS;
+
+static const int NID_undef;
+static const int NID_dsa;
+static const int NID_dsaWithSHA;
+static const int NID_dsaWithSHA1;
+static const int NID_md2;
+static const int NID_md4;
+static const int NID_md5;
+static const int NID_mdc2;
+static const int NID_ripemd160;
+static const int NID_sha;
+static const int NID_sha1;
+static const int NID_sha256;
+static const int NID_sha384;
+static const int NID_sha512;
+static const int NID_sha224;
+static const int NID_sha;
+static const int NID_ecdsa_with_SHA1;
+static const int NID_ecdsa_with_SHA224;
+static const int NID_ecdsa_with_SHA256;
+static const int NID_ecdsa_with_SHA384;
+static const int NID_ecdsa_with_SHA512;
+static const int NID_pbe_WithSHA1And3_Key_TripleDES_CBC;
+static const int NID_X9_62_c2pnb163v1;
+static const int NID_X9_62_c2pnb163v2;
+static const int NID_X9_62_c2pnb163v3;
+static const int NID_X9_62_c2pnb176v1;
+static const int NID_X9_62_c2tnb191v1;
+static const int NID_X9_62_c2tnb191v2;
+static const int NID_X9_62_c2tnb191v3;
+static const int NID_X9_62_c2onb191v4;
+static const int NID_X9_62_c2onb191v5;
+static const int NID_X9_62_c2pnb208w1;
+static const int NID_X9_62_c2tnb239v1;
+static const int NID_X9_62_c2tnb239v2;
+static const int NID_X9_62_c2tnb239v3;
+static const int NID_X9_62_c2onb239v4;
+static const int NID_X9_62_c2onb239v5;
+static const int NID_X9_62_c2pnb272w1;
+static const int NID_X9_62_c2pnb304w1;
+static const int NID_X9_62_c2tnb359v1;
+static const int NID_X9_62_c2pnb368w1;
+static const int NID_X9_62_c2tnb431r1;
+static const int NID_X9_62_prime192v1;
+static const int NID_X9_62_prime192v2;
+static const int NID_X9_62_prime192v3;
+static const int NID_X9_62_prime239v1;
+static const int NID_X9_62_prime239v2;
+static const int NID_X9_62_prime239v3;
+static const int NID_X9_62_prime256v1;
+static const int NID_secp112r1;
+static const int NID_secp112r2;
+static const int NID_secp128r1;
+static const int NID_secp128r2;
+static const int NID_secp160k1;
+static const int NID_secp160r1;
+static const int NID_secp160r2;
+static const int NID_sect163k1;
+static const int NID_sect163r1;
+static const int NID_sect163r2;
+static const int NID_secp192k1;
+static const int NID_secp224k1;
+static const int NID_secp224r1;
+static const int NID_secp256k1;
+static const int NID_secp384r1;
+static const int NID_secp521r1;
+static const int NID_sect113r1;
+static const int NID_sect113r2;
+static const int NID_sect131r1;
+static const int NID_sect131r2;
+static const int NID_sect193r1;
+static const int NID_sect193r2;
+static const int NID_sect233k1;
+static const int NID_sect233r1;
+static const int NID_sect239k1;
+static const int NID_sect283k1;
+static const int NID_sect283r1;
+static const int NID_sect409k1;
+static const int NID_sect409r1;
+static const int NID_sect571k1;
+static const int NID_sect571r1;
+static const int NID_wap_wsg_idm_ecid_wtls1;
+static const int NID_wap_wsg_idm_ecid_wtls3;
+static const int NID_wap_wsg_idm_ecid_wtls4;
+static const int NID_wap_wsg_idm_ecid_wtls5;
+static const int NID_wap_wsg_idm_ecid_wtls6;
+static const int NID_wap_wsg_idm_ecid_wtls7;
+static const int NID_wap_wsg_idm_ecid_wtls8;
+static const int NID_wap_wsg_idm_ecid_wtls9;
+static const int NID_wap_wsg_idm_ecid_wtls10;
+static const int NID_wap_wsg_idm_ecid_wtls11;
+static const int NID_wap_wsg_idm_ecid_wtls12;
+static const int NID_ipsec3;
+static const int NID_ipsec4;
+static const char *const SN_X9_62_c2pnb163v1;
+static const char *const SN_X9_62_c2pnb163v2;
+static const char *const SN_X9_62_c2pnb163v3;
+static const char *const SN_X9_62_c2pnb176v1;
+static const char *const SN_X9_62_c2tnb191v1;
+static const char *const SN_X9_62_c2tnb191v2;
+static const char *const SN_X9_62_c2tnb191v3;
+static const char *const SN_X9_62_c2onb191v4;
+static const char *const SN_X9_62_c2onb191v5;
+static const char *const SN_X9_62_c2pnb208w1;
+static const char *const SN_X9_62_c2tnb239v1;
+static const char *const SN_X9_62_c2tnb239v2;
+static const char *const SN_X9_62_c2tnb239v3;
+static const char *const SN_X9_62_c2onb239v4;
+static const char *const SN_X9_62_c2onb239v5;
+static const char *const SN_X9_62_c2pnb272w1;
+static const char *const SN_X9_62_c2pnb304w1;
+static const char *const SN_X9_62_c2tnb359v1;
+static const char *const SN_X9_62_c2pnb368w1;
+static const char *const SN_X9_62_c2tnb431r1;
+static const char *const SN_X9_62_prime192v1;
+static const char *const SN_X9_62_prime192v2;
+static const char *const SN_X9_62_prime192v3;
+static const char *const SN_X9_62_prime239v1;
+static const char *const SN_X9_62_prime239v2;
+static const char *const SN_X9_62_prime239v3;
+static const char *const SN_X9_62_prime256v1;
+static const char *const SN_secp112r1;
+static const char *const SN_secp112r2;
+static const char *const SN_secp128r1;
+static const char *const SN_secp128r2;
+static const char *const SN_secp160k1;
+static const char *const SN_secp160r1;
+static const char *const SN_secp160r2;
+static const char *const SN_sect163k1;
+static const char *const SN_sect163r1;
+static const char *const SN_sect163r2;
+static const char *const SN_secp192k1;
+static const char *const SN_secp224k1;
+static const char *const SN_secp224r1;
+static const char *const SN_secp256k1;
+static const char *const SN_secp384r1;
+static const char *const SN_secp521r1;
+static const char *const SN_sect113r1;
+static const char *const SN_sect113r2;
+static const char *const SN_sect131r1;
+static const char *const SN_sect131r2;
+static const char *const SN_sect193r1;
+static const char *const SN_sect193r2;
+static const char *const SN_sect233k1;
+static const char *const SN_sect233r1;
+static const char *const SN_sect239k1;
+static const char *const SN_sect283k1;
+static const char *const SN_sect283r1;
+static const char *const SN_sect409k1;
+static const char *const SN_sect409r1;
+static const char *const SN_sect571k1;
+static const char *const SN_sect571r1;
+static const char *const SN_wap_wsg_idm_ecid_wtls1;
+static const char *const SN_wap_wsg_idm_ecid_wtls3;
+static const char *const SN_wap_wsg_idm_ecid_wtls4;
+static const char *const SN_wap_wsg_idm_ecid_wtls5;
+static const char *const SN_wap_wsg_idm_ecid_wtls6;
+static const char *const SN_wap_wsg_idm_ecid_wtls7;
+static const char *const SN_wap_wsg_idm_ecid_wtls8;
+static const char *const SN_wap_wsg_idm_ecid_wtls9;
+static const char *const SN_wap_wsg_idm_ecid_wtls10;
+static const char *const SN_wap_wsg_idm_ecid_wtls11;
+static const char *const SN_wap_wsg_idm_ecid_wtls12;
+static const char *const SN_ipsec3;
+static const char *const SN_ipsec4;
+
+static const int NID_subject_key_identifier;
+static const int NID_authority_key_identifier;
+static const int NID_policy_constraints;
+static const int NID_ext_key_usage;
+static const int NID_info_access;
+static const int NID_key_usage;
+static const int NID_subject_alt_name;
+static const int NID_issuer_alt_name;
+static const int NID_basic_constraints;
+static const int NID_issuing_distribution_point;
+static const int NID_certificate_issuer;
+static const int NID_name_constraints;
+static const int NID_crl_distribution_points;
+static const int NID_certificate_policies;
+static const int NID_inhibit_any_policy;
+
+static const int NID_private_key_usage_period;
+static const int NID_crl_number;
+static const int NID_crl_reason;
+static const int NID_invalidity_date;
+static const int NID_delta_crl;
+static const int NID_any_policy;
+static const int NID_policy_mappings;
+static const int NID_target_information;
+static const int NID_no_rev_avail;
+
+static const int NID_commonName;
+static const int NID_countryName;
+static const int NID_localityName;
+static const int NID_stateOrProvinceName;
+static const int NID_organizationName;
+static const int NID_organizationalUnitName;
+static const int NID_serialNumber;
+static const int NID_surname;
+static const int NID_givenName;
+static const int NID_title;
+static const int NID_generationQualifier;
+static const int NID_dnQualifier;
+static const int NID_pseudonym;
+static const int NID_domainComponent;
+static const int NID_pkcs9_emailAddress;
+"""
+
+FUNCTIONS = """
+"""
+
+MACROS = """
+"""
+
+CUSTOMIZATIONS = """
+/* OpenSSL 0.9.8g+ */
+#if OPENSSL_VERSION_NUMBER >= 0x0090807fL
+static const long Cryptography_HAS_ECDSA_SHA2_NIDS = 1;
+#else
+static const long Cryptography_HAS_ECDSA_SHA2_NIDS = 0;
+static const int NID_ecdsa_with_SHA224 = 0;
+static const int NID_ecdsa_with_SHA256 = 0;
+static const int NID_ecdsa_with_SHA384 = 0;
+static const int NID_ecdsa_with_SHA512 = 0;
+#endif
+"""
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/objects.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/objects.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/objects.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/objects.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,34 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+INCLUDES = """
+#include <openssl/objects.h>
+"""
+
+TYPES = """
+"""
+
+FUNCTIONS = """
+ASN1_OBJECT *OBJ_nid2obj(int);
+const char *OBJ_nid2ln(int);
+const char *OBJ_nid2sn(int);
+int OBJ_obj2nid(const ASN1_OBJECT *);
+int OBJ_ln2nid(const char *);
+int OBJ_sn2nid(const char *);
+int OBJ_txt2nid(const char *);
+ASN1_OBJECT *OBJ_txt2obj(const char *, int);
+int OBJ_obj2txt(char *, int, const ASN1_OBJECT *, int);
+int OBJ_cmp(const ASN1_OBJECT *, const ASN1_OBJECT *);
+ASN1_OBJECT *OBJ_dup(const ASN1_OBJECT *);
+int OBJ_create(const char *, const char *, const char *);
+void OBJ_cleanup(void);
+"""
+
+MACROS = """
+"""
+
+CUSTOMIZATIONS = """
+"""
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/opensslv.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/opensslv.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/opensslv.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/opensslv.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,25 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+INCLUDES = """
+#include <openssl/opensslv.h>
+"""
+
+TYPES = """
+/* Note that these will be resolved when cryptography is compiled and are NOT
+   guaranteed to be the version that it actually loads. */
+static const int OPENSSL_VERSION_NUMBER;
+static const char *const OPENSSL_VERSION_TEXT;
+"""
+
+FUNCTIONS = """
+"""
+
+MACROS = """
+"""
+
+CUSTOMIZATIONS = """
+"""
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/pem.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/pem.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/pem.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/pem.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,92 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+INCLUDES = """
+#include <openssl/pem.h>
+"""
+
+TYPES = """
+typedef int pem_password_cb(char *buf, int size, int rwflag, void *userdata);
+"""
+
+FUNCTIONS = """
+X509 *PEM_read_bio_X509(BIO *, X509 **, pem_password_cb *, void *);
+int PEM_write_bio_X509(BIO *, X509 *);
+
+int PEM_write_bio_PrivateKey(BIO *, EVP_PKEY *, const EVP_CIPHER *,
+                             unsigned char *, int, pem_password_cb *, void *);
+
+EVP_PKEY *PEM_read_bio_PrivateKey(BIO *, EVP_PKEY **, pem_password_cb *,
+                                 void *);
+
+int PEM_write_bio_PKCS8PrivateKey(BIO *, EVP_PKEY *, const EVP_CIPHER *,
+                                  char *, int, pem_password_cb *, void *);
+int PEM_write_bio_PKCS8PrivateKey_nid(BIO *, EVP_PKEY *, int, char *, int,
+                                      pem_password_cb *, void *);
+
+int i2d_PKCS8PrivateKey_bio(BIO *, EVP_PKEY *, const EVP_CIPHER *,
+                            char *, int, pem_password_cb *, void *);
+int i2d_PKCS8PrivateKey_nid_bio(BIO *, EVP_PKEY *, int,
+                                char *, int, pem_password_cb *, void *);
+
+int i2d_PKCS7_bio(BIO *, PKCS7 *);
+PKCS7 *d2i_PKCS7_bio(BIO *, PKCS7 **);
+
+EVP_PKEY *d2i_PKCS8PrivateKey_bio(BIO *, EVP_PKEY **, pem_password_cb *,
+                                  void *);
+
+int PEM_write_bio_X509_REQ(BIO *, X509_REQ *);
+
+X509_REQ *PEM_read_bio_X509_REQ(BIO *, X509_REQ **, pem_password_cb *, void *);
+
+X509_CRL *PEM_read_bio_X509_CRL(BIO *, X509_CRL **, pem_password_cb *, void *);
+
+int PEM_write_bio_X509_CRL(BIO *, X509_CRL *);
+
+PKCS7 *PEM_read_bio_PKCS7(BIO *, PKCS7 **, pem_password_cb *, void *);
+int PEM_write_bio_PKCS7(BIO *, PKCS7 *);
+
+DH *PEM_read_bio_DHparams(BIO *, DH **, pem_password_cb *, void *);
+
+DSA *PEM_read_bio_DSAPrivateKey(BIO *, DSA **, pem_password_cb *, void *);
+
+RSA *PEM_read_bio_RSAPrivateKey(BIO *, RSA **, pem_password_cb *, void *);
+
+int PEM_write_bio_DSAPrivateKey(BIO *, DSA *, const EVP_CIPHER *,
+                                unsigned char *, int,
+                                pem_password_cb *, void *);
+
+int PEM_write_bio_RSAPrivateKey(BIO *, RSA *, const EVP_CIPHER *,
+                                unsigned char *, int,
+                                pem_password_cb *, void *);
+
+DSA *PEM_read_bio_DSA_PUBKEY(BIO *, DSA **, pem_password_cb *, void *);
+
+RSA *PEM_read_bio_RSAPublicKey(BIO *, RSA **, pem_password_cb *, void *);
+
+int PEM_write_bio_DSA_PUBKEY(BIO *, DSA *);
+
+int PEM_write_bio_RSAPublicKey(BIO *, const RSA *);
+
+EVP_PKEY *PEM_read_bio_PUBKEY(BIO *, EVP_PKEY **, pem_password_cb *, void *);
+int PEM_write_bio_PUBKEY(BIO *, EVP_PKEY *);
+"""
+
+MACROS = """
+int PEM_write_bio_ECPrivateKey(BIO *, EC_KEY *, const EVP_CIPHER *,
+                               unsigned char *, int, pem_password_cb *,
+                               void *);
+"""
+
+CUSTOMIZATIONS = """
+// Cryptography_HAS_EC is provided by ec.py so we don't need to define it here
+#ifdef OPENSSL_NO_EC
+int (*PEM_write_bio_ECPrivateKey)(BIO *, EC_KEY *, const EVP_CIPHER *,
+                                  unsigned char *, int, pem_password_cb *,
+                                  void *) = NULL;
+#endif
+
+"""
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/pkcs12.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/pkcs12.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/pkcs12.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/pkcs12.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,30 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+INCLUDES = """
+#include <openssl/pkcs12.h>
+"""
+
+TYPES = """
+typedef ... PKCS12;
+"""
+
+FUNCTIONS = """
+void PKCS12_free(PKCS12 *);
+
+PKCS12 *d2i_PKCS12_bio(BIO *, PKCS12 **);
+int i2d_PKCS12_bio(BIO *, PKCS12 *);
+"""
+
+MACROS = """
+int PKCS12_parse(PKCS12 *, const char *, EVP_PKEY **, X509 **,
+                 Cryptography_STACK_OF_X509 **);
+PKCS12 *PKCS12_create(char *, char *, EVP_PKEY *, X509 *,
+                      Cryptography_STACK_OF_X509 *, int, int, int, int, int);
+"""
+
+CUSTOMIZATIONS = """
+"""
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/pkcs7.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/pkcs7.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/pkcs7.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/pkcs7.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,86 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+INCLUDES = """
+#include <openssl/pkcs7.h>
+"""
+
+TYPES = """
+typedef struct {
+    Cryptography_STACK_OF_X509 *cert;
+    Cryptography_STACK_OF_X509_CRL *crl;
+    ...;
+} PKCS7_SIGNED;
+
+typedef struct {
+    Cryptography_STACK_OF_X509 *cert;
+    Cryptography_STACK_OF_X509_CRL *crl;
+    ...;
+} PKCS7_SIGN_ENVELOPE;
+
+typedef ... PKCS7_DIGEST;
+typedef ... PKCS7_ENCRYPT;
+typedef ... PKCS7_ENVELOPE;
+
+typedef struct {
+    ASN1_OBJECT *type;
+    union {
+        char *ptr;
+        ASN1_OCTET_STRING *data;
+        PKCS7_SIGNED *sign;
+        PKCS7_ENVELOPE *enveloped;
+        PKCS7_SIGN_ENVELOPE *signed_and_enveloped;
+        PKCS7_DIGEST *digest;
+        PKCS7_ENCRYPT *encrypted;
+        ASN1_TYPE *other;
+     } d;
+    ...;
+} PKCS7;
+
+static const int PKCS7_BINARY;
+static const int PKCS7_DETACHED;
+static const int PKCS7_NOATTR;
+static const int PKCS7_NOCERTS;
+static const int PKCS7_NOCHAIN;
+static const int PKCS7_NOINTERN;
+static const int PKCS7_NOSIGS;
+static const int PKCS7_NOSMIMECAP;
+static const int PKCS7_NOVERIFY;
+static const int PKCS7_STREAM;
+static const int PKCS7_TEXT;
+"""
+
+FUNCTIONS = """
+PKCS7 *SMIME_read_PKCS7(BIO *, BIO **);
+int SMIME_write_PKCS7(BIO *, PKCS7 *, BIO *, int);
+
+void PKCS7_free(PKCS7 *);
+
+PKCS7 *PKCS7_sign(X509 *, EVP_PKEY *, Cryptography_STACK_OF_X509 *,
+                  BIO *, int);
+int PKCS7_verify(PKCS7 *, Cryptography_STACK_OF_X509 *, X509_STORE *, BIO *,
+                 BIO *, int);
+Cryptography_STACK_OF_X509 *PKCS7_get0_signers(PKCS7 *,
+                                               Cryptography_STACK_OF_X509 *,
+                                               int);
+
+PKCS7 *PKCS7_encrypt(Cryptography_STACK_OF_X509 *, BIO *,
+                     const EVP_CIPHER *, int);
+int PKCS7_decrypt(PKCS7 *, EVP_PKEY *, X509 *, BIO *, int);
+
+BIO *PKCS7_dataInit(PKCS7 *, BIO *);
+"""
+
+MACROS = """
+int PKCS7_type_is_encrypted(PKCS7 *);
+int PKCS7_type_is_signed(PKCS7 *);
+int PKCS7_type_is_enveloped(PKCS7 *);
+int PKCS7_type_is_signedAndEnveloped(PKCS7 *);
+int PKCS7_type_is_data(PKCS7 *);
+int PKCS7_type_is_digest(PKCS7 *);
+"""
+
+CUSTOMIZATIONS = ""
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/rand.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/rand.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/rand.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/rand.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,43 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+INCLUDES = """
+#include <openssl/rand.h>
+"""
+
+TYPES = """
+static const long Cryptography_HAS_EGD;
+"""
+
+FUNCTIONS = """
+void ERR_load_RAND_strings(void);
+void RAND_seed(const void *, int);
+void RAND_add(const void *, int, double);
+int RAND_status(void);
+const char *RAND_file_name(char *, size_t);
+int RAND_load_file(const char *, long);
+int RAND_write_file(const char *);
+void RAND_cleanup(void);
+int RAND_bytes(unsigned char *, int);
+int RAND_pseudo_bytes(unsigned char *, int);
+"""
+
+MACROS = """
+int RAND_egd(const char *);
+int RAND_egd_bytes(const char *, int);
+int RAND_query_egd_bytes(const char *, unsigned char *, int);
+"""
+
+CUSTOMIZATIONS = """
+#if defined(LIBRESSL_VERSION_NUMBER)
+static const long Cryptography_HAS_EGD = 0;
+int (*RAND_egd)(const char *) = NULL;
+int (*RAND_egd_bytes)(const char *, int) = NULL;
+int (*RAND_query_egd_bytes)(const char *, unsigned char *, int) = NULL;
+#else
+static const long Cryptography_HAS_EGD = 1;
+#endif
+"""
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/rsa.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/rsa.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/rsa.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/rsa.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,86 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+INCLUDES = """
+#include <openssl/rsa.h>
+"""
+
+TYPES = """
+typedef struct rsa_st {
+    BIGNUM *n;
+    BIGNUM *e;
+    BIGNUM *d;
+    BIGNUM *p;
+    BIGNUM *q;
+    BIGNUM *dmp1;
+    BIGNUM *dmq1;
+    BIGNUM *iqmp;
+    ...;
+} RSA;
+typedef ... BN_GENCB;
+static const int RSA_PKCS1_PADDING;
+static const int RSA_SSLV23_PADDING;
+static const int RSA_NO_PADDING;
+static const int RSA_PKCS1_OAEP_PADDING;
+static const int RSA_X931_PADDING;
+static const int RSA_PKCS1_PSS_PADDING;
+static const int RSA_F4;
+
+static const int Cryptography_HAS_PSS_PADDING;
+static const int Cryptography_HAS_MGF1_MD;
+"""
+
+FUNCTIONS = """
+RSA *RSA_new(void);
+void RSA_free(RSA *);
+int RSA_size(const RSA *);
+int RSA_generate_key_ex(RSA *, int, BIGNUM *, BN_GENCB *);
+int RSA_check_key(const RSA *);
+RSA *RSAPublicKey_dup(RSA *);
+int RSA_blinding_on(RSA *, BN_CTX *);
+void RSA_blinding_off(RSA *);
+int RSA_public_encrypt(int, const unsigned char *, unsigned char *,
+                       RSA *, int);
+int RSA_private_encrypt(int, const unsigned char *, unsigned char *,
+                        RSA *, int);
+int RSA_public_decrypt(int, const unsigned char *, unsigned char *,
+                       RSA *, int);
+int RSA_private_decrypt(int, const unsigned char *, unsigned char *,
+                        RSA *, int);
+int RSA_print(BIO *, const RSA *, int);
+int RSA_verify_PKCS1_PSS(RSA *, const unsigned char *, const EVP_MD *,
+                         const unsigned char *, int);
+int RSA_padding_add_PKCS1_PSS(RSA *, unsigned char *, const unsigned char *,
+                              const EVP_MD *, int);
+int RSA_padding_add_PKCS1_OAEP(unsigned char *, int, const unsigned char *,
+                               int, const unsigned char *, int);
+int RSA_padding_check_PKCS1_OAEP(unsigned char *, int, const unsigned char *,
+                                 int, int, const unsigned char *, int);
+"""
+
+MACROS = """
+int EVP_PKEY_CTX_set_rsa_padding(EVP_PKEY_CTX *, int);
+int EVP_PKEY_CTX_set_rsa_pss_saltlen(EVP_PKEY_CTX *, int);
+int EVP_PKEY_CTX_set_rsa_mgf1_md(EVP_PKEY_CTX *, EVP_MD *);
+"""
+
+CUSTOMIZATIONS = """
+#if OPENSSL_VERSION_NUMBER >= 0x10000000
+static const long Cryptography_HAS_PSS_PADDING = 1;
+#else
+/* see evp.py for the definition of Cryptography_HAS_PKEY_CTX */
+static const long Cryptography_HAS_PSS_PADDING = 0;
+int (*EVP_PKEY_CTX_set_rsa_padding)(EVP_PKEY_CTX *, int) = NULL;
+int (*EVP_PKEY_CTX_set_rsa_pss_saltlen)(EVP_PKEY_CTX *, int) = NULL;
+static const long RSA_PKCS1_PSS_PADDING = 0;
+#endif
+#if OPENSSL_VERSION_NUMBER >= 0x1000100f
+static const long Cryptography_HAS_MGF1_MD = 1;
+#else
+static const long Cryptography_HAS_MGF1_MD = 0;
+int (*EVP_PKEY_CTX_set_rsa_mgf1_md)(EVP_PKEY_CTX *, EVP_MD *) = NULL;
+#endif
+"""
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/ssl.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/ssl.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/ssl.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/ssl.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,653 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+INCLUDES = """
+#include <openssl/ssl.h>
+
+typedef STACK_OF(SSL_CIPHER) Cryptography_STACK_OF_SSL_CIPHER;
+"""
+
+TYPES = """
+/*
+ * Internally invented symbols to tell which versions of SSL/TLS are supported.
+*/
+static const long Cryptography_HAS_SSL2;
+static const long Cryptography_HAS_SSL3_METHOD;
+static const long Cryptography_HAS_TLSv1_1;
+static const long Cryptography_HAS_TLSv1_2;
+static const long Cryptography_HAS_SECURE_RENEGOTIATION;
+static const long Cryptography_HAS_COMPRESSION;
+static const long Cryptography_HAS_TLSEXT_STATUS_REQ_CB;
+static const long Cryptography_HAS_STATUS_REQ_OCSP_RESP;
+static const long Cryptography_HAS_TLSEXT_STATUS_REQ_TYPE;
+static const long Cryptography_HAS_GET_SERVER_TMP_KEY;
+static const long Cryptography_HAS_SSL_CTX_SET_CLIENT_CERT_ENGINE;
+
+/* Internally invented symbol to tell us if SNI is supported */
+static const long Cryptography_HAS_TLSEXT_HOSTNAME;
+
+/* Internally invented symbol to tell us if SSL_MODE_RELEASE_BUFFERS is
+ * supported
+ */
+static const long Cryptography_HAS_RELEASE_BUFFERS;
+
+/* Internally invented symbol to tell us if SSL_OP_NO_COMPRESSION is
+ * supported
+ */
+static const long Cryptography_HAS_OP_NO_COMPRESSION;
+
+static const long Cryptography_HAS_SSL_OP_MSIE_SSLV2_RSA_PADDING;
+static const long Cryptography_HAS_SSL_SET_SSL_CTX;
+static const long Cryptography_HAS_SSL_OP_NO_TICKET;
+static const long Cryptography_HAS_NETBSD_D1_METH;
+static const long Cryptography_HAS_NEXTPROTONEG;
+static const long Cryptography_HAS_ALPN;
+static const long Cryptography_HAS_SET_CERT_CB;
+
+static const long SSL_FILETYPE_PEM;
+static const long SSL_FILETYPE_ASN1;
+static const long SSL_ERROR_NONE;
+static const long SSL_ERROR_ZERO_RETURN;
+static const long SSL_ERROR_WANT_READ;
+static const long SSL_ERROR_WANT_WRITE;
+static const long SSL_ERROR_WANT_X509_LOOKUP;
+static const long SSL_ERROR_SYSCALL;
+static const long SSL_ERROR_SSL;
+static const long SSL_SENT_SHUTDOWN;
+static const long SSL_RECEIVED_SHUTDOWN;
+static const long SSL_OP_NO_SSLv2;
+static const long SSL_OP_NO_SSLv3;
+static const long SSL_OP_NO_TLSv1;
+static const long SSL_OP_NO_TLSv1_1;
+static const long SSL_OP_NO_TLSv1_2;
+static const long SSL_OP_NO_COMPRESSION;
+static const long SSL_OP_SINGLE_DH_USE;
+static const long SSL_OP_EPHEMERAL_RSA;
+static const long SSL_OP_MICROSOFT_SESS_ID_BUG;
+static const long SSL_OP_NETSCAPE_CHALLENGE_BUG;
+static const long SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG;
+static const long SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG;
+static const long SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER;
+static const long SSL_OP_MSIE_SSLV2_RSA_PADDING;
+static const long SSL_OP_SSLEAY_080_CLIENT_DH_BUG;
+static const long SSL_OP_TLS_D5_BUG;
+static const long SSL_OP_TLS_BLOCK_PADDING_BUG;
+static const long SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS;
+static const long SSL_OP_CIPHER_SERVER_PREFERENCE;
+static const long SSL_OP_TLS_ROLLBACK_BUG;
+static const long SSL_OP_PKCS1_CHECK_1;
+static const long SSL_OP_PKCS1_CHECK_2;
+static const long SSL_OP_NETSCAPE_CA_DN_BUG;
+static const long SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG;
+static const long SSL_OP_NO_QUERY_MTU;
+static const long SSL_OP_COOKIE_EXCHANGE;
+static const long SSL_OP_NO_TICKET;
+static const long SSL_OP_ALL;
+static const long SSL_OP_SINGLE_ECDH_USE;
+static const long SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION;
+static const long SSL_OP_LEGACY_SERVER_CONNECT;
+static const long SSL_VERIFY_PEER;
+static const long SSL_VERIFY_FAIL_IF_NO_PEER_CERT;
+static const long SSL_VERIFY_CLIENT_ONCE;
+static const long SSL_VERIFY_NONE;
+static const long SSL_SESS_CACHE_OFF;
+static const long SSL_SESS_CACHE_CLIENT;
+static const long SSL_SESS_CACHE_SERVER;
+static const long SSL_SESS_CACHE_BOTH;
+static const long SSL_SESS_CACHE_NO_AUTO_CLEAR;
+static const long SSL_SESS_CACHE_NO_INTERNAL_LOOKUP;
+static const long SSL_SESS_CACHE_NO_INTERNAL_STORE;
+static const long SSL_SESS_CACHE_NO_INTERNAL;
+static const long SSL_ST_CONNECT;
+static const long SSL_ST_ACCEPT;
+static const long SSL_ST_MASK;
+static const long SSL_ST_INIT;
+static const long SSL_ST_BEFORE;
+static const long SSL_ST_OK;
+static const long SSL_ST_RENEGOTIATE;
+static const long SSL_CB_LOOP;
+static const long SSL_CB_EXIT;
+static const long SSL_CB_READ;
+static const long SSL_CB_WRITE;
+static const long SSL_CB_ALERT;
+static const long SSL_CB_READ_ALERT;
+static const long SSL_CB_WRITE_ALERT;
+static const long SSL_CB_ACCEPT_LOOP;
+static const long SSL_CB_ACCEPT_EXIT;
+static const long SSL_CB_CONNECT_LOOP;
+static const long SSL_CB_CONNECT_EXIT;
+static const long SSL_CB_HANDSHAKE_START;
+static const long SSL_CB_HANDSHAKE_DONE;
+static const long SSL_MODE_RELEASE_BUFFERS;
+static const long SSL_MODE_ENABLE_PARTIAL_WRITE;
+static const long SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER;
+static const long SSL_MODE_AUTO_RETRY;
+static const long SSL3_RANDOM_SIZE;
+
+typedef ... SSL_METHOD;
+typedef ... SSL_CTX;
+
+typedef struct {
+    int master_key_length;
+    unsigned char master_key[...];
+    unsigned int session_id_length;
+    unsigned char session_id[...];
+    unsigned int sid_ctx_length;
+    unsigned char sid_ctx[...];
+    ...;
+} SSL_SESSION;
+
+typedef struct {
+    unsigned char server_random[...];
+    unsigned char client_random[...];
+    ...;
+} SSL3_STATE;
+
+typedef struct {
+    int version;
+    int type;
+    SSL3_STATE *s3;
+    SSL_SESSION *session;
+    ...;
+} SSL;
+
+static const long TLSEXT_NAMETYPE_host_name;
+
+typedef ... SSL_CIPHER;
+typedef ... Cryptography_STACK_OF_SSL_CIPHER;
+typedef ... COMP_METHOD;
+"""
+
+FUNCTIONS = """
+void SSL_load_error_strings(void);
+int SSL_library_init(void);
+
+/*  SSL */
+const char *SSL_state_string_long(const SSL *);
+SSL_SESSION *SSL_get1_session(SSL *);
+int SSL_set_session(SSL *, SSL_SESSION *);
+int SSL_get_verify_mode(const SSL *);
+void SSL_set_verify(SSL *, int, int (*)(int, X509_STORE_CTX *));
+void SSL_set_verify_depth(SSL *, int);
+int SSL_get_verify_depth(const SSL *);
+int (*SSL_get_verify_callback(const SSL *))(int, X509_STORE_CTX *);
+void SSL_set_info_callback(SSL *ssl, void (*)(const SSL *, int, int));
+void (*SSL_get_info_callback(const SSL *))(const SSL *, int, int);
+SSL *SSL_new(SSL_CTX *);
+void SSL_free(SSL *);
+int SSL_set_fd(SSL *, int);
+void SSL_set_bio(SSL *, BIO *, BIO *);
+void SSL_set_connect_state(SSL *);
+void SSL_set_accept_state(SSL *);
+void SSL_set_shutdown(SSL *, int);
+int SSL_get_shutdown(const SSL *);
+int SSL_pending(const SSL *);
+int SSL_write(SSL *, const void *, int);
+int SSL_read(SSL *, void *, int);
+int SSL_peek(SSL *, void *, int);
+X509 *SSL_get_peer_certificate(const SSL *);
+int SSL_get_ex_data_X509_STORE_CTX_idx(void);
+
+int SSL_use_certificate(SSL *, X509 *);
+int SSL_use_certificate_ASN1(SSL *, const unsigned char *, int);
+int SSL_use_certificate_file(SSL *, const char *, int);
+int SSL_use_PrivateKey(SSL *, EVP_PKEY *);
+int SSL_use_PrivateKey_ASN1(int, SSL *, const unsigned char *, long);
+int SSL_use_PrivateKey_file(SSL *, const char *, int);
+int SSL_check_private_key(const SSL *);
+
+Cryptography_STACK_OF_X509 *SSL_get_peer_cert_chain(const SSL *);
+Cryptography_STACK_OF_X509_NAME *SSL_get_client_CA_list(const SSL *);
+
+int SSL_get_error(const SSL *, int);
+int SSL_do_handshake(SSL *);
+int SSL_shutdown(SSL *);
+int SSL_renegotiate(SSL *);
+int SSL_renegotiate_pending(SSL *);
+const char *SSL_get_cipher_list(const SSL *, int);
+Cryptography_STACK_OF_SSL_CIPHER *SSL_get_ciphers(const SSL *);
+
+/*  context */
+void SSL_CTX_free(SSL_CTX *);
+long SSL_CTX_set_timeout(SSL_CTX *, long);
+int SSL_CTX_set_default_verify_paths(SSL_CTX *);
+void SSL_CTX_set_verify(SSL_CTX *, int, int (*)(int, X509_STORE_CTX *));
+void SSL_CTX_set_verify_depth(SSL_CTX *, int);
+int (*SSL_CTX_get_verify_callback(const SSL_CTX *))(int, X509_STORE_CTX *);
+int SSL_CTX_get_verify_mode(const SSL_CTX *);
+int SSL_CTX_get_verify_depth(const SSL_CTX *);
+int SSL_CTX_set_cipher_list(SSL_CTX *, const char *);
+int SSL_CTX_load_verify_locations(SSL_CTX *, const char *, const char *);
+void SSL_CTX_set_default_passwd_cb(SSL_CTX *, pem_password_cb *);
+void SSL_CTX_set_default_passwd_cb_userdata(SSL_CTX *, void *);
+int SSL_CTX_use_certificate(SSL_CTX *, X509 *);
+int SSL_CTX_use_certificate_ASN1(SSL_CTX *, int, const unsigned char *);
+int SSL_CTX_use_certificate_file(SSL_CTX *, const char *, int);
+int SSL_CTX_use_certificate_chain_file(SSL_CTX *, const char *);
+int SSL_CTX_use_PrivateKey(SSL_CTX *, EVP_PKEY *);
+int SSL_CTX_use_PrivateKey_ASN1(int, SSL_CTX *, const unsigned char *, long);
+int SSL_CTX_use_PrivateKey_file(SSL_CTX *, const char *, int);
+int SSL_CTX_check_private_key(const SSL_CTX *);
+void SSL_CTX_set_cert_verify_callback(SSL_CTX *,
+                                      int (*)(X509_STORE_CTX *,void *),
+                                      void *);
+
+void SSL_CTX_set_cert_store(SSL_CTX *, X509_STORE *);
+X509_STORE *SSL_CTX_get_cert_store(const SSL_CTX *);
+int SSL_CTX_add_client_CA(SSL_CTX *, X509 *);
+
+void SSL_CTX_set_client_CA_list(SSL_CTX *, Cryptography_STACK_OF_X509_NAME *);
+
+/*  SSL_SESSION */
+void SSL_SESSION_free(SSL_SESSION *);
+
+/* Information about actually used cipher */
+const char *SSL_CIPHER_get_name(const SSL_CIPHER *);
+int SSL_CIPHER_get_bits(const SSL_CIPHER *, int *);
+char *SSL_CIPHER_get_version(const SSL_CIPHER *);
+
+size_t SSL_get_finished(const SSL *, void *, size_t);
+size_t SSL_get_peer_finished(const SSL *, void *, size_t);
+"""
+
+MACROS = """
+/* not a macro, but older OpenSSLs don't pass the args as const */
+char *SSL_CIPHER_description(const SSL_CIPHER *, char *, int);
+int SSL_SESSION_print(BIO *, const SSL_SESSION *);
+
+/* not macros, but will be conditionally bound so can't live in functions */
+const COMP_METHOD *SSL_get_current_compression(SSL *);
+const COMP_METHOD *SSL_get_current_expansion(SSL *);
+const char *SSL_COMP_get_name(const COMP_METHOD *);
+int SSL_CTX_set_client_cert_engine(SSL_CTX *, ENGINE *);
+
+unsigned long SSL_set_mode(SSL *, unsigned long);
+unsigned long SSL_get_mode(SSL *);
+
+unsigned long SSL_set_options(SSL *, unsigned long);
+unsigned long SSL_get_options(SSL *);
+
+int SSL_want_read(const SSL *);
+int SSL_want_write(const SSL *);
+
+long SSL_total_renegotiations(SSL *);
+long SSL_get_secure_renegotiation_support(SSL *);
+
+/* Defined as unsigned long because SSL_OP_ALL is greater than signed 32-bit
+   and Windows defines long as 32-bit. */
+unsigned long SSL_CTX_set_options(SSL_CTX *, unsigned long);
+unsigned long SSL_CTX_get_options(SSL_CTX *);
+unsigned long SSL_CTX_set_mode(SSL_CTX *, unsigned long);
+unsigned long SSL_CTX_get_mode(SSL_CTX *);
+unsigned long SSL_CTX_set_session_cache_mode(SSL_CTX *, unsigned long);
+unsigned long SSL_CTX_get_session_cache_mode(SSL_CTX *);
+unsigned long SSL_CTX_set_tmp_dh(SSL_CTX *, DH *);
+unsigned long SSL_CTX_set_tmp_ecdh(SSL_CTX *, EC_KEY *);
+unsigned long SSL_CTX_add_extra_chain_cert(SSL_CTX *, X509 *);
+
+/*- These aren't macros these functions are all const X on openssl > 1.0.x -*/
+
+/*  methods */
+
+/* SSLv2 support is compiled out of some versions of OpenSSL.  These will
+ * get special support when we generate the bindings so that if they are
+ * available they will be wrapped, but if they are not they won't cause
+ * problems (like link errors).
+ */
+const SSL_METHOD *SSLv2_method(void);
+const SSL_METHOD *SSLv2_server_method(void);
+const SSL_METHOD *SSLv2_client_method(void);
+
+/*
+ * TLSv1_1 and TLSv1_2 are recent additions.  Only sufficiently new versions of
+ * OpenSSL support them.
+ */
+const SSL_METHOD *TLSv1_1_method(void);
+const SSL_METHOD *TLSv1_1_server_method(void);
+const SSL_METHOD *TLSv1_1_client_method(void);
+
+const SSL_METHOD *TLSv1_2_method(void);
+const SSL_METHOD *TLSv1_2_server_method(void);
+const SSL_METHOD *TLSv1_2_client_method(void);
+
+const SSL_METHOD *SSLv3_method(void);
+const SSL_METHOD *SSLv3_server_method(void);
+const SSL_METHOD *SSLv3_client_method(void);
+
+const SSL_METHOD *TLSv1_method(void);
+const SSL_METHOD *TLSv1_server_method(void);
+const SSL_METHOD *TLSv1_client_method(void);
+
+const SSL_METHOD *DTLSv1_method(void);
+const SSL_METHOD *DTLSv1_server_method(void);
+const SSL_METHOD *DTLSv1_client_method(void);
+
+const SSL_METHOD *SSLv23_method(void);
+const SSL_METHOD *SSLv23_server_method(void);
+const SSL_METHOD *SSLv23_client_method(void);
+
+/*- These aren't macros these arguments are all const X on openssl > 1.0.x -*/
+SSL_CTX *SSL_CTX_new(SSL_METHOD *);
+long SSL_CTX_get_timeout(const SSL_CTX *);
+
+const SSL_CIPHER *SSL_get_current_cipher(const SSL *);
+const char *SSL_get_version(const SSL *);
+int SSL_version(const SSL *);
+
+/* SNI APIs were introduced in OpenSSL 1.0.0.  To continue to support
+ * earlier versions some special handling of these is necessary.
+ */
+const char *SSL_get_servername(const SSL *, const int);
+void SSL_set_tlsext_host_name(SSL *, char *);
+void SSL_CTX_set_tlsext_servername_callback(
+    SSL_CTX *,
+    int (*)(const SSL *, int *, void *));
+
+/* These were added in OpenSSL 0.9.8h, but since version testing in OpenSSL
+   is fraught with peril thanks to OS distributions we check some constants
+   to determine if they are supported or not */
+long SSL_set_tlsext_status_ocsp_resp(SSL *, unsigned char *, int);
+long SSL_get_tlsext_status_ocsp_resp(SSL *, const unsigned char **);
+long SSL_set_tlsext_status_type(SSL *, long);
+long SSL_CTX_set_tlsext_status_cb(SSL_CTX *, int(*)(SSL *, void *));
+long SSL_CTX_set_tlsext_status_arg(SSL_CTX *, void *);
+
+long SSL_session_reused(SSL *);
+
+/* The following were macros in 0.9.8e. Once we drop support for RHEL/CentOS 5
+   we should move these back to FUNCTIONS. */
+void SSL_CTX_set_info_callback(SSL_CTX *, void (*)(const SSL *, int, int));
+void (*SSL_CTX_get_info_callback(SSL_CTX *))(const SSL *, int, int);
+/* This function does not exist in 0.9.8e. Once we drop support for
+   RHEL/CentOS 5 this can be moved back to FUNCTIONS. */
+SSL_CTX *SSL_set_SSL_CTX(SSL *, SSL_CTX *);
+
+const SSL_METHOD *Cryptography_SSL_CTX_get_method(const SSL_CTX *);
+
+/* NPN APIs were introduced in OpenSSL 1.0.1.  To continue to support earlier
+ * versions some special handling of these is necessary.
+ */
+void SSL_CTX_set_next_protos_advertised_cb(SSL_CTX *,
+                                           int (*)(SSL *,
+                                                   const unsigned char **,
+                                                   unsigned int *,
+                                                   void *),
+                                           void *);
+void SSL_CTX_set_next_proto_select_cb(SSL_CTX *,
+                                      int (*)(SSL *,
+                                              unsigned char **,
+                                              unsigned char *,
+                                              const unsigned char *,
+                                              unsigned int,
+                                              void *),
+                                      void *);
+int SSL_select_next_proto(unsigned char **, unsigned char *,
+                          const unsigned char *, unsigned int,
+                          const unsigned char *, unsigned int);
+void SSL_get0_next_proto_negotiated(const SSL *,
+                                    const unsigned char **, unsigned *);
+
+int sk_SSL_CIPHER_num(Cryptography_STACK_OF_SSL_CIPHER *);
+SSL_CIPHER *sk_SSL_CIPHER_value(Cryptography_STACK_OF_SSL_CIPHER *, int);
+
+/* ALPN APIs were introduced in OpenSSL 1.0.2.  To continue to support earlier
+ * versions some special handling of these is necessary.
+ */
+int SSL_CTX_set_alpn_protos(SSL_CTX *, const unsigned char *, unsigned);
+int SSL_set_alpn_protos(SSL *, const unsigned char *, unsigned);
+void SSL_CTX_set_alpn_select_cb(SSL_CTX *,
+                                int (*) (SSL *,
+                                         const unsigned char **,
+                                         unsigned char *,
+                                         const unsigned char *,
+                                         unsigned int,
+                                         void *),
+                                void *);
+void SSL_get0_alpn_selected(const SSL *, const unsigned char **, unsigned *);
+
+long SSL_get_server_tmp_key(SSL *, EVP_PKEY **);
+
+/* SSL_CTX_set_cert_cb is introduced in OpenSSL 1.0.2. To continue to support
+ * earlier versions some special handling of these is necessary.
+ */
+void SSL_CTX_set_cert_cb(SSL_CTX *, int (*)(SSL *, void *), void *);
+void SSL_set_cert_cb(SSL *, int (*)(SSL *, void *), void *);
+"""
+
+CUSTOMIZATIONS = """
+/** Secure renegotiation is supported in OpenSSL >= 0.9.8m
+ *  But some Linux distributions have back ported some features.
+ */
+#ifndef SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION
+static const long Cryptography_HAS_SECURE_RENEGOTIATION = 0;
+long (*SSL_get_secure_renegotiation_support)(SSL *) = NULL;
+const long SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION = 0;
+const long SSL_OP_LEGACY_SERVER_CONNECT = 0;
+#else
+static const long Cryptography_HAS_SECURE_RENEGOTIATION = 1;
+#endif
+#ifdef OPENSSL_NO_SSL2
+static const long Cryptography_HAS_SSL2 = 0;
+SSL_METHOD* (*SSLv2_method)(void) = NULL;
+SSL_METHOD* (*SSLv2_client_method)(void) = NULL;
+SSL_METHOD* (*SSLv2_server_method)(void) = NULL;
+#else
+static const long Cryptography_HAS_SSL2 = 1;
+#endif
+
+#ifdef OPENSSL_NO_SSL3_METHOD
+static const long Cryptography_HAS_SSL3_METHOD = 0;
+SSL_METHOD* (*SSLv3_method)(void) = NULL;
+SSL_METHOD* (*SSLv3_client_method)(void) = NULL;
+SSL_METHOD* (*SSLv3_server_method)(void) = NULL;
+#else
+static const long Cryptography_HAS_SSL3_METHOD = 1;
+#endif
+
+#ifdef SSL_CTRL_SET_TLSEXT_HOSTNAME
+static const long Cryptography_HAS_TLSEXT_HOSTNAME = 1;
+#else
+static const long Cryptography_HAS_TLSEXT_HOSTNAME = 0;
+void (*SSL_set_tlsext_host_name)(SSL *, char *) = NULL;
+const char* (*SSL_get_servername)(const SSL *, const int) = NULL;
+void (*SSL_CTX_set_tlsext_servername_callback)(
+    SSL_CTX *,
+    int (*)(const SSL *, int *, void *)) = NULL;
+#endif
+
+#ifdef SSL_CTRL_SET_TLSEXT_STATUS_REQ_CB
+static const long Cryptography_HAS_TLSEXT_STATUS_REQ_CB = 1;
+#else
+static const long Cryptography_HAS_TLSEXT_STATUS_REQ_CB = 0;
+long (*SSL_CTX_set_tlsext_status_cb)(SSL_CTX *, int(*)(SSL *, void *)) = NULL;
+long (*SSL_CTX_set_tlsext_status_arg)(SSL_CTX *, void *) = NULL;
+#endif
+
+#ifdef SSL_CTRL_SET_TLSEXT_STATUS_REQ_OCSP_RESP
+static const long Cryptography_HAS_STATUS_REQ_OCSP_RESP = 1;
+#else
+static const long Cryptography_HAS_STATUS_REQ_OCSP_RESP = 0;
+long (*SSL_set_tlsext_status_ocsp_resp)(SSL *, unsigned char *, int) = NULL;
+long (*SSL_get_tlsext_status_ocsp_resp)(SSL *, const unsigned char **) = NULL;
+#endif
+
+#ifdef SSL_CTRL_SET_TLSEXT_STATUS_REQ_TYPE
+static const long Cryptography_HAS_TLSEXT_STATUS_REQ_TYPE = 1;
+#else
+static const long Cryptography_HAS_TLSEXT_STATUS_REQ_TYPE = 0;
+long (*SSL_set_tlsext_status_type)(SSL *, long) = NULL;
+#endif
+
+#ifdef SSL_MODE_RELEASE_BUFFERS
+static const long Cryptography_HAS_RELEASE_BUFFERS = 1;
+#else
+static const long Cryptography_HAS_RELEASE_BUFFERS = 0;
+const long SSL_MODE_RELEASE_BUFFERS = 0;
+#endif
+
+#ifdef SSL_OP_NO_COMPRESSION
+static const long Cryptography_HAS_OP_NO_COMPRESSION = 1;
+#else
+static const long Cryptography_HAS_OP_NO_COMPRESSION = 0;
+const long SSL_OP_NO_COMPRESSION = 0;
+#endif
+
+#ifdef SSL_OP_NO_TLSv1_1
+static const long Cryptography_HAS_TLSv1_1 = 1;
+#else
+static const long Cryptography_HAS_TLSv1_1 = 0;
+static const long SSL_OP_NO_TLSv1_1 = 0;
+SSL_METHOD* (*TLSv1_1_method)(void) = NULL;
+SSL_METHOD* (*TLSv1_1_client_method)(void) = NULL;
+SSL_METHOD* (*TLSv1_1_server_method)(void) = NULL;
+#endif
+
+#ifdef SSL_OP_NO_TLSv1_2
+static const long Cryptography_HAS_TLSv1_2 = 1;
+#else
+static const long Cryptography_HAS_TLSv1_2 = 0;
+static const long SSL_OP_NO_TLSv1_2 = 0;
+SSL_METHOD* (*TLSv1_2_method)(void) = NULL;
+SSL_METHOD* (*TLSv1_2_client_method)(void) = NULL;
+SSL_METHOD* (*TLSv1_2_server_method)(void) = NULL;
+#endif
+
+#ifdef SSL_OP_MSIE_SSLV2_RSA_PADDING
+static const long Cryptography_HAS_SSL_OP_MSIE_SSLV2_RSA_PADDING = 1;
+#else
+static const long Cryptography_HAS_SSL_OP_MSIE_SSLV2_RSA_PADDING = 0;
+const long SSL_OP_MSIE_SSLV2_RSA_PADDING = 0;
+#endif
+
+#ifdef OPENSSL_NO_EC
+long (*SSL_CTX_set_tmp_ecdh)(SSL_CTX *, EC_KEY *) = NULL;
+#endif
+
+#ifdef SSL_OP_NO_TICKET
+static const long Cryptography_HAS_SSL_OP_NO_TICKET = 1;
+#else
+static const long Cryptography_HAS_SSL_OP_NO_TICKET = 0;
+const long SSL_OP_NO_TICKET = 0;
+#endif
+
+/* OpenSSL 0.9.8f+ */
+#if OPENSSL_VERSION_NUMBER >= 0x00908070L
+static const long Cryptography_HAS_SSL_SET_SSL_CTX = 1;
+#else
+static const long Cryptography_HAS_SSL_SET_SSL_CTX = 0;
+static const long TLSEXT_NAMETYPE_host_name = 0;
+SSL_CTX *(*SSL_set_SSL_CTX)(SSL *, SSL_CTX *) = NULL;
+#endif
+
+/* NetBSD shipped without including d1_meth.c. This workaround checks to see
+   if the version of NetBSD we're currently running on is old enough to
+   have the bug and provides an empty implementation so we can link and
+   then remove the function from the ffi object. */
+#ifdef __NetBSD__
+#  include <sys/param.h>
+#  if (__NetBSD_Version__ < 699003800)
+static const long Cryptography_HAS_NETBSD_D1_METH = 0;
+const SSL_METHOD *DTLSv1_method(void) {
+    return NULL;
+}
+#  else
+static const long Cryptography_HAS_NETBSD_D1_METH = 1;
+#  endif
+#else
+static const long Cryptography_HAS_NETBSD_D1_METH = 1;
+#endif
+
+/* Workaround for #794 caused by cffi const** bug. */
+const SSL_METHOD *Cryptography_SSL_CTX_get_method(const SSL_CTX *ctx) {
+    return ctx->method;
+}
+
+/* Because OPENSSL defines macros that claim lack of support for things, rather
+ * than macros that claim support for things, we need to do a version check in
+ * addition to a definition check. NPN was added in 1.0.1: for any version
+ * before that, there is no compatibility.
+ */
+#if defined(OPENSSL_NO_NEXTPROTONEG) || OPENSSL_VERSION_NUMBER < 0x1000100fL
+static const long Cryptography_HAS_NEXTPROTONEG = 0;
+void (*SSL_CTX_set_next_protos_advertised_cb)(SSL_CTX *,
+                                              int (*)(SSL *,
+                                                      const unsigned char **,
+                                                      unsigned int *,
+                                                      void *),
+                                              void *) = NULL;
+void (*SSL_CTX_set_next_proto_select_cb)(SSL_CTX *,
+                                         int (*)(SSL *,
+                                                 unsigned char **,
+                                                 unsigned char *,
+                                                 const unsigned char *,
+                                                 unsigned int,
+                                                 void *),
+                                         void *) = NULL;
+int (*SSL_select_next_proto)(unsigned char **, unsigned char *,
+                             const unsigned char *, unsigned int,
+                             const unsigned char *, unsigned int) = NULL;
+void (*SSL_get0_next_proto_negotiated)(const SSL *,
+                                       const unsigned char **,
+                                       unsigned *) = NULL;
+#else
+static const long Cryptography_HAS_NEXTPROTONEG = 1;
+#endif
+
+/* ALPN was added in OpenSSL 1.0.2. */
+#if OPENSSL_VERSION_NUMBER < 0x10002001L && !defined(LIBRESSL_VERSION_NUMBER)
+int (*SSL_CTX_set_alpn_protos)(SSL_CTX *,
+                               const unsigned char *,
+                               unsigned) = NULL;
+int (*SSL_set_alpn_protos)(SSL *, const unsigned char *, unsigned) = NULL;
+void (*SSL_CTX_set_alpn_select_cb)(SSL_CTX *,
+                                   int (*) (SSL *,
+                                            const unsigned char **,
+                                            unsigned char *,
+                                            const unsigned char *,
+                                            unsigned int,
+                                            void *),
+                                   void *) = NULL;
+void (*SSL_get0_alpn_selected)(const SSL *,
+                               const unsigned char **,
+                               unsigned *) = NULL;
+static const long Cryptography_HAS_ALPN = 0;
+#else
+static const long Cryptography_HAS_ALPN = 1;
+#endif
+
+/* SSL_CTX_set_cert_cb was added in OpenSSL 1.0.2. */
+#if OPENSSL_VERSION_NUMBER < 0x10002001L || defined(LIBRESSL_VERSION_NUMBER)
+void (*SSL_CTX_set_cert_cb)(SSL_CTX *, int (*)(SSL *, void *), void *) = NULL;
+void (*SSL_set_cert_cb)(SSL *, int (*)(SSL *, void *), void *) = NULL;
+static const long Cryptography_HAS_SET_CERT_CB = 0;
+#else
+static const long Cryptography_HAS_SET_CERT_CB = 1;
+#endif
+
+
+#if defined(OPENSSL_NO_COMP) || defined(LIBRESSL_VERSION_NUMBER)
+static const long Cryptography_HAS_COMPRESSION = 0;
+typedef void COMP_METHOD;
+#else
+static const long Cryptography_HAS_COMPRESSION = 1;
+#endif
+
+#if defined(SSL_CTRL_GET_SERVER_TMP_KEY)
+static const long Cryptography_HAS_GET_SERVER_TMP_KEY = 1;
+#else
+static const long Cryptography_HAS_GET_SERVER_TMP_KEY = 0;
+long (*SSL_get_server_tmp_key)(SSL *, EVP_PKEY **) = NULL;
+#endif
+
+/* Added in 0.9.8i */
+#if OPENSSL_VERSION_NUMBER < 0x0090809fL
+int (*SSL_CTX_set_client_cert_engine)(SSL_CTX *, ENGINE *) = NULL;
+static const long Cryptography_HAS_SSL_CTX_SET_CLIENT_CERT_ENGINE = 0;
+# else
+static const long Cryptography_HAS_SSL_CTX_SET_CLIENT_CERT_ENGINE = 1;
+#endif
+
+"""
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/x509name.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/x509name.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/x509name.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/x509name.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,67 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+INCLUDES = """
+#include <openssl/x509.h>
+
+/*
+ * See the comment above Cryptography_STACK_OF_X509 in x509.py
+ */
+typedef STACK_OF(X509_NAME) Cryptography_STACK_OF_X509_NAME;
+typedef STACK_OF(X509_NAME_ENTRY) Cryptography_STACK_OF_X509_NAME_ENTRY;
+"""
+
+TYPES = """
+typedef ... Cryptography_STACK_OF_X509_NAME_ENTRY;
+typedef struct {
+    Cryptography_STACK_OF_X509_NAME_ENTRY *entries;
+    ...;
+} X509_NAME;
+typedef ... X509_NAME_ENTRY;
+typedef ... Cryptography_STACK_OF_X509_NAME;
+"""
+
+FUNCTIONS = """
+X509_NAME *X509_NAME_new(void);
+void X509_NAME_free(X509_NAME *);
+
+int X509_NAME_entry_count(X509_NAME *);
+X509_NAME_ENTRY *X509_NAME_get_entry(X509_NAME *, int);
+ASN1_OBJECT *X509_NAME_ENTRY_get_object(X509_NAME_ENTRY *);
+ASN1_STRING *X509_NAME_ENTRY_get_data(X509_NAME_ENTRY *);
+unsigned long X509_NAME_hash(X509_NAME *);
+
+int i2d_X509_NAME(X509_NAME *, unsigned char **);
+int X509_NAME_add_entry_by_txt(X509_NAME *, const char *, int,
+                               const unsigned char *, int, int, int);
+int X509_NAME_add_entry_by_OBJ(X509_NAME *, ASN1_OBJECT *, int,
+                               unsigned char *, int, int, int);
+int X509_NAME_add_entry_by_NID(X509_NAME *, int, int, unsigned char *,
+                               int, int, int);
+X509_NAME_ENTRY *X509_NAME_delete_entry(X509_NAME *, int);
+void X509_NAME_ENTRY_free(X509_NAME_ENTRY *);
+int X509_NAME_get_index_by_NID(X509_NAME *, int, int);
+int X509_NAME_cmp(const X509_NAME *, const X509_NAME *);
+char *X509_NAME_oneline(X509_NAME *, char *, int);
+X509_NAME *X509_NAME_dup(X509_NAME *);
+"""
+
+MACROS = """
+Cryptography_STACK_OF_X509_NAME *sk_X509_NAME_new_null(void);
+int sk_X509_NAME_num(Cryptography_STACK_OF_X509_NAME *);
+int sk_X509_NAME_push(Cryptography_STACK_OF_X509_NAME *, X509_NAME *);
+X509_NAME *sk_X509_NAME_value(Cryptography_STACK_OF_X509_NAME *, int);
+void sk_X509_NAME_free(Cryptography_STACK_OF_X509_NAME *);
+int sk_X509_NAME_ENTRY_num(Cryptography_STACK_OF_X509_NAME_ENTRY *);
+X509_NAME_ENTRY *sk_X509_NAME_ENTRY_value(
+    Cryptography_STACK_OF_X509_NAME_ENTRY *, int);
+Cryptography_STACK_OF_X509_NAME_ENTRY *sk_X509_NAME_ENTRY_dup(
+    Cryptography_STACK_OF_X509_NAME_ENTRY *
+);
+"""
+
+CUSTOMIZATIONS = """
+"""
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/x509.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/x509.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/x509.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/x509.py	2015-11-19 05:01:40.000000000 +0100
@@ -0,0 +1,350 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+INCLUDES = """
+#include <openssl/ssl.h>
+
+/*
+ * This is part of a work-around for the difficulty cffi has in dealing with
+ * `STACK_OF(foo)` as the name of a type.  We invent a new, simpler name that
+ * will be an alias for this type and use the alias throughout.  This works
+ * together with another opaque typedef for the same name in the TYPES section.
+ * Note that the result is an opaque type.
+ */
+typedef STACK_OF(X509) Cryptography_STACK_OF_X509;
+typedef STACK_OF(X509_CRL) Cryptography_STACK_OF_X509_CRL;
+typedef STACK_OF(X509_REVOKED) Cryptography_STACK_OF_X509_REVOKED;
+"""
+
+TYPES = """
+typedef ... Cryptography_STACK_OF_X509;
+typedef ... Cryptography_STACK_OF_X509_CRL;
+typedef ... Cryptography_STACK_OF_X509_REVOKED;
+
+typedef struct {
+    ASN1_OBJECT *algorithm;
+    ...;
+} X509_ALGOR;
+
+typedef ... X509_ATTRIBUTE;
+
+typedef struct {
+    X509_ALGOR *signature;
+    ...;
+} X509_CINF;
+
+typedef struct {
+    ASN1_OBJECT *object;
+    ASN1_BOOLEAN critical;
+    ASN1_OCTET_STRING *value;
+} X509_EXTENSION;
+
+typedef ... X509_EXTENSIONS;
+
+typedef struct {
+    X509_ALGOR *sig_alg;
+    ...;
+} X509_REQ;
+
+typedef struct {
+    ASN1_INTEGER *serialNumber;
+    ASN1_TIME *revocationDate;
+    X509_EXTENSIONS *extensions;
+    int sequence;
+    ...;
+} X509_REVOKED;
+
+typedef struct {
+    Cryptography_STACK_OF_X509_REVOKED *revoked;
+    ...;
+} X509_CRL_INFO;
+
+typedef struct {
+    X509_CRL_INFO *crl;
+    X509_ALGOR *sig_alg;
+    ...;
+} X509_CRL;
+
+typedef struct {
+    X509_ALGOR *sig_alg;
+    X509_CINF *cert_info;
+    ...;
+} X509;
+
+typedef ... NETSCAPE_SPKI;
+
+typedef ... PKCS8_PRIV_KEY_INFO;
+
+static const int X509_FLAG_COMPAT;
+static const int X509_FLAG_NO_HEADER;
+static const int X509_FLAG_NO_VERSION;
+static const int X509_FLAG_NO_SERIAL;
+static const int X509_FLAG_NO_SIGNAME;
+static const int X509_FLAG_NO_ISSUER;
+static const int X509_FLAG_NO_VALIDITY;
+static const int X509_FLAG_NO_SUBJECT;
+static const int X509_FLAG_NO_PUBKEY;
+static const int X509_FLAG_NO_EXTENSIONS;
+static const int X509_FLAG_NO_SIGDUMP;
+static const int X509_FLAG_NO_AUX;
+static const int X509_FLAG_NO_ATTRIBUTES;
+
+static const int XN_FLAG_SEP_MASK;
+static const int XN_FLAG_COMPAT;
+static const int XN_FLAG_SEP_COMMA_PLUS;
+static const int XN_FLAG_SEP_CPLUS_SPC;
+static const int XN_FLAG_SEP_SPLUS_SPC;
+static const int XN_FLAG_SEP_MULTILINE;
+static const int XN_FLAG_DN_REV;
+static const int XN_FLAG_FN_MASK;
+static const int XN_FLAG_FN_SN;
+static const int XN_FLAG_FN_LN;
+static const int XN_FLAG_FN_OID;
+static const int XN_FLAG_FN_NONE;
+static const int XN_FLAG_SPC_EQ;
+static const int XN_FLAG_DUMP_UNKNOWN_FIELDS;
+static const int XN_FLAG_FN_ALIGN;
+static const int XN_FLAG_RFC2253;
+static const int XN_FLAG_ONELINE;
+static const int XN_FLAG_MULTILINE;
+"""
+
+FUNCTIONS = """
+X509 *X509_new(void);
+void X509_free(X509 *);
+X509 *X509_dup(X509 *);
+int X509_cmp(const X509 *, const X509 *);
+
+int X509_print_ex(BIO *, X509 *, unsigned long, unsigned long);
+
+int X509_set_version(X509 *, long);
+
+EVP_PKEY *X509_get_pubkey(X509 *);
+int X509_set_pubkey(X509 *, EVP_PKEY *);
+
+unsigned char *X509_alias_get0(X509 *, int *);
+int X509_sign(X509 *, EVP_PKEY *, const EVP_MD *);
+
+int X509_digest(const X509 *, const EVP_MD *, unsigned char *, unsigned int *);
+
+ASN1_TIME *X509_gmtime_adj(ASN1_TIME *, long);
+
+unsigned long X509_subject_name_hash(X509 *);
+
+X509_NAME *X509_get_subject_name(X509 *);
+int X509_set_subject_name(X509 *, X509_NAME *);
+
+X509_NAME *X509_get_issuer_name(X509 *);
+int X509_set_issuer_name(X509 *, X509_NAME *);
+
+int X509_get_ext_count(X509 *);
+int X509_add_ext(X509 *, X509_EXTENSION *, int);
+X509_EXTENSION *X509_delete_ext(X509 *, int);
+X509_EXTENSION *X509_EXTENSION_dup(X509_EXTENSION *);
+X509_EXTENSION *X509_get_ext(X509 *, int);
+int X509_get_ext_by_NID(X509 *, int, int);
+
+int X509_EXTENSION_get_critical(X509_EXTENSION *);
+ASN1_OBJECT *X509_EXTENSION_get_object(X509_EXTENSION *);
+void X509_EXTENSION_free(X509_EXTENSION *);
+X509_EXTENSION *X509_EXTENSION_create_by_OBJ(X509_EXTENSION **,
+                                             ASN1_OBJECT *, int,
+                                             ASN1_OCTET_STRING *);
+
+int i2d_X509(X509 *, unsigned char **);
+
+int X509_REQ_set_version(X509_REQ *, long);
+X509_REQ *X509_REQ_new(void);
+void X509_REQ_free(X509_REQ *);
+int X509_REQ_set_pubkey(X509_REQ *, EVP_PKEY *);
+int X509_REQ_set_subject_name(X509_REQ *, X509_NAME *);
+int X509_REQ_sign(X509_REQ *, EVP_PKEY *, const EVP_MD *);
+int X509_REQ_verify(X509_REQ *, EVP_PKEY *);
+int X509_REQ_digest(const X509_REQ *, const EVP_MD *,
+                    unsigned char *, unsigned int *);
+EVP_PKEY *X509_REQ_get_pubkey(X509_REQ *);
+int X509_REQ_print(BIO *, X509_REQ *);
+int X509_REQ_print_ex(BIO *, X509_REQ *, unsigned long, unsigned long);
+
+int X509V3_EXT_print(BIO *, X509_EXTENSION *, unsigned long, int);
+ASN1_OCTET_STRING *X509_EXTENSION_get_data(X509_EXTENSION *);
+
+X509_REVOKED *X509_REVOKED_new(void);
+void X509_REVOKED_free(X509_REVOKED *);
+
+int X509_REVOKED_set_serialNumber(X509_REVOKED *, ASN1_INTEGER *);
+
+int X509_REVOKED_get_ext_count(X509_REVOKED *);
+X509_EXTENSION *X509_REVOKED_get_ext(X509_REVOKED *, int);
+int X509_REVOKED_add_ext(X509_REVOKED *, X509_EXTENSION*, int);
+int X509_REVOKED_add1_ext_i2d(X509_REVOKED *, int, void *, int, unsigned long);
+
+X509_CRL *X509_CRL_new(void);
+X509_CRL *d2i_X509_CRL_bio(BIO *, X509_CRL **);
+X509_EXTENSION *X509_CRL_get_ext(X509_CRL *, int);
+int X509_CRL_add0_revoked(X509_CRL *, X509_REVOKED *);
+int X509_CRL_add_ext(X509_CRL *, X509_EXTENSION *, int);
+int X509_CRL_cmp(const X509_CRL *, const X509_CRL *);
+int X509_CRL_get_ext_count(X509_CRL *);
+int X509_CRL_print(BIO *, X509_CRL *);
+int X509_CRL_set_issuer_name(X509_CRL *, X509_NAME *);
+int X509_CRL_set_version(X509_CRL *, long);
+int X509_CRL_sign(X509_CRL *, EVP_PKEY *, const EVP_MD *);
+int X509_CRL_sort(X509_CRL *);
+int X509_CRL_verify(X509_CRL *, EVP_PKEY *);
+int i2d_X509_CRL_bio(BIO *, X509_CRL *);
+void X509_CRL_free(X509_CRL *);
+
+int NETSCAPE_SPKI_verify(NETSCAPE_SPKI *, EVP_PKEY *);
+int NETSCAPE_SPKI_sign(NETSCAPE_SPKI *, EVP_PKEY *, const EVP_MD *);
+char *NETSCAPE_SPKI_b64_encode(NETSCAPE_SPKI *);
+NETSCAPE_SPKI *NETSCAPE_SPKI_b64_decode(const char *, int);
+EVP_PKEY *NETSCAPE_SPKI_get_pubkey(NETSCAPE_SPKI *);
+int NETSCAPE_SPKI_set_pubkey(NETSCAPE_SPKI *, EVP_PKEY *);
+NETSCAPE_SPKI *NETSCAPE_SPKI_new(void);
+void NETSCAPE_SPKI_free(NETSCAPE_SPKI *);
+
+/*  ASN1 serialization */
+int i2d_X509_bio(BIO *, X509 *);
+X509 *d2i_X509_bio(BIO *, X509 **);
+
+int i2d_X509_REQ_bio(BIO *, X509_REQ *);
+X509_REQ *d2i_X509_REQ_bio(BIO *, X509_REQ **);
+
+int i2d_PrivateKey_bio(BIO *, EVP_PKEY *);
+EVP_PKEY *d2i_PrivateKey_bio(BIO *, EVP_PKEY **);
+int i2d_PUBKEY_bio(BIO *, EVP_PKEY *);
+EVP_PKEY *d2i_PUBKEY_bio(BIO *, EVP_PKEY **);
+
+ASN1_INTEGER *X509_get_serialNumber(X509 *);
+int X509_set_serialNumber(X509 *, ASN1_INTEGER *);
+
+const char *X509_verify_cert_error_string(long);
+
+const char *X509_get_default_cert_area(void);
+const char *X509_get_default_cert_dir(void);
+const char *X509_get_default_cert_file(void);
+const char *X509_get_default_cert_dir_env(void);
+const char *X509_get_default_cert_file_env(void);
+const char *X509_get_default_private_dir(void);
+
+int i2d_RSA_PUBKEY(RSA *, unsigned char **);
+RSA *d2i_RSA_PUBKEY(RSA **, const unsigned char **, long);
+RSA *d2i_RSAPublicKey(RSA **, const unsigned char **, long);
+RSA *d2i_RSAPrivateKey(RSA **, const unsigned char **, long);
+int i2d_DSA_PUBKEY(DSA *, unsigned char **);
+DSA *d2i_DSA_PUBKEY(DSA **, const unsigned char **, long);
+DSA *d2i_DSAPublicKey(DSA **, const unsigned char **, long);
+DSA *d2i_DSAPrivateKey(DSA **, const unsigned char **, long);
+
+RSA *d2i_RSAPrivateKey_bio(BIO *, RSA **);
+int i2d_RSAPrivateKey_bio(BIO *, RSA *);
+RSA *d2i_RSAPublicKey_bio(BIO *, RSA **);
+int i2d_RSAPublicKey_bio(BIO *, RSA *);
+RSA *d2i_RSA_PUBKEY_bio(BIO *, RSA **);
+int i2d_RSA_PUBKEY_bio(BIO *, RSA *);
+DSA *d2i_DSA_PUBKEY_bio(BIO *, DSA **);
+int i2d_DSA_PUBKEY_bio(BIO *, DSA *);
+DSA *d2i_DSAPrivateKey_bio(BIO *, DSA **);
+int i2d_DSAPrivateKey_bio(BIO *, DSA *);
+
+PKCS8_PRIV_KEY_INFO *d2i_PKCS8_PRIV_KEY_INFO_bio(BIO *,
+                                                 PKCS8_PRIV_KEY_INFO **);
+void PKCS8_PRIV_KEY_INFO_free(PKCS8_PRIV_KEY_INFO *);
+"""
+
+MACROS = """
+long X509_get_version(X509 *);
+
+ASN1_TIME *X509_get_notBefore(X509 *);
+ASN1_TIME *X509_get_notAfter(X509 *);
+
+long X509_REQ_get_version(X509_REQ *);
+X509_NAME *X509_REQ_get_subject_name(X509_REQ *);
+
+Cryptography_STACK_OF_X509 *sk_X509_new_null(void);
+void sk_X509_free(Cryptography_STACK_OF_X509 *);
+int sk_X509_num(Cryptography_STACK_OF_X509 *);
+int sk_X509_push(Cryptography_STACK_OF_X509 *, X509 *);
+X509 *sk_X509_value(Cryptography_STACK_OF_X509 *, int);
+
+X509_EXTENSIONS *sk_X509_EXTENSION_new_null(void);
+int sk_X509_EXTENSION_num(X509_EXTENSIONS *);
+X509_EXTENSION *sk_X509_EXTENSION_value(X509_EXTENSIONS *, int);
+int sk_X509_EXTENSION_push(X509_EXTENSIONS *, X509_EXTENSION *);
+X509_EXTENSION *sk_X509_EXTENSION_delete(X509_EXTENSIONS *, int);
+void sk_X509_EXTENSION_free(X509_EXTENSIONS *);
+
+int sk_X509_REVOKED_num(Cryptography_STACK_OF_X509_REVOKED *);
+X509_REVOKED *sk_X509_REVOKED_value(Cryptography_STACK_OF_X509_REVOKED *, int);
+
+Cryptography_STACK_OF_X509_CRL *sk_X509_CRL_new_null(void);
+void sk_X509_CRL_free(Cryptography_STACK_OF_X509_CRL *);
+int sk_X509_CRL_num(Cryptography_STACK_OF_X509_CRL *);
+int sk_X509_CRL_push(Cryptography_STACK_OF_X509_CRL *, X509_CRL *);
+X509_CRL *sk_X509_CRL_value(Cryptography_STACK_OF_X509_CRL *, int);
+
+int i2d_RSAPublicKey(RSA *, unsigned char **);
+int i2d_RSAPrivateKey(RSA *, unsigned char **);
+int i2d_DSAPublicKey(DSA *, unsigned char **);
+int i2d_DSAPrivateKey(DSA *, unsigned char **);
+
+int X509_CRL_get_version(X509_CRL *);
+ASN1_TIME *X509_CRL_get_lastUpdate(X509_CRL *);
+ASN1_TIME *X509_CRL_get_nextUpdate(X509_CRL *);
+X509_NAME *X509_CRL_get_issuer(X509_CRL *);
+Cryptography_STACK_OF_X509_REVOKED *X509_CRL_get_REVOKED(X509_CRL *);
+
+/* These aren't macros these arguments are all const X on openssl > 1.0.x */
+int X509_CRL_set_lastUpdate(X509_CRL *, ASN1_TIME *);
+int X509_CRL_set_nextUpdate(X509_CRL *, ASN1_TIME *);
+int X509_set_notBefore(X509 *, ASN1_TIME *);
+int X509_set_notAfter(X509 *, ASN1_TIME *);
+
+/* These use STACK_OF(X509_EXTENSION) in 0.9.8e. Once we drop support for
+   RHEL/CentOS 5 we should move these back to FUNCTIONS. */
+int X509_REQ_add_extensions(X509_REQ *, X509_EXTENSIONS *);
+X509_EXTENSIONS *X509_REQ_get_extensions(X509_REQ *);
+
+int i2d_EC_PUBKEY(EC_KEY *, unsigned char **);
+EC_KEY *d2i_EC_PUBKEY(EC_KEY **, const unsigned char **, long);
+EC_KEY *d2i_EC_PUBKEY_bio(BIO *, EC_KEY **);
+int i2d_EC_PUBKEY_bio(BIO *, EC_KEY *);
+EC_KEY *d2i_ECPrivateKey(EC_KEY **, const unsigned char **, long);
+EC_KEY *d2i_ECPrivateKey_bio(BIO *, EC_KEY **);
+int i2d_ECPrivateKey(EC_KEY *, unsigned char **);
+int i2d_ECPrivateKey_bio(BIO *, EC_KEY *);
+
+EC_KEY *o2i_ECPublicKey(EC_KEY **, const unsigned char **, long);
+int i2o_ECPublicKey(EC_KEY *, unsigned char **);
+
+// declared in safestack
+int sk_ASN1_OBJECT_num(Cryptography_STACK_OF_ASN1_OBJECT *);
+ASN1_OBJECT *sk_ASN1_OBJECT_value(Cryptography_STACK_OF_ASN1_OBJECT *, int);
+void sk_ASN1_OBJECT_free(Cryptography_STACK_OF_ASN1_OBJECT *);
+Cryptography_STACK_OF_ASN1_OBJECT *sk_ASN1_OBJECT_new_null(void);
+int sk_ASN1_OBJECT_push(Cryptography_STACK_OF_ASN1_OBJECT *, ASN1_OBJECT *);
+"""
+
+CUSTOMIZATIONS = """
+/* OpenSSL 0.9.8e does not have this definition. */
+#if OPENSSL_VERSION_NUMBER <= 0x0090805fL
+typedef STACK_OF(X509_EXTENSION) X509_EXTENSIONS;
+#endif
+#ifdef OPENSSL_NO_EC
+int (*i2d_EC_PUBKEY)(EC_KEY *, unsigned char **) = NULL;
+EC_KEY *(*d2i_EC_PUBKEY)(EC_KEY **, const unsigned char **, long) = NULL;
+EC_KEY *(*d2i_EC_PUBKEY_bio)(BIO *, EC_KEY **) = NULL;
+int (*i2d_EC_PUBKEY_bio)(BIO *, EC_KEY *) = NULL;
+EC_KEY *(*d2i_ECPrivateKey)(EC_KEY **, const unsigned char **, long) = NULL;
+EC_KEY *(*d2i_ECPrivateKey_bio)(BIO *, EC_KEY **) = NULL;
+int (*i2d_ECPrivateKey)(EC_KEY *, unsigned char **) = NULL;
+int (*i2d_ECPrivateKey_bio)(BIO *, EC_KEY *) = NULL;
+
+EC_KEY *(*o2i_ECPublicKey)(EC_KEY **, const unsigned char **, long) = NULL;
+int (*i2o_ECPublicKey)(EC_KEY *, unsigned char **) = NULL;
+#endif
+"""
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/x509v3.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/x509v3.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/x509v3.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/x509v3.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,298 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+INCLUDES = """
+#include <openssl/x509v3.h>
+
+/*
+ * This is part of a work-around for the difficulty cffi has in dealing with
+ * `LHASH_OF(foo)` as the name of a type.  We invent a new, simpler name that
+ * will be an alias for this type and use the alias throughout.  This works
+ * together with another opaque typedef for the same name in the TYPES section.
+ * Note that the result is an opaque type.
+ */
+#if OPENSSL_VERSION_NUMBER >= 0x10000000
+typedef LHASH_OF(CONF_VALUE) Cryptography_LHASH_OF_CONF_VALUE;
+#else
+typedef LHASH Cryptography_LHASH_OF_CONF_VALUE;
+#endif
+typedef STACK_OF(ACCESS_DESCRIPTION) Cryptography_STACK_OF_ACCESS_DESCRIPTION;
+typedef STACK_OF(DIST_POINT) Cryptography_STACK_OF_DIST_POINT;
+typedef STACK_OF(POLICYQUALINFO) Cryptography_STACK_OF_POLICYQUALINFO;
+typedef STACK_OF(POLICYINFO) Cryptography_STACK_OF_POLICYINFO;
+typedef STACK_OF(ASN1_INTEGER) Cryptography_STACK_OF_ASN1_INTEGER;
+typedef STACK_OF(GENERAL_SUBTREE) Cryptography_STACK_OF_GENERAL_SUBTREE;
+"""
+
+TYPES = """
+typedef ... Cryptography_STACK_OF_ACCESS_DESCRIPTION;
+typedef ... Cryptography_STACK_OF_POLICYQUALINFO;
+typedef ... Cryptography_STACK_OF_POLICYINFO;
+typedef ... Cryptography_STACK_OF_ASN1_INTEGER;
+typedef ... Cryptography_STACK_OF_GENERAL_SUBTREE;
+typedef ... EXTENDED_KEY_USAGE;
+
+typedef struct {
+    X509 *issuer_cert;
+    X509 *subject_cert;
+    ...;
+} X509V3_CTX;
+
+typedef void * (*X509V3_EXT_D2I)(void *, const unsigned char **, long);
+
+typedef struct {
+    ASN1_ITEM_EXP *it;
+    X509V3_EXT_D2I d2i;
+    ...;
+} X509V3_EXT_METHOD;
+
+static const int GEN_OTHERNAME;
+static const int GEN_EMAIL;
+static const int GEN_X400;
+static const int GEN_DNS;
+static const int GEN_URI;
+static const int GEN_DIRNAME;
+static const int GEN_EDIPARTY;
+static const int GEN_IPADD;
+static const int GEN_RID;
+
+typedef struct {
+    ASN1_OBJECT *type_id;
+    ASN1_TYPE *value;
+} OTHERNAME;
+
+typedef struct {
+    ...;
+} EDIPARTYNAME;
+
+typedef struct {
+    int ca;
+    ASN1_INTEGER *pathlen;
+} BASIC_CONSTRAINTS;
+
+typedef struct {
+    Cryptography_STACK_OF_GENERAL_SUBTREE *permittedSubtrees;
+    Cryptography_STACK_OF_GENERAL_SUBTREE *excludedSubtrees;
+} NAME_CONSTRAINTS;
+
+
+typedef struct {
+    int type;
+    union {
+        char *ptr;
+        OTHERNAME *otherName;  /* otherName */
+        ASN1_IA5STRING *rfc822Name;
+        ASN1_IA5STRING *dNSName;
+        ASN1_TYPE *x400Address;
+        X509_NAME *directoryName;
+        EDIPARTYNAME *ediPartyName;
+        ASN1_IA5STRING *uniformResourceIdentifier;
+        ASN1_OCTET_STRING *iPAddress;
+        ASN1_OBJECT *registeredID;
+
+        /* Old names */
+        ASN1_OCTET_STRING *ip; /* iPAddress */
+        X509_NAME *dirn;       /* dirn */
+        ASN1_IA5STRING *ia5;   /* rfc822Name, dNSName, */
+                               /*   uniformResourceIdentifier */
+        ASN1_OBJECT *rid;      /* registeredID */
+        ASN1_TYPE *other;      /* x400Address */
+    } d;
+    ...;
+} GENERAL_NAME;
+
+typedef struct {
+    GENERAL_NAME *base;
+    ASN1_INTEGER *minimum;
+    ASN1_INTEGER *maximum;
+} GENERAL_SUBTREE;
+
+typedef struct stack_st_GENERAL_NAME GENERAL_NAMES;
+
+typedef struct {
+    ASN1_OCTET_STRING *keyid;
+    GENERAL_NAMES *issuer;
+    ASN1_INTEGER *serial;
+} AUTHORITY_KEYID;
+
+typedef struct {
+    ASN1_OBJECT *method;
+    GENERAL_NAME *location;
+} ACCESS_DESCRIPTION;
+
+typedef ... Cryptography_LHASH_OF_CONF_VALUE;
+
+
+typedef ... Cryptography_STACK_OF_DIST_POINT;
+
+typedef struct {
+    int type;
+    union {
+        GENERAL_NAMES *fullname;
+        Cryptography_STACK_OF_X509_NAME_ENTRY *relativename;
+    } name;
+    ...;
+} DIST_POINT_NAME;
+
+typedef struct {
+    DIST_POINT_NAME *distpoint;
+    ASN1_BIT_STRING *reasons;
+    GENERAL_NAMES *CRLissuer;
+    ...;
+} DIST_POINT;
+
+typedef struct {
+    ASN1_STRING *organization;
+    Cryptography_STACK_OF_ASN1_INTEGER *noticenos;
+} NOTICEREF;
+
+typedef struct {
+    NOTICEREF *noticeref;
+    ASN1_STRING *exptext;
+} USERNOTICE;
+
+typedef struct {
+    ASN1_OBJECT *pqualid;
+    union {
+        ASN1_IA5STRING *cpsuri;
+        USERNOTICE *usernotice;
+        ASN1_TYPE *other;
+    } d;
+} POLICYQUALINFO;
+
+typedef struct {
+    ASN1_OBJECT *policyid;
+    Cryptography_STACK_OF_POLICYQUALINFO *qualifiers;
+} POLICYINFO;
+"""
+
+
+FUNCTIONS = """
+int X509V3_EXT_add_alias(int, int);
+void X509V3_set_ctx(X509V3_CTX *, X509 *, X509 *, X509_REQ *, X509_CRL *, int);
+X509_EXTENSION *X509V3_EXT_nconf(CONF *, X509V3_CTX *, char *, char *);
+GENERAL_NAME *GENERAL_NAME_new(void);
+int GENERAL_NAME_print(BIO *, GENERAL_NAME *);
+GENERAL_NAMES *GENERAL_NAMES_new(void);
+void GENERAL_NAMES_free(GENERAL_NAMES *);
+void *X509V3_EXT_d2i(X509_EXTENSION *);
+"""
+
+MACROS = """
+/* This is a macro defined by a call to DECLARE_ASN1_FUNCTIONS in the
+   x509v3.h header. */
+int i2d_BASIC_CONSTRAINTS(BASIC_CONSTRAINTS *, unsigned char **);
+BASIC_CONSTRAINTS *BASIC_CONSTRAINTS_new(void);
+void BASIC_CONSTRAINTS_free(BASIC_CONSTRAINTS *);
+/* This is a macro defined by a call to DECLARE_ASN1_FUNCTIONS in the
+   x509v3.h header. */
+AUTHORITY_KEYID *AUTHORITY_KEYID_new(void);
+void AUTHORITY_KEYID_free(AUTHORITY_KEYID *);
+int i2d_AUTHORITY_KEYID(AUTHORITY_KEYID *, unsigned char **);
+
+NAME_CONSTRAINTS *NAME_CONSTRAINTS_new(void);
+void NAME_CONSTRAINTS_free(NAME_CONSTRAINTS *);
+
+OTHERNAME *OTHERNAME_new(void);
+void OTHERNAME_free(OTHERNAME *);
+
+void *X509V3_set_ctx_nodb(X509V3_CTX *);
+
+int i2d_GENERAL_NAMES(GENERAL_NAMES *, unsigned char **);
+GENERAL_NAMES *d2i_GENERAL_NAMES(GENERAL_NAMES **, const unsigned char **,
+                                 long);
+
+int i2d_EXTENDED_KEY_USAGE(EXTENDED_KEY_USAGE *, unsigned char **);
+
+int i2d_AUTHORITY_INFO_ACCESS(Cryptography_STACK_OF_ACCESS_DESCRIPTION *,
+                              unsigned char **);
+
+int sk_GENERAL_NAME_num(struct stack_st_GENERAL_NAME *);
+int sk_GENERAL_NAME_push(struct stack_st_GENERAL_NAME *, GENERAL_NAME *);
+GENERAL_NAME *sk_GENERAL_NAME_value(struct stack_st_GENERAL_NAME *, int);
+
+Cryptography_STACK_OF_ACCESS_DESCRIPTION *sk_ACCESS_DESCRIPTION_new_null(void);
+int sk_ACCESS_DESCRIPTION_num(Cryptography_STACK_OF_ACCESS_DESCRIPTION *);
+ACCESS_DESCRIPTION *sk_ACCESS_DESCRIPTION_value(
+    Cryptography_STACK_OF_ACCESS_DESCRIPTION *, int
+);
+void sk_ACCESS_DESCRIPTION_free(Cryptography_STACK_OF_ACCESS_DESCRIPTION *);
+int sk_ACCESS_DESCRIPTION_push(Cryptography_STACK_OF_ACCESS_DESCRIPTION *,
+                               ACCESS_DESCRIPTION *);
+
+ACCESS_DESCRIPTION *ACCESS_DESCRIPTION_new(void);
+void ACCESS_DESCRIPTION_free(ACCESS_DESCRIPTION *);
+
+X509_EXTENSION *X509V3_EXT_conf_nid(Cryptography_LHASH_OF_CONF_VALUE *,
+                                    X509V3_CTX *, int, char *);
+
+/* These aren't macros these functions are all const X on openssl > 1.0.x */
+const X509V3_EXT_METHOD *X509V3_EXT_get(X509_EXTENSION *);
+const X509V3_EXT_METHOD *X509V3_EXT_get_nid(int);
+
+Cryptography_STACK_OF_DIST_POINT *sk_DIST_POINT_new_null(void);
+void sk_DIST_POINT_free(Cryptography_STACK_OF_DIST_POINT *);
+int sk_DIST_POINT_num(Cryptography_STACK_OF_DIST_POINT *);
+DIST_POINT *sk_DIST_POINT_value(Cryptography_STACK_OF_DIST_POINT *, int);
+int sk_DIST_POINT_push(Cryptography_STACK_OF_DIST_POINT *, DIST_POINT *);
+
+void sk_POLICYINFO_free(Cryptography_STACK_OF_POLICYINFO *);
+int sk_POLICYINFO_num(Cryptography_STACK_OF_POLICYINFO *);
+POLICYINFO *sk_POLICYINFO_value(Cryptography_STACK_OF_POLICYINFO *, int);
+int sk_POLICYINFO_push(Cryptography_STACK_OF_POLICYINFO *, POLICYINFO *);
+Cryptography_STACK_OF_POLICYINFO *sk_POLICYINFO_new_null(void);
+
+POLICYINFO *POLICYINFO_new(void);
+void POLICYINFO_free(POLICYINFO *);
+
+POLICYQUALINFO *POLICYQUALINFO_new(void);
+void POLICYQUALINFO_free(POLICYQUALINFO *);
+
+NOTICEREF *NOTICEREF_new(void);
+void NOTICEREF_free(NOTICEREF *);
+
+USERNOTICE *USERNOTICE_new(void);
+void USERNOTICE_free(USERNOTICE *);
+
+int i2d_CERTIFICATEPOLICIES(Cryptography_STACK_OF_POLICYINFO *,
+                            unsigned char **);
+
+void sk_POLICYQUALINFO_free(Cryptography_STACK_OF_POLICYQUALINFO *);
+int sk_POLICYQUALINFO_num(Cryptography_STACK_OF_POLICYQUALINFO *);
+POLICYQUALINFO *sk_POLICYQUALINFO_value(Cryptography_STACK_OF_POLICYQUALINFO *,
+                                        int);
+int sk_POLICYQUALINFO_push(Cryptography_STACK_OF_POLICYQUALINFO *,
+                           POLICYQUALINFO *);
+Cryptography_STACK_OF_POLICYQUALINFO *sk_POLICYQUALINFO_new_null(void);
+
+Cryptography_STACK_OF_GENERAL_SUBTREE *sk_GENERAL_SUBTREE_new_null(void);
+void sk_GENERAL_SUBTREE_free(Cryptography_STACK_OF_GENERAL_SUBTREE *);
+int sk_GENERAL_SUBTREE_num(Cryptography_STACK_OF_GENERAL_SUBTREE *);
+GENERAL_SUBTREE *sk_GENERAL_SUBTREE_value(
+    Cryptography_STACK_OF_GENERAL_SUBTREE *, int
+);
+int sk_GENERAL_SUBTREE_push(Cryptography_STACK_OF_GENERAL_SUBTREE *,
+                            GENERAL_SUBTREE *);
+
+void sk_ASN1_INTEGER_free(Cryptography_STACK_OF_ASN1_INTEGER *);
+int sk_ASN1_INTEGER_num(Cryptography_STACK_OF_ASN1_INTEGER *);
+ASN1_INTEGER *sk_ASN1_INTEGER_value(Cryptography_STACK_OF_ASN1_INTEGER *, int);
+int sk_ASN1_INTEGER_push(Cryptography_STACK_OF_ASN1_INTEGER *, ASN1_INTEGER *);
+Cryptography_STACK_OF_ASN1_INTEGER *sk_ASN1_INTEGER_new_null(void);
+
+X509_EXTENSION *X509V3_EXT_i2d(int, int, void *);
+
+DIST_POINT *DIST_POINT_new(void);
+void DIST_POINT_free(DIST_POINT *);
+
+DIST_POINT_NAME *DIST_POINT_NAME_new(void);
+void DIST_POINT_NAME_free(DIST_POINT_NAME *);
+
+int i2d_CRL_DIST_POINTS(Cryptography_STACK_OF_DIST_POINT *, unsigned char **);
+"""
+
+CUSTOMIZATIONS = """
+"""
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/x509_vfy.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/x509_vfy.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/x509_vfy.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/openssl/x509_vfy.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,297 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+INCLUDES = """
+#include <openssl/x509_vfy.h>
+
+/*
+ * This is part of a work-around for the difficulty cffi has in dealing with
+ * `STACK_OF(foo)` as the name of a type.  We invent a new, simpler name that
+ * will be an alias for this type and use the alias throughout.  This works
+ * together with another opaque typedef for the same name in the TYPES section.
+ * Note that the result is an opaque type.
+ */
+typedef STACK_OF(ASN1_OBJECT) Cryptography_STACK_OF_ASN1_OBJECT;
+"""
+
+TYPES = """
+static const long Cryptography_HAS_102_VERIFICATION_ERROR_CODES;
+static const long Cryptography_HAS_102_VERIFICATION_PARAMS;
+static const long Cryptography_HAS_X509_V_FLAG_TRUSTED_FIRST;
+static const long Cryptography_HAS_X509_V_FLAG_PARTIAL_CHAIN;
+static const long Cryptography_HAS_100_VERIFICATION_ERROR_CODES;
+static const long Cryptography_HAS_100_VERIFICATION_PARAMS;
+static const long Cryptography_HAS_X509_V_FLAG_CHECK_SS_SIGNATURE;
+
+typedef ... Cryptography_STACK_OF_ASN1_OBJECT;
+
+typedef ... X509_STORE;
+typedef ... X509_VERIFY_PARAM;
+
+typedef struct x509_store_ctx_st X509_STORE_CTX;
+struct x509_store_ctx_st {
+    X509_STORE *ctx;
+    int current_method;
+    X509 *cert;
+    Cryptography_STACK_OF_X509 *untrusted;
+    Cryptography_STACK_OF_X509_CRL *crls;
+    X509_VERIFY_PARAM *param;
+    void *other_ctx;
+    int (*verify)(X509_STORE_CTX *);
+    int (*verify_cb)(int, X509_STORE_CTX *);
+    int (*get_issuer)(X509 **, X509_STORE_CTX *, X509 *);
+    ...;
+};
+
+/* While these are defined in the source as ints, they're tagged here
+   as longs, just in case they ever grow to large, such as what we saw
+   with OP_ALL. */
+
+/* Verification error codes */
+static const int X509_V_OK;
+static const int X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT;
+static const int X509_V_ERR_UNABLE_TO_GET_CRL;
+static const int X509_V_ERR_UNABLE_TO_DECRYPT_CERT_SIGNATURE;
+static const int X509_V_ERR_UNABLE_TO_DECRYPT_CRL_SIGNATURE;
+static const int X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY;
+static const int X509_V_ERR_CERT_SIGNATURE_FAILURE;
+static const int X509_V_ERR_CRL_SIGNATURE_FAILURE;
+static const int X509_V_ERR_CERT_NOT_YET_VALID;
+static const int X509_V_ERR_CERT_HAS_EXPIRED;
+static const int X509_V_ERR_CRL_NOT_YET_VALID;
+static const int X509_V_ERR_CRL_HAS_EXPIRED;
+static const int X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD;
+static const int X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD;
+static const int X509_V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD;
+static const int X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD;
+static const int X509_V_ERR_OUT_OF_MEM;
+static const int X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT;
+static const int X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN;
+static const int X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY;
+static const int X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE;
+static const int X509_V_ERR_CERT_CHAIN_TOO_LONG;
+static const int X509_V_ERR_CERT_REVOKED;
+static const int X509_V_ERR_INVALID_CA;
+static const int X509_V_ERR_PATH_LENGTH_EXCEEDED;
+static const int X509_V_ERR_INVALID_PURPOSE;
+static const int X509_V_ERR_CERT_UNTRUSTED;
+static const int X509_V_ERR_CERT_REJECTED;
+static const int X509_V_ERR_SUBJECT_ISSUER_MISMATCH;
+static const int X509_V_ERR_AKID_SKID_MISMATCH;
+static const int X509_V_ERR_AKID_ISSUER_SERIAL_MISMATCH;
+static const int X509_V_ERR_KEYUSAGE_NO_CERTSIGN;
+static const int X509_V_ERR_UNABLE_TO_GET_CRL_ISSUER;
+static const int X509_V_ERR_UNHANDLED_CRITICAL_EXTENSION;
+static const int X509_V_ERR_KEYUSAGE_NO_CRL_SIGN;
+static const int X509_V_ERR_UNHANDLED_CRITICAL_CRL_EXTENSION;
+static const int X509_V_ERR_INVALID_NON_CA;
+static const int X509_V_ERR_PROXY_PATH_LENGTH_EXCEEDED;
+static const int X509_V_ERR_KEYUSAGE_NO_DIGITAL_SIGNATURE;
+static const int X509_V_ERR_PROXY_CERTIFICATES_NOT_ALLOWED;
+static const int X509_V_ERR_INVALID_EXTENSION;
+static const int X509_V_ERR_INVALID_POLICY_EXTENSION;
+static const int X509_V_ERR_NO_EXPLICIT_POLICY;
+static const int X509_V_ERR_DIFFERENT_CRL_SCOPE;
+static const int X509_V_ERR_UNSUPPORTED_EXTENSION_FEATURE;
+static const int X509_V_ERR_UNNESTED_RESOURCE;
+static const int X509_V_ERR_PERMITTED_VIOLATION;
+static const int X509_V_ERR_EXCLUDED_VIOLATION;
+static const int X509_V_ERR_SUBTREE_MINMAX;
+static const int X509_V_ERR_UNSUPPORTED_CONSTRAINT_TYPE;
+static const int X509_V_ERR_UNSUPPORTED_CONSTRAINT_SYNTAX;
+static const int X509_V_ERR_UNSUPPORTED_NAME_SYNTAX;
+static const int X509_V_ERR_CRL_PATH_VALIDATION_ERROR;
+static const int X509_V_ERR_SUITE_B_INVALID_VERSION;
+static const int X509_V_ERR_SUITE_B_INVALID_ALGORITHM;
+static const int X509_V_ERR_SUITE_B_INVALID_CURVE;
+static const int X509_V_ERR_SUITE_B_INVALID_SIGNATURE_ALGORITHM;
+static const int X509_V_ERR_SUITE_B_LOS_NOT_ALLOWED;
+static const int X509_V_ERR_SUITE_B_CANNOT_SIGN_P_384_WITH_P_256;
+static const int X509_V_ERR_HOSTNAME_MISMATCH;
+static const int X509_V_ERR_EMAIL_MISMATCH;
+static const int X509_V_ERR_IP_ADDRESS_MISMATCH;
+static const int X509_V_ERR_APPLICATION_VERIFICATION;
+
+/* Verification parameters */
+static const long X509_V_FLAG_CB_ISSUER_CHECK;
+static const long X509_V_FLAG_USE_CHECK_TIME;
+static const long X509_V_FLAG_CRL_CHECK;
+static const long X509_V_FLAG_CRL_CHECK_ALL;
+static const long X509_V_FLAG_IGNORE_CRITICAL;
+static const long X509_V_FLAG_X509_STRICT;
+static const long X509_V_FLAG_ALLOW_PROXY_CERTS;
+static const long X509_V_FLAG_POLICY_CHECK;
+static const long X509_V_FLAG_EXPLICIT_POLICY;
+static const long X509_V_FLAG_INHIBIT_ANY;
+static const long X509_V_FLAG_INHIBIT_MAP;
+static const long X509_V_FLAG_NOTIFY_POLICY;
+static const long X509_V_FLAG_EXTENDED_CRL_SUPPORT;
+static const long X509_V_FLAG_USE_DELTAS;
+static const long X509_V_FLAG_CHECK_SS_SIGNATURE;
+static const long X509_V_FLAG_TRUSTED_FIRST;
+static const long X509_V_FLAG_SUITEB_128_LOS_ONLY;
+static const long X509_V_FLAG_SUITEB_192_LOS;
+static const long X509_V_FLAG_SUITEB_128_LOS;
+static const long X509_V_FLAG_PARTIAL_CHAIN;
+"""
+
+FUNCTIONS = """
+int X509_verify_cert(X509_STORE_CTX *);
+
+/* X509_STORE */
+X509_STORE *X509_STORE_new(void);
+int X509_STORE_add_cert(X509_STORE *, X509 *);
+int X509_STORE_add_crl(X509_STORE *, X509_CRL *);
+int X509_STORE_load_locations(X509_STORE *, const char *, const char *);
+int X509_STORE_set1_param(X509_STORE *, X509_VERIFY_PARAM *);
+int X509_STORE_set_default_paths(X509_STORE *);
+int X509_STORE_set_flags(X509_STORE *, unsigned long);
+void X509_STORE_free(X509_STORE *);
+
+
+/* X509_STORE_CTX */
+X509_STORE_CTX *X509_STORE_CTX_new(void);
+void X509_STORE_CTX_cleanup(X509_STORE_CTX *);
+void X509_STORE_CTX_free(X509_STORE_CTX *);
+int X509_STORE_CTX_init(X509_STORE_CTX *, X509_STORE *, X509 *,
+                        Cryptography_STACK_OF_X509 *);
+void X509_STORE_CTX_trusted_stack(X509_STORE_CTX *,
+                                  Cryptography_STACK_OF_X509 *);
+void X509_STORE_CTX_set_cert(X509_STORE_CTX *, X509 *);
+void X509_STORE_CTX_set_chain(X509_STORE_CTX *,Cryptography_STACK_OF_X509 *);
+X509_VERIFY_PARAM *X509_STORE_CTX_get0_param(X509_STORE_CTX *);
+void X509_STORE_CTX_set0_param(X509_STORE_CTX *, X509_VERIFY_PARAM *);
+int X509_STORE_CTX_set_default(X509_STORE_CTX *, const char *);
+void X509_STORE_CTX_set_verify_cb(X509_STORE_CTX *,
+                                  int (*)(int, X509_STORE_CTX *));
+Cryptography_STACK_OF_X509 *X509_STORE_CTX_get_chain(X509_STORE_CTX *);
+Cryptography_STACK_OF_X509 *X509_STORE_CTX_get1_chain(X509_STORE_CTX *);
+int X509_STORE_CTX_get_error(X509_STORE_CTX *);
+void X509_STORE_CTX_set_error(X509_STORE_CTX *, int);
+int X509_STORE_CTX_get_error_depth(X509_STORE_CTX *);
+X509 *X509_STORE_CTX_get_current_cert(X509_STORE_CTX *);
+int X509_STORE_CTX_set_ex_data(X509_STORE_CTX *, int, void *);
+void *X509_STORE_CTX_get_ex_data(X509_STORE_CTX *, int);
+
+/* X509_VERIFY_PARAM */
+X509_VERIFY_PARAM *X509_VERIFY_PARAM_new(void);
+int X509_VERIFY_PARAM_set_flags(X509_VERIFY_PARAM *, unsigned long);
+int X509_VERIFY_PARAM_clear_flags(X509_VERIFY_PARAM *, unsigned long);
+unsigned long X509_VERIFY_PARAM_get_flags(X509_VERIFY_PARAM *);
+int X509_VERIFY_PARAM_set_purpose(X509_VERIFY_PARAM *, int);
+int X509_VERIFY_PARAM_set_trust(X509_VERIFY_PARAM *, int);
+void X509_VERIFY_PARAM_set_time(X509_VERIFY_PARAM *, time_t);
+int X509_VERIFY_PARAM_add0_policy(X509_VERIFY_PARAM *, ASN1_OBJECT *);
+int X509_VERIFY_PARAM_set1_policies(X509_VERIFY_PARAM *,
+                                    Cryptography_STACK_OF_ASN1_OBJECT *);
+void X509_VERIFY_PARAM_set_depth(X509_VERIFY_PARAM *, int);
+int X509_VERIFY_PARAM_get_depth(const X509_VERIFY_PARAM *);
+"""
+
+MACROS = """
+/* X509_STORE_CTX */
+void X509_STORE_CTX_set0_crls(X509_STORE_CTX *,
+                              Cryptography_STACK_OF_X509_CRL *);
+
+/* X509_VERIFY_PARAM */
+int X509_VERIFY_PARAM_set1_host(X509_VERIFY_PARAM *, const char *,
+                                size_t);
+void X509_VERIFY_PARAM_set_hostflags(X509_VERIFY_PARAM *, unsigned int);
+int X509_VERIFY_PARAM_set1_email(X509_VERIFY_PARAM *, const char *,
+                                 size_t);
+int X509_VERIFY_PARAM_set1_ip(X509_VERIFY_PARAM *, const unsigned char *,
+                              size_t);
+int X509_VERIFY_PARAM_set1_ip_asc(X509_VERIFY_PARAM *, const char *);
+"""
+
+CUSTOMIZATIONS = """
+/* OpenSSL 1.0.2+ verification error codes */
+#if OPENSSL_VERSION_NUMBER >= 0x10002002L && !defined(LIBRESSL_VERSION_NUMBER)
+static const long Cryptography_HAS_102_VERIFICATION_ERROR_CODES = 1;
+#else
+static const long Cryptography_HAS_102_VERIFICATION_ERROR_CODES = 0;
+static const long X509_V_ERR_SUITE_B_INVALID_VERSION = 0;
+static const long X509_V_ERR_SUITE_B_INVALID_ALGORITHM = 0;
+static const long X509_V_ERR_SUITE_B_INVALID_CURVE = 0;
+static const long X509_V_ERR_SUITE_B_INVALID_SIGNATURE_ALGORITHM = 0;
+static const long X509_V_ERR_SUITE_B_LOS_NOT_ALLOWED = 0;
+static const long X509_V_ERR_SUITE_B_CANNOT_SIGN_P_384_WITH_P_256 = 0;
+static const long X509_V_ERR_HOSTNAME_MISMATCH = 0;
+static const long X509_V_ERR_EMAIL_MISMATCH = 0;
+static const long X509_V_ERR_IP_ADDRESS_MISMATCH = 0;
+#endif
+
+/* OpenSSL 1.0.2+ verification parameters */
+#if OPENSSL_VERSION_NUMBER >= 0x10002002L && !defined(LIBRESSL_VERSION_NUMBER)
+static const long Cryptography_HAS_102_VERIFICATION_PARAMS = 1;
+#else
+static const long Cryptography_HAS_102_VERIFICATION_PARAMS = 0;
+/* X509_V_FLAG_TRUSTED_FIRST is also new in 1.0.2+, but it is added separately
+   below because it shows up in some earlier 3rd party OpenSSL packages. */
+static const long X509_V_FLAG_SUITEB_128_LOS_ONLY = 0;
+static const long X509_V_FLAG_SUITEB_192_LOS = 0;
+static const long X509_V_FLAG_SUITEB_128_LOS = 0;
+
+int (*X509_VERIFY_PARAM_set1_host)(X509_VERIFY_PARAM *, const char *,
+                                   size_t) = NULL;
+int (*X509_VERIFY_PARAM_set1_email)(X509_VERIFY_PARAM *, const char *,
+                                    size_t) = NULL;
+int (*X509_VERIFY_PARAM_set1_ip)(X509_VERIFY_PARAM *, const unsigned char *,
+                                 size_t) = NULL;
+int (*X509_VERIFY_PARAM_set1_ip_asc)(X509_VERIFY_PARAM *, const char *) = NULL;
+void (*X509_VERIFY_PARAM_set_hostflags)(X509_VERIFY_PARAM *,
+                                        unsigned int) = NULL;
+#endif
+
+/* OpenSSL 1.0.2+ or Solaris's backport */
+#ifdef X509_V_FLAG_PARTIAL_CHAIN
+static const long Cryptography_HAS_X509_V_FLAG_PARTIAL_CHAIN = 1;
+#else
+static const long Cryptography_HAS_X509_V_FLAG_PARTIAL_CHAIN = 0;
+static const long X509_V_FLAG_PARTIAL_CHAIN = 0;
+#endif
+
+/* OpenSSL 1.0.2+, *or* Fedora 20's flavor of OpenSSL 1.0.1e... */
+#ifdef X509_V_FLAG_TRUSTED_FIRST
+static const long Cryptography_HAS_X509_V_FLAG_TRUSTED_FIRST = 1;
+#else
+static const long Cryptography_HAS_X509_V_FLAG_TRUSTED_FIRST = 0;
+static const long X509_V_FLAG_TRUSTED_FIRST = 0;
+#endif
+
+/* OpenSSL 1.0.0+ verification error codes */
+#if OPENSSL_VERSION_NUMBER >= 0x10000000L
+static const long Cryptography_HAS_100_VERIFICATION_ERROR_CODES = 1;
+#else
+static const long Cryptography_HAS_100_VERIFICATION_ERROR_CODES = 0;
+static const long X509_V_ERR_DIFFERENT_CRL_SCOPE = 0;
+static const long X509_V_ERR_UNSUPPORTED_EXTENSION_FEATURE = 0;
+static const long X509_V_ERR_PERMITTED_VIOLATION = 0;
+static const long X509_V_ERR_EXCLUDED_VIOLATION = 0;
+static const long X509_V_ERR_SUBTREE_MINMAX = 0;
+static const long X509_V_ERR_UNSUPPORTED_CONSTRAINT_TYPE = 0;
+static const long X509_V_ERR_UNSUPPORTED_CONSTRAINT_SYNTAX = 0;
+static const long X509_V_ERR_UNSUPPORTED_NAME_SYNTAX = 0;
+static const long X509_V_ERR_CRL_PATH_VALIDATION_ERROR = 0;
+#endif
+
+/* OpenSSL 1.0.0+ verification parameters */
+#if OPENSSL_VERSION_NUMBER >= 0x10000000L
+static const long Cryptography_HAS_100_VERIFICATION_PARAMS = 1;
+#else
+static const long Cryptography_HAS_100_VERIFICATION_PARAMS = 0;
+static const long X509_V_FLAG_EXTENDED_CRL_SUPPORT = 0;
+static const long X509_V_FLAG_USE_DELTAS = 0;
+#endif
+
+/* OpenSSL 0.9.8recent+ */
+#ifdef X509_V_FLAG_CHECK_SS_SIGNATURE
+static const long Cryptography_HAS_X509_V_FLAG_CHECK_SS_SIGNATURE = 1;
+#else
+static const long Cryptography_HAS_X509_V_FLAG_CHECK_SS_SIGNATURE = 0;
+static const long X509_V_FLAG_CHECK_SS_SIGNATURE = 0;
+#endif
+"""
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/utils.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/utils.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/utils.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/_cffi_src/utils.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,88 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import sys
+
+from cffi import FFI
+
+
+def build_ffi_for_binding(module_name, module_prefix, modules, pre_include="",
+                          post_include="", libraries=[], extra_compile_args=[],
+                          extra_link_args=[]):
+    """
+    Modules listed in ``modules`` should have the following attributes:
+
+    * ``INCLUDES``: A string containing C includes.
+    * ``TYPES``: A string containing C declarations for types.
+    * ``FUNCTIONS``: A string containing C declarations for functions.
+    * ``MACROS``: A string containing C declarations for any macros.
+    * ``CUSTOMIZATIONS``: A string containing arbitrary top-level C code, this
+        can be used to do things like test for a define and provide an
+        alternate implementation based on that.
+    """
+    types = []
+    includes = []
+    functions = []
+    macros = []
+    customizations = []
+    for name in modules:
+        __import__(module_prefix + name)
+        module = sys.modules[module_prefix + name]
+
+        types.append(module.TYPES)
+        macros.append(module.MACROS)
+        functions.append(module.FUNCTIONS)
+        includes.append(module.INCLUDES)
+        customizations.append(module.CUSTOMIZATIONS)
+
+    # We include functions here so that if we got any of their definitions
+    # wrong, the underlying C compiler will explode. In C you are allowed
+    # to re-declare a function if it has the same signature. That is:
+    #   int foo(int);
+    #   int foo(int);
+    # is legal, but the following will fail to compile:
+    #   int foo(int);
+    #   int foo(short);
+    verify_source = "\n".join(
+        [pre_include] +
+        includes +
+        [post_include] +
+        functions +
+        customizations
+    )
+    ffi = build_ffi(
+        module_name,
+        cdef_source="\n".join(types + functions + macros),
+        verify_source=verify_source,
+        libraries=libraries,
+        extra_compile_args=extra_compile_args,
+        extra_link_args=extra_link_args,
+    )
+
+    return ffi
+
+
+def build_ffi(module_name, cdef_source, verify_source, libraries=[],
+              extra_compile_args=[], extra_link_args=[]):
+    ffi = FFI()
+    ffi.cdef(cdef_source)
+    ffi.set_source(
+        module_name,
+        verify_source,
+        libraries=libraries,
+        extra_compile_args=extra_compile_args,
+        extra_link_args=extra_link_args,
+    )
+    return ffi
+
+
+def extra_link_args(platform):
+    if platform != "win32":
+        return []
+    else:
+        # Enable NX and ASLR for Windows builds. These are enabled by default
+        # on Python 3.3+ but not on 2.x.
+        return ["/NXCOMPAT", "/DYNAMICBASE"]
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/__about__.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/__about__.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/__about__.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/__about__.py	2015-11-19 05:01:40.000000000 +0100
@@ -0,0 +1,23 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+__all__ = [
+    "__title__", "__summary__", "__uri__", "__version__", "__author__",
+    "__email__", "__license__", "__copyright__",
+]
+
+__title__ = "cryptography"
+__summary__ = ("cryptography is a package which provides cryptographic recipes"
+               " and primitives to Python developers.")
+__uri__ = "https://github.com/pyca/cryptography"
+
+__version__ = "1.1.1"
+
+__author__ = "The cryptography developers"
+__email__ = "cryptography-dev@python.org"
+
+__license__ = "BSD or Apache License, Version 2.0"
+__copyright__ = "Copyright 2013-2015 {0}".format(__author__)
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/exceptions.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/exceptions.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/exceptions.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/exceptions.py	2015-11-19 05:01:40.000000000 +0100
@@ -0,0 +1,70 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+from enum import Enum
+
+from cryptography import utils
+from cryptography.hazmat.primitives import twofactor
+
+
+class _Reasons(Enum):
+    BACKEND_MISSING_INTERFACE = 0
+    UNSUPPORTED_HASH = 1
+    UNSUPPORTED_CIPHER = 2
+    UNSUPPORTED_PADDING = 3
+    UNSUPPORTED_MGF = 4
+    UNSUPPORTED_PUBLIC_KEY_ALGORITHM = 5
+    UNSUPPORTED_ELLIPTIC_CURVE = 6
+    UNSUPPORTED_SERIALIZATION = 7
+    UNSUPPORTED_X509 = 8
+    UNSUPPORTED_EXCHANGE_ALGORITHM = 9
+
+
+class UnsupportedAlgorithm(Exception):
+    def __init__(self, message, reason=None):
+        super(UnsupportedAlgorithm, self).__init__(message)
+        self._reason = reason
+
+
+class AlreadyFinalized(Exception):
+    pass
+
+
+class AlreadyUpdated(Exception):
+    pass
+
+
+class NotYetFinalized(Exception):
+    pass
+
+
+class InvalidTag(Exception):
+    pass
+
+
+class InvalidSignature(Exception):
+    pass
+
+
+class InternalError(Exception):
+    def __init__(self, msg, err_code):
+        super(InternalError, self).__init__(msg)
+        self.err_code = err_code
+
+
+class InvalidKey(Exception):
+    pass
+
+
+InvalidToken = utils.deprecated(
+    twofactor.InvalidToken,
+    __name__,
+    (
+        "The InvalidToken exception has moved to the "
+        "cryptography.hazmat.primitives.twofactor module"
+    ),
+    utils.DeprecatedIn09
+)
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/fernet.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/fernet.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/fernet.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/fernet.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,141 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import base64
+import binascii
+import os
+import struct
+import time
+
+import six
+
+from cryptography.exceptions import InvalidSignature
+from cryptography.hazmat.backends import default_backend
+from cryptography.hazmat.primitives import hashes, padding
+from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
+from cryptography.hazmat.primitives.hmac import HMAC
+
+
+class InvalidToken(Exception):
+    pass
+
+
+_MAX_CLOCK_SKEW = 60
+
+
+class Fernet(object):
+    def __init__(self, key, backend=None):
+        if backend is None:
+            backend = default_backend()
+
+        key = base64.urlsafe_b64decode(key)
+        if len(key) != 32:
+            raise ValueError(
+                "Fernet key must be 32 url-safe base64-encoded bytes."
+            )
+
+        self._signing_key = key[:16]
+        self._encryption_key = key[16:]
+        self._backend = backend
+
+    @classmethod
+    def generate_key(cls):
+        return base64.urlsafe_b64encode(os.urandom(32))
+
+    def encrypt(self, data):
+        current_time = int(time.time())
+        iv = os.urandom(16)
+        return self._encrypt_from_parts(data, current_time, iv)
+
+    def _encrypt_from_parts(self, data, current_time, iv):
+        if not isinstance(data, bytes):
+            raise TypeError("data must be bytes.")
+
+        padder = padding.PKCS7(algorithms.AES.block_size).padder()
+        padded_data = padder.update(data) + padder.finalize()
+        encryptor = Cipher(
+            algorithms.AES(self._encryption_key), modes.CBC(iv), self._backend
+        ).encryptor()
+        ciphertext = encryptor.update(padded_data) + encryptor.finalize()
+
+        basic_parts = (
+            b"\x80" + struct.pack(">Q", current_time) + iv + ciphertext
+        )
+
+        h = HMAC(self._signing_key, hashes.SHA256(), backend=self._backend)
+        h.update(basic_parts)
+        hmac = h.finalize()
+        return base64.urlsafe_b64encode(basic_parts + hmac)
+
+    def decrypt(self, token, ttl=None):
+        if not isinstance(token, bytes):
+            raise TypeError("token must be bytes.")
+
+        current_time = int(time.time())
+
+        try:
+            data = base64.urlsafe_b64decode(token)
+        except (TypeError, binascii.Error):
+            raise InvalidToken
+
+        if not data or six.indexbytes(data, 0) != 0x80:
+            raise InvalidToken
+
+        try:
+            timestamp, = struct.unpack(">Q", data[1:9])
+        except struct.error:
+            raise InvalidToken
+        if ttl is not None:
+            if timestamp + ttl < current_time:
+                raise InvalidToken
+        if current_time + _MAX_CLOCK_SKEW < timestamp:
+            raise InvalidToken
+        h = HMAC(self._signing_key, hashes.SHA256(), backend=self._backend)
+        h.update(data[:-32])
+        try:
+            h.verify(data[-32:])
+        except InvalidSignature:
+            raise InvalidToken
+
+        iv = data[9:25]
+        ciphertext = data[25:-32]
+        decryptor = Cipher(
+            algorithms.AES(self._encryption_key), modes.CBC(iv), self._backend
+        ).decryptor()
+        plaintext_padded = decryptor.update(ciphertext)
+        try:
+            plaintext_padded += decryptor.finalize()
+        except ValueError:
+            raise InvalidToken
+        unpadder = padding.PKCS7(algorithms.AES.block_size).unpadder()
+
+        unpadded = unpadder.update(plaintext_padded)
+        try:
+            unpadded += unpadder.finalize()
+        except ValueError:
+            raise InvalidToken
+        return unpadded
+
+
+class MultiFernet(object):
+    def __init__(self, fernets):
+        fernets = list(fernets)
+        if not fernets:
+            raise ValueError(
+                "MultiFernet requires at least one Fernet instance"
+            )
+        self._fernets = fernets
+
+    def encrypt(self, msg):
+        return self._fernets[0].encrypt(msg)
+
+    def decrypt(self, msg, ttl=None):
+        for f in self._fernets:
+            try:
+                return f.decrypt(msg, ttl)
+            except InvalidToken:
+                pass
+        raise InvalidToken
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/commoncrypto/backend.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/commoncrypto/backend.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/commoncrypto/backend.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/commoncrypto/backend.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,245 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+from collections import namedtuple
+
+from cryptography import utils
+from cryptography.exceptions import InternalError
+from cryptography.hazmat.backends.commoncrypto.ciphers import (
+    _CipherContext, _GCMCipherContext
+)
+from cryptography.hazmat.backends.commoncrypto.hashes import _HashContext
+from cryptography.hazmat.backends.commoncrypto.hmac import _HMACContext
+from cryptography.hazmat.backends.interfaces import (
+    CipherBackend, HMACBackend, HashBackend, PBKDF2HMACBackend
+)
+from cryptography.hazmat.bindings.commoncrypto.binding import Binding
+from cryptography.hazmat.primitives.ciphers.algorithms import (
+    AES, ARC4, Blowfish, CAST5, TripleDES
+)
+from cryptography.hazmat.primitives.ciphers.modes import (
+    CBC, CFB, CFB8, CTR, ECB, GCM, OFB
+)
+
+
+HashMethods = namedtuple(
+    "HashMethods", ["ctx", "hash_init", "hash_update", "hash_final"]
+)
+
+
+@utils.register_interface(CipherBackend)
+@utils.register_interface(HashBackend)
+@utils.register_interface(HMACBackend)
+@utils.register_interface(PBKDF2HMACBackend)
+class Backend(object):
+    """
+    CommonCrypto API wrapper.
+    """
+    name = "commoncrypto"
+
+    def __init__(self):
+        self._binding = Binding()
+        self._ffi = self._binding.ffi
+        self._lib = self._binding.lib
+
+        self._cipher_registry = {}
+        self._register_default_ciphers()
+        self._hash_mapping = {
+            "md5": HashMethods(
+                "CC_MD5_CTX *", self._lib.CC_MD5_Init,
+                self._lib.CC_MD5_Update, self._lib.CC_MD5_Final
+            ),
+            "sha1": HashMethods(
+                "CC_SHA1_CTX *", self._lib.CC_SHA1_Init,
+                self._lib.CC_SHA1_Update, self._lib.CC_SHA1_Final
+            ),
+            "sha224": HashMethods(
+                "CC_SHA256_CTX *", self._lib.CC_SHA224_Init,
+                self._lib.CC_SHA224_Update, self._lib.CC_SHA224_Final
+            ),
+            "sha256": HashMethods(
+                "CC_SHA256_CTX *", self._lib.CC_SHA256_Init,
+                self._lib.CC_SHA256_Update, self._lib.CC_SHA256_Final
+            ),
+            "sha384": HashMethods(
+                "CC_SHA512_CTX *", self._lib.CC_SHA384_Init,
+                self._lib.CC_SHA384_Update, self._lib.CC_SHA384_Final
+            ),
+            "sha512": HashMethods(
+                "CC_SHA512_CTX *", self._lib.CC_SHA512_Init,
+                self._lib.CC_SHA512_Update, self._lib.CC_SHA512_Final
+            ),
+        }
+
+        self._supported_hmac_algorithms = {
+            "md5": self._lib.kCCHmacAlgMD5,
+            "sha1": self._lib.kCCHmacAlgSHA1,
+            "sha224": self._lib.kCCHmacAlgSHA224,
+            "sha256": self._lib.kCCHmacAlgSHA256,
+            "sha384": self._lib.kCCHmacAlgSHA384,
+            "sha512": self._lib.kCCHmacAlgSHA512,
+        }
+
+        self._supported_pbkdf2_hmac_algorithms = {
+            "sha1": self._lib.kCCPRFHmacAlgSHA1,
+            "sha224": self._lib.kCCPRFHmacAlgSHA224,
+            "sha256": self._lib.kCCPRFHmacAlgSHA256,
+            "sha384": self._lib.kCCPRFHmacAlgSHA384,
+            "sha512": self._lib.kCCPRFHmacAlgSHA512,
+        }
+
+    def hash_supported(self, algorithm):
+        return algorithm.name in self._hash_mapping
+
+    def hmac_supported(self, algorithm):
+        return algorithm.name in self._supported_hmac_algorithms
+
+    def create_hash_ctx(self, algorithm):
+        return _HashContext(self, algorithm)
+
+    def create_hmac_ctx(self, key, algorithm):
+        return _HMACContext(self, key, algorithm)
+
+    def cipher_supported(self, cipher, mode):
+        return (type(cipher), type(mode)) in self._cipher_registry
+
+    def create_symmetric_encryption_ctx(self, cipher, mode):
+        if isinstance(mode, GCM):
+            return _GCMCipherContext(
+                self, cipher, mode, self._lib.kCCEncrypt
+            )
+        else:
+            return _CipherContext(self, cipher, mode, self._lib.kCCEncrypt)
+
+    def create_symmetric_decryption_ctx(self, cipher, mode):
+        if isinstance(mode, GCM):
+            return _GCMCipherContext(
+                self, cipher, mode, self._lib.kCCDecrypt
+            )
+        else:
+            return _CipherContext(self, cipher, mode, self._lib.kCCDecrypt)
+
+    def pbkdf2_hmac_supported(self, algorithm):
+        return algorithm.name in self._supported_pbkdf2_hmac_algorithms
+
+    def derive_pbkdf2_hmac(self, algorithm, length, salt, iterations,
+                           key_material):
+        alg_enum = self._supported_pbkdf2_hmac_algorithms[algorithm.name]
+        buf = self._ffi.new("char[]", length)
+        res = self._lib.CCKeyDerivationPBKDF(
+            self._lib.kCCPBKDF2,
+            key_material,
+            len(key_material),
+            salt,
+            len(salt),
+            alg_enum,
+            iterations,
+            buf,
+            length
+        )
+        self._check_cipher_response(res)
+
+        return self._ffi.buffer(buf)[:]
+
+    def _register_cipher_adapter(self, cipher_cls, cipher_const, mode_cls,
+                                 mode_const):
+        if (cipher_cls, mode_cls) in self._cipher_registry:
+            raise ValueError("Duplicate registration for: {0} {1}.".format(
+                cipher_cls, mode_cls)
+            )
+        self._cipher_registry[cipher_cls, mode_cls] = (cipher_const,
+                                                       mode_const)
+
+    def _register_default_ciphers(self):
+        for mode_cls, mode_const in [
+            (CBC, self._lib.kCCModeCBC),
+            (ECB, self._lib.kCCModeECB),
+            (CFB, self._lib.kCCModeCFB),
+            (CFB8, self._lib.kCCModeCFB8),
+            (OFB, self._lib.kCCModeOFB),
+            (CTR, self._lib.kCCModeCTR),
+            (GCM, self._lib.kCCModeGCM),
+        ]:
+            self._register_cipher_adapter(
+                AES,
+                self._lib.kCCAlgorithmAES128,
+                mode_cls,
+                mode_const
+            )
+        for mode_cls, mode_const in [
+            (CBC, self._lib.kCCModeCBC),
+            (ECB, self._lib.kCCModeECB),
+            (CFB, self._lib.kCCModeCFB),
+            (CFB8, self._lib.kCCModeCFB8),
+            (OFB, self._lib.kCCModeOFB),
+        ]:
+            self._register_cipher_adapter(
+                TripleDES,
+                self._lib.kCCAlgorithm3DES,
+                mode_cls,
+                mode_const
+            )
+        for mode_cls, mode_const in [
+            (CBC, self._lib.kCCModeCBC),
+            (ECB, self._lib.kCCModeECB),
+            (CFB, self._lib.kCCModeCFB),
+            (OFB, self._lib.kCCModeOFB)
+        ]:
+            self._register_cipher_adapter(
+                Blowfish,
+                self._lib.kCCAlgorithmBlowfish,
+                mode_cls,
+                mode_const
+            )
+        for mode_cls, mode_const in [
+            (CBC, self._lib.kCCModeCBC),
+            (ECB, self._lib.kCCModeECB),
+            (CFB, self._lib.kCCModeCFB),
+            (OFB, self._lib.kCCModeOFB),
+            (CTR, self._lib.kCCModeCTR)
+        ]:
+            self._register_cipher_adapter(
+                CAST5,
+                self._lib.kCCAlgorithmCAST,
+                mode_cls,
+                mode_const
+            )
+        self._register_cipher_adapter(
+            ARC4,
+            self._lib.kCCAlgorithmRC4,
+            type(None),
+            self._lib.kCCModeRC4
+        )
+
+    def _check_cipher_response(self, response):
+        if response == self._lib.kCCSuccess:
+            return
+        elif response == self._lib.kCCAlignmentError:
+            # This error is not currently triggered due to a bug filed as
+            # rdar://15589470
+            raise ValueError(
+                "The length of the provided data is not a multiple of "
+                "the block length."
+            )
+        else:
+            raise InternalError(
+                "The backend returned an unknown error, consider filing a bug."
+                " Code: {0}.".format(response),
+                response
+            )
+
+    def _release_cipher_ctx(self, ctx):
+        """
+        Called by the garbage collector and used to safely dereference and
+        release the context.
+        """
+        if ctx[0] != self._ffi.NULL:
+            res = self._lib.CCCryptorRelease(ctx[0])
+            self._check_cipher_response(res)
+            ctx[0] = self._ffi.NULL
+
+
+backend = Backend()
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/commoncrypto/ciphers.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/commoncrypto/ciphers.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/commoncrypto/ciphers.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/commoncrypto/ciphers.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,193 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+from cryptography import utils
+from cryptography.exceptions import (
+    InvalidTag, UnsupportedAlgorithm, _Reasons
+)
+from cryptography.hazmat.primitives import ciphers, constant_time
+from cryptography.hazmat.primitives.ciphers import modes
+from cryptography.hazmat.primitives.ciphers.modes import (
+    CFB, CFB8, CTR, OFB
+)
+
+
+@utils.register_interface(ciphers.CipherContext)
+class _CipherContext(object):
+    def __init__(self, backend, cipher, mode, operation):
+        self._backend = backend
+        self._cipher = cipher
+        self._mode = mode
+        self._operation = operation
+        # There is a bug in CommonCrypto where block ciphers do not raise
+        # kCCAlignmentError when finalizing if you supply non-block aligned
+        # data. To work around this we need to keep track of the block
+        # alignment ourselves, but only for alg+mode combos that require
+        # block alignment. OFB, CFB, and CTR make a block cipher algorithm
+        # into a stream cipher so we don't need to track them (and thus their
+        # block size is effectively 1 byte just like OpenSSL/CommonCrypto
+        # treat RC4 and other stream cipher block sizes).
+        # This bug has been filed as rdar://15589470
+        self._bytes_processed = 0
+        if (isinstance(cipher, ciphers.BlockCipherAlgorithm) and not
+                isinstance(mode, (OFB, CFB, CFB8, CTR))):
+            self._byte_block_size = cipher.block_size // 8
+        else:
+            self._byte_block_size = 1
+
+        registry = self._backend._cipher_registry
+        try:
+            cipher_enum, mode_enum = registry[type(cipher), type(mode)]
+        except KeyError:
+            raise UnsupportedAlgorithm(
+                "cipher {0} in {1} mode is not supported "
+                "by this backend.".format(
+                    cipher.name, mode.name if mode else mode),
+                _Reasons.UNSUPPORTED_CIPHER
+            )
+
+        ctx = self._backend._ffi.new("CCCryptorRef *")
+        ctx = self._backend._ffi.gc(ctx, self._backend._release_cipher_ctx)
+
+        if isinstance(mode, modes.ModeWithInitializationVector):
+            iv_nonce = mode.initialization_vector
+        elif isinstance(mode, modes.ModeWithNonce):
+            iv_nonce = mode.nonce
+        else:
+            iv_nonce = self._backend._ffi.NULL
+
+        if isinstance(mode, CTR):
+            mode_option = self._backend._lib.kCCModeOptionCTR_BE
+        else:
+            mode_option = 0
+
+        res = self._backend._lib.CCCryptorCreateWithMode(
+            operation,
+            mode_enum, cipher_enum,
+            self._backend._lib.ccNoPadding, iv_nonce,
+            cipher.key, len(cipher.key),
+            self._backend._ffi.NULL, 0, 0, mode_option, ctx)
+        self._backend._check_cipher_response(res)
+
+        self._ctx = ctx
+
+    def update(self, data):
+        # Count bytes processed to handle block alignment.
+        self._bytes_processed += len(data)
+        buf = self._backend._ffi.new(
+            "unsigned char[]", len(data) + self._byte_block_size - 1)
+        outlen = self._backend._ffi.new("size_t *")
+        res = self._backend._lib.CCCryptorUpdate(
+            self._ctx[0], data, len(data), buf,
+            len(data) + self._byte_block_size - 1, outlen)
+        self._backend._check_cipher_response(res)
+        return self._backend._ffi.buffer(buf)[:outlen[0]]
+
+    def finalize(self):
+        # Raise error if block alignment is wrong.
+        if self._bytes_processed % self._byte_block_size:
+            raise ValueError(
+                "The length of the provided data is not a multiple of "
+                "the block length."
+            )
+        buf = self._backend._ffi.new("unsigned char[]", self._byte_block_size)
+        outlen = self._backend._ffi.new("size_t *")
+        res = self._backend._lib.CCCryptorFinal(
+            self._ctx[0], buf, len(buf), outlen)
+        self._backend._check_cipher_response(res)
+        self._backend._release_cipher_ctx(self._ctx)
+        return self._backend._ffi.buffer(buf)[:outlen[0]]
+
+
+@utils.register_interface(ciphers.AEADCipherContext)
+@utils.register_interface(ciphers.AEADEncryptionContext)
+class _GCMCipherContext(object):
+    def __init__(self, backend, cipher, mode, operation):
+        self._backend = backend
+        self._cipher = cipher
+        self._mode = mode
+        self._operation = operation
+        self._tag = None
+
+        registry = self._backend._cipher_registry
+        try:
+            cipher_enum, mode_enum = registry[type(cipher), type(mode)]
+        except KeyError:
+            raise UnsupportedAlgorithm(
+                "cipher {0} in {1} mode is not supported "
+                "by this backend.".format(
+                    cipher.name, mode.name if mode else mode),
+                _Reasons.UNSUPPORTED_CIPHER
+            )
+
+        ctx = self._backend._ffi.new("CCCryptorRef *")
+        ctx = self._backend._ffi.gc(ctx, self._backend._release_cipher_ctx)
+
+        self._ctx = ctx
+
+        res = self._backend._lib.CCCryptorCreateWithMode(
+            operation,
+            mode_enum, cipher_enum,
+            self._backend._lib.ccNoPadding,
+            self._backend._ffi.NULL,
+            cipher.key, len(cipher.key),
+            self._backend._ffi.NULL, 0, 0, 0, self._ctx)
+        self._backend._check_cipher_response(res)
+
+        res = self._backend._lib.CCCryptorGCMAddIV(
+            self._ctx[0],
+            mode.initialization_vector,
+            len(mode.initialization_vector)
+        )
+        self._backend._check_cipher_response(res)
+        # CommonCrypto has a bug where calling update without at least one
+        # call to authenticate_additional_data will result in null byte output
+        # for ciphertext. The following empty byte string call prevents the
+        # issue, which is present in at least 10.8 and 10.9.
+        # Filed as rdar://18314544
+        self.authenticate_additional_data(b"")
+
+    def update(self, data):
+        buf = self._backend._ffi.new("unsigned char[]", len(data))
+        args = (self._ctx[0], data, len(data), buf)
+        if self._operation == self._backend._lib.kCCEncrypt:
+            res = self._backend._lib.CCCryptorGCMEncrypt(*args)
+        else:
+            res = self._backend._lib.CCCryptorGCMDecrypt(*args)
+
+        self._backend._check_cipher_response(res)
+        return self._backend._ffi.buffer(buf)[:]
+
+    def finalize(self):
+        # CommonCrypto has a yet another bug where you must make at least one
+        # call to update. If you pass just AAD and call finalize without a call
+        # to update you'll get null bytes for tag. The following update call
+        # prevents this issue, which is present in at least 10.8 and 10.9.
+        # Filed as rdar://18314580
+        self.update(b"")
+        tag_size = self._cipher.block_size // 8
+        tag_buf = self._backend._ffi.new("unsigned char[]", tag_size)
+        tag_len = self._backend._ffi.new("size_t *", tag_size)
+        res = self._backend._lib.CCCryptorGCMFinal(
+            self._ctx[0], tag_buf, tag_len
+        )
+        self._backend._check_cipher_response(res)
+        self._backend._release_cipher_ctx(self._ctx)
+        self._tag = self._backend._ffi.buffer(tag_buf)[:]
+        if (self._operation == self._backend._lib.kCCDecrypt and
+                not constant_time.bytes_eq(
+                    self._tag[:len(self._mode.tag)], self._mode.tag
+                )):
+            raise InvalidTag
+        return b""
+
+    def authenticate_additional_data(self, data):
+        res = self._backend._lib.CCCryptorGCMAddAAD(
+            self._ctx[0], data, len(data)
+        )
+        self._backend._check_cipher_response(res)
+
+    tag = utils.read_only_property("_tag")
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/commoncrypto/hashes.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/commoncrypto/hashes.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/commoncrypto/hashes.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/commoncrypto/hashes.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,55 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+from cryptography import utils
+from cryptography.exceptions import UnsupportedAlgorithm, _Reasons
+from cryptography.hazmat.primitives import hashes
+
+
+@utils.register_interface(hashes.HashContext)
+class _HashContext(object):
+    def __init__(self, backend, algorithm, ctx=None):
+        self._algorithm = algorithm
+        self._backend = backend
+
+        if ctx is None:
+            try:
+                methods = self._backend._hash_mapping[self.algorithm.name]
+            except KeyError:
+                raise UnsupportedAlgorithm(
+                    "{0} is not a supported hash on this backend.".format(
+                        algorithm.name),
+                    _Reasons.UNSUPPORTED_HASH
+                )
+            ctx = self._backend._ffi.new(methods.ctx)
+            res = methods.hash_init(ctx)
+            assert res == 1
+
+        self._ctx = ctx
+
+    algorithm = utils.read_only_property("_algorithm")
+
+    def copy(self):
+        methods = self._backend._hash_mapping[self.algorithm.name]
+        new_ctx = self._backend._ffi.new(methods.ctx)
+        # CommonCrypto has no APIs for copying hashes, so we have to copy the
+        # underlying struct.
+        new_ctx[0] = self._ctx[0]
+
+        return _HashContext(self._backend, self.algorithm, ctx=new_ctx)
+
+    def update(self, data):
+        methods = self._backend._hash_mapping[self.algorithm.name]
+        res = methods.hash_update(self._ctx, data, len(data))
+        assert res == 1
+
+    def finalize(self):
+        methods = self._backend._hash_mapping[self.algorithm.name]
+        buf = self._backend._ffi.new("unsigned char[]",
+                                     self.algorithm.digest_size)
+        res = methods.hash_final(buf, self._ctx)
+        assert res == 1
+        return self._backend._ffi.buffer(buf)[:]
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/commoncrypto/hmac.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/commoncrypto/hmac.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/commoncrypto/hmac.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/commoncrypto/hmac.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,59 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+from cryptography import utils
+from cryptography.exceptions import (
+    InvalidSignature, UnsupportedAlgorithm, _Reasons
+)
+from cryptography.hazmat.primitives import constant_time, hashes, interfaces
+
+
+@utils.register_interface(interfaces.MACContext)
+@utils.register_interface(hashes.HashContext)
+class _HMACContext(object):
+    def __init__(self, backend, key, algorithm, ctx=None):
+        self._algorithm = algorithm
+        self._backend = backend
+        if ctx is None:
+            ctx = self._backend._ffi.new("CCHmacContext *")
+            try:
+                alg = self._backend._supported_hmac_algorithms[algorithm.name]
+            except KeyError:
+                raise UnsupportedAlgorithm(
+                    "{0} is not a supported HMAC hash on this backend.".format(
+                        algorithm.name),
+                    _Reasons.UNSUPPORTED_HASH
+                )
+
+            self._backend._lib.CCHmacInit(ctx, alg, key, len(key))
+
+        self._ctx = ctx
+        self._key = key
+
+    algorithm = utils.read_only_property("_algorithm")
+
+    def copy(self):
+        copied_ctx = self._backend._ffi.new("CCHmacContext *")
+        # CommonCrypto has no APIs for copying HMACs, so we have to copy the
+        # underlying struct.
+        copied_ctx[0] = self._ctx[0]
+        return _HMACContext(
+            self._backend, self._key, self.algorithm, ctx=copied_ctx
+        )
+
+    def update(self, data):
+        self._backend._lib.CCHmacUpdate(self._ctx, data, len(data))
+
+    def finalize(self):
+        buf = self._backend._ffi.new("unsigned char[]",
+                                     self.algorithm.digest_size)
+        self._backend._lib.CCHmacFinal(self._ctx, buf)
+        return self._backend._ffi.buffer(buf)[:]
+
+    def verify(self, signature):
+        digest = self.finalize()
+        if not constant_time.bytes_eq(digest, signature):
+            raise InvalidSignature("Signature did not match digest.")
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/commoncrypto/__init__.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/commoncrypto/__init__.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/commoncrypto/__init__.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/commoncrypto/__init__.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,10 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+from cryptography.hazmat.backends.commoncrypto.backend import backend
+
+
+__all__ = ["backend"]
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/__init__.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/__init__.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/__init__.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/__init__.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,42 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import pkg_resources
+
+from cryptography.hazmat.backends.multibackend import MultiBackend
+
+
+_available_backends_list = None
+
+
+def _available_backends():
+    global _available_backends_list
+
+    if _available_backends_list is None:
+        _available_backends_list = [
+            # setuptools 11.3 deprecated support for the require parameter to
+            # load(), and introduced the new resolve() method instead.
+            # This can be removed if/when we can assume setuptools>=11.3. At
+            # some point we may wish to add a warning, to push people along,
+            # but at present this would result in too many warnings.
+            ep.resolve() if hasattr(ep, "resolve") else ep.load(require=False)
+            for ep in pkg_resources.iter_entry_points(
+                "cryptography.backends"
+            )
+        ]
+
+    return _available_backends_list
+
+_default_backend = None
+
+
+def default_backend():
+    global _default_backend
+
+    if _default_backend is None:
+        _default_backend = MultiBackend(_available_backends())
+
+    return _default_backend
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/interfaces.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/interfaces.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/interfaces.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/interfaces.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,345 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import abc
+
+import six
+
+
+@six.add_metaclass(abc.ABCMeta)
+class CipherBackend(object):
+    @abc.abstractmethod
+    def cipher_supported(self, cipher, mode):
+        """
+        Return True if the given cipher and mode are supported.
+        """
+
+    @abc.abstractmethod
+    def create_symmetric_encryption_ctx(self, cipher, mode):
+        """
+        Get a CipherContext that can be used for encryption.
+        """
+
+    @abc.abstractmethod
+    def create_symmetric_decryption_ctx(self, cipher, mode):
+        """
+        Get a CipherContext that can be used for decryption.
+        """
+
+
+@six.add_metaclass(abc.ABCMeta)
+class HashBackend(object):
+    @abc.abstractmethod
+    def hash_supported(self, algorithm):
+        """
+        Return True if the hash algorithm is supported by this backend.
+        """
+
+    @abc.abstractmethod
+    def create_hash_ctx(self, algorithm):
+        """
+        Create a HashContext for calculating a message digest.
+        """
+
+
+@six.add_metaclass(abc.ABCMeta)
+class HMACBackend(object):
+    @abc.abstractmethod
+    def hmac_supported(self, algorithm):
+        """
+        Return True if the hash algorithm is supported for HMAC by this
+        backend.
+        """
+
+    @abc.abstractmethod
+    def create_hmac_ctx(self, key, algorithm):
+        """
+        Create a MACContext for calculating a message authentication code.
+        """
+
+
+@six.add_metaclass(abc.ABCMeta)
+class CMACBackend(object):
+    @abc.abstractmethod
+    def cmac_algorithm_supported(self, algorithm):
+        """
+        Returns True if the block cipher is supported for CMAC by this backend
+        """
+
+    @abc.abstractmethod
+    def create_cmac_ctx(self, algorithm):
+        """
+        Create a MACContext for calculating a message authentication code.
+        """
+
+
+@six.add_metaclass(abc.ABCMeta)
+class PBKDF2HMACBackend(object):
+    @abc.abstractmethod
+    def pbkdf2_hmac_supported(self, algorithm):
+        """
+        Return True if the hash algorithm is supported for PBKDF2 by this
+        backend.
+        """
+
+    @abc.abstractmethod
+    def derive_pbkdf2_hmac(self, algorithm, length, salt, iterations,
+                           key_material):
+        """
+        Return length bytes derived from provided PBKDF2 parameters.
+        """
+
+
+@six.add_metaclass(abc.ABCMeta)
+class RSABackend(object):
+    @abc.abstractmethod
+    def generate_rsa_private_key(self, public_exponent, key_size):
+        """
+        Generate an RSAPrivateKey instance with public_exponent and a modulus
+        of key_size bits.
+        """
+
+    @abc.abstractmethod
+    def rsa_padding_supported(self, padding):
+        """
+        Returns True if the backend supports the given padding options.
+        """
+
+    @abc.abstractmethod
+    def generate_rsa_parameters_supported(self, public_exponent, key_size):
+        """
+        Returns True if the backend supports the given parameters for key
+        generation.
+        """
+
+    @abc.abstractmethod
+    def load_rsa_private_numbers(self, numbers):
+        """
+        Returns an RSAPrivateKey provider.
+        """
+
+    @abc.abstractmethod
+    def load_rsa_public_numbers(self, numbers):
+        """
+        Returns an RSAPublicKey provider.
+        """
+
+
+@six.add_metaclass(abc.ABCMeta)
+class DSABackend(object):
+    @abc.abstractmethod
+    def generate_dsa_parameters(self, key_size):
+        """
+        Generate a DSAParameters instance with a modulus of key_size bits.
+        """
+
+    @abc.abstractmethod
+    def generate_dsa_private_key(self, parameters):
+        """
+        Generate a DSAPrivateKey instance with parameters as a DSAParameters
+        object.
+        """
+
+    @abc.abstractmethod
+    def generate_dsa_private_key_and_parameters(self, key_size):
+        """
+        Generate a DSAPrivateKey instance using key size only.
+        """
+
+    @abc.abstractmethod
+    def dsa_hash_supported(self, algorithm):
+        """
+        Return True if the hash algorithm is supported by the backend for DSA.
+        """
+
+    @abc.abstractmethod
+    def dsa_parameters_supported(self, p, q, g):
+        """
+        Return True if the parameters are supported by the backend for DSA.
+        """
+
+    @abc.abstractmethod
+    def load_dsa_private_numbers(self, numbers):
+        """
+        Returns a DSAPrivateKey provider.
+        """
+
+    @abc.abstractmethod
+    def load_dsa_public_numbers(self, numbers):
+        """
+        Returns a DSAPublicKey provider.
+        """
+
+    @abc.abstractmethod
+    def load_dsa_parameter_numbers(self, numbers):
+        """
+        Returns a DSAParameters provider.
+        """
+
+
+@six.add_metaclass(abc.ABCMeta)
+class EllipticCurveBackend(object):
+    @abc.abstractmethod
+    def elliptic_curve_signature_algorithm_supported(
+        self, signature_algorithm, curve
+    ):
+        """
+        Returns True if the backend supports the named elliptic curve with the
+        specified signature algorithm.
+        """
+
+    @abc.abstractmethod
+    def elliptic_curve_supported(self, curve):
+        """
+        Returns True if the backend supports the named elliptic curve.
+        """
+
+    @abc.abstractmethod
+    def generate_elliptic_curve_private_key(self, curve):
+        """
+        Return an object conforming to the EllipticCurvePrivateKey interface.
+        """
+
+    @abc.abstractmethod
+    def load_elliptic_curve_public_numbers(self, numbers):
+        """
+        Return an EllipticCurvePublicKey provider using the given numbers.
+        """
+
+    @abc.abstractmethod
+    def load_elliptic_curve_private_numbers(self, numbers):
+        """
+        Return an EllipticCurvePrivateKey provider using the given numbers.
+        """
+
+    @abc.abstractmethod
+    def elliptic_curve_exchange_algorithm_supported(self, algorithm, curve):
+        """
+        Returns whether the exchange algorithm is supported by this backend.
+        """
+
+
+@six.add_metaclass(abc.ABCMeta)
+class PEMSerializationBackend(object):
+    @abc.abstractmethod
+    def load_pem_private_key(self, data, password):
+        """
+        Loads a private key from PEM encoded data, using the provided password
+        if the data is encrypted.
+        """
+
+    @abc.abstractmethod
+    def load_pem_public_key(self, data):
+        """
+        Loads a public key from PEM encoded data.
+        """
+
+
+@six.add_metaclass(abc.ABCMeta)
+class DERSerializationBackend(object):
+    @abc.abstractmethod
+    def load_der_private_key(self, data, password):
+        """
+        Loads a private key from DER encoded data. Uses the provided password
+        if the data is encrypted.
+        """
+
+    @abc.abstractmethod
+    def load_der_public_key(self, data):
+        """
+        Loads a public key from DER encoded data.
+        """
+
+
+@six.add_metaclass(abc.ABCMeta)
+class X509Backend(object):
+    @abc.abstractmethod
+    def load_pem_x509_certificate(self, data):
+        """
+        Load an X.509 certificate from PEM encoded data.
+        """
+
+    @abc.abstractmethod
+    def load_der_x509_certificate(self, data):
+        """
+        Load an X.509 certificate from DER encoded data.
+        """
+
+    @abc.abstractmethod
+    def load_der_x509_csr(self, data):
+        """
+        Load an X.509 CSR from DER encoded data.
+        """
+
+    @abc.abstractmethod
+    def load_pem_x509_csr(self, data):
+        """
+        Load an X.509 CSR from PEM encoded data.
+        """
+
+    @abc.abstractmethod
+    def create_x509_csr(self, builder, private_key, algorithm):
+        """
+        Create and sign an X.509 CSR from a CSR builder object.
+        """
+
+    @abc.abstractmethod
+    def create_x509_certificate(self, builder, private_key, algorithm):
+        """
+        Create and sign an X.509 certificate from a CertificateBuilder object.
+        """
+
+
+@six.add_metaclass(abc.ABCMeta)
+class DHBackend(object):
+    @abc.abstractmethod
+    def generate_dh_parameters(self, key_size):
+        """
+        Generate a DHParameters instance with a modulus of key_size bits.
+        """
+
+    @abc.abstractmethod
+    def generate_dh_private_key(self, parameters):
+        """
+        Generate a DHPrivateKey instance with parameters as a DHParameters
+        object.
+        """
+
+    @abc.abstractmethod
+    def generate_dh_private_key_and_parameters(self, key_size):
+        """
+        Generate a DHPrivateKey instance using key size only.
+        """
+
+    @abc.abstractmethod
+    def load_dh_private_numbers(self, numbers):
+        """
+        Returns a DHPrivateKey provider.
+        """
+
+    @abc.abstractmethod
+    def load_dh_public_numbers(self, numbers):
+        """
+        Returns a DHPublicKey provider.
+        """
+
+    @abc.abstractmethod
+    def load_dh_parameter_numbers(self, numbers):
+        """
+        Returns a DHParameters provider.
+        """
+
+    @abc.abstractmethod
+    def dh_exchange_algorithm_supported(self, exchange_algorithm):
+        """
+        Returns whether the exchange algorithm is supported by this backend.
+        """
+
+    @abc.abstractmethod
+    def dh_parameters_supported(self, p, g):
+        """
+        Returns whether the backend supports DH with these parameter values.
+        """
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/multibackend.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/multibackend.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/multibackend.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/multibackend.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,386 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+from cryptography import utils
+from cryptography.exceptions import UnsupportedAlgorithm, _Reasons
+from cryptography.hazmat.backends.interfaces import (
+    CMACBackend, CipherBackend, DERSerializationBackend, DSABackend,
+    EllipticCurveBackend, HMACBackend, HashBackend, PBKDF2HMACBackend,
+    PEMSerializationBackend, RSABackend, X509Backend
+)
+
+
+@utils.register_interface(CMACBackend)
+@utils.register_interface(CipherBackend)
+@utils.register_interface(DERSerializationBackend)
+@utils.register_interface(HashBackend)
+@utils.register_interface(HMACBackend)
+@utils.register_interface(PBKDF2HMACBackend)
+@utils.register_interface(RSABackend)
+@utils.register_interface(DSABackend)
+@utils.register_interface(EllipticCurveBackend)
+@utils.register_interface(PEMSerializationBackend)
+@utils.register_interface(X509Backend)
+class MultiBackend(object):
+    name = "multibackend"
+
+    def __init__(self, backends):
+        self._backends = backends
+
+    def _filtered_backends(self, interface):
+        for b in self._backends:
+            if isinstance(b, interface):
+                yield b
+
+    def cipher_supported(self, cipher, mode):
+        return any(
+            b.cipher_supported(cipher, mode)
+            for b in self._filtered_backends(CipherBackend)
+        )
+
+    def create_symmetric_encryption_ctx(self, cipher, mode):
+        for b in self._filtered_backends(CipherBackend):
+            try:
+                return b.create_symmetric_encryption_ctx(cipher, mode)
+            except UnsupportedAlgorithm:
+                pass
+        raise UnsupportedAlgorithm(
+            "cipher {0} in {1} mode is not supported by this backend.".format(
+                cipher.name, mode.name if mode else mode),
+            _Reasons.UNSUPPORTED_CIPHER
+        )
+
+    def create_symmetric_decryption_ctx(self, cipher, mode):
+        for b in self._filtered_backends(CipherBackend):
+            try:
+                return b.create_symmetric_decryption_ctx(cipher, mode)
+            except UnsupportedAlgorithm:
+                pass
+        raise UnsupportedAlgorithm(
+            "cipher {0} in {1} mode is not supported by this backend.".format(
+                cipher.name, mode.name if mode else mode),
+            _Reasons.UNSUPPORTED_CIPHER
+        )
+
+    def hash_supported(self, algorithm):
+        return any(
+            b.hash_supported(algorithm)
+            for b in self._filtered_backends(HashBackend)
+        )
+
+    def create_hash_ctx(self, algorithm):
+        for b in self._filtered_backends(HashBackend):
+            try:
+                return b.create_hash_ctx(algorithm)
+            except UnsupportedAlgorithm:
+                pass
+        raise UnsupportedAlgorithm(
+            "{0} is not a supported hash on this backend.".format(
+                algorithm.name),
+            _Reasons.UNSUPPORTED_HASH
+        )
+
+    def hmac_supported(self, algorithm):
+        return any(
+            b.hmac_supported(algorithm)
+            for b in self._filtered_backends(HMACBackend)
+        )
+
+    def create_hmac_ctx(self, key, algorithm):
+        for b in self._filtered_backends(HMACBackend):
+            try:
+                return b.create_hmac_ctx(key, algorithm)
+            except UnsupportedAlgorithm:
+                pass
+        raise UnsupportedAlgorithm(
+            "{0} is not a supported hash on this backend.".format(
+                algorithm.name),
+            _Reasons.UNSUPPORTED_HASH
+        )
+
+    def pbkdf2_hmac_supported(self, algorithm):
+        return any(
+            b.pbkdf2_hmac_supported(algorithm)
+            for b in self._filtered_backends(PBKDF2HMACBackend)
+        )
+
+    def derive_pbkdf2_hmac(self, algorithm, length, salt, iterations,
+                           key_material):
+        for b in self._filtered_backends(PBKDF2HMACBackend):
+            try:
+                return b.derive_pbkdf2_hmac(
+                    algorithm, length, salt, iterations, key_material
+                )
+            except UnsupportedAlgorithm:
+                pass
+        raise UnsupportedAlgorithm(
+            "{0} is not a supported hash on this backend.".format(
+                algorithm.name),
+            _Reasons.UNSUPPORTED_HASH
+        )
+
+    def generate_rsa_private_key(self, public_exponent, key_size):
+        for b in self._filtered_backends(RSABackend):
+            return b.generate_rsa_private_key(public_exponent, key_size)
+        raise UnsupportedAlgorithm("RSA is not supported by the backend.",
+                                   _Reasons.UNSUPPORTED_PUBLIC_KEY_ALGORITHM)
+
+    def generate_rsa_parameters_supported(self, public_exponent, key_size):
+        for b in self._filtered_backends(RSABackend):
+            return b.generate_rsa_parameters_supported(
+                public_exponent, key_size
+            )
+        raise UnsupportedAlgorithm("RSA is not supported by the backend.",
+                                   _Reasons.UNSUPPORTED_PUBLIC_KEY_ALGORITHM)
+
+    def rsa_padding_supported(self, padding):
+        for b in self._filtered_backends(RSABackend):
+            return b.rsa_padding_supported(padding)
+        raise UnsupportedAlgorithm("RSA is not supported by the backend.",
+                                   _Reasons.UNSUPPORTED_PUBLIC_KEY_ALGORITHM)
+
+    def load_rsa_private_numbers(self, numbers):
+        for b in self._filtered_backends(RSABackend):
+            return b.load_rsa_private_numbers(numbers)
+
+        raise UnsupportedAlgorithm("RSA is not supported by the backend",
+                                   _Reasons.UNSUPPORTED_PUBLIC_KEY_ALGORITHM)
+
+    def load_rsa_public_numbers(self, numbers):
+        for b in self._filtered_backends(RSABackend):
+            return b.load_rsa_public_numbers(numbers)
+
+        raise UnsupportedAlgorithm("RSA is not supported by the backend",
+                                   _Reasons.UNSUPPORTED_PUBLIC_KEY_ALGORITHM)
+
+    def generate_dsa_parameters(self, key_size):
+        for b in self._filtered_backends(DSABackend):
+            return b.generate_dsa_parameters(key_size)
+        raise UnsupportedAlgorithm("DSA is not supported by the backend.",
+                                   _Reasons.UNSUPPORTED_PUBLIC_KEY_ALGORITHM)
+
+    def generate_dsa_private_key(self, parameters):
+        for b in self._filtered_backends(DSABackend):
+            return b.generate_dsa_private_key(parameters)
+        raise UnsupportedAlgorithm("DSA is not supported by the backend.",
+                                   _Reasons.UNSUPPORTED_PUBLIC_KEY_ALGORITHM)
+
+    def generate_dsa_private_key_and_parameters(self, key_size):
+        for b in self._filtered_backends(DSABackend):
+            return b.generate_dsa_private_key_and_parameters(key_size)
+        raise UnsupportedAlgorithm("DSA is not supported by the backend.",
+                                   _Reasons.UNSUPPORTED_PUBLIC_KEY_ALGORITHM)
+
+    def dsa_hash_supported(self, algorithm):
+        for b in self._filtered_backends(DSABackend):
+            return b.dsa_hash_supported(algorithm)
+        raise UnsupportedAlgorithm("DSA is not supported by the backend.",
+                                   _Reasons.UNSUPPORTED_PUBLIC_KEY_ALGORITHM)
+
+    def dsa_parameters_supported(self, p, q, g):
+        for b in self._filtered_backends(DSABackend):
+            return b.dsa_parameters_supported(p, q, g)
+        raise UnsupportedAlgorithm("DSA is not supported by the backend.",
+                                   _Reasons.UNSUPPORTED_PUBLIC_KEY_ALGORITHM)
+
+    def load_dsa_public_numbers(self, numbers):
+        for b in self._filtered_backends(DSABackend):
+            return b.load_dsa_public_numbers(numbers)
+        raise UnsupportedAlgorithm("DSA is not supported by the backend.",
+                                   _Reasons.UNSUPPORTED_PUBLIC_KEY_ALGORITHM)
+
+    def load_dsa_private_numbers(self, numbers):
+        for b in self._filtered_backends(DSABackend):
+            return b.load_dsa_private_numbers(numbers)
+        raise UnsupportedAlgorithm("DSA is not supported by the backend.",
+                                   _Reasons.UNSUPPORTED_PUBLIC_KEY_ALGORITHM)
+
+    def load_dsa_parameter_numbers(self, numbers):
+        for b in self._filtered_backends(DSABackend):
+            return b.load_dsa_parameter_numbers(numbers)
+        raise UnsupportedAlgorithm("DSA is not supported by the backend.",
+                                   _Reasons.UNSUPPORTED_PUBLIC_KEY_ALGORITHM)
+
+    def cmac_algorithm_supported(self, algorithm):
+        return any(
+            b.cmac_algorithm_supported(algorithm)
+            for b in self._filtered_backends(CMACBackend)
+        )
+
+    def create_cmac_ctx(self, algorithm):
+        for b in self._filtered_backends(CMACBackend):
+            try:
+                return b.create_cmac_ctx(algorithm)
+            except UnsupportedAlgorithm:
+                pass
+        raise UnsupportedAlgorithm("This backend does not support CMAC.",
+                                   _Reasons.UNSUPPORTED_CIPHER)
+
+    def elliptic_curve_supported(self, curve):
+        return any(
+            b.elliptic_curve_supported(curve)
+            for b in self._filtered_backends(EllipticCurveBackend)
+        )
+
+    def elliptic_curve_signature_algorithm_supported(
+        self, signature_algorithm, curve
+    ):
+        return any(
+            b.elliptic_curve_signature_algorithm_supported(
+                signature_algorithm, curve
+            )
+            for b in self._filtered_backends(EllipticCurveBackend)
+        )
+
+    def generate_elliptic_curve_private_key(self, curve):
+        for b in self._filtered_backends(EllipticCurveBackend):
+            try:
+                return b.generate_elliptic_curve_private_key(curve)
+            except UnsupportedAlgorithm:
+                continue
+
+        raise UnsupportedAlgorithm(
+            "This backend does not support this elliptic curve.",
+            _Reasons.UNSUPPORTED_ELLIPTIC_CURVE
+        )
+
+    def load_elliptic_curve_private_numbers(self, numbers):
+        for b in self._filtered_backends(EllipticCurveBackend):
+            try:
+                return b.load_elliptic_curve_private_numbers(numbers)
+            except UnsupportedAlgorithm:
+                continue
+
+        raise UnsupportedAlgorithm(
+            "This backend does not support this elliptic curve.",
+            _Reasons.UNSUPPORTED_ELLIPTIC_CURVE
+        )
+
+    def load_elliptic_curve_public_numbers(self, numbers):
+        for b in self._filtered_backends(EllipticCurveBackend):
+            try:
+                return b.load_elliptic_curve_public_numbers(numbers)
+            except UnsupportedAlgorithm:
+                continue
+
+        raise UnsupportedAlgorithm(
+            "This backend does not support this elliptic curve.",
+            _Reasons.UNSUPPORTED_ELLIPTIC_CURVE
+        )
+
+    def elliptic_curve_exchange_algorithm_supported(self, algorithm, curve):
+        return any(
+            b.elliptic_curve_exchange_algorithm_supported(algorithm, curve)
+            for b in self._filtered_backends(EllipticCurveBackend)
+        )
+
+    def load_pem_private_key(self, data, password):
+        for b in self._filtered_backends(PEMSerializationBackend):
+            return b.load_pem_private_key(data, password)
+
+        raise UnsupportedAlgorithm(
+            "This backend does not support this key serialization.",
+            _Reasons.UNSUPPORTED_SERIALIZATION
+        )
+
+    def load_pem_public_key(self, data):
+        for b in self._filtered_backends(PEMSerializationBackend):
+            return b.load_pem_public_key(data)
+
+        raise UnsupportedAlgorithm(
+            "This backend does not support this key serialization.",
+            _Reasons.UNSUPPORTED_SERIALIZATION
+        )
+
+    def load_der_private_key(self, data, password):
+        for b in self._filtered_backends(DERSerializationBackend):
+            return b.load_der_private_key(data, password)
+
+        raise UnsupportedAlgorithm(
+            "This backend does not support this key serialization.",
+            _Reasons.UNSUPPORTED_SERIALIZATION
+        )
+
+    def load_der_public_key(self, data):
+        for b in self._filtered_backends(DERSerializationBackend):
+            return b.load_der_public_key(data)
+
+        raise UnsupportedAlgorithm(
+            "This backend does not support this key serialization.",
+            _Reasons.UNSUPPORTED_SERIALIZATION
+        )
+
+    def load_pem_x509_certificate(self, data):
+        for b in self._filtered_backends(X509Backend):
+            return b.load_pem_x509_certificate(data)
+
+        raise UnsupportedAlgorithm(
+            "This backend does not support X.509.",
+            _Reasons.UNSUPPORTED_X509
+        )
+
+    def load_der_x509_certificate(self, data):
+        for b in self._filtered_backends(X509Backend):
+            return b.load_der_x509_certificate(data)
+
+        raise UnsupportedAlgorithm(
+            "This backend does not support X.509.",
+            _Reasons.UNSUPPORTED_X509
+        )
+
+    def load_pem_x509_crl(self, data):
+        for b in self._filtered_backends(X509Backend):
+            return b.load_pem_x509_crl(data)
+
+        raise UnsupportedAlgorithm(
+            "This backend does not support X.509.",
+            _Reasons.UNSUPPORTED_X509
+        )
+
+    def load_der_x509_crl(self, data):
+        for b in self._filtered_backends(X509Backend):
+            return b.load_der_x509_crl(data)
+
+        raise UnsupportedAlgorithm(
+            "This backend does not support X.509.",
+            _Reasons.UNSUPPORTED_X509
+        )
+
+    def load_der_x509_csr(self, data):
+        for b in self._filtered_backends(X509Backend):
+            return b.load_der_x509_csr(data)
+
+        raise UnsupportedAlgorithm(
+            "This backend does not support X.509.",
+            _Reasons.UNSUPPORTED_X509
+        )
+
+    def load_pem_x509_csr(self, data):
+        for b in self._filtered_backends(X509Backend):
+            return b.load_pem_x509_csr(data)
+
+        raise UnsupportedAlgorithm(
+            "This backend does not support X.509.",
+            _Reasons.UNSUPPORTED_X509
+        )
+
+    def create_x509_csr(self, builder, private_key, algorithm):
+        for b in self._filtered_backends(X509Backend):
+            return b.create_x509_csr(builder, private_key, algorithm)
+
+        raise UnsupportedAlgorithm(
+            "This backend does not support X.509.",
+            _Reasons.UNSUPPORTED_X509
+        )
+
+    def create_x509_certificate(self, builder, private_key, algorithm):
+        for b in self._filtered_backends(X509Backend):
+            return b.create_x509_certificate(builder, private_key, algorithm)
+
+        raise UnsupportedAlgorithm(
+            "This backend does not support X.509.",
+            _Reasons.UNSUPPORTED_X509
+        )
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/openssl/backend.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/openssl/backend.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/openssl/backend.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/openssl/backend.py	2015-11-19 05:01:40.000000000 +0100
@@ -0,0 +1,2102 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import calendar
+import collections
+import datetime
+import itertools
+from contextlib import contextmanager
+
+import idna
+
+import six
+
+from cryptography import utils, x509
+from cryptography.exceptions import UnsupportedAlgorithm, _Reasons
+from cryptography.hazmat.backends.interfaces import (
+    CMACBackend, CipherBackend, DERSerializationBackend, DSABackend,
+    EllipticCurveBackend, HMACBackend, HashBackend, PBKDF2HMACBackend,
+    PEMSerializationBackend, RSABackend, X509Backend
+)
+from cryptography.hazmat.backends.openssl.ciphers import (
+    _AESCTRCipherContext, _CipherContext
+)
+from cryptography.hazmat.backends.openssl.cmac import _CMACContext
+from cryptography.hazmat.backends.openssl.dsa import (
+    _DSAParameters, _DSAPrivateKey, _DSAPublicKey
+)
+from cryptography.hazmat.backends.openssl.ec import (
+    _EllipticCurvePrivateKey, _EllipticCurvePublicKey
+)
+from cryptography.hazmat.backends.openssl.hashes import _HashContext
+from cryptography.hazmat.backends.openssl.hmac import _HMACContext
+from cryptography.hazmat.backends.openssl.rsa import (
+    _RSAPrivateKey, _RSAPublicKey
+)
+from cryptography.hazmat.backends.openssl.x509 import (
+    _Certificate, _CertificateRevocationList, _CertificateSigningRequest,
+    _DISTPOINT_TYPE_FULLNAME, _DISTPOINT_TYPE_RELATIVENAME
+)
+from cryptography.hazmat.bindings.openssl import binding
+from cryptography.hazmat.primitives import hashes, serialization
+from cryptography.hazmat.primitives.asymmetric import dsa, ec, rsa
+from cryptography.hazmat.primitives.asymmetric.padding import (
+    MGF1, OAEP, PKCS1v15, PSS
+)
+from cryptography.hazmat.primitives.ciphers.algorithms import (
+    AES, ARC4, Blowfish, CAST5, Camellia, IDEA, SEED, TripleDES
+)
+from cryptography.hazmat.primitives.ciphers.modes import (
+    CBC, CFB, CFB8, CTR, ECB, GCM, OFB
+)
+from cryptography.x509.oid import ExtensionOID, NameOID
+
+
+_MemoryBIO = collections.namedtuple("_MemoryBIO", ["bio", "char_ptr"])
+
+
+def _encode_asn1_int(backend, x):
+    """
+    Converts a python integer to a ASN1_INTEGER. The returned ASN1_INTEGER will
+    not be garbage collected (to support adding them to structs that take
+    ownership of the object). Be sure to register it for GC if it will be
+    discarded after use.
+
+    """
+    # Convert Python integer to OpenSSL "bignum" in case value exceeds
+    # machine's native integer limits (note: `int_to_bn` doesn't automatically
+    # GC).
+    i = backend._int_to_bn(x)
+    i = backend._ffi.gc(i, backend._lib.BN_free)
+
+    # Wrap in a ASN.1 integer.  Don't GC -- as documented.
+    i = backend._lib.BN_to_ASN1_INTEGER(i, backend._ffi.NULL)
+    backend.openssl_assert(i != backend._ffi.NULL)
+    return i
+
+
+def _encode_asn1_int_gc(backend, x):
+    i = _encode_asn1_int(backend, x)
+    i = backend._ffi.gc(i, backend._lib.ASN1_INTEGER_free)
+    return i
+
+
+def _encode_asn1_str(backend, data, length):
+    """
+    Create an ASN1_OCTET_STRING from a Python byte string.
+    """
+    s = backend._lib.ASN1_OCTET_STRING_new()
+    res = backend._lib.ASN1_OCTET_STRING_set(s, data, length)
+    backend.openssl_assert(res == 1)
+    return s
+
+
+def _encode_asn1_utf8_str(backend, string):
+    """
+    Create an ASN1_UTF8STRING from a Python unicode string.
+    This object will be a ASN1_STRING with UTF8 type in OpenSSL and
+    can be decoded with ASN1_STRING_to_UTF8.
+    """
+    s = backend._lib.ASN1_UTF8STRING_new()
+    res = backend._lib.ASN1_STRING_set(
+        s, string.encode("utf8"), len(string.encode("utf8"))
+    )
+    backend.openssl_assert(res == 1)
+    return s
+
+
+def _encode_asn1_str_gc(backend, data, length):
+    s = _encode_asn1_str(backend, data, length)
+    s = backend._ffi.gc(s, backend._lib.ASN1_OCTET_STRING_free)
+    return s
+
+
+def _encode_inhibit_any_policy(backend, inhibit_any_policy):
+    asn1int = _encode_asn1_int_gc(backend, inhibit_any_policy.skip_certs)
+    pp = backend._ffi.new('unsigned char **')
+    r = backend._lib.i2d_ASN1_INTEGER(asn1int, pp)
+    backend.openssl_assert(r > 0)
+    pp = backend._ffi.gc(
+        pp, lambda pointer: backend._lib.OPENSSL_free(pointer[0])
+    )
+    return pp, r
+
+
+def _encode_name(backend, attributes):
+    """
+    The X509_NAME created will not be gc'd. Use _encode_name_gc if needed.
+    """
+    subject = backend._lib.X509_NAME_new()
+    for attribute in attributes:
+        value = attribute.value.encode('utf8')
+        obj = _txt2obj_gc(backend, attribute.oid.dotted_string)
+        if attribute.oid == NameOID.COUNTRY_NAME:
+            # Per RFC5280 Appendix A.1 countryName should be encoded as
+            # PrintableString, not UTF8String
+            type = backend._lib.MBSTRING_ASC
+        else:
+            type = backend._lib.MBSTRING_UTF8
+        res = backend._lib.X509_NAME_add_entry_by_OBJ(
+            subject, obj, type, value, -1, -1, 0,
+        )
+        backend.openssl_assert(res == 1)
+    return subject
+
+
+def _encode_name_gc(backend, attributes):
+    subject = _encode_name(backend, attributes)
+    subject = backend._ffi.gc(subject, backend._lib.X509_NAME_free)
+    return subject
+
+
+def _encode_certificate_policies(backend, certificate_policies):
+    cp = backend._lib.sk_POLICYINFO_new_null()
+    backend.openssl_assert(cp != backend._ffi.NULL)
+    cp = backend._ffi.gc(cp, backend._lib.sk_POLICYINFO_free)
+    for policy_info in certificate_policies:
+        pi = backend._lib.POLICYINFO_new()
+        backend.openssl_assert(pi != backend._ffi.NULL)
+        res = backend._lib.sk_POLICYINFO_push(cp, pi)
+        backend.openssl_assert(res >= 1)
+        oid = _txt2obj(backend, policy_info.policy_identifier.dotted_string)
+        pi.policyid = oid
+        if policy_info.policy_qualifiers:
+            pqis = backend._lib.sk_POLICYQUALINFO_new_null()
+            backend.openssl_assert(pqis != backend._ffi.NULL)
+            for qualifier in policy_info.policy_qualifiers:
+                pqi = backend._lib.POLICYQUALINFO_new()
+                backend.openssl_assert(pqi != backend._ffi.NULL)
+                res = backend._lib.sk_POLICYQUALINFO_push(pqis, pqi)
+                backend.openssl_assert(res >= 1)
+                if isinstance(qualifier, six.text_type):
+                    pqi.pqualid = _txt2obj(
+                        backend, x509.OID_CPS_QUALIFIER.dotted_string
+                    )
+                    pqi.d.cpsuri = _encode_asn1_str(
+                        backend,
+                        qualifier.encode("ascii"),
+                        len(qualifier.encode("ascii"))
+                    )
+                else:
+                    assert isinstance(qualifier, x509.UserNotice)
+                    pqi.pqualid = _txt2obj(
+                        backend, x509.OID_CPS_USER_NOTICE.dotted_string
+                    )
+                    un = backend._lib.USERNOTICE_new()
+                    backend.openssl_assert(un != backend._ffi.NULL)
+                    pqi.d.usernotice = un
+                    if qualifier.explicit_text:
+                        un.exptext = _encode_asn1_utf8_str(
+                            backend, qualifier.explicit_text
+                        )
+
+                    un.noticeref = _encode_notice_reference(
+                        backend, qualifier.notice_reference
+                    )
+
+            pi.qualifiers = pqis
+
+    pp = backend._ffi.new('unsigned char **')
+    r = backend._lib.i2d_CERTIFICATEPOLICIES(cp, pp)
+    backend.openssl_assert(r > 0)
+    pp = backend._ffi.gc(
+        pp, lambda pointer: backend._lib.OPENSSL_free(pointer[0])
+    )
+    return pp, r
+
+
+def _encode_notice_reference(backend, notice):
+    if notice is None:
+        return backend._ffi.NULL
+    else:
+        nr = backend._lib.NOTICEREF_new()
+        backend.openssl_assert(nr != backend._ffi.NULL)
+        # organization is a required field
+        nr.organization = _encode_asn1_utf8_str(backend, notice.organization)
+
+        notice_stack = backend._lib.sk_ASN1_INTEGER_new_null()
+        nr.noticenos = notice_stack
+        for number in notice.notice_numbers:
+            num = _encode_asn1_int(backend, number)
+            res = backend._lib.sk_ASN1_INTEGER_push(notice_stack, num)
+            backend.openssl_assert(res >= 1)
+
+        return nr
+
+
+def _txt2obj(backend, name):
+    """
+    Converts a Python string with an ASN.1 object ID in dotted form to a
+    ASN1_OBJECT.
+    """
+    name = name.encode('ascii')
+    obj = backend._lib.OBJ_txt2obj(name, 1)
+    backend.openssl_assert(obj != backend._ffi.NULL)
+    return obj
+
+
+def _txt2obj_gc(backend, name):
+    obj = _txt2obj(backend, name)
+    obj = backend._ffi.gc(obj, backend._lib.ASN1_OBJECT_free)
+    return obj
+
+
+def _encode_ocsp_nocheck(backend, ext):
+    """
+    The OCSP No Check extension is defined as a null ASN.1 value. Rather than
+    calling OpenSSL we can return a Python bytestring value in a list.
+    """
+    return [b"\x05\x00"], 2
+
+
+def _encode_key_usage(backend, key_usage):
+    set_bit = backend._lib.ASN1_BIT_STRING_set_bit
+    ku = backend._lib.ASN1_BIT_STRING_new()
+    ku = backend._ffi.gc(ku, backend._lib.ASN1_BIT_STRING_free)
+    res = set_bit(ku, 0, key_usage.digital_signature)
+    backend.openssl_assert(res == 1)
+    res = set_bit(ku, 1, key_usage.content_commitment)
+    backend.openssl_assert(res == 1)
+    res = set_bit(ku, 2, key_usage.key_encipherment)
+    backend.openssl_assert(res == 1)
+    res = set_bit(ku, 3, key_usage.data_encipherment)
+    backend.openssl_assert(res == 1)
+    res = set_bit(ku, 4, key_usage.key_agreement)
+    backend.openssl_assert(res == 1)
+    res = set_bit(ku, 5, key_usage.key_cert_sign)
+    backend.openssl_assert(res == 1)
+    res = set_bit(ku, 6, key_usage.crl_sign)
+    backend.openssl_assert(res == 1)
+    if key_usage.key_agreement:
+        res = set_bit(ku, 7, key_usage.encipher_only)
+        backend.openssl_assert(res == 1)
+        res = set_bit(ku, 8, key_usage.decipher_only)
+        backend.openssl_assert(res == 1)
+    else:
+        res = set_bit(ku, 7, 0)
+        backend.openssl_assert(res == 1)
+        res = set_bit(ku, 8, 0)
+        backend.openssl_assert(res == 1)
+
+    pp = backend._ffi.new('unsigned char **')
+    r = backend._lib.i2d_ASN1_BIT_STRING(ku, pp)
+    backend.openssl_assert(r > 0)
+    pp = backend._ffi.gc(
+        pp, lambda pointer: backend._lib.OPENSSL_free(pointer[0])
+    )
+    return pp, r
+
+
+def _encode_authority_key_identifier(backend, authority_keyid):
+    akid = backend._lib.AUTHORITY_KEYID_new()
+    backend.openssl_assert(akid != backend._ffi.NULL)
+    akid = backend._ffi.gc(akid, backend._lib.AUTHORITY_KEYID_free)
+    if authority_keyid.key_identifier is not None:
+        akid.keyid = _encode_asn1_str(
+            backend,
+            authority_keyid.key_identifier,
+            len(authority_keyid.key_identifier)
+        )
+
+    if authority_keyid.authority_cert_issuer is not None:
+        akid.issuer = _encode_general_names(
+            backend, authority_keyid.authority_cert_issuer
+        )
+
+    if authority_keyid.authority_cert_serial_number is not None:
+        akid.serial = _encode_asn1_int(
+            backend, authority_keyid.authority_cert_serial_number
+        )
+
+    pp = backend._ffi.new('unsigned char **')
+    r = backend._lib.i2d_AUTHORITY_KEYID(akid, pp)
+    backend.openssl_assert(r > 0)
+    pp = backend._ffi.gc(
+        pp, lambda pointer: backend._lib.OPENSSL_free(pointer[0])
+    )
+    return pp, r
+
+
+def _encode_basic_constraints(backend, basic_constraints):
+    constraints = backend._lib.BASIC_CONSTRAINTS_new()
+    constraints = backend._ffi.gc(
+        constraints, backend._lib.BASIC_CONSTRAINTS_free
+    )
+    constraints.ca = 255 if basic_constraints.ca else 0
+    if basic_constraints.ca and basic_constraints.path_length is not None:
+        constraints.pathlen = _encode_asn1_int(
+            backend, basic_constraints.path_length
+        )
+
+    # Fetch the encoded payload.
+    pp = backend._ffi.new('unsigned char **')
+    r = backend._lib.i2d_BASIC_CONSTRAINTS(constraints, pp)
+    backend.openssl_assert(r > 0)
+    pp = backend._ffi.gc(
+        pp, lambda pointer: backend._lib.OPENSSL_free(pointer[0])
+    )
+    return pp, r
+
+
+def _encode_authority_information_access(backend, authority_info_access):
+    aia = backend._lib.sk_ACCESS_DESCRIPTION_new_null()
+    backend.openssl_assert(aia != backend._ffi.NULL)
+    aia = backend._ffi.gc(
+        aia, backend._lib.sk_ACCESS_DESCRIPTION_free
+    )
+    for access_description in authority_info_access:
+        ad = backend._lib.ACCESS_DESCRIPTION_new()
+        method = _txt2obj(
+            backend, access_description.access_method.dotted_string
+        )
+        gn = _encode_general_name(backend, access_description.access_location)
+        ad.method = method
+        ad.location = gn
+        res = backend._lib.sk_ACCESS_DESCRIPTION_push(aia, ad)
+        backend.openssl_assert(res >= 1)
+
+    pp = backend._ffi.new('unsigned char **')
+    r = backend._lib.i2d_AUTHORITY_INFO_ACCESS(aia, pp)
+    backend.openssl_assert(r > 0)
+    pp = backend._ffi.gc(
+        pp, lambda pointer: backend._lib.OPENSSL_free(pointer[0])
+    )
+    return pp, r
+
+
+def _encode_general_names(backend, names):
+    general_names = backend._lib.GENERAL_NAMES_new()
+    backend.openssl_assert(general_names != backend._ffi.NULL)
+    for name in names:
+        gn = _encode_general_name(backend, name)
+        res = backend._lib.sk_GENERAL_NAME_push(general_names, gn)
+        backend.openssl_assert(res != 0)
+
+    return general_names
+
+
+def _encode_alt_name(backend, san):
+    general_names = _encode_general_names(backend, san)
+    general_names = backend._ffi.gc(
+        general_names, backend._lib.GENERAL_NAMES_free
+    )
+    pp = backend._ffi.new("unsigned char **")
+    r = backend._lib.i2d_GENERAL_NAMES(general_names, pp)
+    backend.openssl_assert(r > 0)
+    pp = backend._ffi.gc(
+        pp, lambda pointer: backend._lib.OPENSSL_free(pointer[0])
+    )
+    return pp, r
+
+
+def _encode_subject_key_identifier(backend, ski):
+    asn1_str = _encode_asn1_str_gc(backend, ski.digest, len(ski.digest))
+    pp = backend._ffi.new("unsigned char **")
+    r = backend._lib.i2d_ASN1_OCTET_STRING(asn1_str, pp)
+    backend.openssl_assert(r > 0)
+    pp = backend._ffi.gc(
+        pp, lambda pointer: backend._lib.OPENSSL_free(pointer[0])
+    )
+    return pp, r
+
+
+def _encode_general_name(backend, name):
+    if isinstance(name, x509.DNSName):
+        gn = backend._lib.GENERAL_NAME_new()
+        backend.openssl_assert(gn != backend._ffi.NULL)
+        gn.type = backend._lib.GEN_DNS
+
+        ia5 = backend._lib.ASN1_IA5STRING_new()
+        backend.openssl_assert(ia5 != backend._ffi.NULL)
+
+        if name.value.startswith(u"*."):
+            value = b"*." + idna.encode(name.value[2:])
+        else:
+            value = idna.encode(name.value)
+
+        res = backend._lib.ASN1_STRING_set(ia5, value, len(value))
+        backend.openssl_assert(res == 1)
+        gn.d.dNSName = ia5
+    elif isinstance(name, x509.RegisteredID):
+        gn = backend._lib.GENERAL_NAME_new()
+        backend.openssl_assert(gn != backend._ffi.NULL)
+        gn.type = backend._lib.GEN_RID
+        obj = backend._lib.OBJ_txt2obj(
+            name.value.dotted_string.encode('ascii'), 1
+        )
+        backend.openssl_assert(obj != backend._ffi.NULL)
+        gn.d.registeredID = obj
+    elif isinstance(name, x509.DirectoryName):
+        gn = backend._lib.GENERAL_NAME_new()
+        backend.openssl_assert(gn != backend._ffi.NULL)
+        dir_name = _encode_name(backend, name.value)
+        gn.type = backend._lib.GEN_DIRNAME
+        gn.d.directoryName = dir_name
+    elif isinstance(name, x509.IPAddress):
+        gn = backend._lib.GENERAL_NAME_new()
+        backend.openssl_assert(gn != backend._ffi.NULL)
+        ipaddr = _encode_asn1_str(
+            backend, name.value.packed, len(name.value.packed)
+        )
+        gn.type = backend._lib.GEN_IPADD
+        gn.d.iPAddress = ipaddr
+    elif isinstance(name, x509.OtherName):
+        gn = backend._lib.GENERAL_NAME_new()
+        backend.openssl_assert(gn != backend._ffi.NULL)
+        other_name = backend._lib.OTHERNAME_new()
+        backend.openssl_assert(other_name != backend._ffi.NULL)
+
+        type_id = backend._lib.OBJ_txt2obj(
+            name.type_id.dotted_string.encode('ascii'), 1
+        )
+        backend.openssl_assert(type_id != backend._ffi.NULL)
+        data = backend._ffi.new("unsigned char[]", name.value)
+        data_ptr_ptr = backend._ffi.new("unsigned char **")
+        data_ptr_ptr[0] = data
+        value = backend._lib.d2i_ASN1_TYPE(
+            backend._ffi.NULL, data_ptr_ptr, len(name.value)
+        )
+        if value == backend._ffi.NULL:
+            backend._consume_errors()
+            raise ValueError("Invalid ASN.1 data")
+        other_name.type_id = type_id
+        other_name.value = value
+        gn.type = backend._lib.GEN_OTHERNAME
+        gn.d.otherName = other_name
+    elif isinstance(name, x509.RFC822Name):
+        gn = backend._lib.GENERAL_NAME_new()
+        backend.openssl_assert(gn != backend._ffi.NULL)
+        asn1_str = _encode_asn1_str(
+            backend, name._encoded, len(name._encoded)
+        )
+        gn.type = backend._lib.GEN_EMAIL
+        gn.d.rfc822Name = asn1_str
+    elif isinstance(name, x509.UniformResourceIdentifier):
+        gn = backend._lib.GENERAL_NAME_new()
+        backend.openssl_assert(gn != backend._ffi.NULL)
+        asn1_str = _encode_asn1_str(
+            backend, name._encoded, len(name._encoded)
+        )
+        gn.type = backend._lib.GEN_URI
+        gn.d.uniformResourceIdentifier = asn1_str
+    else:
+        raise ValueError(
+            "{0} is an unknown GeneralName type".format(name)
+        )
+
+    return gn
+
+
+def _encode_extended_key_usage(backend, extended_key_usage):
+    eku = backend._lib.sk_ASN1_OBJECT_new_null()
+    eku = backend._ffi.gc(eku, backend._lib.sk_ASN1_OBJECT_free)
+    for oid in extended_key_usage:
+        obj = _txt2obj(backend, oid.dotted_string)
+        res = backend._lib.sk_ASN1_OBJECT_push(eku, obj)
+        backend.openssl_assert(res >= 1)
+
+    pp = backend._ffi.new('unsigned char **')
+    r = backend._lib.i2d_EXTENDED_KEY_USAGE(
+        backend._ffi.cast("EXTENDED_KEY_USAGE *", eku), pp
+    )
+    backend.openssl_assert(r > 0)
+    pp = backend._ffi.gc(
+        pp, lambda pointer: backend._lib.OPENSSL_free(pointer[0])
+    )
+    return pp, r
+
+
+_CRLREASONFLAGS = {
+    x509.ReasonFlags.key_compromise: 1,
+    x509.ReasonFlags.ca_compromise: 2,
+    x509.ReasonFlags.affiliation_changed: 3,
+    x509.ReasonFlags.superseded: 4,
+    x509.ReasonFlags.cessation_of_operation: 5,
+    x509.ReasonFlags.certificate_hold: 6,
+    x509.ReasonFlags.privilege_withdrawn: 7,
+    x509.ReasonFlags.aa_compromise: 8,
+}
+
+
+def _encode_crl_distribution_points(backend, crl_distribution_points):
+    cdp = backend._lib.sk_DIST_POINT_new_null()
+    cdp = backend._ffi.gc(cdp, backend._lib.sk_DIST_POINT_free)
+    for point in crl_distribution_points:
+        dp = backend._lib.DIST_POINT_new()
+        backend.openssl_assert(dp != backend._ffi.NULL)
+
+        if point.reasons:
+            bitmask = backend._lib.ASN1_BIT_STRING_new()
+            backend.openssl_assert(bitmask != backend._ffi.NULL)
+            dp.reasons = bitmask
+            for reason in point.reasons:
+                res = backend._lib.ASN1_BIT_STRING_set_bit(
+                    bitmask, _CRLREASONFLAGS[reason], 1
+                )
+                backend.openssl_assert(res == 1)
+
+        if point.full_name:
+            dpn = backend._lib.DIST_POINT_NAME_new()
+            backend.openssl_assert(dpn != backend._ffi.NULL)
+            dpn.type = _DISTPOINT_TYPE_FULLNAME
+            dpn.name.fullname = _encode_general_names(backend, point.full_name)
+            dp.distpoint = dpn
+
+        if point.relative_name:
+            dpn = backend._lib.DIST_POINT_NAME_new()
+            backend.openssl_assert(dpn != backend._ffi.NULL)
+            dpn.type = _DISTPOINT_TYPE_RELATIVENAME
+            name = _encode_name_gc(backend, point.relative_name)
+            relativename = backend._lib.sk_X509_NAME_ENTRY_dup(name.entries)
+            backend.openssl_assert(relativename != backend._ffi.NULL)
+            dpn.name.relativename = relativename
+            dp.distpoint = dpn
+
+        if point.crl_issuer:
+            dp.CRLissuer = _encode_general_names(backend, point.crl_issuer)
+
+        res = backend._lib.sk_DIST_POINT_push(cdp, dp)
+        backend.openssl_assert(res >= 1)
+
+    pp = backend._ffi.new('unsigned char **')
+    r = backend._lib.i2d_CRL_DIST_POINTS(cdp, pp)
+    backend.openssl_assert(r > 0)
+    pp = backend._ffi.gc(
+        pp, lambda pointer: backend._lib.OPENSSL_free(pointer[0])
+    )
+    return pp, r
+
+
+_EXTENSION_ENCODE_HANDLERS = {
+    ExtensionOID.BASIC_CONSTRAINTS: _encode_basic_constraints,
+    ExtensionOID.SUBJECT_KEY_IDENTIFIER: _encode_subject_key_identifier,
+    ExtensionOID.KEY_USAGE: _encode_key_usage,
+    ExtensionOID.SUBJECT_ALTERNATIVE_NAME: _encode_alt_name,
+    ExtensionOID.ISSUER_ALTERNATIVE_NAME: _encode_alt_name,
+    ExtensionOID.EXTENDED_KEY_USAGE: _encode_extended_key_usage,
+    ExtensionOID.AUTHORITY_KEY_IDENTIFIER: _encode_authority_key_identifier,
+    ExtensionOID.CERTIFICATE_POLICIES: _encode_certificate_policies,
+    ExtensionOID.AUTHORITY_INFORMATION_ACCESS: (
+        _encode_authority_information_access
+    ),
+    ExtensionOID.CRL_DISTRIBUTION_POINTS: _encode_crl_distribution_points,
+    ExtensionOID.INHIBIT_ANY_POLICY: _encode_inhibit_any_policy,
+    ExtensionOID.OCSP_NO_CHECK: _encode_ocsp_nocheck,
+}
+
+
+@utils.register_interface(CipherBackend)
+@utils.register_interface(CMACBackend)
+@utils.register_interface(DERSerializationBackend)
+@utils.register_interface(DSABackend)
+@utils.register_interface(EllipticCurveBackend)
+@utils.register_interface(HashBackend)
+@utils.register_interface(HMACBackend)
+@utils.register_interface(PBKDF2HMACBackend)
+@utils.register_interface(RSABackend)
+@utils.register_interface(PEMSerializationBackend)
+@utils.register_interface(X509Backend)
+class Backend(object):
+    """
+    OpenSSL API binding interfaces.
+    """
+    name = "openssl"
+
+    def __init__(self):
+        self._binding = binding.Binding()
+        self._ffi = self._binding.ffi
+        self._lib = self._binding.lib
+
+        # Set the default string mask for encoding ASN1 strings to UTF8. This
+        # is the default for newer OpenSSLs for several years and is
+        # recommended in RFC 2459.
+        res = self._lib.ASN1_STRING_set_default_mask_asc(b"utf8only")
+        self.openssl_assert(res == 1)
+
+        self._cipher_registry = {}
+        self._register_default_ciphers()
+        self.activate_osrandom_engine()
+
+    def openssl_assert(self, ok):
+        return binding._openssl_assert(self._lib, ok)
+
+    def activate_builtin_random(self):
+        # Obtain a new structural reference.
+        e = self._lib.ENGINE_get_default_RAND()
+        if e != self._ffi.NULL:
+            self._lib.ENGINE_unregister_RAND(e)
+            # Reset the RNG to use the new engine.
+            self._lib.RAND_cleanup()
+            # decrement the structural reference from get_default_RAND
+            res = self._lib.ENGINE_finish(e)
+            self.openssl_assert(res == 1)
+
+    def activate_osrandom_engine(self):
+        # Unregister and free the current engine.
+        self.activate_builtin_random()
+        # Fetches an engine by id and returns it. This creates a structural
+        # reference.
+        e = self._lib.ENGINE_by_id(self._binding._osrandom_engine_id)
+        self.openssl_assert(e != self._ffi.NULL)
+        # Initialize the engine for use. This adds a functional reference.
+        res = self._lib.ENGINE_init(e)
+        self.openssl_assert(res == 1)
+        # Set the engine as the default RAND provider.
+        res = self._lib.ENGINE_set_default_RAND(e)
+        self.openssl_assert(res == 1)
+        # Decrement the structural ref incremented by ENGINE_by_id.
+        res = self._lib.ENGINE_free(e)
+        self.openssl_assert(res == 1)
+        # Decrement the functional ref incremented by ENGINE_init.
+        res = self._lib.ENGINE_finish(e)
+        self.openssl_assert(res == 1)
+        # Reset the RNG to use the new engine.
+        self._lib.RAND_cleanup()
+
+    def openssl_version_text(self):
+        """
+        Friendly string name of the loaded OpenSSL library. This is not
+        necessarily the same version as it was compiled against.
+
+        Example: OpenSSL 1.0.1e 11 Feb 2013
+        """
+        return self._ffi.string(
+            self._lib.SSLeay_version(self._lib.SSLEAY_VERSION)
+        ).decode("ascii")
+
+    def create_hmac_ctx(self, key, algorithm):
+        return _HMACContext(self, key, algorithm)
+
+    def hash_supported(self, algorithm):
+        digest = self._lib.EVP_get_digestbyname(algorithm.name.encode("ascii"))
+        return digest != self._ffi.NULL
+
+    def hmac_supported(self, algorithm):
+        return self.hash_supported(algorithm)
+
+    def create_hash_ctx(self, algorithm):
+        return _HashContext(self, algorithm)
+
+    def cipher_supported(self, cipher, mode):
+        if self._evp_cipher_supported(cipher, mode):
+            return True
+        elif isinstance(mode, CTR) and isinstance(cipher, AES):
+            return True
+        else:
+            return False
+
+    def _evp_cipher_supported(self, cipher, mode):
+        try:
+            adapter = self._cipher_registry[type(cipher), type(mode)]
+        except KeyError:
+            return False
+        evp_cipher = adapter(self, cipher, mode)
+        return self._ffi.NULL != evp_cipher
+
+    def register_cipher_adapter(self, cipher_cls, mode_cls, adapter):
+        if (cipher_cls, mode_cls) in self._cipher_registry:
+            raise ValueError("Duplicate registration for: {0} {1}.".format(
+                cipher_cls, mode_cls)
+            )
+        self._cipher_registry[cipher_cls, mode_cls] = adapter
+
+    def _register_default_ciphers(self):
+        for mode_cls in [CBC, CTR, ECB, OFB, CFB, CFB8]:
+            self.register_cipher_adapter(
+                AES,
+                mode_cls,
+                GetCipherByName("{cipher.name}-{cipher.key_size}-{mode.name}")
+            )
+        for mode_cls in [CBC, CTR, ECB, OFB, CFB]:
+            self.register_cipher_adapter(
+                Camellia,
+                mode_cls,
+                GetCipherByName("{cipher.name}-{cipher.key_size}-{mode.name}")
+            )
+        for mode_cls in [CBC, CFB, CFB8, OFB]:
+            self.register_cipher_adapter(
+                TripleDES,
+                mode_cls,
+                GetCipherByName("des-ede3-{mode.name}")
+            )
+        self.register_cipher_adapter(
+            TripleDES,
+            ECB,
+            GetCipherByName("des-ede3")
+        )
+        for mode_cls in [CBC, CFB, OFB, ECB]:
+            self.register_cipher_adapter(
+                Blowfish,
+                mode_cls,
+                GetCipherByName("bf-{mode.name}")
+            )
+        for mode_cls in [CBC, CFB, OFB, ECB]:
+            self.register_cipher_adapter(
+                SEED,
+                mode_cls,
+                GetCipherByName("seed-{mode.name}")
+            )
+        for cipher_cls, mode_cls in itertools.product(
+            [CAST5, IDEA],
+            [CBC, OFB, CFB, ECB],
+        ):
+            self.register_cipher_adapter(
+                cipher_cls,
+                mode_cls,
+                GetCipherByName("{cipher.name}-{mode.name}")
+            )
+        self.register_cipher_adapter(
+            ARC4,
+            type(None),
+            GetCipherByName("rc4")
+        )
+        self.register_cipher_adapter(
+            AES,
+            GCM,
+            GetCipherByName("{cipher.name}-{cipher.key_size}-{mode.name}")
+        )
+
+    def create_symmetric_encryption_ctx(self, cipher, mode):
+        if (isinstance(mode, CTR) and isinstance(cipher, AES) and
+                not self._evp_cipher_supported(cipher, mode)):
+            # This is needed to provide support for AES CTR mode in OpenSSL
+            # 0.9.8. It can be removed when we drop 0.9.8 support (RHEL 5
+            # extended life ends 2020).
+            return _AESCTRCipherContext(self, cipher, mode)
+        else:
+            return _CipherContext(self, cipher, mode, _CipherContext._ENCRYPT)
+
+    def create_symmetric_decryption_ctx(self, cipher, mode):
+        if (isinstance(mode, CTR) and isinstance(cipher, AES) and
+                not self._evp_cipher_supported(cipher, mode)):
+            # This is needed to provide support for AES CTR mode in OpenSSL
+            # 0.9.8. It can be removed when we drop 0.9.8 support (RHEL 5
+            # extended life ends 2020).
+            return _AESCTRCipherContext(self, cipher, mode)
+        else:
+            return _CipherContext(self, cipher, mode, _CipherContext._DECRYPT)
+
+    def pbkdf2_hmac_supported(self, algorithm):
+        if self._lib.Cryptography_HAS_PBKDF2_HMAC:
+            return self.hmac_supported(algorithm)
+        else:
+            # OpenSSL < 1.0.0 has an explicit PBKDF2-HMAC-SHA1 function,
+            # so if the PBKDF2_HMAC function is missing we only support
+            # SHA1 via PBKDF2_HMAC_SHA1.
+            return isinstance(algorithm, hashes.SHA1)
+
+    def derive_pbkdf2_hmac(self, algorithm, length, salt, iterations,
+                           key_material):
+        buf = self._ffi.new("char[]", length)
+        if self._lib.Cryptography_HAS_PBKDF2_HMAC:
+            evp_md = self._lib.EVP_get_digestbyname(
+                algorithm.name.encode("ascii"))
+            self.openssl_assert(evp_md != self._ffi.NULL)
+            res = self._lib.PKCS5_PBKDF2_HMAC(
+                key_material,
+                len(key_material),
+                salt,
+                len(salt),
+                iterations,
+                evp_md,
+                length,
+                buf
+            )
+            self.openssl_assert(res == 1)
+        else:
+            if not isinstance(algorithm, hashes.SHA1):
+                raise UnsupportedAlgorithm(
+                    "This version of OpenSSL only supports PBKDF2HMAC with "
+                    "SHA1.",
+                    _Reasons.UNSUPPORTED_HASH
+                )
+            res = self._lib.PKCS5_PBKDF2_HMAC_SHA1(
+                key_material,
+                len(key_material),
+                salt,
+                len(salt),
+                iterations,
+                length,
+                buf
+            )
+            self.openssl_assert(res == 1)
+
+        return self._ffi.buffer(buf)[:]
+
+    def _consume_errors(self):
+        return binding._consume_errors(self._lib)
+
+    def _bn_to_int(self, bn):
+        assert bn != self._ffi.NULL
+        if six.PY3:
+            # Python 3 has constant time from_bytes, so use that.
+
+            bn_num_bytes = (self._lib.BN_num_bits(bn) + 7) // 8
+            bin_ptr = self._ffi.new("unsigned char[]", bn_num_bytes)
+            bin_len = self._lib.BN_bn2bin(bn, bin_ptr)
+            # A zero length means the BN has value 0
+            self.openssl_assert(bin_len >= 0)
+            return int.from_bytes(self._ffi.buffer(bin_ptr)[:bin_len], "big")
+
+        else:
+            # Under Python 2 the best we can do is hex()
+
+            hex_cdata = self._lib.BN_bn2hex(bn)
+            self.openssl_assert(hex_cdata != self._ffi.NULL)
+            hex_str = self._ffi.string(hex_cdata)
+            self._lib.OPENSSL_free(hex_cdata)
+            return int(hex_str, 16)
+
+    def _int_to_bn(self, num, bn=None):
+        """
+        Converts a python integer to a BIGNUM. The returned BIGNUM will not
+        be garbage collected (to support adding them to structs that take
+        ownership of the object). Be sure to register it for GC if it will
+        be discarded after use.
+        """
+        assert bn is None or bn != self._ffi.NULL
+
+        if bn is None:
+            bn = self._ffi.NULL
+
+        if six.PY3:
+            # Python 3 has constant time to_bytes, so use that.
+
+            binary = num.to_bytes(int(num.bit_length() / 8.0 + 1), "big")
+            bn_ptr = self._lib.BN_bin2bn(binary, len(binary), bn)
+            self.openssl_assert(bn_ptr != self._ffi.NULL)
+            return bn_ptr
+
+        else:
+            # Under Python 2 the best we can do is hex()
+
+            hex_num = hex(num).rstrip("L").lstrip("0x").encode("ascii") or b"0"
+            bn_ptr = self._ffi.new("BIGNUM **")
+            bn_ptr[0] = bn
+            res = self._lib.BN_hex2bn(bn_ptr, hex_num)
+            self.openssl_assert(res != 0)
+            self.openssl_assert(bn_ptr[0] != self._ffi.NULL)
+            return bn_ptr[0]
+
+    def generate_rsa_private_key(self, public_exponent, key_size):
+        rsa._verify_rsa_parameters(public_exponent, key_size)
+
+        rsa_cdata = self._lib.RSA_new()
+        self.openssl_assert(rsa_cdata != self._ffi.NULL)
+        rsa_cdata = self._ffi.gc(rsa_cdata, self._lib.RSA_free)
+
+        bn = self._int_to_bn(public_exponent)
+        bn = self._ffi.gc(bn, self._lib.BN_free)
+
+        res = self._lib.RSA_generate_key_ex(
+            rsa_cdata, key_size, bn, self._ffi.NULL
+        )
+        self.openssl_assert(res == 1)
+        evp_pkey = self._rsa_cdata_to_evp_pkey(rsa_cdata)
+
+        return _RSAPrivateKey(self, rsa_cdata, evp_pkey)
+
+    def generate_rsa_parameters_supported(self, public_exponent, key_size):
+        return (public_exponent >= 3 and public_exponent & 1 != 0 and
+                key_size >= 512)
+
+    def load_rsa_private_numbers(self, numbers):
+        rsa._check_private_key_components(
+            numbers.p,
+            numbers.q,
+            numbers.d,
+            numbers.dmp1,
+            numbers.dmq1,
+            numbers.iqmp,
+            numbers.public_numbers.e,
+            numbers.public_numbers.n
+        )
+        rsa_cdata = self._lib.RSA_new()
+        self.openssl_assert(rsa_cdata != self._ffi.NULL)
+        rsa_cdata = self._ffi.gc(rsa_cdata, self._lib.RSA_free)
+        rsa_cdata.p = self._int_to_bn(numbers.p)
+        rsa_cdata.q = self._int_to_bn(numbers.q)
+        rsa_cdata.d = self._int_to_bn(numbers.d)
+        rsa_cdata.dmp1 = self._int_to_bn(numbers.dmp1)
+        rsa_cdata.dmq1 = self._int_to_bn(numbers.dmq1)
+        rsa_cdata.iqmp = self._int_to_bn(numbers.iqmp)
+        rsa_cdata.e = self._int_to_bn(numbers.public_numbers.e)
+        rsa_cdata.n = self._int_to_bn(numbers.public_numbers.n)
+        res = self._lib.RSA_blinding_on(rsa_cdata, self._ffi.NULL)
+        self.openssl_assert(res == 1)
+        evp_pkey = self._rsa_cdata_to_evp_pkey(rsa_cdata)
+
+        return _RSAPrivateKey(self, rsa_cdata, evp_pkey)
+
+    def load_rsa_public_numbers(self, numbers):
+        rsa._check_public_key_components(numbers.e, numbers.n)
+        rsa_cdata = self._lib.RSA_new()
+        self.openssl_assert(rsa_cdata != self._ffi.NULL)
+        rsa_cdata = self._ffi.gc(rsa_cdata, self._lib.RSA_free)
+        rsa_cdata.e = self._int_to_bn(numbers.e)
+        rsa_cdata.n = self._int_to_bn(numbers.n)
+        res = self._lib.RSA_blinding_on(rsa_cdata, self._ffi.NULL)
+        self.openssl_assert(res == 1)
+        evp_pkey = self._rsa_cdata_to_evp_pkey(rsa_cdata)
+
+        return _RSAPublicKey(self, rsa_cdata, evp_pkey)
+
+    def _rsa_cdata_to_evp_pkey(self, rsa_cdata):
+        evp_pkey = self._lib.EVP_PKEY_new()
+        self.openssl_assert(evp_pkey != self._ffi.NULL)
+        evp_pkey = self._ffi.gc(evp_pkey, self._lib.EVP_PKEY_free)
+        res = self._lib.EVP_PKEY_set1_RSA(evp_pkey, rsa_cdata)
+        self.openssl_assert(res == 1)
+        return evp_pkey
+
+    def _bytes_to_bio(self, data):
+        """
+        Return a _MemoryBIO namedtuple of (BIO, char*).
+
+        The char* is the storage for the BIO and it must stay alive until the
+        BIO is finished with.
+        """
+        data_char_p = self._ffi.new("char[]", data)
+        bio = self._lib.BIO_new_mem_buf(
+            data_char_p, len(data)
+        )
+        self.openssl_assert(bio != self._ffi.NULL)
+
+        return _MemoryBIO(self._ffi.gc(bio, self._lib.BIO_free), data_char_p)
+
+    def _create_mem_bio(self):
+        """
+        Creates an empty memory BIO.
+        """
+        bio_method = self._lib.BIO_s_mem()
+        self.openssl_assert(bio_method != self._ffi.NULL)
+        bio = self._lib.BIO_new(bio_method)
+        self.openssl_assert(bio != self._ffi.NULL)
+        bio = self._ffi.gc(bio, self._lib.BIO_free)
+        return bio
+
+    def _read_mem_bio(self, bio):
+        """
+        Reads a memory BIO. This only works on memory BIOs.
+        """
+        buf = self._ffi.new("char **")
+        buf_len = self._lib.BIO_get_mem_data(bio, buf)
+        self.openssl_assert(buf_len > 0)
+        self.openssl_assert(buf[0] != self._ffi.NULL)
+        bio_data = self._ffi.buffer(buf[0], buf_len)[:]
+        return bio_data
+
+    def _evp_pkey_to_private_key(self, evp_pkey):
+        """
+        Return the appropriate type of PrivateKey given an evp_pkey cdata
+        pointer.
+        """
+
+        key_type = evp_pkey.type
+
+        if key_type == self._lib.EVP_PKEY_RSA:
+            rsa_cdata = self._lib.EVP_PKEY_get1_RSA(evp_pkey)
+            self.openssl_assert(rsa_cdata != self._ffi.NULL)
+            rsa_cdata = self._ffi.gc(rsa_cdata, self._lib.RSA_free)
+            return _RSAPrivateKey(self, rsa_cdata, evp_pkey)
+        elif key_type == self._lib.EVP_PKEY_DSA:
+            dsa_cdata = self._lib.EVP_PKEY_get1_DSA(evp_pkey)
+            self.openssl_assert(dsa_cdata != self._ffi.NULL)
+            dsa_cdata = self._ffi.gc(dsa_cdata, self._lib.DSA_free)
+            return _DSAPrivateKey(self, dsa_cdata, evp_pkey)
+        elif (self._lib.Cryptography_HAS_EC == 1 and
+              key_type == self._lib.EVP_PKEY_EC):
+            ec_cdata = self._lib.EVP_PKEY_get1_EC_KEY(evp_pkey)
+            self.openssl_assert(ec_cdata != self._ffi.NULL)
+            ec_cdata = self._ffi.gc(ec_cdata, self._lib.EC_KEY_free)
+            return _EllipticCurvePrivateKey(self, ec_cdata, evp_pkey)
+        else:
+            raise UnsupportedAlgorithm("Unsupported key type.")
+
+    def _evp_pkey_to_public_key(self, evp_pkey):
+        """
+        Return the appropriate type of PublicKey given an evp_pkey cdata
+        pointer.
+        """
+
+        key_type = evp_pkey.type
+
+        if key_type == self._lib.EVP_PKEY_RSA:
+            rsa_cdata = self._lib.EVP_PKEY_get1_RSA(evp_pkey)
+            self.openssl_assert(rsa_cdata != self._ffi.NULL)
+            rsa_cdata = self._ffi.gc(rsa_cdata, self._lib.RSA_free)
+            return _RSAPublicKey(self, rsa_cdata, evp_pkey)
+        elif key_type == self._lib.EVP_PKEY_DSA:
+            dsa_cdata = self._lib.EVP_PKEY_get1_DSA(evp_pkey)
+            self.openssl_assert(dsa_cdata != self._ffi.NULL)
+            dsa_cdata = self._ffi.gc(dsa_cdata, self._lib.DSA_free)
+            return _DSAPublicKey(self, dsa_cdata, evp_pkey)
+        elif (self._lib.Cryptography_HAS_EC == 1 and
+              key_type == self._lib.EVP_PKEY_EC):
+            ec_cdata = self._lib.EVP_PKEY_get1_EC_KEY(evp_pkey)
+            self.openssl_assert(ec_cdata != self._ffi.NULL)
+            ec_cdata = self._ffi.gc(ec_cdata, self._lib.EC_KEY_free)
+            return _EllipticCurvePublicKey(self, ec_cdata, evp_pkey)
+        else:
+            raise UnsupportedAlgorithm("Unsupported key type.")
+
+    def _pem_password_cb(self, password):
+        """
+        Generate a pem_password_cb function pointer that copied the password to
+        OpenSSL as required and returns the number of bytes copied.
+
+        typedef int pem_password_cb(char *buf, int size,
+                                    int rwflag, void *userdata);
+
+        Useful for decrypting PKCS8 files and so on.
+
+        Returns a tuple of (cdata function pointer, callback function).
+        """
+
+        def pem_password_cb(buf, size, writing, userdata):
+            pem_password_cb.called += 1
+
+            if not password:
+                pem_password_cb.exception = TypeError(
+                    "Password was not given but private key is encrypted."
+                )
+                return 0
+            elif len(password) < size:
+                pw_buf = self._ffi.buffer(buf, size)
+                pw_buf[:len(password)] = password
+                return len(password)
+            else:
+                pem_password_cb.exception = ValueError(
+                    "Passwords longer than {0} bytes are not supported "
+                    "by this backend.".format(size - 1)
+                )
+                return 0
+
+        pem_password_cb.called = 0
+        pem_password_cb.exception = None
+
+        return (
+            self._ffi.callback("int (char *, int, int, void *)",
+                               pem_password_cb),
+            pem_password_cb
+        )
+
+    def _mgf1_hash_supported(self, algorithm):
+        if self._lib.Cryptography_HAS_MGF1_MD:
+            return self.hash_supported(algorithm)
+        else:
+            return isinstance(algorithm, hashes.SHA1)
+
+    def rsa_padding_supported(self, padding):
+        if isinstance(padding, PKCS1v15):
+            return True
+        elif isinstance(padding, PSS) and isinstance(padding._mgf, MGF1):
+            return self._mgf1_hash_supported(padding._mgf._algorithm)
+        elif isinstance(padding, OAEP) and isinstance(padding._mgf, MGF1):
+            return isinstance(padding._mgf._algorithm, hashes.SHA1)
+        else:
+            return False
+
+    def generate_dsa_parameters(self, key_size):
+        if key_size not in (1024, 2048, 3072):
+            raise ValueError("Key size must be 1024 or 2048 or 3072 bits.")
+
+        if (self._lib.OPENSSL_VERSION_NUMBER < 0x1000000f and
+                key_size > 1024):
+            raise ValueError(
+                "Key size must be 1024 because OpenSSL < 1.0.0 doesn't "
+                "support larger key sizes.")
+
+        ctx = self._lib.DSA_new()
+        self.openssl_assert(ctx != self._ffi.NULL)
+        ctx = self._ffi.gc(ctx, self._lib.DSA_free)
+
+        res = self._lib.DSA_generate_parameters_ex(
+            ctx, key_size, self._ffi.NULL, 0,
+            self._ffi.NULL, self._ffi.NULL, self._ffi.NULL
+        )
+
+        self.openssl_assert(res == 1)
+
+        return _DSAParameters(self, ctx)
+
+    def generate_dsa_private_key(self, parameters):
+        ctx = self._lib.DSA_new()
+        self.openssl_assert(ctx != self._ffi.NULL)
+        ctx = self._ffi.gc(ctx, self._lib.DSA_free)
+        ctx.p = self._lib.BN_dup(parameters._dsa_cdata.p)
+        ctx.q = self._lib.BN_dup(parameters._dsa_cdata.q)
+        ctx.g = self._lib.BN_dup(parameters._dsa_cdata.g)
+
+        self._lib.DSA_generate_key(ctx)
+        evp_pkey = self._dsa_cdata_to_evp_pkey(ctx)
+
+        return _DSAPrivateKey(self, ctx, evp_pkey)
+
+    def generate_dsa_private_key_and_parameters(self, key_size):
+        parameters = self.generate_dsa_parameters(key_size)
+        return self.generate_dsa_private_key(parameters)
+
+    def load_dsa_private_numbers(self, numbers):
+        dsa._check_dsa_private_numbers(numbers)
+        parameter_numbers = numbers.public_numbers.parameter_numbers
+
+        dsa_cdata = self._lib.DSA_new()
+        self.openssl_assert(dsa_cdata != self._ffi.NULL)
+        dsa_cdata = self._ffi.gc(dsa_cdata, self._lib.DSA_free)
+
+        dsa_cdata.p = self._int_to_bn(parameter_numbers.p)
+        dsa_cdata.q = self._int_to_bn(parameter_numbers.q)
+        dsa_cdata.g = self._int_to_bn(parameter_numbers.g)
+        dsa_cdata.pub_key = self._int_to_bn(numbers.public_numbers.y)
+        dsa_cdata.priv_key = self._int_to_bn(numbers.x)
+
+        evp_pkey = self._dsa_cdata_to_evp_pkey(dsa_cdata)
+
+        return _DSAPrivateKey(self, dsa_cdata, evp_pkey)
+
+    def load_dsa_public_numbers(self, numbers):
+        dsa._check_dsa_parameters(numbers.parameter_numbers)
+        dsa_cdata = self._lib.DSA_new()
+        self.openssl_assert(dsa_cdata != self._ffi.NULL)
+        dsa_cdata = self._ffi.gc(dsa_cdata, self._lib.DSA_free)
+
+        dsa_cdata.p = self._int_to_bn(numbers.parameter_numbers.p)
+        dsa_cdata.q = self._int_to_bn(numbers.parameter_numbers.q)
+        dsa_cdata.g = self._int_to_bn(numbers.parameter_numbers.g)
+        dsa_cdata.pub_key = self._int_to_bn(numbers.y)
+
+        evp_pkey = self._dsa_cdata_to_evp_pkey(dsa_cdata)
+
+        return _DSAPublicKey(self, dsa_cdata, evp_pkey)
+
+    def load_dsa_parameter_numbers(self, numbers):
+        dsa._check_dsa_parameters(numbers)
+        dsa_cdata = self._lib.DSA_new()
+        self.openssl_assert(dsa_cdata != self._ffi.NULL)
+        dsa_cdata = self._ffi.gc(dsa_cdata, self._lib.DSA_free)
+
+        dsa_cdata.p = self._int_to_bn(numbers.p)
+        dsa_cdata.q = self._int_to_bn(numbers.q)
+        dsa_cdata.g = self._int_to_bn(numbers.g)
+
+        return _DSAParameters(self, dsa_cdata)
+
+    def _dsa_cdata_to_evp_pkey(self, dsa_cdata):
+        evp_pkey = self._lib.EVP_PKEY_new()
+        self.openssl_assert(evp_pkey != self._ffi.NULL)
+        evp_pkey = self._ffi.gc(evp_pkey, self._lib.EVP_PKEY_free)
+        res = self._lib.EVP_PKEY_set1_DSA(evp_pkey, dsa_cdata)
+        self.openssl_assert(res == 1)
+        return evp_pkey
+
+    def dsa_hash_supported(self, algorithm):
+        if self._lib.OPENSSL_VERSION_NUMBER < 0x1000000f:
+            return isinstance(algorithm, hashes.SHA1)
+        else:
+            return self.hash_supported(algorithm)
+
+    def dsa_parameters_supported(self, p, q, g):
+        if self._lib.OPENSSL_VERSION_NUMBER < 0x1000000f:
+            return utils.bit_length(p) <= 1024 and utils.bit_length(q) <= 160
+        else:
+            return True
+
+    def cmac_algorithm_supported(self, algorithm):
+        return (
+            self._lib.Cryptography_HAS_CMAC == 1 and
+            self.cipher_supported(
+                algorithm, CBC(b"\x00" * algorithm.block_size)
+            )
+        )
+
+    def create_cmac_ctx(self, algorithm):
+        return _CMACContext(self, algorithm)
+
+    def create_x509_csr(self, builder, private_key, algorithm):
+        if not isinstance(algorithm, hashes.HashAlgorithm):
+            raise TypeError('Algorithm must be a registered hash algorithm.')
+
+        if self._lib.OPENSSL_VERSION_NUMBER <= 0x10001000:
+            if isinstance(private_key, _DSAPrivateKey):
+                raise NotImplementedError(
+                    "Certificate signing requests aren't implemented for DSA"
+                    " keys on OpenSSL versions less than 1.0.1."
+                )
+            if isinstance(private_key, _EllipticCurvePrivateKey):
+                raise NotImplementedError(
+                    "Certificate signing requests aren't implemented for EC"
+                    " keys on OpenSSL versions less than 1.0.1."
+                )
+
+        # Resolve the signature algorithm.
+        evp_md = self._lib.EVP_get_digestbyname(
+            algorithm.name.encode('ascii')
+        )
+        self.openssl_assert(evp_md != self._ffi.NULL)
+
+        # Create an empty request.
+        x509_req = self._lib.X509_REQ_new()
+        self.openssl_assert(x509_req != self._ffi.NULL)
+        x509_req = self._ffi.gc(x509_req, self._lib.X509_REQ_free)
+
+        # Set x509 version.
+        res = self._lib.X509_REQ_set_version(x509_req, x509.Version.v1.value)
+        self.openssl_assert(res == 1)
+
+        # Set subject name.
+        res = self._lib.X509_REQ_set_subject_name(
+            x509_req, _encode_name_gc(self, builder._subject_name)
+        )
+        self.openssl_assert(res == 1)
+
+        # Set subject public key.
+        public_key = private_key.public_key()
+        res = self._lib.X509_REQ_set_pubkey(
+            x509_req, public_key._evp_pkey
+        )
+        self.openssl_assert(res == 1)
+
+        # Add extensions.
+        extensions = self._lib.sk_X509_EXTENSION_new_null()
+        self.openssl_assert(extensions != self._ffi.NULL)
+        extensions = self._ffi.gc(
+            extensions,
+            self._lib.sk_X509_EXTENSION_free,
+        )
+        for extension in builder._extensions:
+            try:
+                encode = _EXTENSION_ENCODE_HANDLERS[extension.oid]
+            except KeyError:
+                raise NotImplementedError('Extension not yet supported.')
+
+            pp, r = encode(self, extension.value)
+            obj = _txt2obj_gc(self, extension.oid.dotted_string)
+            extension = self._lib.X509_EXTENSION_create_by_OBJ(
+                self._ffi.NULL,
+                obj,
+                1 if extension.critical else 0,
+                _encode_asn1_str_gc(self, pp[0], r),
+            )
+            self.openssl_assert(extension != self._ffi.NULL)
+            res = self._lib.sk_X509_EXTENSION_push(extensions, extension)
+            self.openssl_assert(res >= 1)
+        res = self._lib.X509_REQ_add_extensions(x509_req, extensions)
+        self.openssl_assert(res == 1)
+
+        # Sign the request using the requester's private key.
+        res = self._lib.X509_REQ_sign(
+            x509_req, private_key._evp_pkey, evp_md
+        )
+        if res == 0:
+            errors = self._consume_errors()
+            self.openssl_assert(errors[0][1] == self._lib.ERR_LIB_RSA)
+            self.openssl_assert(
+                errors[0][3] == self._lib.RSA_R_DIGEST_TOO_BIG_FOR_RSA_KEY
+            )
+            raise ValueError("Digest too big for RSA key")
+
+        return _CertificateSigningRequest(self, x509_req)
+
+    def create_x509_certificate(self, builder, private_key, algorithm):
+        if not isinstance(builder, x509.CertificateBuilder):
+            raise TypeError('Builder type mismatch.')
+        if not isinstance(algorithm, hashes.HashAlgorithm):
+            raise TypeError('Algorithm must be a registered hash algorithm.')
+
+        if self._lib.OPENSSL_VERSION_NUMBER <= 0x10001000:
+            if isinstance(private_key, _DSAPrivateKey):
+                raise NotImplementedError(
+                    "Certificate signatures aren't implemented for DSA"
+                    " keys on OpenSSL versions less than 1.0.1."
+                )
+            if isinstance(private_key, _EllipticCurvePrivateKey):
+                raise NotImplementedError(
+                    "Certificate signatures aren't implemented for EC"
+                    " keys on OpenSSL versions less than 1.0.1."
+                )
+
+        # Resolve the signature algorithm.
+        evp_md = self._lib.EVP_get_digestbyname(
+            algorithm.name.encode('ascii')
+        )
+        self.openssl_assert(evp_md != self._ffi.NULL)
+
+        # Create an empty certificate.
+        x509_cert = self._lib.X509_new()
+        x509_cert = self._ffi.gc(x509_cert, backend._lib.X509_free)
+
+        # Set the x509 version.
+        res = self._lib.X509_set_version(x509_cert, builder._version.value)
+        self.openssl_assert(res == 1)
+
+        # Set the subject's name.
+        res = self._lib.X509_set_subject_name(
+            x509_cert, _encode_name(self, list(builder._subject_name))
+        )
+        self.openssl_assert(res == 1)
+
+        # Set the subject's public key.
+        res = self._lib.X509_set_pubkey(
+            x509_cert, builder._public_key._evp_pkey
+        )
+        self.openssl_assert(res == 1)
+
+        # Set the certificate serial number.
+        serial_number = _encode_asn1_int_gc(self, builder._serial_number)
+        res = self._lib.X509_set_serialNumber(x509_cert, serial_number)
+        self.openssl_assert(res == 1)
+
+        # Set the "not before" time.
+        res = self._lib.ASN1_TIME_set(
+            self._lib.X509_get_notBefore(x509_cert),
+            calendar.timegm(builder._not_valid_before.timetuple())
+        )
+        self.openssl_assert(res != self._ffi.NULL)
+
+        # Set the "not after" time.
+        res = self._lib.ASN1_TIME_set(
+            self._lib.X509_get_notAfter(x509_cert),
+            calendar.timegm(builder._not_valid_after.timetuple())
+        )
+        self.openssl_assert(res != self._ffi.NULL)
+
+        # Add extensions.
+        for i, extension in enumerate(builder._extensions):
+            try:
+                encode = _EXTENSION_ENCODE_HANDLERS[extension.oid]
+            except KeyError:
+                raise NotImplementedError('Extension not yet supported.')
+
+            pp, r = encode(self, extension.value)
+            obj = _txt2obj_gc(self, extension.oid.dotted_string)
+            extension = self._lib.X509_EXTENSION_create_by_OBJ(
+                self._ffi.NULL,
+                obj,
+                1 if extension.critical else 0,
+                _encode_asn1_str_gc(self, pp[0], r)
+            )
+            self.openssl_assert(extension != self._ffi.NULL)
+            extension = self._ffi.gc(extension, self._lib.X509_EXTENSION_free)
+            res = self._lib.X509_add_ext(x509_cert, extension, i)
+            self.openssl_assert(res == 1)
+
+        # Set the issuer name.
+        res = self._lib.X509_set_issuer_name(
+            x509_cert, _encode_name(self, list(builder._issuer_name))
+        )
+        self.openssl_assert(res == 1)
+
+        # Sign the certificate with the issuer's private key.
+        res = self._lib.X509_sign(
+            x509_cert, private_key._evp_pkey, evp_md
+        )
+        if res == 0:
+            errors = self._consume_errors()
+            self.openssl_assert(errors[0][1] == self._lib.ERR_LIB_RSA)
+            self.openssl_assert(
+                errors[0][3] == self._lib.RSA_R_DIGEST_TOO_BIG_FOR_RSA_KEY
+            )
+            raise ValueError("Digest too big for RSA key")
+
+        return _Certificate(self, x509_cert)
+
+    def load_pem_private_key(self, data, password):
+        return self._load_key(
+            self._lib.PEM_read_bio_PrivateKey,
+            self._evp_pkey_to_private_key,
+            data,
+            password,
+        )
+
+    def load_pem_public_key(self, data):
+        mem_bio = self._bytes_to_bio(data)
+        evp_pkey = self._lib.PEM_read_bio_PUBKEY(
+            mem_bio.bio, self._ffi.NULL, self._ffi.NULL, self._ffi.NULL
+        )
+        if evp_pkey != self._ffi.NULL:
+            evp_pkey = self._ffi.gc(evp_pkey, self._lib.EVP_PKEY_free)
+            return self._evp_pkey_to_public_key(evp_pkey)
+        else:
+            # It's not a (RSA/DSA/ECDSA) subjectPublicKeyInfo, but we still
+            # need to check to see if it is a pure PKCS1 RSA public key (not
+            # embedded in a subjectPublicKeyInfo)
+            self._consume_errors()
+            res = self._lib.BIO_reset(mem_bio.bio)
+            self.openssl_assert(res == 1)
+            rsa_cdata = self._lib.PEM_read_bio_RSAPublicKey(
+                mem_bio.bio, self._ffi.NULL, self._ffi.NULL, self._ffi.NULL
+            )
+            if rsa_cdata != self._ffi.NULL:
+                rsa_cdata = self._ffi.gc(rsa_cdata, self._lib.RSA_free)
+                evp_pkey = self._rsa_cdata_to_evp_pkey(rsa_cdata)
+                return _RSAPublicKey(self, rsa_cdata, evp_pkey)
+            else:
+                self._handle_key_loading_error()
+
+    def load_der_private_key(self, data, password):
+        # OpenSSL has a function called d2i_AutoPrivateKey that can simplify
+        # this. Unfortunately it doesn't properly support PKCS8 on OpenSSL
+        # 0.9.8 so we can't use it. Instead we sequentially try to load it 3
+        # different ways. First we'll try to load it as a traditional key
+        bio_data = self._bytes_to_bio(data)
+        key = self._evp_pkey_from_der_traditional_key(bio_data, password)
+        if not key:
+            # Okay so it's not a traditional key. Let's try
+            # PKCS8 unencrypted. OpenSSL 0.9.8 can't load unencrypted
+            # PKCS8 keys using d2i_PKCS8PrivateKey_bio so we do this instead.
+            # Reset the memory BIO so we can read the data again.
+            res = self._lib.BIO_reset(bio_data.bio)
+            self.openssl_assert(res == 1)
+            key = self._evp_pkey_from_der_unencrypted_pkcs8(bio_data, password)
+
+        if key:
+            return self._evp_pkey_to_private_key(key)
+        else:
+            # Finally we try to load it with the method that handles encrypted
+            # PKCS8 properly.
+            return self._load_key(
+                self._lib.d2i_PKCS8PrivateKey_bio,
+                self._evp_pkey_to_private_key,
+                data,
+                password,
+            )
+
+    def _evp_pkey_from_der_traditional_key(self, bio_data, password):
+        key = self._lib.d2i_PrivateKey_bio(bio_data.bio, self._ffi.NULL)
+        if key != self._ffi.NULL:
+            key = self._ffi.gc(key, self._lib.EVP_PKEY_free)
+            if password is not None:
+                raise TypeError(
+                    "Password was given but private key is not encrypted."
+                )
+
+            return key
+        else:
+            self._consume_errors()
+            return None
+
+    def _evp_pkey_from_der_unencrypted_pkcs8(self, bio_data, password):
+        info = self._lib.d2i_PKCS8_PRIV_KEY_INFO_bio(
+            bio_data.bio, self._ffi.NULL
+        )
+        info = self._ffi.gc(info, self._lib.PKCS8_PRIV_KEY_INFO_free)
+        if info != self._ffi.NULL:
+            key = self._lib.EVP_PKCS82PKEY(info)
+            self.openssl_assert(key != self._ffi.NULL)
+            key = self._ffi.gc(key, self._lib.EVP_PKEY_free)
+            if password is not None:
+                raise TypeError(
+                    "Password was given but private key is not encrypted."
+                )
+            return key
+        else:
+            self._consume_errors()
+            return None
+
+    def load_der_public_key(self, data):
+        mem_bio = self._bytes_to_bio(data)
+        evp_pkey = self._lib.d2i_PUBKEY_bio(mem_bio.bio, self._ffi.NULL)
+        if evp_pkey != self._ffi.NULL:
+            evp_pkey = self._ffi.gc(evp_pkey, self._lib.EVP_PKEY_free)
+            return self._evp_pkey_to_public_key(evp_pkey)
+        else:
+            # It's not a (RSA/DSA/ECDSA) subjectPublicKeyInfo, but we still
+            # need to check to see if it is a pure PKCS1 RSA public key (not
+            # embedded in a subjectPublicKeyInfo)
+            self._consume_errors()
+            res = self._lib.BIO_reset(mem_bio.bio)
+            self.openssl_assert(res == 1)
+            rsa_cdata = self._lib.d2i_RSAPublicKey_bio(
+                mem_bio.bio, self._ffi.NULL
+            )
+            if rsa_cdata != self._ffi.NULL:
+                rsa_cdata = self._ffi.gc(rsa_cdata, self._lib.RSA_free)
+                evp_pkey = self._rsa_cdata_to_evp_pkey(rsa_cdata)
+                return _RSAPublicKey(self, rsa_cdata, evp_pkey)
+            else:
+                self._handle_key_loading_error()
+
+    def load_pem_x509_certificate(self, data):
+        mem_bio = self._bytes_to_bio(data)
+        x509 = self._lib.PEM_read_bio_X509(
+            mem_bio.bio, self._ffi.NULL, self._ffi.NULL, self._ffi.NULL
+        )
+        if x509 == self._ffi.NULL:
+            self._consume_errors()
+            raise ValueError("Unable to load certificate")
+
+        x509 = self._ffi.gc(x509, self._lib.X509_free)
+        return _Certificate(self, x509)
+
+    def load_der_x509_certificate(self, data):
+        mem_bio = self._bytes_to_bio(data)
+        x509 = self._lib.d2i_X509_bio(mem_bio.bio, self._ffi.NULL)
+        if x509 == self._ffi.NULL:
+            self._consume_errors()
+            raise ValueError("Unable to load certificate")
+
+        x509 = self._ffi.gc(x509, self._lib.X509_free)
+        return _Certificate(self, x509)
+
+    def load_pem_x509_crl(self, data):
+        mem_bio = self._bytes_to_bio(data)
+        x509_crl = self._lib.PEM_read_bio_X509_CRL(
+            mem_bio.bio, self._ffi.NULL, self._ffi.NULL, self._ffi.NULL
+        )
+        if x509_crl == self._ffi.NULL:
+            self._consume_errors()
+            raise ValueError("Unable to load CRL")
+
+        x509_crl = self._ffi.gc(x509_crl, self._lib.X509_CRL_free)
+        return _CertificateRevocationList(self, x509_crl)
+
+    def load_der_x509_crl(self, data):
+        mem_bio = self._bytes_to_bio(data)
+        x509_crl = self._lib.d2i_X509_CRL_bio(mem_bio.bio, self._ffi.NULL)
+        if x509_crl == self._ffi.NULL:
+            self._consume_errors()
+            raise ValueError("Unable to load CRL")
+
+        x509_crl = self._ffi.gc(x509_crl, self._lib.X509_CRL_free)
+        return _CertificateRevocationList(self, x509_crl)
+
+    def load_pem_x509_csr(self, data):
+        mem_bio = self._bytes_to_bio(data)
+        x509_req = self._lib.PEM_read_bio_X509_REQ(
+            mem_bio.bio, self._ffi.NULL, self._ffi.NULL, self._ffi.NULL
+        )
+        if x509_req == self._ffi.NULL:
+            self._consume_errors()
+            raise ValueError("Unable to load request")
+
+        x509_req = self._ffi.gc(x509_req, self._lib.X509_REQ_free)
+        return _CertificateSigningRequest(self, x509_req)
+
+    def load_der_x509_csr(self, data):
+        mem_bio = self._bytes_to_bio(data)
+        x509_req = self._lib.d2i_X509_REQ_bio(mem_bio.bio, self._ffi.NULL)
+        if x509_req == self._ffi.NULL:
+            self._consume_errors()
+            raise ValueError("Unable to load request")
+
+        x509_req = self._ffi.gc(x509_req, self._lib.X509_REQ_free)
+        return _CertificateSigningRequest(self, x509_req)
+
+    def _load_key(self, openssl_read_func, convert_func, data, password):
+        mem_bio = self._bytes_to_bio(data)
+
+        password_callback, password_func = self._pem_password_cb(password)
+
+        evp_pkey = openssl_read_func(
+            mem_bio.bio,
+            self._ffi.NULL,
+            password_callback,
+            self._ffi.NULL
+        )
+
+        if evp_pkey == self._ffi.NULL:
+            if password_func.exception is not None:
+                errors = self._consume_errors()
+                self.openssl_assert(errors)
+                raise password_func.exception
+            else:
+                self._handle_key_loading_error()
+
+        evp_pkey = self._ffi.gc(evp_pkey, self._lib.EVP_PKEY_free)
+
+        if password is not None and password_func.called == 0:
+            raise TypeError(
+                "Password was given but private key is not encrypted.")
+
+        assert (
+            (password is not None and password_func.called == 1) or
+            password is None
+        )
+
+        return convert_func(evp_pkey)
+
+    def _handle_key_loading_error(self):
+        errors = self._consume_errors()
+
+        if not errors:
+            raise ValueError("Could not unserialize key data.")
+
+        elif errors[0][1:] in (
+            (
+                self._lib.ERR_LIB_EVP,
+                self._lib.EVP_F_EVP_DECRYPTFINAL_EX,
+                self._lib.EVP_R_BAD_DECRYPT
+            ),
+            (
+                self._lib.ERR_LIB_PKCS12,
+                self._lib.PKCS12_F_PKCS12_PBE_CRYPT,
+                self._lib.PKCS12_R_PKCS12_CIPHERFINAL_ERROR,
+            )
+        ):
+            raise ValueError("Bad decrypt. Incorrect password?")
+
+        elif errors[0][1:] in (
+            (
+                self._lib.ERR_LIB_PEM,
+                self._lib.PEM_F_PEM_GET_EVP_CIPHER_INFO,
+                self._lib.PEM_R_UNSUPPORTED_ENCRYPTION
+            ),
+
+            (
+                self._lib.ERR_LIB_EVP,
+                self._lib.EVP_F_EVP_PBE_CIPHERINIT,
+                self._lib.EVP_R_UNKNOWN_PBE_ALGORITHM
+            )
+        ):
+            raise UnsupportedAlgorithm(
+                "PEM data is encrypted with an unsupported cipher",
+                _Reasons.UNSUPPORTED_CIPHER
+            )
+
+        elif any(
+            error[1:] == (
+                self._lib.ERR_LIB_EVP,
+                self._lib.EVP_F_EVP_PKCS82PKEY,
+                self._lib.EVP_R_UNSUPPORTED_PRIVATE_KEY_ALGORITHM
+            )
+            for error in errors
+        ):
+            raise UnsupportedAlgorithm(
+                "Unsupported public key algorithm.",
+                _Reasons.UNSUPPORTED_PUBLIC_KEY_ALGORITHM
+            )
+
+        else:
+            assert errors[0][1] in (
+                self._lib.ERR_LIB_EVP,
+                self._lib.ERR_LIB_PEM,
+                self._lib.ERR_LIB_ASN1,
+            )
+            raise ValueError("Could not unserialize key data.")
+
+    def elliptic_curve_supported(self, curve):
+        if self._lib.Cryptography_HAS_EC != 1:
+            return False
+
+        try:
+            curve_nid = self._elliptic_curve_to_nid(curve)
+        except UnsupportedAlgorithm:
+            curve_nid = self._lib.NID_undef
+
+        ctx = self._lib.EC_GROUP_new_by_curve_name(curve_nid)
+
+        if ctx == self._ffi.NULL:
+            errors = self._consume_errors()
+            self.openssl_assert(
+                curve_nid == self._lib.NID_undef or
+                errors[0][1:] == (
+                    self._lib.ERR_LIB_EC,
+                    self._lib.EC_F_EC_GROUP_NEW_BY_CURVE_NAME,
+                    self._lib.EC_R_UNKNOWN_GROUP
+                )
+            )
+            return False
+        else:
+            self.openssl_assert(curve_nid != self._lib.NID_undef)
+            self._lib.EC_GROUP_free(ctx)
+            return True
+
+    def elliptic_curve_signature_algorithm_supported(
+        self, signature_algorithm, curve
+    ):
+        if self._lib.Cryptography_HAS_EC != 1:
+            return False
+
+        # We only support ECDSA right now.
+        if not isinstance(signature_algorithm, ec.ECDSA):
+            return False
+
+        # Before 0.9.8m OpenSSL can't cope with digests longer than the curve.
+        if (
+            self._lib.OPENSSL_VERSION_NUMBER < 0x009080df and
+            curve.key_size < signature_algorithm.algorithm.digest_size * 8
+        ):
+            return False
+
+        return self.elliptic_curve_supported(curve)
+
+    def generate_elliptic_curve_private_key(self, curve):
+        """
+        Generate a new private key on the named curve.
+        """
+
+        if self.elliptic_curve_supported(curve):
+            curve_nid = self._elliptic_curve_to_nid(curve)
+
+            ec_cdata = self._lib.EC_KEY_new_by_curve_name(curve_nid)
+            self.openssl_assert(ec_cdata != self._ffi.NULL)
+            ec_cdata = self._ffi.gc(ec_cdata, self._lib.EC_KEY_free)
+
+            res = self._lib.EC_KEY_generate_key(ec_cdata)
+            self.openssl_assert(res == 1)
+
+            res = self._lib.EC_KEY_check_key(ec_cdata)
+            self.openssl_assert(res == 1)
+
+            evp_pkey = self._ec_cdata_to_evp_pkey(ec_cdata)
+
+            return _EllipticCurvePrivateKey(self, ec_cdata, evp_pkey)
+        else:
+            raise UnsupportedAlgorithm(
+                "Backend object does not support {0}.".format(curve.name),
+                _Reasons.UNSUPPORTED_ELLIPTIC_CURVE
+            )
+
+    def load_elliptic_curve_private_numbers(self, numbers):
+        public = numbers.public_numbers
+
+        curve_nid = self._elliptic_curve_to_nid(public.curve)
+
+        ec_cdata = self._lib.EC_KEY_new_by_curve_name(curve_nid)
+        self.openssl_assert(ec_cdata != self._ffi.NULL)
+        ec_cdata = self._ffi.gc(ec_cdata, self._lib.EC_KEY_free)
+
+        ec_cdata = self._ec_key_set_public_key_affine_coordinates(
+            ec_cdata, public.x, public.y)
+
+        res = self._lib.EC_KEY_set_private_key(
+            ec_cdata, self._int_to_bn(numbers.private_value))
+        self.openssl_assert(res == 1)
+        evp_pkey = self._ec_cdata_to_evp_pkey(ec_cdata)
+
+        return _EllipticCurvePrivateKey(self, ec_cdata, evp_pkey)
+
+    def load_elliptic_curve_public_numbers(self, numbers):
+        curve_nid = self._elliptic_curve_to_nid(numbers.curve)
+
+        ec_cdata = self._lib.EC_KEY_new_by_curve_name(curve_nid)
+        self.openssl_assert(ec_cdata != self._ffi.NULL)
+        ec_cdata = self._ffi.gc(ec_cdata, self._lib.EC_KEY_free)
+
+        ec_cdata = self._ec_key_set_public_key_affine_coordinates(
+            ec_cdata, numbers.x, numbers.y)
+        evp_pkey = self._ec_cdata_to_evp_pkey(ec_cdata)
+
+        return _EllipticCurvePublicKey(self, ec_cdata, evp_pkey)
+
+    def elliptic_curve_exchange_algorithm_supported(self, algorithm, curve):
+        return (
+            self.elliptic_curve_supported(curve) and
+            self._lib.Cryptography_HAS_ECDH == 1 and
+            isinstance(algorithm, ec.ECDH)
+        )
+
+    def _ec_cdata_to_evp_pkey(self, ec_cdata):
+        evp_pkey = self._lib.EVP_PKEY_new()
+        self.openssl_assert(evp_pkey != self._ffi.NULL)
+        evp_pkey = self._ffi.gc(evp_pkey, self._lib.EVP_PKEY_free)
+        res = self._lib.EVP_PKEY_set1_EC_KEY(evp_pkey, ec_cdata)
+        self.openssl_assert(res == 1)
+        return evp_pkey
+
+    def _elliptic_curve_to_nid(self, curve):
+        """
+        Get the NID for a curve name.
+        """
+
+        curve_aliases = {
+            "secp192r1": "prime192v1",
+            "secp256r1": "prime256v1"
+        }
+
+        curve_name = curve_aliases.get(curve.name, curve.name)
+
+        curve_nid = self._lib.OBJ_sn2nid(curve_name.encode())
+        if curve_nid == self._lib.NID_undef:
+            raise UnsupportedAlgorithm(
+                "{0} is not a supported elliptic curve".format(curve.name),
+                _Reasons.UNSUPPORTED_ELLIPTIC_CURVE
+            )
+        return curve_nid
+
+    @contextmanager
+    def _tmp_bn_ctx(self):
+        bn_ctx = self._lib.BN_CTX_new()
+        self.openssl_assert(bn_ctx != self._ffi.NULL)
+        bn_ctx = self._ffi.gc(bn_ctx, self._lib.BN_CTX_free)
+        self._lib.BN_CTX_start(bn_ctx)
+        try:
+            yield bn_ctx
+        finally:
+            self._lib.BN_CTX_end(bn_ctx)
+
+    def _ec_key_determine_group_get_set_funcs(self, ctx):
+        """
+        Given an EC_KEY determine the group and what methods are required to
+        get/set point coordinates.
+        """
+        self.openssl_assert(ctx != self._ffi.NULL)
+
+        nid_two_field = self._lib.OBJ_sn2nid(b"characteristic-two-field")
+        self.openssl_assert(nid_two_field != self._lib.NID_undef)
+
+        group = self._lib.EC_KEY_get0_group(ctx)
+        self.openssl_assert(group != self._ffi.NULL)
+
+        method = self._lib.EC_GROUP_method_of(group)
+        self.openssl_assert(method != self._ffi.NULL)
+
+        nid = self._lib.EC_METHOD_get_field_type(method)
+        self.openssl_assert(nid != self._lib.NID_undef)
+
+        if nid == nid_two_field and self._lib.Cryptography_HAS_EC2M:
+            set_func = self._lib.EC_POINT_set_affine_coordinates_GF2m
+            get_func = self._lib.EC_POINT_get_affine_coordinates_GF2m
+        else:
+            set_func = self._lib.EC_POINT_set_affine_coordinates_GFp
+            get_func = self._lib.EC_POINT_get_affine_coordinates_GFp
+
+        assert set_func and get_func
+
+        return set_func, get_func, group
+
+    def _ec_key_set_public_key_affine_coordinates(self, ctx, x, y):
+        """
+        This is a port of EC_KEY_set_public_key_affine_coordinates that was
+        added in 1.0.1.
+
+        Sets the public key point in the EC_KEY context to the affine x and y
+        values.
+        """
+
+        if x < 0 or y < 0:
+            raise ValueError(
+                "Invalid EC key. Both x and y must be non-negative."
+            )
+
+        set_func, get_func, group = (
+            self._ec_key_determine_group_get_set_funcs(ctx)
+        )
+
+        point = self._lib.EC_POINT_new(group)
+        self.openssl_assert(point != self._ffi.NULL)
+        point = self._ffi.gc(point, self._lib.EC_POINT_free)
+
+        bn_x = self._int_to_bn(x)
+        bn_y = self._int_to_bn(y)
+
+        with self._tmp_bn_ctx() as bn_ctx:
+            check_x = self._lib.BN_CTX_get(bn_ctx)
+            check_y = self._lib.BN_CTX_get(bn_ctx)
+
+            res = set_func(group, point, bn_x, bn_y, bn_ctx)
+            self.openssl_assert(res == 1)
+
+            res = get_func(group, point, check_x, check_y, bn_ctx)
+            self.openssl_assert(res == 1)
+
+            res = self._lib.BN_cmp(bn_x, check_x)
+            if res != 0:
+                self._consume_errors()
+                raise ValueError("Invalid EC Key X point.")
+            res = self._lib.BN_cmp(bn_y, check_y)
+            if res != 0:
+                self._consume_errors()
+                raise ValueError("Invalid EC Key Y point.")
+
+        res = self._lib.EC_KEY_set_public_key(ctx, point)
+        self.openssl_assert(res == 1)
+
+        res = self._lib.EC_KEY_check_key(ctx)
+        if res != 1:
+            self._consume_errors()
+            raise ValueError("Invalid EC key.")
+
+        return ctx
+
+    def _private_key_bytes(self, encoding, format, encryption_algorithm,
+                           evp_pkey, cdata):
+        if not isinstance(format, serialization.PrivateFormat):
+            raise TypeError(
+                "format must be an item from the PrivateFormat enum"
+            )
+
+        if not isinstance(encryption_algorithm,
+                          serialization.KeySerializationEncryption):
+            raise TypeError(
+                "Encryption algorithm must be a KeySerializationEncryption "
+                "instance"
+            )
+
+        if isinstance(encryption_algorithm, serialization.NoEncryption):
+            password = b""
+            passlen = 0
+            evp_cipher = self._ffi.NULL
+        elif isinstance(encryption_algorithm,
+                        serialization.BestAvailableEncryption):
+            # This is a curated value that we will update over time.
+            evp_cipher = self._lib.EVP_get_cipherbyname(
+                b"aes-256-cbc"
+            )
+            password = encryption_algorithm.password
+            passlen = len(password)
+            if passlen > 1023:
+                raise ValueError(
+                    "Passwords longer than 1023 bytes are not supported by "
+                    "this backend"
+                )
+        else:
+            raise ValueError("Unsupported encryption type")
+
+        if encoding is serialization.Encoding.PEM:
+            if format is serialization.PrivateFormat.PKCS8:
+                write_bio = self._lib.PEM_write_bio_PKCS8PrivateKey
+                key = evp_pkey
+            else:
+                assert format is serialization.PrivateFormat.TraditionalOpenSSL
+                if evp_pkey.type == self._lib.EVP_PKEY_RSA:
+                    write_bio = self._lib.PEM_write_bio_RSAPrivateKey
+                elif evp_pkey.type == self._lib.EVP_PKEY_DSA:
+                    write_bio = self._lib.PEM_write_bio_DSAPrivateKey
+                else:
+                    assert self._lib.Cryptography_HAS_EC == 1
+                    assert evp_pkey.type == self._lib.EVP_PKEY_EC
+                    write_bio = self._lib.PEM_write_bio_ECPrivateKey
+
+                key = cdata
+        elif encoding is serialization.Encoding.DER:
+            if format is serialization.PrivateFormat.TraditionalOpenSSL:
+                if not isinstance(
+                    encryption_algorithm, serialization.NoEncryption
+                ):
+                    raise ValueError(
+                        "Encryption is not supported for DER encoded "
+                        "traditional OpenSSL keys"
+                    )
+
+                return self._private_key_bytes_traditional_der(
+                    evp_pkey.type, cdata
+                )
+            else:
+                assert format is serialization.PrivateFormat.PKCS8
+                write_bio = self._lib.i2d_PKCS8PrivateKey_bio
+                key = evp_pkey
+        else:
+            raise TypeError("encoding must be an item from the Encoding enum")
+
+        bio = self._create_mem_bio()
+        res = write_bio(
+            bio,
+            key,
+            evp_cipher,
+            password,
+            passlen,
+            self._ffi.NULL,
+            self._ffi.NULL
+        )
+        self.openssl_assert(res == 1)
+        return self._read_mem_bio(bio)
+
+    def _private_key_bytes_traditional_der(self, key_type, cdata):
+        if key_type == self._lib.EVP_PKEY_RSA:
+            write_bio = self._lib.i2d_RSAPrivateKey_bio
+        elif (self._lib.Cryptography_HAS_EC == 1 and
+              key_type == self._lib.EVP_PKEY_EC):
+            write_bio = self._lib.i2d_ECPrivateKey_bio
+        else:
+            self.openssl_assert(key_type == self._lib.EVP_PKEY_DSA)
+            write_bio = self._lib.i2d_DSAPrivateKey_bio
+
+        bio = self._create_mem_bio()
+        res = write_bio(bio, cdata)
+        self.openssl_assert(res == 1)
+        return self._read_mem_bio(bio)
+
+    def _public_key_bytes(self, encoding, format, evp_pkey, cdata):
+        if not isinstance(encoding, serialization.Encoding):
+            raise TypeError("encoding must be an item from the Encoding enum")
+
+        if format is serialization.PublicFormat.SubjectPublicKeyInfo:
+            if encoding is serialization.Encoding.PEM:
+                write_bio = self._lib.PEM_write_bio_PUBKEY
+            else:
+                assert encoding is serialization.Encoding.DER
+                write_bio = self._lib.i2d_PUBKEY_bio
+
+            key = evp_pkey
+        elif format is serialization.PublicFormat.PKCS1:
+            # Only RSA is supported here.
+            assert evp_pkey.type == self._lib.EVP_PKEY_RSA
+            if encoding is serialization.Encoding.PEM:
+                write_bio = self._lib.PEM_write_bio_RSAPublicKey
+            else:
+                assert encoding is serialization.Encoding.DER
+                write_bio = self._lib.i2d_RSAPublicKey_bio
+
+            key = cdata
+        else:
+            raise TypeError(
+                "format must be an item from the PublicFormat enum"
+            )
+
+        bio = self._create_mem_bio()
+        res = write_bio(bio, key)
+        self.openssl_assert(res == 1)
+        return self._read_mem_bio(bio)
+
+    def _asn1_integer_to_int(self, asn1_int):
+        bn = self._lib.ASN1_INTEGER_to_BN(asn1_int, self._ffi.NULL)
+        self.openssl_assert(bn != self._ffi.NULL)
+        bn = self._ffi.gc(bn, self._lib.BN_free)
+        return self._bn_to_int(bn)
+
+    def _asn1_string_to_bytes(self, asn1_string):
+        return self._ffi.buffer(asn1_string.data, asn1_string.length)[:]
+
+    def _asn1_string_to_ascii(self, asn1_string):
+        return self._asn1_string_to_bytes(asn1_string).decode("ascii")
+
+    def _asn1_string_to_utf8(self, asn1_string):
+        buf = self._ffi.new("unsigned char **")
+        res = self._lib.ASN1_STRING_to_UTF8(buf, asn1_string)
+        self.openssl_assert(res >= 0)
+        self.openssl_assert(buf[0] != self._ffi.NULL)
+        buf = self._ffi.gc(
+            buf, lambda buffer: self._lib.OPENSSL_free(buffer[0])
+        )
+        return self._ffi.buffer(buf[0], res)[:].decode('utf8')
+
+    def _asn1_to_der(self, asn1_type):
+        buf = self._ffi.new("unsigned char **")
+        res = self._lib.i2d_ASN1_TYPE(asn1_type, buf)
+        self.openssl_assert(res >= 0)
+        self.openssl_assert(buf[0] != self._ffi.NULL)
+        buf = self._ffi.gc(
+            buf, lambda buffer: self._lib.OPENSSL_free(buffer[0])
+        )
+        return self._ffi.buffer(buf[0], res)[:]
+
+    def _parse_asn1_time(self, asn1_time):
+        self.openssl_assert(asn1_time != self._ffi.NULL)
+        generalized_time = self._lib.ASN1_TIME_to_generalizedtime(
+            asn1_time, self._ffi.NULL
+        )
+        self.openssl_assert(generalized_time != self._ffi.NULL)
+        generalized_time = self._ffi.gc(
+            generalized_time, self._lib.ASN1_GENERALIZEDTIME_free
+        )
+        time = self._asn1_string_to_ascii(
+            self._ffi.cast("ASN1_STRING *", generalized_time)
+        )
+        return datetime.datetime.strptime(time, "%Y%m%d%H%M%SZ")
+
+
+class GetCipherByName(object):
+    def __init__(self, fmt):
+        self._fmt = fmt
+
+    def __call__(self, backend, cipher, mode):
+        cipher_name = self._fmt.format(cipher=cipher, mode=mode).lower()
+        return backend._lib.EVP_get_cipherbyname(cipher_name.encode("ascii"))
+
+
+backend = Backend()
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/openssl/ciphers.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/openssl/ciphers.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/openssl/ciphers.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/openssl/ciphers.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,213 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+from cryptography import utils
+from cryptography.exceptions import InvalidTag, UnsupportedAlgorithm, _Reasons
+from cryptography.hazmat.primitives import ciphers
+from cryptography.hazmat.primitives.ciphers import modes
+
+
+@utils.register_interface(ciphers.CipherContext)
+@utils.register_interface(ciphers.AEADCipherContext)
+@utils.register_interface(ciphers.AEADEncryptionContext)
+class _CipherContext(object):
+    _ENCRYPT = 1
+    _DECRYPT = 0
+
+    def __init__(self, backend, cipher, mode, operation):
+        self._backend = backend
+        self._cipher = cipher
+        self._mode = mode
+        self._operation = operation
+        self._tag = None
+
+        if isinstance(self._cipher, ciphers.BlockCipherAlgorithm):
+            self._block_size = self._cipher.block_size
+        else:
+            self._block_size = 1
+
+        ctx = self._backend._lib.EVP_CIPHER_CTX_new()
+        ctx = self._backend._ffi.gc(
+            ctx, self._backend._lib.EVP_CIPHER_CTX_free
+        )
+
+        registry = self._backend._cipher_registry
+        try:
+            adapter = registry[type(cipher), type(mode)]
+        except KeyError:
+            raise UnsupportedAlgorithm(
+                "cipher {0} in {1} mode is not supported "
+                "by this backend.".format(
+                    cipher.name, mode.name if mode else mode),
+                _Reasons.UNSUPPORTED_CIPHER
+            )
+
+        evp_cipher = adapter(self._backend, cipher, mode)
+        if evp_cipher == self._backend._ffi.NULL:
+            raise UnsupportedAlgorithm(
+                "cipher {0} in {1} mode is not supported "
+                "by this backend.".format(
+                    cipher.name, mode.name if mode else mode),
+                _Reasons.UNSUPPORTED_CIPHER
+            )
+
+        if isinstance(mode, modes.ModeWithInitializationVector):
+            iv_nonce = mode.initialization_vector
+        elif isinstance(mode, modes.ModeWithNonce):
+            iv_nonce = mode.nonce
+        else:
+            iv_nonce = self._backend._ffi.NULL
+        # begin init with cipher and operation type
+        res = self._backend._lib.EVP_CipherInit_ex(ctx, evp_cipher,
+                                                   self._backend._ffi.NULL,
+                                                   self._backend._ffi.NULL,
+                                                   self._backend._ffi.NULL,
+                                                   operation)
+        self._backend.openssl_assert(res != 0)
+        # set the key length to handle variable key ciphers
+        res = self._backend._lib.EVP_CIPHER_CTX_set_key_length(
+            ctx, len(cipher.key)
+        )
+        self._backend.openssl_assert(res != 0)
+        if isinstance(mode, modes.GCM):
+            res = self._backend._lib.EVP_CIPHER_CTX_ctrl(
+                ctx, self._backend._lib.EVP_CTRL_GCM_SET_IVLEN,
+                len(iv_nonce), self._backend._ffi.NULL
+            )
+            self._backend.openssl_assert(res != 0)
+            if operation == self._DECRYPT:
+                res = self._backend._lib.EVP_CIPHER_CTX_ctrl(
+                    ctx, self._backend._lib.EVP_CTRL_GCM_SET_TAG,
+                    len(mode.tag), mode.tag
+                )
+                self._backend.openssl_assert(res != 0)
+
+        # pass key/iv
+        res = self._backend._lib.EVP_CipherInit_ex(
+            ctx,
+            self._backend._ffi.NULL,
+            self._backend._ffi.NULL,
+            cipher.key,
+            iv_nonce,
+            operation
+        )
+        self._backend.openssl_assert(res != 0)
+        # We purposely disable padding here as it's handled higher up in the
+        # API.
+        self._backend._lib.EVP_CIPHER_CTX_set_padding(ctx, 0)
+        self._ctx = ctx
+
+    def update(self, data):
+        # OpenSSL 0.9.8e has an assertion in its EVP code that causes it
+        # to SIGABRT if you call update with an empty byte string. This can be
+        # removed when we drop support for 0.9.8e (CentOS/RHEL 5). This branch
+        # should be taken only when length is zero and mode is not GCM because
+        # AES GCM can return improper tag values if you don't call update
+        # with empty plaintext when authenticating AAD for ...reasons.
+        if len(data) == 0 and not isinstance(self._mode, modes.GCM):
+            return b""
+
+        buf = self._backend._ffi.new("unsigned char[]",
+                                     len(data) + self._block_size - 1)
+        outlen = self._backend._ffi.new("int *")
+        res = self._backend._lib.EVP_CipherUpdate(self._ctx, buf, outlen, data,
+                                                  len(data))
+        self._backend.openssl_assert(res != 0)
+        return self._backend._ffi.buffer(buf)[:outlen[0]]
+
+    def finalize(self):
+        # OpenSSL 1.0.1 on Ubuntu 12.04 (and possibly other distributions)
+        # appears to have a bug where you must make at least one call to update
+        # even if you are only using authenticate_additional_data or the
+        # GCM tag will be wrong. An (empty) call to update resolves this
+        # and is harmless for all other versions of OpenSSL.
+        if isinstance(self._mode, modes.GCM):
+            self.update(b"")
+
+        buf = self._backend._ffi.new("unsigned char[]", self._block_size)
+        outlen = self._backend._ffi.new("int *")
+        res = self._backend._lib.EVP_CipherFinal_ex(self._ctx, buf, outlen)
+        if res == 0:
+            errors = self._backend._consume_errors()
+
+            if not errors and isinstance(self._mode, modes.GCM):
+                raise InvalidTag
+
+            self._backend.openssl_assert(
+                errors[0][1:] == (
+                    self._backend._lib.ERR_LIB_EVP,
+                    self._backend._lib.EVP_F_EVP_ENCRYPTFINAL_EX,
+                    self._backend._lib.EVP_R_DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH
+                ) or errors[0][1:] == (
+                    self._backend._lib.ERR_LIB_EVP,
+                    self._backend._lib.EVP_F_EVP_DECRYPTFINAL_EX,
+                    self._backend._lib.EVP_R_DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH
+                )
+            )
+            raise ValueError(
+                "The length of the provided data is not a multiple of "
+                "the block length."
+            )
+
+        if (isinstance(self._mode, modes.GCM) and
+           self._operation == self._ENCRYPT):
+            block_byte_size = self._block_size // 8
+            tag_buf = self._backend._ffi.new(
+                "unsigned char[]", block_byte_size
+            )
+            res = self._backend._lib.EVP_CIPHER_CTX_ctrl(
+                self._ctx, self._backend._lib.EVP_CTRL_GCM_GET_TAG,
+                block_byte_size, tag_buf
+            )
+            self._backend.openssl_assert(res != 0)
+            self._tag = self._backend._ffi.buffer(tag_buf)[:]
+
+        res = self._backend._lib.EVP_CIPHER_CTX_cleanup(self._ctx)
+        self._backend.openssl_assert(res == 1)
+        return self._backend._ffi.buffer(buf)[:outlen[0]]
+
+    def authenticate_additional_data(self, data):
+        outlen = self._backend._ffi.new("int *")
+        res = self._backend._lib.EVP_CipherUpdate(
+            self._ctx, self._backend._ffi.NULL, outlen, data, len(data)
+        )
+        self._backend.openssl_assert(res != 0)
+
+    tag = utils.read_only_property("_tag")
+
+
+@utils.register_interface(ciphers.CipherContext)
+class _AESCTRCipherContext(object):
+    """
+    This is needed to provide support for AES CTR mode in OpenSSL 0.9.8. It can
+    be removed when we drop 0.9.8 support (RHEL5 extended life ends 2020).
+    """
+    def __init__(self, backend, cipher, mode):
+        self._backend = backend
+
+        self._key = self._backend._ffi.new("AES_KEY *")
+        res = self._backend._lib.AES_set_encrypt_key(
+            cipher.key, len(cipher.key) * 8, self._key
+        )
+        self._backend.openssl_assert(res == 0)
+        self._ecount = self._backend._ffi.new("char[]", 16)
+        self._nonce = self._backend._ffi.new("char[16]", mode.nonce)
+        self._num = self._backend._ffi.new("unsigned int *", 0)
+
+    def update(self, data):
+        buf = self._backend._ffi.new("unsigned char[]", len(data))
+        self._backend._lib.AES_ctr128_encrypt(
+            data, buf, len(data), self._key, self._nonce,
+            self._ecount, self._num
+        )
+        return self._backend._ffi.buffer(buf)[:]
+
+    def finalize(self):
+        self._key = None
+        self._ecount = None
+        self._nonce = None
+        self._num = None
+        return b""
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/openssl/cmac.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/openssl/cmac.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/openssl/cmac.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/openssl/cmac.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,80 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+
+from cryptography import utils
+from cryptography.exceptions import (
+    InvalidSignature, UnsupportedAlgorithm, _Reasons
+)
+from cryptography.hazmat.primitives import constant_time, interfaces
+from cryptography.hazmat.primitives.ciphers.modes import CBC
+
+
+@utils.register_interface(interfaces.MACContext)
+class _CMACContext(object):
+    def __init__(self, backend, algorithm, ctx=None):
+        if not backend.cmac_algorithm_supported(algorithm):
+            raise UnsupportedAlgorithm("This backend does not support CMAC.",
+                                       _Reasons.UNSUPPORTED_CIPHER)
+
+        self._backend = backend
+        self._key = algorithm.key
+        self._algorithm = algorithm
+        self._output_length = algorithm.block_size // 8
+
+        if ctx is None:
+            registry = self._backend._cipher_registry
+            adapter = registry[type(algorithm), CBC]
+
+            evp_cipher = adapter(self._backend, algorithm, CBC)
+
+            ctx = self._backend._lib.CMAC_CTX_new()
+
+            self._backend.openssl_assert(ctx != self._backend._ffi.NULL)
+            ctx = self._backend._ffi.gc(ctx, self._backend._lib.CMAC_CTX_free)
+
+            self._backend._lib.CMAC_Init(
+                ctx, self._key, len(self._key),
+                evp_cipher, self._backend._ffi.NULL
+            )
+
+        self._ctx = ctx
+
+    algorithm = utils.read_only_property("_algorithm")
+
+    def update(self, data):
+        res = self._backend._lib.CMAC_Update(self._ctx, data, len(data))
+        self._backend.openssl_assert(res == 1)
+
+    def finalize(self):
+        buf = self._backend._ffi.new("unsigned char[]", self._output_length)
+        length = self._backend._ffi.new("size_t *", self._output_length)
+        res = self._backend._lib.CMAC_Final(
+            self._ctx, buf, length
+        )
+        self._backend.openssl_assert(res == 1)
+
+        self._ctx = None
+
+        return self._backend._ffi.buffer(buf)[:]
+
+    def copy(self):
+        copied_ctx = self._backend._lib.CMAC_CTX_new()
+        copied_ctx = self._backend._ffi.gc(
+            copied_ctx, self._backend._lib.CMAC_CTX_free
+        )
+        res = self._backend._lib.CMAC_CTX_copy(
+            copied_ctx, self._ctx
+        )
+        self._backend.openssl_assert(res == 1)
+        return _CMACContext(
+            self._backend, self._algorithm, ctx=copied_ctx
+        )
+
+    def verify(self, signature):
+        digest = self.finalize()
+        if not constant_time.bytes_eq(digest, signature):
+            raise InvalidSignature("Signature did not match digest.")
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/openssl/dsa.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/openssl/dsa.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/openssl/dsa.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/openssl/dsa.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,218 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+from cryptography import utils
+from cryptography.exceptions import InvalidSignature
+from cryptography.hazmat.backends.openssl.utils import _truncate_digest
+from cryptography.hazmat.primitives import hashes, serialization
+from cryptography.hazmat.primitives.asymmetric import (
+    AsymmetricSignatureContext, AsymmetricVerificationContext, dsa
+)
+
+
+def _truncate_digest_for_dsa(dsa_cdata, digest, backend):
+    """
+    This function truncates digests that are longer than a given DS
+    key's length so they can be signed. OpenSSL does this for us in
+    1.0.0c+ and it isn't needed in 0.9.8, but that leaves us with three
+    releases (1.0.0, 1.0.0a, and 1.0.0b) where this is a problem. This
+    truncation is not required in 0.9.8 because DSA is limited to SHA-1.
+    """
+
+    order_bits = backend._lib.BN_num_bits(dsa_cdata.q)
+    return _truncate_digest(digest, order_bits)
+
+
+@utils.register_interface(AsymmetricVerificationContext)
+class _DSAVerificationContext(object):
+    def __init__(self, backend, public_key, signature, algorithm):
+        self._backend = backend
+        self._public_key = public_key
+        self._signature = signature
+        self._algorithm = algorithm
+
+        self._hash_ctx = hashes.Hash(self._algorithm, self._backend)
+
+    def update(self, data):
+        self._hash_ctx.update(data)
+
+    def verify(self):
+        data_to_verify = self._hash_ctx.finalize()
+
+        data_to_verify = _truncate_digest_for_dsa(
+            self._public_key._dsa_cdata, data_to_verify, self._backend
+        )
+
+        # The first parameter passed to DSA_verify is unused by OpenSSL but
+        # must be an integer.
+        res = self._backend._lib.DSA_verify(
+            0, data_to_verify, len(data_to_verify), self._signature,
+            len(self._signature), self._public_key._dsa_cdata)
+
+        if res != 1:
+            self._backend._consume_errors()
+            raise InvalidSignature
+
+
+@utils.register_interface(AsymmetricSignatureContext)
+class _DSASignatureContext(object):
+    def __init__(self, backend, private_key, algorithm):
+        self._backend = backend
+        self._private_key = private_key
+        self._algorithm = algorithm
+        self._hash_ctx = hashes.Hash(self._algorithm, self._backend)
+
+    def update(self, data):
+        self._hash_ctx.update(data)
+
+    def finalize(self):
+        data_to_sign = self._hash_ctx.finalize()
+        data_to_sign = _truncate_digest_for_dsa(
+            self._private_key._dsa_cdata, data_to_sign, self._backend
+        )
+        sig_buf_len = self._backend._lib.DSA_size(self._private_key._dsa_cdata)
+        sig_buf = self._backend._ffi.new("unsigned char[]", sig_buf_len)
+        buflen = self._backend._ffi.new("unsigned int *")
+
+        # The first parameter passed to DSA_sign is unused by OpenSSL but
+        # must be an integer.
+        res = self._backend._lib.DSA_sign(
+            0, data_to_sign, len(data_to_sign), sig_buf,
+            buflen, self._private_key._dsa_cdata)
+        self._backend.openssl_assert(res == 1)
+        self._backend.openssl_assert(buflen[0])
+
+        return self._backend._ffi.buffer(sig_buf)[:buflen[0]]
+
+
+@utils.register_interface(dsa.DSAParametersWithNumbers)
+class _DSAParameters(object):
+    def __init__(self, backend, dsa_cdata):
+        self._backend = backend
+        self._dsa_cdata = dsa_cdata
+
+    def parameter_numbers(self):
+        return dsa.DSAParameterNumbers(
+            p=self._backend._bn_to_int(self._dsa_cdata.p),
+            q=self._backend._bn_to_int(self._dsa_cdata.q),
+            g=self._backend._bn_to_int(self._dsa_cdata.g)
+        )
+
+    def generate_private_key(self):
+        return self._backend.generate_dsa_private_key(self)
+
+
+@utils.register_interface(dsa.DSAPrivateKeyWithSerialization)
+class _DSAPrivateKey(object):
+    def __init__(self, backend, dsa_cdata, evp_pkey):
+        self._backend = backend
+        self._dsa_cdata = dsa_cdata
+        self._evp_pkey = evp_pkey
+        self._key_size = self._backend._lib.BN_num_bits(self._dsa_cdata.p)
+
+    key_size = utils.read_only_property("_key_size")
+
+    def signer(self, signature_algorithm):
+        return _DSASignatureContext(self._backend, self, signature_algorithm)
+
+    def private_numbers(self):
+        return dsa.DSAPrivateNumbers(
+            public_numbers=dsa.DSAPublicNumbers(
+                parameter_numbers=dsa.DSAParameterNumbers(
+                    p=self._backend._bn_to_int(self._dsa_cdata.p),
+                    q=self._backend._bn_to_int(self._dsa_cdata.q),
+                    g=self._backend._bn_to_int(self._dsa_cdata.g)
+                ),
+                y=self._backend._bn_to_int(self._dsa_cdata.pub_key)
+            ),
+            x=self._backend._bn_to_int(self._dsa_cdata.priv_key)
+        )
+
+    def public_key(self):
+        dsa_cdata = self._backend._lib.DSA_new()
+        self._backend.openssl_assert(dsa_cdata != self._backend._ffi.NULL)
+        dsa_cdata = self._backend._ffi.gc(
+            dsa_cdata, self._backend._lib.DSA_free
+        )
+        dsa_cdata.p = self._backend._lib.BN_dup(self._dsa_cdata.p)
+        dsa_cdata.q = self._backend._lib.BN_dup(self._dsa_cdata.q)
+        dsa_cdata.g = self._backend._lib.BN_dup(self._dsa_cdata.g)
+        dsa_cdata.pub_key = self._backend._lib.BN_dup(self._dsa_cdata.pub_key)
+        evp_pkey = self._backend._dsa_cdata_to_evp_pkey(dsa_cdata)
+        return _DSAPublicKey(self._backend, dsa_cdata, evp_pkey)
+
+    def parameters(self):
+        dsa_cdata = self._backend._lib.DSA_new()
+        self._backend.openssl_assert(dsa_cdata != self._backend._ffi.NULL)
+        dsa_cdata = self._backend._ffi.gc(
+            dsa_cdata, self._backend._lib.DSA_free
+        )
+        dsa_cdata.p = self._backend._lib.BN_dup(self._dsa_cdata.p)
+        dsa_cdata.q = self._backend._lib.BN_dup(self._dsa_cdata.q)
+        dsa_cdata.g = self._backend._lib.BN_dup(self._dsa_cdata.g)
+        return _DSAParameters(self._backend, dsa_cdata)
+
+    def private_bytes(self, encoding, format, encryption_algorithm):
+        return self._backend._private_key_bytes(
+            encoding,
+            format,
+            encryption_algorithm,
+            self._evp_pkey,
+            self._dsa_cdata
+        )
+
+
+@utils.register_interface(dsa.DSAPublicKeyWithSerialization)
+class _DSAPublicKey(object):
+    def __init__(self, backend, dsa_cdata, evp_pkey):
+        self._backend = backend
+        self._dsa_cdata = dsa_cdata
+        self._evp_pkey = evp_pkey
+        self._key_size = self._backend._lib.BN_num_bits(self._dsa_cdata.p)
+
+    key_size = utils.read_only_property("_key_size")
+
+    def verifier(self, signature, signature_algorithm):
+        if not isinstance(signature, bytes):
+            raise TypeError("signature must be bytes.")
+
+        return _DSAVerificationContext(
+            self._backend, self, signature, signature_algorithm
+        )
+
+    def public_numbers(self):
+        return dsa.DSAPublicNumbers(
+            parameter_numbers=dsa.DSAParameterNumbers(
+                p=self._backend._bn_to_int(self._dsa_cdata.p),
+                q=self._backend._bn_to_int(self._dsa_cdata.q),
+                g=self._backend._bn_to_int(self._dsa_cdata.g)
+            ),
+            y=self._backend._bn_to_int(self._dsa_cdata.pub_key)
+        )
+
+    def parameters(self):
+        dsa_cdata = self._backend._lib.DSA_new()
+        self._backend.openssl_assert(dsa_cdata != self._backend._ffi.NULL)
+        dsa_cdata = self._backend._ffi.gc(
+            dsa_cdata, self._backend._lib.DSA_free
+        )
+        dsa_cdata.p = self._backend._lib.BN_dup(self._dsa_cdata.p)
+        dsa_cdata.q = self._backend._lib.BN_dup(self._dsa_cdata.q)
+        dsa_cdata.g = self._backend._lib.BN_dup(self._dsa_cdata.g)
+        return _DSAParameters(self._backend, dsa_cdata)
+
+    def public_bytes(self, encoding, format):
+        if format is serialization.PublicFormat.PKCS1:
+            raise ValueError(
+                "DSA public keys do not support PKCS1 serialization"
+            )
+
+        return self._backend._public_key_bytes(
+            encoding,
+            format,
+            self._evp_pkey,
+            None
+        )
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/openssl/ec.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/openssl/ec.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/openssl/ec.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/openssl/ec.py	2015-11-19 05:01:40.000000000 +0100
@@ -0,0 +1,299 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+from cryptography import utils
+from cryptography.exceptions import (
+    InvalidSignature, UnsupportedAlgorithm, _Reasons
+)
+from cryptography.hazmat.backends.openssl.utils import _truncate_digest
+from cryptography.hazmat.primitives import hashes, serialization
+from cryptography.hazmat.primitives.asymmetric import (
+    AsymmetricSignatureContext, AsymmetricVerificationContext, ec
+)
+
+
+def _truncate_digest_for_ecdsa(ec_key_cdata, digest, backend):
+    """
+    This function truncates digests that are longer than a given elliptic
+    curve key's length so they can be signed. Since elliptic curve keys are
+    much shorter than RSA keys many digests (e.g. SHA-512) may require
+    truncation.
+    """
+
+    _lib = backend._lib
+    _ffi = backend._ffi
+
+    group = _lib.EC_KEY_get0_group(ec_key_cdata)
+
+    with backend._tmp_bn_ctx() as bn_ctx:
+        order = _lib.BN_CTX_get(bn_ctx)
+        backend.openssl_assert(order != _ffi.NULL)
+
+        res = _lib.EC_GROUP_get_order(group, order, bn_ctx)
+        backend.openssl_assert(res == 1)
+
+        order_bits = _lib.BN_num_bits(order)
+
+    return _truncate_digest(digest, order_bits)
+
+
+def _ec_key_curve_sn(backend, ec_key):
+    group = backend._lib.EC_KEY_get0_group(ec_key)
+    backend.openssl_assert(group != backend._ffi.NULL)
+
+    nid = backend._lib.EC_GROUP_get_curve_name(group)
+    # The following check is to find EC keys with unnamed curves and raise
+    # an error for now.
+    if nid == backend._lib.NID_undef:
+        raise NotImplementedError(
+            "ECDSA certificates with unnamed curves are unsupported "
+            "at this time"
+        )
+
+    curve_name = backend._lib.OBJ_nid2sn(nid)
+    backend.openssl_assert(curve_name != backend._ffi.NULL)
+
+    sn = backend._ffi.string(curve_name).decode('ascii')
+    return sn
+
+
+def _mark_asn1_named_ec_curve(backend, ec_cdata):
+    """
+    Set the named curve flag on the EC_KEY. This causes OpenSSL to
+    serialize EC keys along with their curve OID which makes
+    deserialization easier.
+    """
+
+    backend._lib.EC_KEY_set_asn1_flag(
+        ec_cdata, backend._lib.OPENSSL_EC_NAMED_CURVE
+    )
+
+
+def _sn_to_elliptic_curve(backend, sn):
+    try:
+        return ec._CURVE_TYPES[sn]()
+    except KeyError:
+        raise UnsupportedAlgorithm(
+            "{0} is not a supported elliptic curve".format(sn),
+            _Reasons.UNSUPPORTED_ELLIPTIC_CURVE
+        )
+
+
+@utils.register_interface(AsymmetricSignatureContext)
+class _ECDSASignatureContext(object):
+    def __init__(self, backend, private_key, algorithm):
+        self._backend = backend
+        self._private_key = private_key
+        self._digest = hashes.Hash(algorithm, backend)
+
+    def update(self, data):
+        self._digest.update(data)
+
+    def finalize(self):
+        ec_key = self._private_key._ec_key
+
+        digest = self._digest.finalize()
+
+        digest = _truncate_digest_for_ecdsa(ec_key, digest, self._backend)
+
+        max_size = self._backend._lib.ECDSA_size(ec_key)
+        self._backend.openssl_assert(max_size > 0)
+
+        sigbuf = self._backend._ffi.new("char[]", max_size)
+        siglen_ptr = self._backend._ffi.new("unsigned int[]", 1)
+        res = self._backend._lib.ECDSA_sign(
+            0,
+            digest,
+            len(digest),
+            sigbuf,
+            siglen_ptr,
+            ec_key
+        )
+        self._backend.openssl_assert(res == 1)
+        return self._backend._ffi.buffer(sigbuf)[:siglen_ptr[0]]
+
+
+@utils.register_interface(AsymmetricVerificationContext)
+class _ECDSAVerificationContext(object):
+    def __init__(self, backend, public_key, signature, algorithm):
+        self._backend = backend
+        self._public_key = public_key
+        self._signature = signature
+        self._digest = hashes.Hash(algorithm, backend)
+
+    def update(self, data):
+        self._digest.update(data)
+
+    def verify(self):
+        ec_key = self._public_key._ec_key
+
+        digest = self._digest.finalize()
+
+        digest = _truncate_digest_for_ecdsa(ec_key, digest, self._backend)
+
+        res = self._backend._lib.ECDSA_verify(
+            0,
+            digest,
+            len(digest),
+            self._signature,
+            len(self._signature),
+            ec_key
+        )
+        if res != 1:
+            self._backend._consume_errors()
+            raise InvalidSignature
+        return True
+
+
+@utils.register_interface(ec.EllipticCurvePrivateKeyWithSerialization)
+class _EllipticCurvePrivateKey(object):
+    def __init__(self, backend, ec_key_cdata, evp_pkey):
+        self._backend = backend
+        _mark_asn1_named_ec_curve(backend, ec_key_cdata)
+        self._ec_key = ec_key_cdata
+        self._evp_pkey = evp_pkey
+
+        sn = _ec_key_curve_sn(backend, ec_key_cdata)
+        self._curve = _sn_to_elliptic_curve(backend, sn)
+
+    curve = utils.read_only_property("_curve")
+
+    def signer(self, signature_algorithm):
+        if isinstance(signature_algorithm, ec.ECDSA):
+            return _ECDSASignatureContext(
+                self._backend, self, signature_algorithm.algorithm
+            )
+        else:
+            raise UnsupportedAlgorithm(
+                "Unsupported elliptic curve signature algorithm.",
+                _Reasons.UNSUPPORTED_PUBLIC_KEY_ALGORITHM)
+
+    def exchange(self, algorithm, peer_public_key):
+        if not (
+            self._backend.elliptic_curve_exchange_algorithm_supported(
+                algorithm, self.curve
+            )
+        ):
+            raise UnsupportedAlgorithm(
+                "This backend does not support the ECDH algorithm.",
+                _Reasons.UNSUPPORTED_EXCHANGE_ALGORITHM
+            )
+
+        group = self._backend._lib.EC_KEY_get0_group(self._ec_key)
+        z_len = (self._backend._lib.EC_GROUP_get_degree(group) + 7) // 8
+        self._backend.openssl_assert(z_len > 0)
+        z_buf = self._backend._ffi.new("uint8_t[]", z_len)
+        peer_key = self._backend._lib.EC_KEY_get0_public_key(
+            peer_public_key._ec_key
+        )
+
+        r = self._backend._lib.ECDH_compute_key(
+            z_buf, z_len, peer_key, self._ec_key, self._backend._ffi.NULL
+        )
+        self._backend.openssl_assert(r > 0)
+        return self._backend._ffi.buffer(z_buf)[:z_len]
+
+    def public_key(self):
+        group = self._backend._lib.EC_KEY_get0_group(self._ec_key)
+        self._backend.openssl_assert(group != self._backend._ffi.NULL)
+
+        curve_nid = self._backend._lib.EC_GROUP_get_curve_name(group)
+
+        public_ec_key = self._backend._lib.EC_KEY_new_by_curve_name(curve_nid)
+        self._backend.openssl_assert(public_ec_key != self._backend._ffi.NULL)
+        public_ec_key = self._backend._ffi.gc(
+            public_ec_key, self._backend._lib.EC_KEY_free
+        )
+
+        point = self._backend._lib.EC_KEY_get0_public_key(self._ec_key)
+        self._backend.openssl_assert(point != self._backend._ffi.NULL)
+
+        res = self._backend._lib.EC_KEY_set_public_key(public_ec_key, point)
+        self._backend.openssl_assert(res == 1)
+
+        evp_pkey = self._backend._ec_cdata_to_evp_pkey(public_ec_key)
+
+        return _EllipticCurvePublicKey(self._backend, public_ec_key, evp_pkey)
+
+    def private_numbers(self):
+        bn = self._backend._lib.EC_KEY_get0_private_key(self._ec_key)
+        private_value = self._backend._bn_to_int(bn)
+        return ec.EllipticCurvePrivateNumbers(
+            private_value=private_value,
+            public_numbers=self.public_key().public_numbers()
+        )
+
+    def private_bytes(self, encoding, format, encryption_algorithm):
+        return self._backend._private_key_bytes(
+            encoding,
+            format,
+            encryption_algorithm,
+            self._evp_pkey,
+            self._ec_key
+        )
+
+
+@utils.register_interface(ec.EllipticCurvePublicKeyWithSerialization)
+class _EllipticCurvePublicKey(object):
+    def __init__(self, backend, ec_key_cdata, evp_pkey):
+        self._backend = backend
+        _mark_asn1_named_ec_curve(backend, ec_key_cdata)
+        self._ec_key = ec_key_cdata
+        self._evp_pkey = evp_pkey
+
+        sn = _ec_key_curve_sn(backend, ec_key_cdata)
+        self._curve = _sn_to_elliptic_curve(backend, sn)
+
+    curve = utils.read_only_property("_curve")
+
+    def verifier(self, signature, signature_algorithm):
+        if not isinstance(signature, bytes):
+            raise TypeError("signature must be bytes.")
+
+        if isinstance(signature_algorithm, ec.ECDSA):
+            return _ECDSAVerificationContext(
+                self._backend, self, signature, signature_algorithm.algorithm
+            )
+        else:
+            raise UnsupportedAlgorithm(
+                "Unsupported elliptic curve signature algorithm.",
+                _Reasons.UNSUPPORTED_PUBLIC_KEY_ALGORITHM)
+
+    def public_numbers(self):
+        set_func, get_func, group = (
+            self._backend._ec_key_determine_group_get_set_funcs(self._ec_key)
+        )
+        point = self._backend._lib.EC_KEY_get0_public_key(self._ec_key)
+        self._backend.openssl_assert(point != self._backend._ffi.NULL)
+
+        with self._backend._tmp_bn_ctx() as bn_ctx:
+            bn_x = self._backend._lib.BN_CTX_get(bn_ctx)
+            bn_y = self._backend._lib.BN_CTX_get(bn_ctx)
+
+            res = get_func(group, point, bn_x, bn_y, bn_ctx)
+            self._backend.openssl_assert(res == 1)
+
+            x = self._backend._bn_to_int(bn_x)
+            y = self._backend._bn_to_int(bn_y)
+
+        return ec.EllipticCurvePublicNumbers(
+            x=x,
+            y=y,
+            curve=self._curve
+        )
+
+    def public_bytes(self, encoding, format):
+        if format is serialization.PublicFormat.PKCS1:
+            raise ValueError(
+                "EC public keys do not support PKCS1 serialization"
+            )
+
+        return self._backend._public_key_bytes(
+            encoding,
+            format,
+            self._evp_pkey,
+            None
+        )
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/openssl/hashes.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/openssl/hashes.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/openssl/hashes.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/openssl/hashes.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,62 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+
+from cryptography import utils
+from cryptography.exceptions import UnsupportedAlgorithm, _Reasons
+from cryptography.hazmat.primitives import hashes
+
+
+@utils.register_interface(hashes.HashContext)
+class _HashContext(object):
+    def __init__(self, backend, algorithm, ctx=None):
+        self._algorithm = algorithm
+
+        self._backend = backend
+
+        if ctx is None:
+            ctx = self._backend._lib.EVP_MD_CTX_create()
+            ctx = self._backend._ffi.gc(ctx,
+                                        self._backend._lib.EVP_MD_CTX_destroy)
+            evp_md = self._backend._lib.EVP_get_digestbyname(
+                algorithm.name.encode("ascii"))
+            if evp_md == self._backend._ffi.NULL:
+                raise UnsupportedAlgorithm(
+                    "{0} is not a supported hash on this backend.".format(
+                        algorithm.name),
+                    _Reasons.UNSUPPORTED_HASH
+                )
+            res = self._backend._lib.EVP_DigestInit_ex(ctx, evp_md,
+                                                       self._backend._ffi.NULL)
+            self._backend.openssl_assert(res != 0)
+
+        self._ctx = ctx
+
+    algorithm = utils.read_only_property("_algorithm")
+
+    def copy(self):
+        copied_ctx = self._backend._lib.EVP_MD_CTX_create()
+        copied_ctx = self._backend._ffi.gc(
+            copied_ctx, self._backend._lib.EVP_MD_CTX_destroy
+        )
+        res = self._backend._lib.EVP_MD_CTX_copy_ex(copied_ctx, self._ctx)
+        self._backend.openssl_assert(res != 0)
+        return _HashContext(self._backend, self.algorithm, ctx=copied_ctx)
+
+    def update(self, data):
+        res = self._backend._lib.EVP_DigestUpdate(self._ctx, data, len(data))
+        self._backend.openssl_assert(res != 0)
+
+    def finalize(self):
+        buf = self._backend._ffi.new("unsigned char[]",
+                                     self._backend._lib.EVP_MAX_MD_SIZE)
+        outlen = self._backend._ffi.new("unsigned int *")
+        res = self._backend._lib.EVP_DigestFinal_ex(self._ctx, buf, outlen)
+        self._backend.openssl_assert(res != 0)
+        self._backend.openssl_assert(outlen[0] == self.algorithm.digest_size)
+        res = self._backend._lib.EVP_MD_CTX_cleanup(self._ctx)
+        self._backend.openssl_assert(res == 1)
+        return self._backend._ffi.buffer(buf)[:outlen[0]]
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/openssl/hmac.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/openssl/hmac.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/openssl/hmac.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/openssl/hmac.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,81 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+
+from cryptography import utils
+from cryptography.exceptions import (
+    InvalidSignature, UnsupportedAlgorithm, _Reasons
+)
+from cryptography.hazmat.primitives import constant_time, hashes, interfaces
+
+
+@utils.register_interface(interfaces.MACContext)
+@utils.register_interface(hashes.HashContext)
+class _HMACContext(object):
+    def __init__(self, backend, key, algorithm, ctx=None):
+        self._algorithm = algorithm
+        self._backend = backend
+
+        if ctx is None:
+            ctx = self._backend._ffi.new("HMAC_CTX *")
+            self._backend._lib.HMAC_CTX_init(ctx)
+            ctx = self._backend._ffi.gc(
+                ctx, self._backend._lib.HMAC_CTX_cleanup
+            )
+            evp_md = self._backend._lib.EVP_get_digestbyname(
+                algorithm.name.encode('ascii'))
+            if evp_md == self._backend._ffi.NULL:
+                raise UnsupportedAlgorithm(
+                    "{0} is not a supported hash on this backend.".format(
+                        algorithm.name),
+                    _Reasons.UNSUPPORTED_HASH
+                )
+            res = self._backend._lib.Cryptography_HMAC_Init_ex(
+                ctx, key, len(key), evp_md, self._backend._ffi.NULL
+            )
+            self._backend.openssl_assert(res != 0)
+
+        self._ctx = ctx
+        self._key = key
+
+    algorithm = utils.read_only_property("_algorithm")
+
+    def copy(self):
+        copied_ctx = self._backend._ffi.new("HMAC_CTX *")
+        self._backend._lib.HMAC_CTX_init(copied_ctx)
+        copied_ctx = self._backend._ffi.gc(
+            copied_ctx, self._backend._lib.HMAC_CTX_cleanup
+        )
+        res = self._backend._lib.Cryptography_HMAC_CTX_copy(
+            copied_ctx, self._ctx
+        )
+        self._backend.openssl_assert(res != 0)
+        return _HMACContext(
+            self._backend, self._key, self.algorithm, ctx=copied_ctx
+        )
+
+    def update(self, data):
+        res = self._backend._lib.Cryptography_HMAC_Update(
+            self._ctx, data, len(data)
+        )
+        self._backend.openssl_assert(res != 0)
+
+    def finalize(self):
+        buf = self._backend._ffi.new("unsigned char[]",
+                                     self._backend._lib.EVP_MAX_MD_SIZE)
+        outlen = self._backend._ffi.new("unsigned int *")
+        res = self._backend._lib.Cryptography_HMAC_Final(
+            self._ctx, buf, outlen
+        )
+        self._backend.openssl_assert(res != 0)
+        self._backend.openssl_assert(outlen[0] == self.algorithm.digest_size)
+        self._backend._lib.HMAC_CTX_cleanup(self._ctx)
+        return self._backend._ffi.buffer(buf)[:outlen[0]]
+
+    def verify(self, signature):
+        digest = self.finalize()
+        if not constant_time.bytes_eq(digest, signature):
+            raise InvalidSignature("Signature did not match digest.")
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/openssl/__init__.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/openssl/__init__.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/openssl/__init__.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/openssl/__init__.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,10 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+from cryptography.hazmat.backends.openssl.backend import backend
+
+
+__all__ = ["backend"]
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/openssl/rsa.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/openssl/rsa.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/openssl/rsa.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/openssl/rsa.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,604 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import math
+
+from cryptography import utils
+from cryptography.exceptions import (
+    AlreadyFinalized, InvalidSignature, UnsupportedAlgorithm, _Reasons
+)
+from cryptography.hazmat.primitives import hashes
+from cryptography.hazmat.primitives.asymmetric import (
+    AsymmetricSignatureContext, AsymmetricVerificationContext, rsa
+)
+from cryptography.hazmat.primitives.asymmetric.padding import (
+    AsymmetricPadding, MGF1, OAEP, PKCS1v15, PSS
+)
+from cryptography.hazmat.primitives.asymmetric.rsa import (
+    RSAPrivateKeyWithSerialization, RSAPublicKeyWithSerialization
+)
+
+
+def _get_rsa_pss_salt_length(pss, key_size, digest_size):
+    salt = pss._salt_length
+
+    if salt is MGF1.MAX_LENGTH or salt is PSS.MAX_LENGTH:
+        # bit length - 1 per RFC 3447
+        emlen = int(math.ceil((key_size - 1) / 8.0))
+        salt_length = emlen - digest_size - 2
+        assert salt_length >= 0
+        return salt_length
+    else:
+        return salt
+
+
+def _enc_dec_rsa(backend, key, data, padding):
+    if not isinstance(padding, AsymmetricPadding):
+        raise TypeError("Padding must be an instance of AsymmetricPadding.")
+
+    if isinstance(padding, PKCS1v15):
+        padding_enum = backend._lib.RSA_PKCS1_PADDING
+    elif isinstance(padding, OAEP):
+        padding_enum = backend._lib.RSA_PKCS1_OAEP_PADDING
+        if not isinstance(padding._mgf, MGF1):
+            raise UnsupportedAlgorithm(
+                "Only MGF1 is supported by this backend.",
+                _Reasons.UNSUPPORTED_MGF
+            )
+
+        if not isinstance(padding._mgf._algorithm, hashes.SHA1):
+            raise UnsupportedAlgorithm(
+                "This backend supports only SHA1 inside MGF1 when "
+                "using OAEP.",
+                _Reasons.UNSUPPORTED_HASH
+            )
+
+        if padding._label is not None and padding._label != b"":
+            raise ValueError("This backend does not support OAEP labels.")
+
+        if not isinstance(padding._algorithm, hashes.SHA1):
+            raise UnsupportedAlgorithm(
+                "This backend only supports SHA1 when using OAEP.",
+                _Reasons.UNSUPPORTED_HASH
+            )
+    else:
+        raise UnsupportedAlgorithm(
+            "{0} is not supported by this backend.".format(
+                padding.name
+            ),
+            _Reasons.UNSUPPORTED_PADDING
+        )
+
+    if backend._lib.Cryptography_HAS_PKEY_CTX:
+        return _enc_dec_rsa_pkey_ctx(backend, key, data, padding_enum)
+    else:
+        return _enc_dec_rsa_098(backend, key, data, padding_enum)
+
+
+def _enc_dec_rsa_pkey_ctx(backend, key, data, padding_enum):
+    if isinstance(key, _RSAPublicKey):
+        init = backend._lib.EVP_PKEY_encrypt_init
+        crypt = backend._lib.Cryptography_EVP_PKEY_encrypt
+    else:
+        init = backend._lib.EVP_PKEY_decrypt_init
+        crypt = backend._lib.Cryptography_EVP_PKEY_decrypt
+
+    pkey_ctx = backend._lib.EVP_PKEY_CTX_new(
+        key._evp_pkey, backend._ffi.NULL
+    )
+    backend.openssl_assert(pkey_ctx != backend._ffi.NULL)
+    pkey_ctx = backend._ffi.gc(pkey_ctx, backend._lib.EVP_PKEY_CTX_free)
+    res = init(pkey_ctx)
+    backend.openssl_assert(res == 1)
+    res = backend._lib.EVP_PKEY_CTX_set_rsa_padding(
+        pkey_ctx, padding_enum)
+    backend.openssl_assert(res > 0)
+    buf_size = backend._lib.EVP_PKEY_size(key._evp_pkey)
+    backend.openssl_assert(buf_size > 0)
+    outlen = backend._ffi.new("size_t *", buf_size)
+    buf = backend._ffi.new("char[]", buf_size)
+    res = crypt(pkey_ctx, buf, outlen, data, len(data))
+    if res <= 0:
+        _handle_rsa_enc_dec_error(backend, key)
+
+    return backend._ffi.buffer(buf)[:outlen[0]]
+
+
+def _enc_dec_rsa_098(backend, key, data, padding_enum):
+    if isinstance(key, _RSAPublicKey):
+        crypt = backend._lib.RSA_public_encrypt
+    else:
+        crypt = backend._lib.RSA_private_decrypt
+
+    key_size = backend._lib.RSA_size(key._rsa_cdata)
+    backend.openssl_assert(key_size > 0)
+    buf = backend._ffi.new("unsigned char[]", key_size)
+    res = crypt(len(data), data, buf, key._rsa_cdata, padding_enum)
+    if res < 0:
+        _handle_rsa_enc_dec_error(backend, key)
+
+    return backend._ffi.buffer(buf)[:res]
+
+
+def _handle_rsa_enc_dec_error(backend, key):
+    errors = backend._consume_errors()
+    assert errors
+    assert errors[0].lib == backend._lib.ERR_LIB_RSA
+    if isinstance(key, _RSAPublicKey):
+        assert (errors[0].reason ==
+                backend._lib.RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE)
+        raise ValueError(
+            "Data too long for key size. Encrypt less data or use a "
+            "larger key size."
+        )
+    else:
+        decoding_errors = [
+            backend._lib.RSA_R_BLOCK_TYPE_IS_NOT_01,
+            backend._lib.RSA_R_BLOCK_TYPE_IS_NOT_02,
+        ]
+        if backend._lib.Cryptography_HAS_RSA_R_PKCS_DECODING_ERROR:
+            decoding_errors.append(backend._lib.RSA_R_PKCS_DECODING_ERROR)
+
+        assert errors[0].reason in decoding_errors
+        raise ValueError("Decryption failed.")
+
+
+@utils.register_interface(AsymmetricSignatureContext)
+class _RSASignatureContext(object):
+    def __init__(self, backend, private_key, padding, algorithm):
+        self._backend = backend
+        self._private_key = private_key
+
+        if not isinstance(padding, AsymmetricPadding):
+            raise TypeError("Expected provider of AsymmetricPadding.")
+
+        self._pkey_size = self._backend._lib.EVP_PKEY_size(
+            self._private_key._evp_pkey
+        )
+        self._backend.openssl_assert(self._pkey_size > 0)
+
+        if isinstance(padding, PKCS1v15):
+            if self._backend._lib.Cryptography_HAS_PKEY_CTX:
+                self._finalize_method = self._finalize_pkey_ctx
+                self._padding_enum = self._backend._lib.RSA_PKCS1_PADDING
+            else:
+                self._finalize_method = self._finalize_pkcs1
+        elif isinstance(padding, PSS):
+            if not isinstance(padding._mgf, MGF1):
+                raise UnsupportedAlgorithm(
+                    "Only MGF1 is supported by this backend.",
+                    _Reasons.UNSUPPORTED_MGF
+                )
+
+            # Size of key in bytes - 2 is the maximum
+            # PSS signature length (salt length is checked later)
+            if self._pkey_size - algorithm.digest_size - 2 < 0:
+                raise ValueError("Digest too large for key size. Use a larger "
+                                 "key.")
+
+            if not self._backend._mgf1_hash_supported(padding._mgf._algorithm):
+                raise UnsupportedAlgorithm(
+                    "When OpenSSL is older than 1.0.1 then only SHA1 is "
+                    "supported with MGF1.",
+                    _Reasons.UNSUPPORTED_HASH
+                )
+
+            if self._backend._lib.Cryptography_HAS_PKEY_CTX:
+                self._finalize_method = self._finalize_pkey_ctx
+                self._padding_enum = self._backend._lib.RSA_PKCS1_PSS_PADDING
+            else:
+                self._finalize_method = self._finalize_pss
+        else:
+            raise UnsupportedAlgorithm(
+                "{0} is not supported by this backend.".format(padding.name),
+                _Reasons.UNSUPPORTED_PADDING
+            )
+
+        self._padding = padding
+        self._algorithm = algorithm
+        self._hash_ctx = hashes.Hash(self._algorithm, self._backend)
+
+    def update(self, data):
+        self._hash_ctx.update(data)
+
+    def finalize(self):
+        evp_md = self._backend._lib.EVP_get_digestbyname(
+            self._algorithm.name.encode("ascii"))
+        self._backend.openssl_assert(evp_md != self._backend._ffi.NULL)
+
+        return self._finalize_method(evp_md)
+
+    def _finalize_pkey_ctx(self, evp_md):
+        pkey_ctx = self._backend._lib.EVP_PKEY_CTX_new(
+            self._private_key._evp_pkey, self._backend._ffi.NULL
+        )
+        self._backend.openssl_assert(pkey_ctx != self._backend._ffi.NULL)
+        pkey_ctx = self._backend._ffi.gc(pkey_ctx,
+                                         self._backend._lib.EVP_PKEY_CTX_free)
+        res = self._backend._lib.EVP_PKEY_sign_init(pkey_ctx)
+        self._backend.openssl_assert(res == 1)
+        res = self._backend._lib.EVP_PKEY_CTX_set_signature_md(
+            pkey_ctx, evp_md)
+        self._backend.openssl_assert(res > 0)
+
+        res = self._backend._lib.EVP_PKEY_CTX_set_rsa_padding(
+            pkey_ctx, self._padding_enum)
+        self._backend.openssl_assert(res > 0)
+        if isinstance(self._padding, PSS):
+            res = self._backend._lib.EVP_PKEY_CTX_set_rsa_pss_saltlen(
+                pkey_ctx,
+                _get_rsa_pss_salt_length(
+                    self._padding,
+                    self._private_key.key_size,
+                    self._hash_ctx.algorithm.digest_size
+                )
+            )
+            self._backend.openssl_assert(res > 0)
+
+            if self._backend._lib.Cryptography_HAS_MGF1_MD:
+                # MGF1 MD is configurable in OpenSSL 1.0.1+
+                mgf1_md = self._backend._lib.EVP_get_digestbyname(
+                    self._padding._mgf._algorithm.name.encode("ascii"))
+                self._backend.openssl_assert(
+                    mgf1_md != self._backend._ffi.NULL
+                )
+                res = self._backend._lib.EVP_PKEY_CTX_set_rsa_mgf1_md(
+                    pkey_ctx, mgf1_md
+                )
+                self._backend.openssl_assert(res > 0)
+        data_to_sign = self._hash_ctx.finalize()
+        buflen = self._backend._ffi.new("size_t *")
+        res = self._backend._lib.EVP_PKEY_sign(
+            pkey_ctx,
+            self._backend._ffi.NULL,
+            buflen,
+            data_to_sign,
+            len(data_to_sign)
+        )
+        self._backend.openssl_assert(res == 1)
+        buf = self._backend._ffi.new("unsigned char[]", buflen[0])
+        res = self._backend._lib.EVP_PKEY_sign(
+            pkey_ctx, buf, buflen, data_to_sign, len(data_to_sign))
+        if res != 1:
+            errors = self._backend._consume_errors()
+            assert errors[0].lib == self._backend._lib.ERR_LIB_RSA
+            reason = None
+            if (errors[0].reason ==
+                    self._backend._lib.RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE):
+                reason = ("Salt length too long for key size. Try using "
+                          "MAX_LENGTH instead.")
+            else:
+                assert (errors[0].reason ==
+                        self._backend._lib.RSA_R_DIGEST_TOO_BIG_FOR_RSA_KEY)
+                reason = "Digest too large for key size. Use a larger key."
+            assert reason is not None
+            raise ValueError(reason)
+
+        return self._backend._ffi.buffer(buf)[:]
+
+    def _finalize_pkcs1(self, evp_md):
+        if self._hash_ctx._ctx is None:
+            raise AlreadyFinalized("Context has already been finalized.")
+
+        sig_buf = self._backend._ffi.new("char[]", self._pkey_size)
+        sig_len = self._backend._ffi.new("unsigned int *")
+        res = self._backend._lib.EVP_SignFinal(
+            self._hash_ctx._ctx._ctx,
+            sig_buf,
+            sig_len,
+            self._private_key._evp_pkey
+        )
+        self._hash_ctx.finalize()
+        if res == 0:
+            errors = self._backend._consume_errors()
+            assert errors[0].lib == self._backend._lib.ERR_LIB_RSA
+            assert (errors[0].reason ==
+                    self._backend._lib.RSA_R_DIGEST_TOO_BIG_FOR_RSA_KEY)
+            raise ValueError("Digest too large for key size. Use a larger "
+                             "key.")
+
+        return self._backend._ffi.buffer(sig_buf)[:sig_len[0]]
+
+    def _finalize_pss(self, evp_md):
+        data_to_sign = self._hash_ctx.finalize()
+        padded = self._backend._ffi.new("unsigned char[]", self._pkey_size)
+        res = self._backend._lib.RSA_padding_add_PKCS1_PSS(
+            self._private_key._rsa_cdata,
+            padded,
+            data_to_sign,
+            evp_md,
+            _get_rsa_pss_salt_length(
+                self._padding,
+                self._private_key.key_size,
+                len(data_to_sign)
+            )
+        )
+        if res != 1:
+            errors = self._backend._consume_errors()
+            assert errors[0].lib == self._backend._lib.ERR_LIB_RSA
+            assert (errors[0].reason ==
+                    self._backend._lib.RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE)
+            raise ValueError("Salt length too long for key size. Try using "
+                             "MAX_LENGTH instead.")
+
+        sig_buf = self._backend._ffi.new("char[]", self._pkey_size)
+        sig_len = self._backend._lib.RSA_private_encrypt(
+            self._pkey_size,
+            padded,
+            sig_buf,
+            self._private_key._rsa_cdata,
+            self._backend._lib.RSA_NO_PADDING
+        )
+        self._backend.openssl_assert(sig_len != -1)
+        return self._backend._ffi.buffer(sig_buf)[:sig_len]
+
+
+@utils.register_interface(AsymmetricVerificationContext)
+class _RSAVerificationContext(object):
+    def __init__(self, backend, public_key, signature, padding, algorithm):
+        self._backend = backend
+        self._public_key = public_key
+        self._signature = signature
+
+        if not isinstance(padding, AsymmetricPadding):
+            raise TypeError("Expected provider of AsymmetricPadding.")
+
+        self._pkey_size = self._backend._lib.EVP_PKEY_size(
+            self._public_key._evp_pkey
+        )
+        self._backend.openssl_assert(self._pkey_size > 0)
+
+        if isinstance(padding, PKCS1v15):
+            if self._backend._lib.Cryptography_HAS_PKEY_CTX:
+                self._verify_method = self._verify_pkey_ctx
+                self._padding_enum = self._backend._lib.RSA_PKCS1_PADDING
+            else:
+                self._verify_method = self._verify_pkcs1
+        elif isinstance(padding, PSS):
+            if not isinstance(padding._mgf, MGF1):
+                raise UnsupportedAlgorithm(
+                    "Only MGF1 is supported by this backend.",
+                    _Reasons.UNSUPPORTED_MGF
+                )
+
+            # Size of key in bytes - 2 is the maximum
+            # PSS signature length (salt length is checked later)
+            if self._pkey_size - algorithm.digest_size - 2 < 0:
+                raise ValueError(
+                    "Digest too large for key size. Check that you have the "
+                    "correct key and digest algorithm."
+                )
+
+            if not self._backend._mgf1_hash_supported(padding._mgf._algorithm):
+                raise UnsupportedAlgorithm(
+                    "When OpenSSL is older than 1.0.1 then only SHA1 is "
+                    "supported with MGF1.",
+                    _Reasons.UNSUPPORTED_HASH
+                )
+
+            if self._backend._lib.Cryptography_HAS_PKEY_CTX:
+                self._verify_method = self._verify_pkey_ctx
+                self._padding_enum = self._backend._lib.RSA_PKCS1_PSS_PADDING
+            else:
+                self._verify_method = self._verify_pss
+        else:
+            raise UnsupportedAlgorithm(
+                "{0} is not supported by this backend.".format(padding.name),
+                _Reasons.UNSUPPORTED_PADDING
+            )
+
+        self._padding = padding
+        self._algorithm = algorithm
+        self._hash_ctx = hashes.Hash(self._algorithm, self._backend)
+
+    def update(self, data):
+        self._hash_ctx.update(data)
+
+    def verify(self):
+        evp_md = self._backend._lib.EVP_get_digestbyname(
+            self._algorithm.name.encode("ascii"))
+        self._backend.openssl_assert(evp_md != self._backend._ffi.NULL)
+
+        self._verify_method(evp_md)
+
+    def _verify_pkey_ctx(self, evp_md):
+        pkey_ctx = self._backend._lib.EVP_PKEY_CTX_new(
+            self._public_key._evp_pkey, self._backend._ffi.NULL
+        )
+        self._backend.openssl_assert(pkey_ctx != self._backend._ffi.NULL)
+        pkey_ctx = self._backend._ffi.gc(pkey_ctx,
+                                         self._backend._lib.EVP_PKEY_CTX_free)
+        res = self._backend._lib.EVP_PKEY_verify_init(pkey_ctx)
+        self._backend.openssl_assert(res == 1)
+        res = self._backend._lib.EVP_PKEY_CTX_set_signature_md(
+            pkey_ctx, evp_md)
+        self._backend.openssl_assert(res > 0)
+
+        res = self._backend._lib.EVP_PKEY_CTX_set_rsa_padding(
+            pkey_ctx, self._padding_enum)
+        self._backend.openssl_assert(res > 0)
+        if isinstance(self._padding, PSS):
+            res = self._backend._lib.EVP_PKEY_CTX_set_rsa_pss_saltlen(
+                pkey_ctx,
+                _get_rsa_pss_salt_length(
+                    self._padding,
+                    self._public_key.key_size,
+                    self._hash_ctx.algorithm.digest_size
+                )
+            )
+            self._backend.openssl_assert(res > 0)
+            if self._backend._lib.Cryptography_HAS_MGF1_MD:
+                # MGF1 MD is configurable in OpenSSL 1.0.1+
+                mgf1_md = self._backend._lib.EVP_get_digestbyname(
+                    self._padding._mgf._algorithm.name.encode("ascii"))
+                self._backend.openssl_assert(
+                    mgf1_md != self._backend._ffi.NULL
+                )
+                res = self._backend._lib.EVP_PKEY_CTX_set_rsa_mgf1_md(
+                    pkey_ctx, mgf1_md
+                )
+                self._backend.openssl_assert(res > 0)
+
+        data_to_verify = self._hash_ctx.finalize()
+        res = self._backend._lib.EVP_PKEY_verify(
+            pkey_ctx,
+            self._signature,
+            len(self._signature),
+            data_to_verify,
+            len(data_to_verify)
+        )
+        # The previous call can return negative numbers in the event of an
+        # error. This is not a signature failure but we need to fail if it
+        # occurs.
+        self._backend.openssl_assert(res >= 0)
+        if res == 0:
+            errors = self._backend._consume_errors()
+            assert errors
+            raise InvalidSignature
+
+    def _verify_pkcs1(self, evp_md):
+        if self._hash_ctx._ctx is None:
+            raise AlreadyFinalized("Context has already been finalized.")
+
+        res = self._backend._lib.EVP_VerifyFinal(
+            self._hash_ctx._ctx._ctx,
+            self._signature,
+            len(self._signature),
+            self._public_key._evp_pkey
+        )
+        self._hash_ctx.finalize()
+        # The previous call can return negative numbers in the event of an
+        # error. This is not a signature failure but we need to fail if it
+        # occurs.
+        self._backend.openssl_assert(res >= 0)
+        if res == 0:
+            errors = self._backend._consume_errors()
+            assert errors
+            raise InvalidSignature
+
+    def _verify_pss(self, evp_md):
+        buf = self._backend._ffi.new("unsigned char[]", self._pkey_size)
+        res = self._backend._lib.RSA_public_decrypt(
+            len(self._signature),
+            self._signature,
+            buf,
+            self._public_key._rsa_cdata,
+            self._backend._lib.RSA_NO_PADDING
+        )
+        if res != self._pkey_size:
+            errors = self._backend._consume_errors()
+            assert errors
+            raise InvalidSignature
+
+        data_to_verify = self._hash_ctx.finalize()
+        res = self._backend._lib.RSA_verify_PKCS1_PSS(
+            self._public_key._rsa_cdata,
+            data_to_verify,
+            evp_md,
+            buf,
+            _get_rsa_pss_salt_length(
+                self._padding,
+                self._public_key.key_size,
+                len(data_to_verify)
+            )
+        )
+        if res != 1:
+            errors = self._backend._consume_errors()
+            assert errors
+            raise InvalidSignature
+
+
+@utils.register_interface(RSAPrivateKeyWithSerialization)
+class _RSAPrivateKey(object):
+    def __init__(self, backend, rsa_cdata, evp_pkey):
+        self._backend = backend
+        self._rsa_cdata = rsa_cdata
+        self._evp_pkey = evp_pkey
+
+        self._key_size = self._backend._lib.BN_num_bits(self._rsa_cdata.n)
+
+    key_size = utils.read_only_property("_key_size")
+
+    def signer(self, padding, algorithm):
+        return _RSASignatureContext(self._backend, self, padding, algorithm)
+
+    def decrypt(self, ciphertext, padding):
+        key_size_bytes = int(math.ceil(self.key_size / 8.0))
+        if key_size_bytes != len(ciphertext):
+            raise ValueError("Ciphertext length must be equal to key size.")
+
+        return _enc_dec_rsa(self._backend, self, ciphertext, padding)
+
+    def public_key(self):
+        ctx = self._backend._lib.RSA_new()
+        self._backend.openssl_assert(ctx != self._backend._ffi.NULL)
+        ctx = self._backend._ffi.gc(ctx, self._backend._lib.RSA_free)
+        ctx.e = self._backend._lib.BN_dup(self._rsa_cdata.e)
+        ctx.n = self._backend._lib.BN_dup(self._rsa_cdata.n)
+        res = self._backend._lib.RSA_blinding_on(ctx, self._backend._ffi.NULL)
+        self._backend.openssl_assert(res == 1)
+        evp_pkey = self._backend._rsa_cdata_to_evp_pkey(ctx)
+        return _RSAPublicKey(self._backend, ctx, evp_pkey)
+
+    def private_numbers(self):
+        return rsa.RSAPrivateNumbers(
+            p=self._backend._bn_to_int(self._rsa_cdata.p),
+            q=self._backend._bn_to_int(self._rsa_cdata.q),
+            d=self._backend._bn_to_int(self._rsa_cdata.d),
+            dmp1=self._backend._bn_to_int(self._rsa_cdata.dmp1),
+            dmq1=self._backend._bn_to_int(self._rsa_cdata.dmq1),
+            iqmp=self._backend._bn_to_int(self._rsa_cdata.iqmp),
+            public_numbers=rsa.RSAPublicNumbers(
+                e=self._backend._bn_to_int(self._rsa_cdata.e),
+                n=self._backend._bn_to_int(self._rsa_cdata.n),
+            )
+        )
+
+    def private_bytes(self, encoding, format, encryption_algorithm):
+        return self._backend._private_key_bytes(
+            encoding,
+            format,
+            encryption_algorithm,
+            self._evp_pkey,
+            self._rsa_cdata
+        )
+
+
+@utils.register_interface(RSAPublicKeyWithSerialization)
+class _RSAPublicKey(object):
+    def __init__(self, backend, rsa_cdata, evp_pkey):
+        self._backend = backend
+        self._rsa_cdata = rsa_cdata
+        self._evp_pkey = evp_pkey
+
+        self._key_size = self._backend._lib.BN_num_bits(self._rsa_cdata.n)
+
+    key_size = utils.read_only_property("_key_size")
+
+    def verifier(self, signature, padding, algorithm):
+        if not isinstance(signature, bytes):
+            raise TypeError("signature must be bytes.")
+
+        return _RSAVerificationContext(
+            self._backend, self, signature, padding, algorithm
+        )
+
+    def encrypt(self, plaintext, padding):
+        return _enc_dec_rsa(self._backend, self, plaintext, padding)
+
+    def public_numbers(self):
+        return rsa.RSAPublicNumbers(
+            e=self._backend._bn_to_int(self._rsa_cdata.e),
+            n=self._backend._bn_to_int(self._rsa_cdata.n),
+        )
+
+    def public_bytes(self, encoding, format):
+        return self._backend._public_key_bytes(
+            encoding,
+            format,
+            self._evp_pkey,
+            self._rsa_cdata
+        )
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/openssl/utils.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/openssl/utils.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/openssl/utils.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/openssl/utils.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,26 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import six
+
+
+def _truncate_digest(digest, order_bits):
+    digest_len = len(digest)
+
+    if 8 * digest_len > order_bits:
+        digest_len = (order_bits + 7) // 8
+        digest = digest[:digest_len]
+
+    if 8 * digest_len > order_bits:
+        rshift = 8 - (order_bits & 0x7)
+        assert 0 < rshift < 8
+
+        mask = 0xFF >> rshift << rshift
+
+        # Set the bottom rshift bits to 0
+        digest = digest[:-1] + six.int2byte(six.indexbytes(digest, -1) & mask)
+
+    return digest
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/openssl/x509.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/openssl/x509.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/openssl/x509.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/backends/openssl/x509.py	2015-11-19 05:01:40.000000000 +0100
@@ -0,0 +1,940 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import datetime
+import ipaddress
+
+from email.utils import parseaddr
+
+import idna
+
+import six
+
+from six.moves import urllib_parse
+
+from cryptography import utils, x509
+from cryptography.exceptions import UnsupportedAlgorithm
+from cryptography.hazmat.primitives import hashes, serialization
+from cryptography.x509.oid import (
+    CRLExtensionOID, CertificatePoliciesOID, ExtensionOID
+)
+
+
+def _obj2txt(backend, obj):
+    # Set to 80 on the recommendation of
+    # https://www.openssl.org/docs/crypto/OBJ_nid2ln.html#return_values
+    buf_len = 80
+    buf = backend._ffi.new("char[]", buf_len)
+    res = backend._lib.OBJ_obj2txt(buf, buf_len, obj, 1)
+    backend.openssl_assert(res > 0)
+    return backend._ffi.buffer(buf, res)[:].decode()
+
+
+def _decode_x509_name_entry(backend, x509_name_entry):
+    obj = backend._lib.X509_NAME_ENTRY_get_object(x509_name_entry)
+    backend.openssl_assert(obj != backend._ffi.NULL)
+    data = backend._lib.X509_NAME_ENTRY_get_data(x509_name_entry)
+    backend.openssl_assert(data != backend._ffi.NULL)
+    value = backend._asn1_string_to_utf8(data)
+    oid = _obj2txt(backend, obj)
+
+    return x509.NameAttribute(x509.ObjectIdentifier(oid), value)
+
+
+def _decode_x509_name(backend, x509_name):
+    count = backend._lib.X509_NAME_entry_count(x509_name)
+    attributes = []
+    for x in range(count):
+        entry = backend._lib.X509_NAME_get_entry(x509_name, x)
+        attributes.append(_decode_x509_name_entry(backend, entry))
+
+    return x509.Name(attributes)
+
+
+def _decode_general_names(backend, gns):
+    num = backend._lib.sk_GENERAL_NAME_num(gns)
+    names = []
+    for i in range(num):
+        gn = backend._lib.sk_GENERAL_NAME_value(gns, i)
+        backend.openssl_assert(gn != backend._ffi.NULL)
+        names.append(_decode_general_name(backend, gn))
+
+    return names
+
+
+def _decode_general_name(backend, gn):
+    if gn.type == backend._lib.GEN_DNS:
+        data = backend._asn1_string_to_bytes(gn.d.dNSName)
+        if not data:
+            decoded = u""
+        elif data.startswith(b"*."):
+            # This is a wildcard name. We need to remove the leading wildcard,
+            # IDNA decode, then re-add the wildcard. Wildcard characters should
+            # always be left-most (RFC 2595 section 2.4).
+            decoded = u"*." + idna.decode(data[2:])
+        else:
+            # Not a wildcard, decode away. If the string has a * in it anywhere
+            # invalid this will raise an InvalidCodePoint
+            decoded = idna.decode(data)
+            if data.startswith(b"."):
+                # idna strips leading periods. Name constraints can have that
+                # so we need to re-add it. Sigh.
+                decoded = u"." + decoded
+
+        return x509.DNSName(decoded)
+    elif gn.type == backend._lib.GEN_URI:
+        data = backend._asn1_string_to_ascii(gn.d.uniformResourceIdentifier)
+        parsed = urllib_parse.urlparse(data)
+        if parsed.hostname:
+            hostname = idna.decode(parsed.hostname)
+        else:
+            hostname = ""
+        if parsed.port:
+            netloc = hostname + u":" + six.text_type(parsed.port)
+        else:
+            netloc = hostname
+
+        # Note that building a URL in this fashion means it should be
+        # semantically indistinguishable from the original but is not
+        # guaranteed to be exactly the same.
+        uri = urllib_parse.urlunparse((
+            parsed.scheme,
+            netloc,
+            parsed.path,
+            parsed.params,
+            parsed.query,
+            parsed.fragment
+        ))
+        return x509.UniformResourceIdentifier(uri)
+    elif gn.type == backend._lib.GEN_RID:
+        oid = _obj2txt(backend, gn.d.registeredID)
+        return x509.RegisteredID(x509.ObjectIdentifier(oid))
+    elif gn.type == backend._lib.GEN_IPADD:
+        data = backend._asn1_string_to_bytes(gn.d.iPAddress)
+        data_len = len(data)
+        if data_len == 8 or data_len == 32:
+            # This is an IPv4 or IPv6 Network and not a single IP. This
+            # type of data appears in Name Constraints. Unfortunately,
+            # ipaddress doesn't support packed bytes + netmask. Additionally,
+            # IPv6Network can only handle CIDR rather than the full 16 byte
+            # netmask. To handle this we convert the netmask to integer, then
+            # find the first 0 bit, which will be the prefix. If another 1
+            # bit is present after that the netmask is invalid.
+            base = ipaddress.ip_address(data[:data_len // 2])
+            netmask = ipaddress.ip_address(data[data_len // 2:])
+            bits = bin(int(netmask))[2:]
+            prefix = bits.find('0')
+            # If no 0 bits are found it is a /32 or /128
+            if prefix == -1:
+                prefix = len(bits)
+
+            if "1" in bits[prefix:]:
+                raise ValueError("Invalid netmask")
+
+            ip = ipaddress.ip_network(base.exploded + u"/{0}".format(prefix))
+        else:
+            ip = ipaddress.ip_address(data)
+
+        return x509.IPAddress(ip)
+    elif gn.type == backend._lib.GEN_DIRNAME:
+        return x509.DirectoryName(
+            _decode_x509_name(backend, gn.d.directoryName)
+        )
+    elif gn.type == backend._lib.GEN_EMAIL:
+        data = backend._asn1_string_to_ascii(gn.d.rfc822Name)
+        name, address = parseaddr(data)
+        parts = address.split(u"@")
+        if name or not address:
+            # parseaddr has found a name (e.g. Name <email>) or the entire
+            # value is an empty string.
+            raise ValueError("Invalid rfc822name value")
+        elif len(parts) == 1:
+            # Single label email name. This is valid for local delivery. No
+            # IDNA decoding can be done since there is no domain component.
+            return x509.RFC822Name(address)
+        else:
+            # A normal email of the form user@domain.com. Let's attempt to
+            # decode the domain component and return the entire address.
+            return x509.RFC822Name(
+                parts[0] + u"@" + idna.decode(parts[1])
+            )
+    elif gn.type == backend._lib.GEN_OTHERNAME:
+        type_id = _obj2txt(backend, gn.d.otherName.type_id)
+        value = backend._asn1_to_der(gn.d.otherName.value)
+        return x509.OtherName(x509.ObjectIdentifier(type_id), value)
+    else:
+        # x400Address or ediPartyName
+        raise x509.UnsupportedGeneralNameType(
+            "{0} is not a supported type".format(
+                x509._GENERAL_NAMES.get(gn.type, gn.type)
+            ),
+            gn.type
+        )
+
+
+def _decode_ocsp_no_check(backend, ext):
+    return x509.OCSPNoCheck()
+
+
+class _X509ExtensionParser(object):
+    def __init__(self, ext_count, get_ext, handlers, unsupported_exts=None):
+        self.ext_count = ext_count
+        self.get_ext = get_ext
+        self.handlers = handlers
+        self.unsupported_exts = unsupported_exts
+
+    def parse(self, backend, x509_obj):
+        extensions = []
+        seen_oids = set()
+        for i in range(self.ext_count(backend, x509_obj)):
+            ext = self.get_ext(backend, x509_obj, i)
+            backend.openssl_assert(ext != backend._ffi.NULL)
+            crit = backend._lib.X509_EXTENSION_get_critical(ext)
+            critical = crit == 1
+            oid = x509.ObjectIdentifier(_obj2txt(backend, ext.object))
+            if oid in seen_oids:
+                raise x509.DuplicateExtension(
+                    "Duplicate {0} extension found".format(oid), oid
+                )
+            try:
+                handler = self.handlers[oid]
+            except KeyError:
+                if critical:
+                    raise x509.UnsupportedExtension(
+                        "Critical extension {0} is not currently supported"
+                        .format(oid), oid
+                    )
+            else:
+                # For extensions which are not supported by OpenSSL we pass the
+                # extension object directly to the parsing routine so it can
+                # be decoded manually.
+                if self.unsupported_exts and oid in self.unsupported_exts:
+                    ext_data = ext
+                else:
+                    ext_data = backend._lib.X509V3_EXT_d2i(ext)
+                    if ext_data == backend._ffi.NULL:
+                        backend._consume_errors()
+                        raise ValueError(
+                            "The {0} extension is invalid and can't be "
+                            "parsed".format(oid)
+                        )
+
+                value = handler(backend, ext_data)
+                extensions.append(x509.Extension(oid, critical, value))
+
+            seen_oids.add(oid)
+
+        return x509.Extensions(extensions)
+
+
+@utils.register_interface(x509.Certificate)
+class _Certificate(object):
+    def __init__(self, backend, x509):
+        self._backend = backend
+        self._x509 = x509
+
+    def __repr__(self):
+        return "<Certificate(subject={0}, ...)>".format(self.subject)
+
+    def __eq__(self, other):
+        if not isinstance(other, x509.Certificate):
+            return NotImplemented
+
+        res = self._backend._lib.X509_cmp(self._x509, other._x509)
+        return res == 0
+
+    def __ne__(self, other):
+        return not self == other
+
+    def __hash__(self):
+        return hash(self.public_bytes(serialization.Encoding.DER))
+
+    def fingerprint(self, algorithm):
+        h = hashes.Hash(algorithm, self._backend)
+        h.update(self.public_bytes(serialization.Encoding.DER))
+        return h.finalize()
+
+    @property
+    def version(self):
+        version = self._backend._lib.X509_get_version(self._x509)
+        if version == 0:
+            return x509.Version.v1
+        elif version == 2:
+            return x509.Version.v3
+        else:
+            raise x509.InvalidVersion(
+                "{0} is not a valid X509 version".format(version), version
+            )
+
+    @property
+    def serial(self):
+        asn1_int = self._backend._lib.X509_get_serialNumber(self._x509)
+        self._backend.openssl_assert(asn1_int != self._backend._ffi.NULL)
+        return self._backend._asn1_integer_to_int(asn1_int)
+
+    def public_key(self):
+        pkey = self._backend._lib.X509_get_pubkey(self._x509)
+        if pkey == self._backend._ffi.NULL:
+            # Remove errors from the stack.
+            self._backend._consume_errors()
+            raise ValueError("Certificate public key is of an unknown type")
+
+        pkey = self._backend._ffi.gc(pkey, self._backend._lib.EVP_PKEY_free)
+
+        return self._backend._evp_pkey_to_public_key(pkey)
+
+    @property
+    def not_valid_before(self):
+        asn1_time = self._backend._lib.X509_get_notBefore(self._x509)
+        return self._backend._parse_asn1_time(asn1_time)
+
+    @property
+    def not_valid_after(self):
+        asn1_time = self._backend._lib.X509_get_notAfter(self._x509)
+        return self._backend._parse_asn1_time(asn1_time)
+
+    @property
+    def issuer(self):
+        issuer = self._backend._lib.X509_get_issuer_name(self._x509)
+        self._backend.openssl_assert(issuer != self._backend._ffi.NULL)
+        return _decode_x509_name(self._backend, issuer)
+
+    @property
+    def subject(self):
+        subject = self._backend._lib.X509_get_subject_name(self._x509)
+        self._backend.openssl_assert(subject != self._backend._ffi.NULL)
+        return _decode_x509_name(self._backend, subject)
+
+    @property
+    def signature_hash_algorithm(self):
+        oid = _obj2txt(self._backend, self._x509.sig_alg.algorithm)
+        try:
+            return x509._SIG_OIDS_TO_HASH[oid]
+        except KeyError:
+            raise UnsupportedAlgorithm(
+                "Signature algorithm OID:{0} not recognized".format(oid)
+            )
+
+    @property
+    def extensions(self):
+        return _CERTIFICATE_EXTENSION_PARSER.parse(self._backend, self._x509)
+
+    def public_bytes(self, encoding):
+        bio = self._backend._create_mem_bio()
+        if encoding is serialization.Encoding.PEM:
+            res = self._backend._lib.PEM_write_bio_X509(bio, self._x509)
+        elif encoding is serialization.Encoding.DER:
+            res = self._backend._lib.i2d_X509_bio(bio, self._x509)
+        else:
+            raise TypeError("encoding must be an item from the Encoding enum")
+
+        self._backend.openssl_assert(res == 1)
+        return self._backend._read_mem_bio(bio)
+
+
+def _decode_certificate_policies(backend, cp):
+    cp = backend._ffi.cast("Cryptography_STACK_OF_POLICYINFO *", cp)
+    cp = backend._ffi.gc(cp, backend._lib.sk_POLICYINFO_free)
+    num = backend._lib.sk_POLICYINFO_num(cp)
+    certificate_policies = []
+    for i in range(num):
+        qualifiers = None
+        pi = backend._lib.sk_POLICYINFO_value(cp, i)
+        oid = x509.ObjectIdentifier(_obj2txt(backend, pi.policyid))
+        if pi.qualifiers != backend._ffi.NULL:
+            qnum = backend._lib.sk_POLICYQUALINFO_num(pi.qualifiers)
+            qualifiers = []
+            for j in range(qnum):
+                pqi = backend._lib.sk_POLICYQUALINFO_value(
+                    pi.qualifiers, j
+                )
+                pqualid = x509.ObjectIdentifier(
+                    _obj2txt(backend, pqi.pqualid)
+                )
+                if pqualid == CertificatePoliciesOID.CPS_QUALIFIER:
+                    cpsuri = backend._ffi.buffer(
+                        pqi.d.cpsuri.data, pqi.d.cpsuri.length
+                    )[:].decode('ascii')
+                    qualifiers.append(cpsuri)
+                else:
+                    assert pqualid == CertificatePoliciesOID.CPS_USER_NOTICE
+                    user_notice = _decode_user_notice(
+                        backend, pqi.d.usernotice
+                    )
+                    qualifiers.append(user_notice)
+
+        certificate_policies.append(
+            x509.PolicyInformation(oid, qualifiers)
+        )
+
+    return x509.CertificatePolicies(certificate_policies)
+
+
+def _decode_user_notice(backend, un):
+    explicit_text = None
+    notice_reference = None
+
+    if un.exptext != backend._ffi.NULL:
+        explicit_text = backend._asn1_string_to_utf8(un.exptext)
+
+    if un.noticeref != backend._ffi.NULL:
+        organization = backend._asn1_string_to_utf8(un.noticeref.organization)
+
+        num = backend._lib.sk_ASN1_INTEGER_num(
+            un.noticeref.noticenos
+        )
+        notice_numbers = []
+        for i in range(num):
+            asn1_int = backend._lib.sk_ASN1_INTEGER_value(
+                un.noticeref.noticenos, i
+            )
+            notice_num = backend._asn1_integer_to_int(asn1_int)
+            notice_numbers.append(notice_num)
+
+        notice_reference = x509.NoticeReference(
+            organization, notice_numbers
+        )
+
+    return x509.UserNotice(notice_reference, explicit_text)
+
+
+def _decode_basic_constraints(backend, bc_st):
+    basic_constraints = backend._ffi.cast("BASIC_CONSTRAINTS *", bc_st)
+    basic_constraints = backend._ffi.gc(
+        basic_constraints, backend._lib.BASIC_CONSTRAINTS_free
+    )
+    # The byte representation of an ASN.1 boolean true is \xff. OpenSSL
+    # chooses to just map this to its ordinal value, so true is 255 and
+    # false is 0.
+    ca = basic_constraints.ca == 255
+    if basic_constraints.pathlen == backend._ffi.NULL:
+        path_length = None
+    else:
+        path_length = backend._asn1_integer_to_int(basic_constraints.pathlen)
+
+    return x509.BasicConstraints(ca, path_length)
+
+
+def _decode_subject_key_identifier(backend, asn1_string):
+    asn1_string = backend._ffi.cast("ASN1_OCTET_STRING *", asn1_string)
+    asn1_string = backend._ffi.gc(
+        asn1_string, backend._lib.ASN1_OCTET_STRING_free
+    )
+    return x509.SubjectKeyIdentifier(
+        backend._ffi.buffer(asn1_string.data, asn1_string.length)[:]
+    )
+
+
+def _decode_authority_key_identifier(backend, akid):
+    akid = backend._ffi.cast("AUTHORITY_KEYID *", akid)
+    akid = backend._ffi.gc(akid, backend._lib.AUTHORITY_KEYID_free)
+    key_identifier = None
+    authority_cert_issuer = None
+    authority_cert_serial_number = None
+
+    if akid.keyid != backend._ffi.NULL:
+        key_identifier = backend._ffi.buffer(
+            akid.keyid.data, akid.keyid.length
+        )[:]
+
+    if akid.issuer != backend._ffi.NULL:
+        authority_cert_issuer = _decode_general_names(
+            backend, akid.issuer
+        )
+
+    if akid.serial != backend._ffi.NULL:
+        authority_cert_serial_number = backend._asn1_integer_to_int(
+            akid.serial
+        )
+
+    return x509.AuthorityKeyIdentifier(
+        key_identifier, authority_cert_issuer, authority_cert_serial_number
+    )
+
+
+def _decode_authority_information_access(backend, aia):
+    aia = backend._ffi.cast("Cryptography_STACK_OF_ACCESS_DESCRIPTION *", aia)
+    aia = backend._ffi.gc(aia, backend._lib.sk_ACCESS_DESCRIPTION_free)
+    num = backend._lib.sk_ACCESS_DESCRIPTION_num(aia)
+    access_descriptions = []
+    for i in range(num):
+        ad = backend._lib.sk_ACCESS_DESCRIPTION_value(aia, i)
+        backend.openssl_assert(ad.method != backend._ffi.NULL)
+        oid = x509.ObjectIdentifier(_obj2txt(backend, ad.method))
+        backend.openssl_assert(ad.location != backend._ffi.NULL)
+        gn = _decode_general_name(backend, ad.location)
+        access_descriptions.append(x509.AccessDescription(oid, gn))
+
+    return x509.AuthorityInformationAccess(access_descriptions)
+
+
+def _decode_key_usage(backend, bit_string):
+    bit_string = backend._ffi.cast("ASN1_BIT_STRING *", bit_string)
+    bit_string = backend._ffi.gc(bit_string, backend._lib.ASN1_BIT_STRING_free)
+    get_bit = backend._lib.ASN1_BIT_STRING_get_bit
+    digital_signature = get_bit(bit_string, 0) == 1
+    content_commitment = get_bit(bit_string, 1) == 1
+    key_encipherment = get_bit(bit_string, 2) == 1
+    data_encipherment = get_bit(bit_string, 3) == 1
+    key_agreement = get_bit(bit_string, 4) == 1
+    key_cert_sign = get_bit(bit_string, 5) == 1
+    crl_sign = get_bit(bit_string, 6) == 1
+    encipher_only = get_bit(bit_string, 7) == 1
+    decipher_only = get_bit(bit_string, 8) == 1
+    return x509.KeyUsage(
+        digital_signature,
+        content_commitment,
+        key_encipherment,
+        data_encipherment,
+        key_agreement,
+        key_cert_sign,
+        crl_sign,
+        encipher_only,
+        decipher_only
+    )
+
+
+def _decode_general_names_extension(backend, gns):
+    gns = backend._ffi.cast("GENERAL_NAMES *", gns)
+    gns = backend._ffi.gc(gns, backend._lib.GENERAL_NAMES_free)
+    general_names = _decode_general_names(backend, gns)
+    return general_names
+
+
+def _decode_subject_alt_name(backend, ext):
+    return x509.SubjectAlternativeName(
+        _decode_general_names_extension(backend, ext)
+    )
+
+
+def _decode_issuer_alt_name(backend, ext):
+    return x509.IssuerAlternativeName(
+        _decode_general_names_extension(backend, ext)
+    )
+
+
+def _decode_name_constraints(backend, nc):
+    nc = backend._ffi.cast("NAME_CONSTRAINTS *", nc)
+    nc = backend._ffi.gc(nc, backend._lib.NAME_CONSTRAINTS_free)
+    permitted = _decode_general_subtrees(backend, nc.permittedSubtrees)
+    excluded = _decode_general_subtrees(backend, nc.excludedSubtrees)
+    return x509.NameConstraints(
+        permitted_subtrees=permitted, excluded_subtrees=excluded
+    )
+
+
+def _decode_general_subtrees(backend, stack_subtrees):
+    if stack_subtrees == backend._ffi.NULL:
+        return None
+
+    num = backend._lib.sk_GENERAL_SUBTREE_num(stack_subtrees)
+    subtrees = []
+
+    for i in range(num):
+        obj = backend._lib.sk_GENERAL_SUBTREE_value(stack_subtrees, i)
+        backend.openssl_assert(obj != backend._ffi.NULL)
+        name = _decode_general_name(backend, obj.base)
+        subtrees.append(name)
+
+    return subtrees
+
+
+def _decode_extended_key_usage(backend, sk):
+    sk = backend._ffi.cast("Cryptography_STACK_OF_ASN1_OBJECT *", sk)
+    sk = backend._ffi.gc(sk, backend._lib.sk_ASN1_OBJECT_free)
+    num = backend._lib.sk_ASN1_OBJECT_num(sk)
+    ekus = []
+
+    for i in range(num):
+        obj = backend._lib.sk_ASN1_OBJECT_value(sk, i)
+        backend.openssl_assert(obj != backend._ffi.NULL)
+        oid = x509.ObjectIdentifier(_obj2txt(backend, obj))
+        ekus.append(oid)
+
+    return x509.ExtendedKeyUsage(ekus)
+
+
+_DISTPOINT_TYPE_FULLNAME = 0
+_DISTPOINT_TYPE_RELATIVENAME = 1
+
+
+def _decode_crl_distribution_points(backend, cdps):
+    cdps = backend._ffi.cast("Cryptography_STACK_OF_DIST_POINT *", cdps)
+    cdps = backend._ffi.gc(cdps, backend._lib.sk_DIST_POINT_free)
+    num = backend._lib.sk_DIST_POINT_num(cdps)
+
+    dist_points = []
+    for i in range(num):
+        full_name = None
+        relative_name = None
+        crl_issuer = None
+        reasons = None
+        cdp = backend._lib.sk_DIST_POINT_value(cdps, i)
+        if cdp.reasons != backend._ffi.NULL:
+            # We will check each bit from RFC 5280
+            # ReasonFlags ::= BIT STRING {
+            #      unused                  (0),
+            #      keyCompromise           (1),
+            #      cACompromise            (2),
+            #      affiliationChanged      (3),
+            #      superseded              (4),
+            #      cessationOfOperation    (5),
+            #      certificateHold         (6),
+            #      privilegeWithdrawn      (7),
+            #      aACompromise            (8) }
+            reasons = []
+            get_bit = backend._lib.ASN1_BIT_STRING_get_bit
+            if get_bit(cdp.reasons, 1):
+                reasons.append(x509.ReasonFlags.key_compromise)
+
+            if get_bit(cdp.reasons, 2):
+                reasons.append(x509.ReasonFlags.ca_compromise)
+
+            if get_bit(cdp.reasons, 3):
+                reasons.append(x509.ReasonFlags.affiliation_changed)
+
+            if get_bit(cdp.reasons, 4):
+                reasons.append(x509.ReasonFlags.superseded)
+
+            if get_bit(cdp.reasons, 5):
+                reasons.append(x509.ReasonFlags.cessation_of_operation)
+
+            if get_bit(cdp.reasons, 6):
+                reasons.append(x509.ReasonFlags.certificate_hold)
+
+            if get_bit(cdp.reasons, 7):
+                reasons.append(x509.ReasonFlags.privilege_withdrawn)
+
+            if get_bit(cdp.reasons, 8):
+                reasons.append(x509.ReasonFlags.aa_compromise)
+
+            reasons = frozenset(reasons)
+
+        if cdp.CRLissuer != backend._ffi.NULL:
+            crl_issuer = _decode_general_names(backend, cdp.CRLissuer)
+
+        # Certificates may have a crl_issuer/reasons and no distribution
+        # point so make sure it's not null.
+        if cdp.distpoint != backend._ffi.NULL:
+            # Type 0 is fullName, there is no #define for it in the code.
+            if cdp.distpoint.type == _DISTPOINT_TYPE_FULLNAME:
+                full_name = _decode_general_names(
+                    backend, cdp.distpoint.name.fullname
+                )
+            # OpenSSL code doesn't test for a specific type for
+            # relativename, everything that isn't fullname is considered
+            # relativename.
+            else:
+                rns = cdp.distpoint.name.relativename
+                rnum = backend._lib.sk_X509_NAME_ENTRY_num(rns)
+                attributes = []
+                for i in range(rnum):
+                    rn = backend._lib.sk_X509_NAME_ENTRY_value(
+                        rns, i
+                    )
+                    backend.openssl_assert(rn != backend._ffi.NULL)
+                    attributes.append(
+                        _decode_x509_name_entry(backend, rn)
+                    )
+
+                relative_name = x509.Name(attributes)
+
+        dist_points.append(
+            x509.DistributionPoint(
+                full_name, relative_name, reasons, crl_issuer
+            )
+        )
+
+    return x509.CRLDistributionPoints(dist_points)
+
+
+def _decode_inhibit_any_policy(backend, asn1_int):
+    asn1_int = backend._ffi.cast("ASN1_INTEGER *", asn1_int)
+    asn1_int = backend._ffi.gc(asn1_int, backend._lib.ASN1_INTEGER_free)
+    skip_certs = backend._asn1_integer_to_int(asn1_int)
+    return x509.InhibitAnyPolicy(skip_certs)
+
+
+_CRL_REASON_CODE_TO_ENUM = {
+    0: x509.ReasonFlags.unspecified,
+    1: x509.ReasonFlags.key_compromise,
+    2: x509.ReasonFlags.ca_compromise,
+    3: x509.ReasonFlags.affiliation_changed,
+    4: x509.ReasonFlags.superseded,
+    5: x509.ReasonFlags.cessation_of_operation,
+    6: x509.ReasonFlags.certificate_hold,
+    8: x509.ReasonFlags.remove_from_crl,
+    9: x509.ReasonFlags.privilege_withdrawn,
+    10: x509.ReasonFlags.aa_compromise,
+}
+
+
+def _decode_crl_reason(backend, enum):
+    enum = backend._ffi.cast("ASN1_ENUMERATED *", enum)
+    enum = backend._ffi.gc(enum, backend._lib.ASN1_ENUMERATED_free)
+    code = backend._lib.ASN1_ENUMERATED_get(enum)
+
+    try:
+        return _CRL_REASON_CODE_TO_ENUM[code]
+    except KeyError:
+        raise ValueError("Unsupported reason code: {0}".format(code))
+
+
+def _decode_invalidity_date(backend, inv_date):
+    generalized_time = backend._ffi.cast(
+        "ASN1_GENERALIZEDTIME *", inv_date
+    )
+    generalized_time = backend._ffi.gc(
+        generalized_time, backend._lib.ASN1_GENERALIZEDTIME_free
+    )
+    time = backend._ffi.string(
+        backend._lib.ASN1_STRING_data(
+            backend._ffi.cast("ASN1_STRING *", generalized_time)
+        )
+    ).decode("ascii")
+    return datetime.datetime.strptime(time, "%Y%m%d%H%M%SZ")
+
+
+def _decode_cert_issuer(backend, ext):
+    """
+    This handler decodes the CertificateIssuer entry extension directly
+    from the X509_EXTENSION object. This is necessary because this entry
+    extension is not directly supported by OpenSSL 0.9.8.
+    """
+
+    data_ptr_ptr = backend._ffi.new("const unsigned char **")
+    data_ptr_ptr[0] = ext.value.data
+    gns = backend._lib.d2i_GENERAL_NAMES(
+        backend._ffi.NULL, data_ptr_ptr, ext.value.length
+    )
+
+    # Check the result of d2i_GENERAL_NAMES() is valid. Usually this is covered
+    # in _X509ExtensionParser but since we are responsible for decoding this
+    # entry extension ourselves, we have to this here.
+    if gns == backend._ffi.NULL:
+        backend._consume_errors()
+        raise ValueError(
+            "The {0} extension is corrupted and can't be parsed".format(
+                CRLExtensionOID.CERTIFICATE_ISSUER))
+
+    gns = backend._ffi.gc(gns, backend._lib.GENERAL_NAMES_free)
+    return x509.GeneralNames(_decode_general_names(backend, gns))
+
+
+@utils.register_interface(x509.RevokedCertificate)
+class _RevokedCertificate(object):
+    def __init__(self, backend, x509_revoked):
+        self._backend = backend
+        self._x509_revoked = x509_revoked
+
+    @property
+    def serial_number(self):
+        asn1_int = self._x509_revoked.serialNumber
+        self._backend.openssl_assert(asn1_int != self._backend._ffi.NULL)
+        return self._backend._asn1_integer_to_int(asn1_int)
+
+    @property
+    def revocation_date(self):
+        return self._backend._parse_asn1_time(
+            self._x509_revoked.revocationDate)
+
+    @property
+    def extensions(self):
+        return _REVOKED_CERTIFICATE_EXTENSION_PARSER.parse(
+            self._backend, self._x509_revoked
+        )
+
+
+@utils.register_interface(x509.CertificateRevocationList)
+class _CertificateRevocationList(object):
+    def __init__(self, backend, x509_crl):
+        self._backend = backend
+        self._x509_crl = x509_crl
+
+    def __eq__(self, other):
+        if not isinstance(other, x509.CertificateRevocationList):
+            return NotImplemented
+
+        res = self._backend._lib.X509_CRL_cmp(self._x509_crl, other._x509_crl)
+        return res == 0
+
+    def __ne__(self, other):
+        return not self == other
+
+    def fingerprint(self, algorithm):
+        h = hashes.Hash(algorithm, self._backend)
+        bio = self._backend._create_mem_bio()
+        res = self._backend._lib.i2d_X509_CRL_bio(
+            bio, self._x509_crl
+        )
+        self._backend.openssl_assert(res == 1)
+        der = self._backend._read_mem_bio(bio)
+        h.update(der)
+        return h.finalize()
+
+    @property
+    def signature_hash_algorithm(self):
+        oid = _obj2txt(self._backend, self._x509_crl.sig_alg.algorithm)
+        try:
+            return x509._SIG_OIDS_TO_HASH[oid]
+        except KeyError:
+            raise UnsupportedAlgorithm(
+                "Signature algorithm OID:{0} not recognized".format(oid)
+            )
+
+    @property
+    def issuer(self):
+        issuer = self._backend._lib.X509_CRL_get_issuer(self._x509_crl)
+        self._backend.openssl_assert(issuer != self._backend._ffi.NULL)
+        return _decode_x509_name(self._backend, issuer)
+
+    @property
+    def next_update(self):
+        nu = self._backend._lib.X509_CRL_get_nextUpdate(self._x509_crl)
+        self._backend.openssl_assert(nu != self._backend._ffi.NULL)
+        return self._backend._parse_asn1_time(nu)
+
+    @property
+    def last_update(self):
+        lu = self._backend._lib.X509_CRL_get_lastUpdate(self._x509_crl)
+        self._backend.openssl_assert(lu != self._backend._ffi.NULL)
+        return self._backend._parse_asn1_time(lu)
+
+    def _revoked_certificates(self):
+        revoked = self._backend._lib.X509_CRL_get_REVOKED(self._x509_crl)
+        self._backend.openssl_assert(revoked != self._backend._ffi.NULL)
+
+        num = self._backend._lib.sk_X509_REVOKED_num(revoked)
+        revoked_list = []
+        for i in range(num):
+            r = self._backend._lib.sk_X509_REVOKED_value(revoked, i)
+            self._backend.openssl_assert(r != self._backend._ffi.NULL)
+            revoked_list.append(_RevokedCertificate(self._backend, r))
+
+        return revoked_list
+
+    def __iter__(self):
+        return iter(self._revoked_certificates())
+
+    def __getitem__(self, idx):
+        return self._revoked_certificates()[idx]
+
+    def __len__(self):
+        return len(self._revoked_certificates())
+
+    @property
+    def extensions(self):
+        raise NotImplementedError()
+
+
+@utils.register_interface(x509.CertificateSigningRequest)
+class _CertificateSigningRequest(object):
+    def __init__(self, backend, x509_req):
+        self._backend = backend
+        self._x509_req = x509_req
+
+    def __eq__(self, other):
+        if not isinstance(other, _CertificateSigningRequest):
+            return NotImplemented
+
+        self_bytes = self.public_bytes(serialization.Encoding.DER)
+        other_bytes = other.public_bytes(serialization.Encoding.DER)
+        return self_bytes == other_bytes
+
+    def __ne__(self, other):
+        return not self == other
+
+    def __hash__(self):
+        return hash(self.public_bytes(serialization.Encoding.DER))
+
+    def public_key(self):
+        pkey = self._backend._lib.X509_REQ_get_pubkey(self._x509_req)
+        self._backend.openssl_assert(pkey != self._backend._ffi.NULL)
+        pkey = self._backend._ffi.gc(pkey, self._backend._lib.EVP_PKEY_free)
+        return self._backend._evp_pkey_to_public_key(pkey)
+
+    @property
+    def subject(self):
+        subject = self._backend._lib.X509_REQ_get_subject_name(self._x509_req)
+        self._backend.openssl_assert(subject != self._backend._ffi.NULL)
+        return _decode_x509_name(self._backend, subject)
+
+    @property
+    def signature_hash_algorithm(self):
+        oid = _obj2txt(self._backend, self._x509_req.sig_alg.algorithm)
+        try:
+            return x509._SIG_OIDS_TO_HASH[oid]
+        except KeyError:
+            raise UnsupportedAlgorithm(
+                "Signature algorithm OID:{0} not recognized".format(oid)
+            )
+
+    @property
+    def extensions(self):
+        x509_exts = self._backend._lib.X509_REQ_get_extensions(self._x509_req)
+        return _CSR_EXTENSION_PARSER.parse(self._backend, x509_exts)
+
+    def public_bytes(self, encoding):
+        bio = self._backend._create_mem_bio()
+        if encoding is serialization.Encoding.PEM:
+            res = self._backend._lib.PEM_write_bio_X509_REQ(
+                bio, self._x509_req
+            )
+        elif encoding is serialization.Encoding.DER:
+            res = self._backend._lib.i2d_X509_REQ_bio(bio, self._x509_req)
+        else:
+            raise TypeError("encoding must be an item from the Encoding enum")
+
+        self._backend.openssl_assert(res == 1)
+        return self._backend._read_mem_bio(bio)
+
+
+_EXTENSION_HANDLERS = {
+    ExtensionOID.BASIC_CONSTRAINTS: _decode_basic_constraints,
+    ExtensionOID.SUBJECT_KEY_IDENTIFIER: _decode_subject_key_identifier,
+    ExtensionOID.KEY_USAGE: _decode_key_usage,
+    ExtensionOID.SUBJECT_ALTERNATIVE_NAME: _decode_subject_alt_name,
+    ExtensionOID.EXTENDED_KEY_USAGE: _decode_extended_key_usage,
+    ExtensionOID.AUTHORITY_KEY_IDENTIFIER: _decode_authority_key_identifier,
+    ExtensionOID.AUTHORITY_INFORMATION_ACCESS: (
+        _decode_authority_information_access
+    ),
+    ExtensionOID.CERTIFICATE_POLICIES: _decode_certificate_policies,
+    ExtensionOID.CRL_DISTRIBUTION_POINTS: _decode_crl_distribution_points,
+    ExtensionOID.OCSP_NO_CHECK: _decode_ocsp_no_check,
+    ExtensionOID.INHIBIT_ANY_POLICY: _decode_inhibit_any_policy,
+    ExtensionOID.ISSUER_ALTERNATIVE_NAME: _decode_issuer_alt_name,
+    ExtensionOID.NAME_CONSTRAINTS: _decode_name_constraints,
+}
+
+_REVOKED_EXTENSION_HANDLERS = {
+    CRLExtensionOID.CRL_REASON: _decode_crl_reason,
+    CRLExtensionOID.INVALIDITY_DATE: _decode_invalidity_date,
+    CRLExtensionOID.CERTIFICATE_ISSUER: _decode_cert_issuer,
+}
+
+_REVOKED_UNSUPPORTED_EXTENSIONS = set([
+    CRLExtensionOID.CERTIFICATE_ISSUER,
+])
+
+_CERTIFICATE_EXTENSION_PARSER = _X509ExtensionParser(
+    ext_count=lambda backend, x: backend._lib.X509_get_ext_count(x),
+    get_ext=lambda backend, x, i: backend._lib.X509_get_ext(x, i),
+    handlers=_EXTENSION_HANDLERS
+)
+
+_CSR_EXTENSION_PARSER = _X509ExtensionParser(
+    ext_count=lambda backend, x: backend._lib.sk_X509_EXTENSION_num(x),
+    get_ext=lambda backend, x, i: backend._lib.sk_X509_EXTENSION_value(x, i),
+    handlers=_EXTENSION_HANDLERS
+)
+
+_REVOKED_CERTIFICATE_EXTENSION_PARSER = _X509ExtensionParser(
+    ext_count=lambda backend, x: backend._lib.X509_REVOKED_get_ext_count(x),
+    get_ext=lambda backend, x, i: backend._lib.X509_REVOKED_get_ext(x, i),
+    handlers=_REVOKED_EXTENSION_HANDLERS,
+    unsupported_exts=_REVOKED_UNSUPPORTED_EXTENSIONS
+)
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/bindings/commoncrypto/binding.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/bindings/commoncrypto/binding.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/bindings/commoncrypto/binding.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/bindings/commoncrypto/binding.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,15 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+from cryptography.hazmat.bindings._commoncrypto import ffi, lib
+
+
+class Binding(object):
+    """
+    CommonCrypto API wrapper.
+    """
+    lib = lib
+    ffi = ffi
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/bindings/commoncrypto/__init__.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/bindings/commoncrypto/__init__.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/bindings/commoncrypto/__init__.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/bindings/commoncrypto/__init__.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,5 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/bindings/__init__.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/bindings/__init__.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/bindings/__init__.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/bindings/__init__.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,5 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/bindings/openssl/binding.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/bindings/openssl/binding.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/bindings/openssl/binding.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/bindings/openssl/binding.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,182 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import collections
+import os
+import threading
+import types
+
+from cryptography.exceptions import InternalError
+from cryptography.hazmat.bindings._openssl import ffi, lib
+from cryptography.hazmat.bindings.openssl._conditional import CONDITIONAL_NAMES
+
+
+_OpenSSLError = collections.namedtuple("_OpenSSLError",
+                                       ["code", "lib", "func", "reason"])
+
+
+def _consume_errors(lib):
+    errors = []
+    while True:
+        code = lib.ERR_get_error()
+        if code == 0:
+            break
+
+        err_lib = lib.ERR_GET_LIB(code)
+        err_func = lib.ERR_GET_FUNC(code)
+        err_reason = lib.ERR_GET_REASON(code)
+
+        errors.append(_OpenSSLError(code, err_lib, err_func, err_reason))
+    return errors
+
+
+def _openssl_assert(lib, ok):
+    if not ok:
+        errors = _consume_errors(lib)
+        raise InternalError(
+            "Unknown OpenSSL error. Please file an issue at https://github.com"
+            "/pyca/cryptography/issues with information on how to reproduce "
+            "this. ({0!r})".format(errors),
+            errors
+        )
+
+
+@ffi.callback("int (*)(unsigned char *, int)", error=-1)
+def _osrandom_rand_bytes(buf, size):
+    signed = ffi.cast("char *", buf)
+    result = os.urandom(size)
+    signed[0:size] = result
+    return 1
+
+
+@ffi.callback("int (*)(void)")
+def _osrandom_rand_status():
+    return 1
+
+
+def build_conditional_library(lib, conditional_names):
+    conditional_lib = types.ModuleType("lib")
+    excluded_names = set()
+    for condition, names in conditional_names.items():
+        if not getattr(lib, condition):
+            excluded_names |= set(names)
+
+    for attr in dir(lib):
+        if attr not in excluded_names:
+            setattr(conditional_lib, attr, getattr(lib, attr))
+
+    return conditional_lib
+
+
+class Binding(object):
+    """
+    OpenSSL API wrapper.
+    """
+    lib = None
+    ffi = ffi
+    _lib_loaded = False
+    _locks = None
+    _lock_cb_handle = None
+    _init_lock = threading.Lock()
+    _lock_init_lock = threading.Lock()
+
+    _osrandom_engine_id = ffi.new("const char[]", b"osrandom")
+    _osrandom_engine_name = ffi.new("const char[]", b"osrandom_engine")
+    _osrandom_method = ffi.new(
+        "RAND_METHOD *",
+        dict(bytes=_osrandom_rand_bytes, pseudorand=_osrandom_rand_bytes,
+             status=_osrandom_rand_status)
+    )
+
+    def __init__(self):
+        self._ensure_ffi_initialized()
+
+    @classmethod
+    def _register_osrandom_engine(cls):
+        _openssl_assert(cls.lib, cls.lib.ERR_peek_error() == 0)
+
+        engine = cls.lib.ENGINE_new()
+        _openssl_assert(cls.lib, engine != cls.ffi.NULL)
+        try:
+            result = cls.lib.ENGINE_set_id(engine, cls._osrandom_engine_id)
+            _openssl_assert(cls.lib, result == 1)
+            result = cls.lib.ENGINE_set_name(engine, cls._osrandom_engine_name)
+            _openssl_assert(cls.lib, result == 1)
+            result = cls.lib.ENGINE_set_RAND(engine, cls._osrandom_method)
+            _openssl_assert(cls.lib, result == 1)
+            result = cls.lib.ENGINE_add(engine)
+            if result != 1:
+                errors = _consume_errors(cls.lib)
+                _openssl_assert(
+                    cls.lib,
+                    errors[0].reason == cls.lib.ENGINE_R_CONFLICTING_ENGINE_ID
+                )
+
+        finally:
+            result = cls.lib.ENGINE_free(engine)
+            _openssl_assert(cls.lib, result == 1)
+
+    @classmethod
+    def _ensure_ffi_initialized(cls):
+        with cls._init_lock:
+            if not cls._lib_loaded:
+                cls.lib = build_conditional_library(lib, CONDITIONAL_NAMES)
+                cls._lib_loaded = True
+                # initialize the SSL library
+                cls.lib.SSL_library_init()
+                # adds all ciphers/digests for EVP
+                cls.lib.OpenSSL_add_all_algorithms()
+                # loads error strings for libcrypto and libssl functions
+                cls.lib.SSL_load_error_strings()
+                cls._register_osrandom_engine()
+
+    @classmethod
+    def init_static_locks(cls):
+        with cls._lock_init_lock:
+            cls._ensure_ffi_initialized()
+
+            if not cls._lock_cb_handle:
+                cls._lock_cb_handle = cls.ffi.callback(
+                    "void(int, int, const char *, int)",
+                    cls._lock_cb
+                )
+
+            # Use Python's implementation if available, importing _ssl triggers
+            # the setup for this.
+            __import__("_ssl")
+
+            if cls.lib.CRYPTO_get_locking_callback() != cls.ffi.NULL:
+                return
+
+            # If nothing else has setup a locking callback already, we set up
+            # our own
+            num_locks = cls.lib.CRYPTO_num_locks()
+            cls._locks = [threading.Lock() for n in range(num_locks)]
+
+            cls.lib.CRYPTO_set_locking_callback(cls._lock_cb_handle)
+
+    @classmethod
+    def _lock_cb(cls, mode, n, file, line):
+        lock = cls._locks[n]
+
+        if mode & cls.lib.CRYPTO_LOCK:
+            lock.acquire()
+        elif mode & cls.lib.CRYPTO_UNLOCK:
+            lock.release()
+        else:
+            raise RuntimeError(
+                "Unknown lock mode {0}: lock={1}, file={2}, line={3}.".format(
+                    mode, n, file, line
+                )
+            )
+
+
+# OpenSSL is not thread safe until the locks are initialized. We call this
+# method in module scope so that it executes with the import lock. On
+# Pythons < 3.4 this import lock is a global lock, which can prevent a race
+# condition registering the OpenSSL locks. On Python 3.4+ the import lock
+# is per module so this approach will not work.
+Binding.init_static_locks()
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/bindings/openssl/_conditional.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/bindings/openssl/_conditional.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/bindings/openssl/_conditional.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/bindings/openssl/_conditional.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,423 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+# This is a temporary copy of all the CONDITIONAL_NAMES from _cffi_src so
+# we can loop over them and delete them at runtime. It will be removed when
+# cffi supports #if in cdef
+
+CONDITIONAL_NAMES = {
+    "Cryptography_HAS_AES_WRAP": [
+        "AES_wrap_key",
+        "AES_unwrap_key",
+    ],
+    "Cryptography_HAS_CMAC": [
+        "CMAC_CTX_new",
+        "CMAC_Init",
+        "CMAC_Update",
+        "CMAC_Final",
+        "CMAC_CTX_copy",
+        "CMAC_CTX_free",
+    ],
+    "Cryptography_HAS_CMS": [
+        "BIO_new_CMS",
+        "i2d_CMS_bio_stream",
+        "PEM_write_bio_CMS_stream",
+        "CMS_final",
+        "CMS_sign",
+        "CMS_verify",
+        "CMS_encrypt",
+        "CMS_decrypt",
+        "CMS_add1_signer",
+        "CMS_TEXT",
+        "CMS_NOCERTS",
+        "CMS_NO_CONTENT_VERIFY",
+        "CMS_NO_ATTR_VERIFY",
+        "CMS_NOSIGS",
+        "CMS_NOINTERN",
+        "CMS_NO_SIGNER_CERT_VERIFY",
+        "CMS_NOVERIFY",
+        "CMS_DETACHED",
+        "CMS_BINARY",
+        "CMS_NOATTR",
+        "CMS_NOSMIMECAP",
+        "CMS_NOOLDMIMETYPE",
+        "CMS_CRLFEOL",
+        "CMS_STREAM",
+        "CMS_NOCRL",
+        "CMS_PARTIAL",
+        "CMS_REUSE_DIGEST",
+        "CMS_USE_KEYID",
+        "CMS_DEBUG_DECRYPT",
+    ],
+    "Cryptography_HAS_CMS_BIO_FUNCTIONS": [
+        "BIO_new_CMS",
+        "i2d_CMS_bio_stream",
+        "PEM_write_bio_CMS_stream",
+    ],
+    "Cryptography_HAS_EC": [
+        "OPENSSL_EC_NAMED_CURVE",
+        "EC_GROUP_new",
+        "EC_GROUP_free",
+        "EC_GROUP_clear_free",
+        "EC_GROUP_new_curve_GFp",
+        "EC_GROUP_new_by_curve_name",
+        "EC_GROUP_set_curve_GFp",
+        "EC_GROUP_get_curve_GFp",
+        "EC_GROUP_method_of",
+        "EC_GROUP_get0_generator",
+        "EC_GROUP_get_curve_name",
+        "EC_GROUP_get_degree",
+        "EC_GROUP_set_asn1_flag",
+        "EC_GROUP_set_point_conversion_form",
+        "EC_KEY_new",
+        "EC_KEY_free",
+        "EC_get_builtin_curves",
+        "EC_KEY_new_by_curve_name",
+        "EC_KEY_copy",
+        "EC_KEY_dup",
+        "EC_KEY_up_ref",
+        "EC_KEY_set_group",
+        "EC_KEY_get0_private_key",
+        "EC_KEY_set_private_key",
+        "EC_KEY_set_public_key",
+        "EC_KEY_get_enc_flags",
+        "EC_KEY_set_enc_flags",
+        "EC_KEY_set_conv_form",
+        "EC_KEY_get_key_method_data",
+        "EC_KEY_insert_key_method_data",
+        "EC_KEY_set_asn1_flag",
+        "EC_KEY_precompute_mult",
+        "EC_KEY_generate_key",
+        "EC_KEY_check_key",
+        "EC_POINT_new",
+        "EC_POINT_free",
+        "EC_POINT_clear_free",
+        "EC_POINT_copy",
+        "EC_POINT_dup",
+        "EC_POINT_method_of",
+        "EC_POINT_set_to_infinity",
+        "EC_POINT_set_Jprojective_coordinates_GFp",
+        "EC_POINT_get_Jprojective_coordinates_GFp",
+        "EC_POINT_set_affine_coordinates_GFp",
+        "EC_POINT_get_affine_coordinates_GFp",
+        "EC_POINT_set_compressed_coordinates_GFp",
+        "EC_POINT_point2oct",
+        "EC_POINT_oct2point",
+        "EC_POINT_point2bn",
+        "EC_POINT_bn2point",
+        "EC_POINT_point2hex",
+        "EC_POINT_hex2point",
+        "EC_POINT_add",
+        "EC_POINT_dbl",
+        "EC_POINT_invert",
+        "EC_POINT_is_at_infinity",
+        "EC_POINT_is_on_curve",
+        "EC_POINT_cmp",
+        "EC_POINT_make_affine",
+        "EC_POINTs_make_affine",
+        "EC_POINTs_mul",
+        "EC_POINT_mul",
+        "EC_GROUP_precompute_mult",
+        "EC_GROUP_have_precompute_mult",
+        "EC_GFp_simple_method",
+        "EC_GFp_mont_method",
+        "EC_GFp_nist_method",
+        "EC_METHOD_get_field_type",
+        "EVP_PKEY_assign_EC_KEY",
+        "EVP_PKEY_get1_EC_KEY",
+        "EVP_PKEY_set1_EC_KEY",
+        "PEM_write_bio_ECPrivateKey",
+        "i2d_EC_PUBKEY",
+        "d2i_EC_PUBKEY",
+        "d2i_EC_PUBKEY_bio",
+        "i2d_EC_PUBKEY_bio",
+        "d2i_ECPrivateKey",
+        "d2i_ECPrivateKey_bio",
+        "i2d_ECPrivateKey",
+        "i2d_ECPrivateKey_bio",
+        "i2o_ECPublicKey",
+        "o2i_ECPublicKey",
+        "SSL_CTX_set_tmp_ecdh",
+    ],
+
+    "Cryptography_HAS_EC_1_0_1": [
+        "EC_KEY_get_flags",
+        "EC_KEY_set_flags",
+        "EC_KEY_clear_flags",
+        "EC_KEY_set_public_key_affine_coordinates",
+    ],
+
+    "Cryptography_HAS_EC_NISTP_64_GCC_128": [
+        "EC_GFp_nistp224_method",
+        "EC_GFp_nistp256_method",
+        "EC_GFp_nistp521_method",
+    ],
+
+    "Cryptography_HAS_EC2M": [
+        "EC_GF2m_simple_method",
+        "EC_POINT_set_affine_coordinates_GF2m",
+        "EC_POINT_get_affine_coordinates_GF2m",
+        "EC_POINT_set_compressed_coordinates_GF2m",
+        "EC_GROUP_set_curve_GF2m",
+        "EC_GROUP_get_curve_GF2m",
+        "EC_GROUP_new_curve_GF2m",
+    ],
+
+    "Cryptography_HAS_EC_1_0_2": [
+        "EC_curve_nid2nist",
+    ],
+    "Cryptography_HAS_ECDH": [
+        "ECDH_compute_key",
+        "ECDH_get_ex_new_index",
+        "ECDH_set_ex_data",
+        "ECDH_get_ex_data",
+    ],
+    "Cryptography_HAS_ECDSA": [
+        "ECDSA_SIG_new",
+        "ECDSA_SIG_free",
+        "i2d_ECDSA_SIG",
+        "d2i_ECDSA_SIG",
+        "ECDSA_do_sign",
+        "ECDSA_do_sign_ex",
+        "ECDSA_do_verify",
+        "ECDSA_sign_setup",
+        "ECDSA_sign",
+        "ECDSA_sign_ex",
+        "ECDSA_verify",
+        "ECDSA_size",
+        "ECDSA_OpenSSL",
+        "ECDSA_set_default_method",
+        "ECDSA_get_default_method",
+        "ECDSA_set_method",
+        "ECDSA_get_ex_new_index",
+        "ECDSA_set_ex_data",
+        "ECDSA_get_ex_data",
+    ],
+    "Cryptography_HAS_ENGINE_CRYPTODEV": [
+        "ENGINE_load_cryptodev"
+    ],
+    "Cryptography_HAS_REMOVE_THREAD_STATE": [
+        "ERR_remove_thread_state"
+    ],
+    "Cryptography_HAS_098H_ERROR_CODES": [
+        "ASN1_F_B64_READ_ASN1",
+        "ASN1_F_B64_WRITE_ASN1",
+        "ASN1_F_SMIME_READ_ASN1",
+        "ASN1_F_SMIME_TEXT",
+        "ASN1_R_NO_CONTENT_TYPE",
+        "ASN1_R_NO_MULTIPART_BODY_FAILURE",
+        "ASN1_R_NO_MULTIPART_BOUNDARY",
+    ],
+    "Cryptography_HAS_098C_CAMELLIA_CODES": [
+        "EVP_F_CAMELLIA_INIT_KEY",
+        "EVP_R_CAMELLIA_KEY_SETUP_FAILED"
+    ],
+    "Cryptography_HAS_EC_CODES": [
+        "EC_R_UNKNOWN_GROUP",
+        "EC_F_EC_GROUP_NEW_BY_CURVE_NAME"
+    ],
+    "Cryptography_HAS_RSA_R_PKCS_DECODING_ERROR": [
+        "RSA_R_PKCS_DECODING_ERROR"
+    ],
+    "Cryptography_HAS_GCM": [
+        "EVP_CTRL_GCM_GET_TAG",
+        "EVP_CTRL_GCM_SET_TAG",
+        "EVP_CTRL_GCM_SET_IVLEN",
+    ],
+    "Cryptography_HAS_PBKDF2_HMAC": [
+        "PKCS5_PBKDF2_HMAC"
+    ],
+    "Cryptography_HAS_PKEY_CTX": [
+        "EVP_PKEY_CTX_new",
+        "EVP_PKEY_CTX_new_id",
+        "EVP_PKEY_CTX_dup",
+        "EVP_PKEY_CTX_free",
+        "EVP_PKEY_sign",
+        "EVP_PKEY_sign_init",
+        "EVP_PKEY_verify",
+        "EVP_PKEY_verify_init",
+        "Cryptography_EVP_PKEY_encrypt",
+        "EVP_PKEY_encrypt_init",
+        "Cryptography_EVP_PKEY_decrypt",
+        "EVP_PKEY_decrypt_init",
+        "EVP_PKEY_CTX_set_signature_md",
+        "EVP_PKEY_id",
+        "EVP_PKEY_CTX_set_rsa_padding",
+        "EVP_PKEY_CTX_set_rsa_pss_saltlen",
+    ],
+    "Cryptography_HAS_ECDSA_SHA2_NIDS": [
+        "NID_ecdsa_with_SHA224",
+        "NID_ecdsa_with_SHA256",
+        "NID_ecdsa_with_SHA384",
+        "NID_ecdsa_with_SHA512",
+    ],
+    "Cryptography_HAS_EGD": [
+        "RAND_egd",
+        "RAND_egd_bytes",
+        "RAND_query_egd_bytes",
+    ],
+    "Cryptography_HAS_PSS_PADDING": [
+        "RSA_PKCS1_PSS_PADDING",
+    ],
+    "Cryptography_HAS_MGF1_MD": [
+        "EVP_PKEY_CTX_set_rsa_mgf1_md",
+    ],
+    "Cryptography_HAS_TLSv1_1": [
+        "SSL_OP_NO_TLSv1_1",
+        "TLSv1_1_method",
+        "TLSv1_1_server_method",
+        "TLSv1_1_client_method",
+    ],
+
+    "Cryptography_HAS_TLSv1_2": [
+        "SSL_OP_NO_TLSv1_2",
+        "TLSv1_2_method",
+        "TLSv1_2_server_method",
+        "TLSv1_2_client_method",
+    ],
+
+    "Cryptography_HAS_SSL2": [
+        "SSLv2_method",
+        "SSLv2_client_method",
+        "SSLv2_server_method",
+    ],
+
+    "Cryptography_HAS_SSL3_METHOD": [
+        "SSLv3_method",
+        "SSLv3_client_method",
+        "SSLv3_server_method",
+    ],
+
+    "Cryptography_HAS_TLSEXT_HOSTNAME": [
+        "SSL_set_tlsext_host_name",
+        "SSL_get_servername",
+        "SSL_CTX_set_tlsext_servername_callback",
+    ],
+
+    "Cryptography_HAS_TLSEXT_STATUS_REQ_CB": [
+        "SSL_CTX_set_tlsext_status_cb",
+        "SSL_CTX_set_tlsext_status_arg"
+    ],
+
+    "Cryptography_HAS_STATUS_REQ_OCSP_RESP": [
+        "SSL_set_tlsext_status_ocsp_resp",
+        "SSL_get_tlsext_status_ocsp_resp",
+    ],
+
+    "Cryptography_HAS_TLSEXT_STATUS_REQ_TYPE": [
+        "SSL_set_tlsext_status_type",
+    ],
+
+    "Cryptography_HAS_RELEASE_BUFFERS": [
+        "SSL_MODE_RELEASE_BUFFERS",
+    ],
+
+    "Cryptography_HAS_OP_NO_COMPRESSION": [
+        "SSL_OP_NO_COMPRESSION",
+    ],
+
+    "Cryptography_HAS_SSL_OP_MSIE_SSLV2_RSA_PADDING": [
+        "SSL_OP_MSIE_SSLV2_RSA_PADDING",
+    ],
+
+    "Cryptography_HAS_SSL_OP_NO_TICKET": [
+        "SSL_OP_NO_TICKET",
+    ],
+
+    "Cryptography_HAS_SSL_SET_SSL_CTX": [
+        "SSL_set_SSL_CTX",
+        "TLSEXT_NAMETYPE_host_name",
+    ],
+
+    "Cryptography_HAS_NETBSD_D1_METH": [
+        "DTLSv1_method",
+    ],
+
+    "Cryptography_HAS_NEXTPROTONEG": [
+        "SSL_CTX_set_next_protos_advertised_cb",
+        "SSL_CTX_set_next_proto_select_cb",
+        "SSL_select_next_proto",
+        "SSL_get0_next_proto_negotiated",
+    ],
+
+    "Cryptography_HAS_SECURE_RENEGOTIATION": [
+        "SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION",
+        "SSL_OP_LEGACY_SERVER_CONNECT",
+        "SSL_get_secure_renegotiation_support",
+    ],
+
+    "Cryptography_HAS_ALPN": [
+        "SSL_CTX_set_alpn_protos",
+        "SSL_set_alpn_protos",
+        "SSL_CTX_set_alpn_select_cb",
+        "SSL_get0_alpn_selected",
+    ],
+
+    "Cryptography_HAS_COMPRESSION": [
+        "SSL_get_current_compression",
+        "SSL_get_current_expansion",
+        "SSL_COMP_get_name",
+    ],
+
+    "Cryptography_HAS_GET_SERVER_TMP_KEY": [
+        "SSL_get_server_tmp_key",
+    ],
+
+    "Cryptography_HAS_SSL_CTX_SET_CLIENT_CERT_ENGINE": [
+        "SSL_CTX_set_client_cert_engine",
+    ],
+    "Cryptography_HAS_102_VERIFICATION_ERROR_CODES": [
+        'X509_V_ERR_SUITE_B_INVALID_VERSION',
+        'X509_V_ERR_SUITE_B_INVALID_ALGORITHM',
+        'X509_V_ERR_SUITE_B_INVALID_CURVE',
+        'X509_V_ERR_SUITE_B_INVALID_SIGNATURE_ALGORITHM',
+        'X509_V_ERR_SUITE_B_LOS_NOT_ALLOWED',
+        'X509_V_ERR_SUITE_B_CANNOT_SIGN_P_384_WITH_P_256',
+        'X509_V_ERR_HOSTNAME_MISMATCH',
+        'X509_V_ERR_EMAIL_MISMATCH',
+        'X509_V_ERR_IP_ADDRESS_MISMATCH'
+    ],
+    "Cryptography_HAS_102_VERIFICATION_PARAMS": [
+        "X509_V_FLAG_SUITEB_128_LOS_ONLY",
+        "X509_V_FLAG_SUITEB_192_LOS",
+        "X509_V_FLAG_SUITEB_128_LOS",
+        "X509_VERIFY_PARAM_set1_host",
+        "X509_VERIFY_PARAM_set1_email",
+        "X509_VERIFY_PARAM_set1_ip",
+        "X509_VERIFY_PARAM_set1_ip_asc",
+        "X509_VERIFY_PARAM_set_hostflags",
+    ],
+    "Cryptography_HAS_X509_V_FLAG_TRUSTED_FIRST": [
+        "X509_V_FLAG_TRUSTED_FIRST",
+    ],
+    "Cryptography_HAS_X509_V_FLAG_PARTIAL_CHAIN": [
+        "X509_V_FLAG_PARTIAL_CHAIN",
+    ],
+    "Cryptography_HAS_100_VERIFICATION_ERROR_CODES": [
+        'X509_V_ERR_DIFFERENT_CRL_SCOPE',
+        'X509_V_ERR_UNSUPPORTED_EXTENSION_FEATURE',
+        'X509_V_ERR_UNNESTED_RESOURCE',
+        'X509_V_ERR_PERMITTED_VIOLATION',
+        'X509_V_ERR_EXCLUDED_VIOLATION',
+        'X509_V_ERR_SUBTREE_MINMAX',
+        'X509_V_ERR_UNSUPPORTED_CONSTRAINT_TYPE',
+        'X509_V_ERR_UNSUPPORTED_CONSTRAINT_SYNTAX',
+        'X509_V_ERR_UNSUPPORTED_NAME_SYNTAX',
+        'X509_V_ERR_CRL_PATH_VALIDATION_ERROR',
+    ],
+    "Cryptography_HAS_100_VERIFICATION_PARAMS": [
+        "Cryptography_HAS_100_VERIFICATION_PARAMS",
+        "X509_V_FLAG_EXTENDED_CRL_SUPPORT",
+        "X509_V_FLAG_USE_DELTAS",
+    ],
+    "Cryptography_HAS_X509_V_FLAG_CHECK_SS_SIGNATURE": [
+        "X509_V_FLAG_CHECK_SS_SIGNATURE",
+    ],
+    "Cryptography_HAS_SET_CERT_CB": [
+        "SSL_CTX_set_cert_cb",
+        "SSL_set_cert_cb",
+    ],
+}
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/bindings/openssl/__init__.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/bindings/openssl/__init__.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/bindings/openssl/__init__.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/bindings/openssl/__init__.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,5 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/__init__.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/__init__.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/__init__.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/__init__.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,5 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/asymmetric/dh.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/asymmetric/dh.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/asymmetric/dh.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/asymmetric/dh.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,166 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import abc
+
+import six
+
+from cryptography import utils
+
+
+class DHPrivateNumbers(object):
+    def __init__(self, x, public_numbers):
+        if not isinstance(x, six.integer_types):
+            raise TypeError("x must be an integer.")
+
+        if not isinstance(public_numbers, DHPublicNumbers):
+            raise TypeError("public_numbers must be an instance of "
+                            "DHPublicNumbers.")
+
+        self._x = x
+        self._public_numbers = public_numbers
+
+    def __eq__(self, other):
+        if not isinstance(other, DHPrivateNumbers):
+            return NotImplemented
+
+        return (
+            self._x == other._x and
+            self._public_numbers == other._public_numbers
+        )
+
+    def __ne__(self, other):
+        return not self == other
+
+    public_numbers = utils.read_only_property("_public_numbers")
+    x = utils.read_only_property("_x")
+
+
+class DHPublicNumbers(object):
+    def __init__(self, y, parameter_numbers):
+        if not isinstance(y, six.integer_types):
+            raise TypeError("y must be an integer.")
+
+        if not isinstance(parameter_numbers, DHParameterNumbers):
+            raise TypeError(
+                "parameters must be an instance of DHParameterNumbers.")
+
+        self._y = y
+        self._parameter_numbers = parameter_numbers
+
+    def __eq__(self, other):
+        if not isinstance(other, DHPublicNumbers):
+            return NotImplemented
+
+        return (
+            self._y == other._y and
+            self._parameter_numbers == other._parameter_numbers
+        )
+
+    def __ne__(self, other):
+        return not self == other
+
+    y = utils.read_only_property("_y")
+    parameter_numbers = utils.read_only_property("_parameter_numbers")
+
+
+class DHParameterNumbers(object):
+    def __init__(self, p, g):
+        if (
+            not isinstance(p, six.integer_types) or
+            not isinstance(g, six.integer_types)
+        ):
+            raise TypeError("p and g must be integers")
+
+        self._p = p
+        self._g = g
+
+    def __eq__(self, other):
+        if not isinstance(other, DHParameterNumbers):
+            return NotImplemented
+
+        return (
+            self._p == other._p and
+            self._g == other._g
+        )
+
+    def __ne__(self, other):
+        return not self == other
+
+    p = utils.read_only_property("_p")
+    g = utils.read_only_property("_g")
+
+
+@six.add_metaclass(abc.ABCMeta)
+class DHParameters(object):
+    @abc.abstractmethod
+    def generate_private_key(self):
+        """
+        Generates and returns a DHPrivateKey.
+        """
+
+
+@six.add_metaclass(abc.ABCMeta)
+class DHParametersWithSerialization(DHParameters):
+    @abc.abstractmethod
+    def parameter_numbers(self):
+        """
+        Returns a DHParameterNumbers.
+        """
+
+
+@six.add_metaclass(abc.ABCMeta)
+class DHPrivateKey(object):
+    @abc.abstractproperty
+    def key_size(self):
+        """
+        The bit length of the prime modulus.
+        """
+
+    @abc.abstractmethod
+    def public_key(self):
+        """
+        The DHPublicKey associated with this private key.
+        """
+
+    @abc.abstractmethod
+    def parameters(self):
+        """
+        The DHParameters object associated with this private key.
+        """
+
+
+@six.add_metaclass(abc.ABCMeta)
+class DHPrivateKeyWithSerialization(DHPrivateKey):
+    @abc.abstractmethod
+    def private_numbers(self):
+        """
+        Returns a DHPrivateNumbers.
+        """
+
+
+@six.add_metaclass(abc.ABCMeta)
+class DHPublicKey(object):
+    @abc.abstractproperty
+    def key_size(self):
+        """
+        The bit length of the prime modulus.
+        """
+
+    @abc.abstractmethod
+    def parameters(self):
+        """
+        The DHParameters object associated with this public key.
+        """
+
+
+@six.add_metaclass(abc.ABCMeta)
+class DHPublicKeyWithSerialization(DHPublicKey):
+    @abc.abstractmethod
+    def public_numbers(self):
+        """
+        Returns a DHPublicNumbers.
+        """
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/asymmetric/dsa.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/asymmetric/dsa.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/asymmetric/dsa.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/asymmetric/dsa.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,229 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import abc
+
+import six
+
+from cryptography import utils
+
+
+@six.add_metaclass(abc.ABCMeta)
+class DSAParameters(object):
+    @abc.abstractmethod
+    def generate_private_key(self):
+        """
+        Generates and returns a DSAPrivateKey.
+        """
+
+
+@six.add_metaclass(abc.ABCMeta)
+class DSAParametersWithNumbers(DSAParameters):
+    @abc.abstractmethod
+    def parameter_numbers(self):
+        """
+        Returns a DSAParameterNumbers.
+        """
+
+
+@six.add_metaclass(abc.ABCMeta)
+class DSAPrivateKey(object):
+    @abc.abstractproperty
+    def key_size(self):
+        """
+        The bit length of the prime modulus.
+        """
+
+    @abc.abstractmethod
+    def public_key(self):
+        """
+        The DSAPublicKey associated with this private key.
+        """
+
+    @abc.abstractmethod
+    def parameters(self):
+        """
+        The DSAParameters object associated with this private key.
+        """
+
+    @abc.abstractmethod
+    def signer(self, signature_algorithm):
+        """
+        Returns an AsymmetricSignatureContext used for signing data.
+        """
+
+
+@six.add_metaclass(abc.ABCMeta)
+class DSAPrivateKeyWithSerialization(DSAPrivateKey):
+    @abc.abstractmethod
+    def private_numbers(self):
+        """
+        Returns a DSAPrivateNumbers.
+        """
+
+    @abc.abstractmethod
+    def private_bytes(self, encoding, format, encryption_algorithm):
+        """
+        Returns the key serialized as bytes.
+        """
+
+
+@six.add_metaclass(abc.ABCMeta)
+class DSAPublicKey(object):
+    @abc.abstractproperty
+    def key_size(self):
+        """
+        The bit length of the prime modulus.
+        """
+
+    @abc.abstractmethod
+    def parameters(self):
+        """
+        The DSAParameters object associated with this public key.
+        """
+
+    @abc.abstractmethod
+    def verifier(self, signature, signature_algorithm):
+        """
+        Returns an AsymmetricVerificationContext used for signing data.
+        """
+
+    @abc.abstractmethod
+    def public_numbers(self):
+        """
+        Returns a DSAPublicNumbers.
+        """
+
+    @abc.abstractmethod
+    def public_bytes(self, encoding, format):
+        """
+        Returns the key serialized as bytes.
+        """
+
+
+DSAPublicKeyWithSerialization = DSAPublicKey
+
+
+def generate_parameters(key_size, backend):
+    return backend.generate_dsa_parameters(key_size)
+
+
+def generate_private_key(key_size, backend):
+    return backend.generate_dsa_private_key_and_parameters(key_size)
+
+
+def _check_dsa_parameters(parameters):
+    if utils.bit_length(parameters.p) not in [1024, 2048, 3072]:
+        raise ValueError("p must be exactly 1024, 2048, or 3072 bits long")
+    if utils.bit_length(parameters.q) not in [160, 256]:
+        raise ValueError("q must be exactly 160 or 256 bits long")
+
+    if not (1 < parameters.g < parameters.p):
+        raise ValueError("g, p don't satisfy 1 < g < p.")
+
+
+def _check_dsa_private_numbers(numbers):
+    parameters = numbers.public_numbers.parameter_numbers
+    _check_dsa_parameters(parameters)
+    if numbers.x <= 0 or numbers.x >= parameters.q:
+        raise ValueError("x must be > 0 and < q.")
+
+    if numbers.public_numbers.y != pow(parameters.g, numbers.x, parameters.p):
+        raise ValueError("y must be equal to (g ** x % p).")
+
+
+class DSAParameterNumbers(object):
+    def __init__(self, p, q, g):
+        if (
+            not isinstance(p, six.integer_types) or
+            not isinstance(q, six.integer_types) or
+            not isinstance(g, six.integer_types)
+        ):
+            raise TypeError(
+                "DSAParameterNumbers p, q, and g arguments must be integers."
+            )
+
+        self._p = p
+        self._q = q
+        self._g = g
+
+    p = utils.read_only_property("_p")
+    q = utils.read_only_property("_q")
+    g = utils.read_only_property("_g")
+
+    def parameters(self, backend):
+        return backend.load_dsa_parameter_numbers(self)
+
+    def __eq__(self, other):
+        if not isinstance(other, DSAParameterNumbers):
+            return NotImplemented
+
+        return self.p == other.p and self.q == other.q and self.g == other.g
+
+    def __ne__(self, other):
+        return not self == other
+
+
+class DSAPublicNumbers(object):
+    def __init__(self, y, parameter_numbers):
+        if not isinstance(y, six.integer_types):
+            raise TypeError("DSAPublicNumbers y argument must be an integer.")
+
+        if not isinstance(parameter_numbers, DSAParameterNumbers):
+            raise TypeError(
+                "parameter_numbers must be a DSAParameterNumbers instance."
+            )
+
+        self._y = y
+        self._parameter_numbers = parameter_numbers
+
+    y = utils.read_only_property("_y")
+    parameter_numbers = utils.read_only_property("_parameter_numbers")
+
+    def public_key(self, backend):
+        return backend.load_dsa_public_numbers(self)
+
+    def __eq__(self, other):
+        if not isinstance(other, DSAPublicNumbers):
+            return NotImplemented
+
+        return (
+            self.y == other.y and
+            self.parameter_numbers == other.parameter_numbers
+        )
+
+    def __ne__(self, other):
+        return not self == other
+
+
+class DSAPrivateNumbers(object):
+    def __init__(self, x, public_numbers):
+        if not isinstance(x, six.integer_types):
+            raise TypeError("DSAPrivateNumbers x argument must be an integer.")
+
+        if not isinstance(public_numbers, DSAPublicNumbers):
+            raise TypeError(
+                "public_numbers must be a DSAPublicNumbers instance."
+            )
+        self._public_numbers = public_numbers
+        self._x = x
+
+    x = utils.read_only_property("_x")
+    public_numbers = utils.read_only_property("_public_numbers")
+
+    def private_key(self, backend):
+        return backend.load_dsa_private_numbers(self)
+
+    def __eq__(self, other):
+        if not isinstance(other, DSAPrivateNumbers):
+            return NotImplemented
+
+        return (
+            self.x == other.x and self.public_numbers == other.public_numbers
+        )
+
+    def __ne__(self, other):
+        return not self == other
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/asymmetric/ec.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/asymmetric/ec.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/asymmetric/ec.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/asymmetric/ec.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,346 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import abc
+
+import six
+
+from cryptography import utils
+
+
+@six.add_metaclass(abc.ABCMeta)
+class EllipticCurve(object):
+    @abc.abstractproperty
+    def name(self):
+        """
+        The name of the curve. e.g. secp256r1.
+        """
+
+    @abc.abstractproperty
+    def key_size(self):
+        """
+        The bit length of the base point of the curve.
+        """
+
+
+@six.add_metaclass(abc.ABCMeta)
+class EllipticCurveSignatureAlgorithm(object):
+    @abc.abstractproperty
+    def algorithm(self):
+        """
+        The digest algorithm used with this signature.
+        """
+
+
+@six.add_metaclass(abc.ABCMeta)
+class EllipticCurvePrivateKey(object):
+    @abc.abstractmethod
+    def signer(self, signature_algorithm):
+        """
+        Returns an AsymmetricSignatureContext used for signing data.
+        """
+
+    @abc.abstractmethod
+    def exchange(self, algorithm, peer_public_key):
+        """
+        Performs a key exchange operation using the provided algorithm with the
+        provided peer's public key.
+        """
+
+    @abc.abstractmethod
+    def public_key(self):
+        """
+        The EllipticCurvePublicKey for this private key.
+        """
+
+    @abc.abstractproperty
+    def curve(self):
+        """
+        The EllipticCurve that this key is on.
+        """
+
+
+@six.add_metaclass(abc.ABCMeta)
+class EllipticCurvePrivateKeyWithSerialization(EllipticCurvePrivateKey):
+    @abc.abstractmethod
+    def private_numbers(self):
+        """
+        Returns an EllipticCurvePrivateNumbers.
+        """
+
+    @abc.abstractmethod
+    def private_bytes(self, encoding, format, encryption_algorithm):
+        """
+        Returns the key serialized as bytes.
+        """
+
+
+@six.add_metaclass(abc.ABCMeta)
+class EllipticCurvePublicKey(object):
+    @abc.abstractmethod
+    def verifier(self, signature, signature_algorithm):
+        """
+        Returns an AsymmetricVerificationContext used for signing data.
+        """
+
+    @abc.abstractproperty
+    def curve(self):
+        """
+        The EllipticCurve that this key is on.
+        """
+
+    @abc.abstractmethod
+    def public_numbers(self):
+        """
+        Returns an EllipticCurvePublicNumbers.
+        """
+
+    @abc.abstractmethod
+    def public_bytes(self, encoding, format):
+        """
+        Returns the key serialized as bytes.
+        """
+
+
+EllipticCurvePublicKeyWithSerialization = EllipticCurvePublicKey
+
+
+@utils.register_interface(EllipticCurve)
+class SECT571R1(object):
+    name = "sect571r1"
+    key_size = 571
+
+
+@utils.register_interface(EllipticCurve)
+class SECT409R1(object):
+    name = "sect409r1"
+    key_size = 409
+
+
+@utils.register_interface(EllipticCurve)
+class SECT283R1(object):
+    name = "sect283r1"
+    key_size = 283
+
+
+@utils.register_interface(EllipticCurve)
+class SECT233R1(object):
+    name = "sect233r1"
+    key_size = 233
+
+
+@utils.register_interface(EllipticCurve)
+class SECT163R2(object):
+    name = "sect163r2"
+    key_size = 163
+
+
+@utils.register_interface(EllipticCurve)
+class SECT571K1(object):
+    name = "sect571k1"
+    key_size = 571
+
+
+@utils.register_interface(EllipticCurve)
+class SECT409K1(object):
+    name = "sect409k1"
+    key_size = 409
+
+
+@utils.register_interface(EllipticCurve)
+class SECT283K1(object):
+    name = "sect283k1"
+    key_size = 283
+
+
+@utils.register_interface(EllipticCurve)
+class SECT233K1(object):
+    name = "sect233k1"
+    key_size = 233
+
+
+@utils.register_interface(EllipticCurve)
+class SECT163K1(object):
+    name = "sect163k1"
+    key_size = 163
+
+
+@utils.register_interface(EllipticCurve)
+class SECP521R1(object):
+    name = "secp521r1"
+    key_size = 521
+
+
+@utils.register_interface(EllipticCurve)
+class SECP384R1(object):
+    name = "secp384r1"
+    key_size = 384
+
+
+@utils.register_interface(EllipticCurve)
+class SECP256R1(object):
+    name = "secp256r1"
+    key_size = 256
+
+
+@utils.register_interface(EllipticCurve)
+class SECP256K1(object):
+    name = "secp256k1"
+    key_size = 256
+
+
+@utils.register_interface(EllipticCurve)
+class SECP224R1(object):
+    name = "secp224r1"
+    key_size = 224
+
+
+@utils.register_interface(EllipticCurve)
+class SECP192R1(object):
+    name = "secp192r1"
+    key_size = 192
+
+
+_CURVE_TYPES = {
+    "prime192v1": SECP192R1,
+    "prime256v1": SECP256R1,
+
+    "secp192r1": SECP192R1,
+    "secp224r1": SECP224R1,
+    "secp256r1": SECP256R1,
+    "secp384r1": SECP384R1,
+    "secp521r1": SECP521R1,
+    "secp256k1": SECP256K1,
+
+    "sect163k1": SECT163K1,
+    "sect233k1": SECT233K1,
+    "sect283k1": SECT283K1,
+    "sect409k1": SECT409K1,
+    "sect571k1": SECT571K1,
+
+    "sect163r2": SECT163R2,
+    "sect233r1": SECT233R1,
+    "sect283r1": SECT283R1,
+    "sect409r1": SECT409R1,
+    "sect571r1": SECT571R1,
+}
+
+
+@utils.register_interface(EllipticCurveSignatureAlgorithm)
+class ECDSA(object):
+    def __init__(self, algorithm):
+        self._algorithm = algorithm
+
+    algorithm = utils.read_only_property("_algorithm")
+
+
+def generate_private_key(curve, backend):
+    return backend.generate_elliptic_curve_private_key(curve)
+
+
+class EllipticCurvePublicNumbers(object):
+    def __init__(self, x, y, curve):
+        if (
+            not isinstance(x, six.integer_types) or
+            not isinstance(y, six.integer_types)
+        ):
+            raise TypeError("x and y must be integers.")
+
+        if not isinstance(curve, EllipticCurve):
+            raise TypeError("curve must provide the EllipticCurve interface.")
+
+        self._y = y
+        self._x = x
+        self._curve = curve
+
+    def public_key(self, backend):
+        return backend.load_elliptic_curve_public_numbers(self)
+
+    def encode_point(self):
+        # key_size is in bits. Convert to bytes and round up
+        byte_length = (self.curve.key_size + 7) // 8
+        return (
+            b'\x04' + utils.int_to_bytes(self.x, byte_length) +
+            utils.int_to_bytes(self.y, byte_length)
+        )
+
+    @classmethod
+    def from_encoded_point(cls, curve, data):
+        if not isinstance(curve, EllipticCurve):
+            raise TypeError("curve must be an EllipticCurve instance")
+
+        if data.startswith(b'\x04'):
+            # key_size is in bits. Convert to bytes and round up
+            byte_length = (curve.key_size + 7) // 8
+            if len(data) == 2 * byte_length + 1:
+                x = utils.int_from_bytes(data[1:byte_length + 1], 'big')
+                y = utils.int_from_bytes(data[byte_length + 1:], 'big')
+                return cls(x, y, curve)
+            else:
+                raise ValueError('Invalid elliptic curve point data length')
+        else:
+            raise ValueError('Unsupported elliptic curve point type')
+
+    curve = utils.read_only_property("_curve")
+    x = utils.read_only_property("_x")
+    y = utils.read_only_property("_y")
+
+    def __eq__(self, other):
+        if not isinstance(other, EllipticCurvePublicNumbers):
+            return NotImplemented
+
+        return (
+            self.x == other.x and
+            self.y == other.y and
+            self.curve.name == other.curve.name and
+            self.curve.key_size == other.curve.key_size
+        )
+
+    def __ne__(self, other):
+        return not self == other
+
+    def __repr__(self):
+        return (
+            "<EllipticCurvePublicNumbers(curve={0.curve.name}, x={0.x}, "
+            "y={0.y}>".format(self)
+        )
+
+
+class EllipticCurvePrivateNumbers(object):
+    def __init__(self, private_value, public_numbers):
+        if not isinstance(private_value, six.integer_types):
+            raise TypeError("private_value must be an integer.")
+
+        if not isinstance(public_numbers, EllipticCurvePublicNumbers):
+            raise TypeError(
+                "public_numbers must be an EllipticCurvePublicNumbers "
+                "instance."
+            )
+
+        self._private_value = private_value
+        self._public_numbers = public_numbers
+
+    def private_key(self, backend):
+        return backend.load_elliptic_curve_private_numbers(self)
+
+    private_value = utils.read_only_property("_private_value")
+    public_numbers = utils.read_only_property("_public_numbers")
+
+    def __eq__(self, other):
+        if not isinstance(other, EllipticCurvePrivateNumbers):
+            return NotImplemented
+
+        return (
+            self.private_value == other.private_value and
+            self.public_numbers == other.public_numbers
+        )
+
+    def __ne__(self, other):
+        return not self == other
+
+
+class ECDH(object):
+    pass
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/asymmetric/__init__.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/asymmetric/__init__.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/asymmetric/__init__.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/asymmetric/__init__.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,40 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import abc
+
+import six
+
+
+@six.add_metaclass(abc.ABCMeta)
+class AsymmetricSignatureContext(object):
+    @abc.abstractmethod
+    def update(self, data):
+        """
+        Processes the provided bytes and returns nothing.
+        """
+
+    @abc.abstractmethod
+    def finalize(self):
+        """
+        Returns the signature as bytes.
+        """
+
+
+@six.add_metaclass(abc.ABCMeta)
+class AsymmetricVerificationContext(object):
+    @abc.abstractmethod
+    def update(self, data):
+        """
+        Processes the provided bytes and returns nothing.
+        """
+
+    @abc.abstractmethod
+    def verify(self):
+        """
+        Raises an exception if the bytes provided to update do not match the
+        signature or the signature does not match the public key.
+        """
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/asymmetric/padding.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/asymmetric/padding.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/asymmetric/padding.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/asymmetric/padding.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,67 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import abc
+
+import six
+
+from cryptography import utils
+from cryptography.hazmat.primitives import hashes
+
+
+@six.add_metaclass(abc.ABCMeta)
+class AsymmetricPadding(object):
+    @abc.abstractproperty
+    def name(self):
+        """
+        A string naming this padding (e.g. "PSS", "PKCS1").
+        """
+
+
+@utils.register_interface(AsymmetricPadding)
+class PKCS1v15(object):
+    name = "EMSA-PKCS1-v1_5"
+
+
+@utils.register_interface(AsymmetricPadding)
+class PSS(object):
+    MAX_LENGTH = object()
+    name = "EMSA-PSS"
+
+    def __init__(self, mgf, salt_length):
+        self._mgf = mgf
+
+        if (not isinstance(salt_length, six.integer_types) and
+                salt_length is not self.MAX_LENGTH):
+            raise TypeError("salt_length must be an integer.")
+
+        if salt_length is not self.MAX_LENGTH and salt_length < 0:
+            raise ValueError("salt_length must be zero or greater.")
+
+        self._salt_length = salt_length
+
+
+@utils.register_interface(AsymmetricPadding)
+class OAEP(object):
+    name = "EME-OAEP"
+
+    def __init__(self, mgf, algorithm, label):
+        if not isinstance(algorithm, hashes.HashAlgorithm):
+            raise TypeError("Expected instance of hashes.HashAlgorithm.")
+
+        self._mgf = mgf
+        self._algorithm = algorithm
+        self._label = label
+
+
+class MGF1(object):
+    MAX_LENGTH = object()
+
+    def __init__(self, algorithm):
+        if not isinstance(algorithm, hashes.HashAlgorithm):
+            raise TypeError("Expected instance of hashes.HashAlgorithm.")
+
+        self._algorithm = algorithm
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/asymmetric/rsa.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/asymmetric/rsa.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/asymmetric/rsa.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/asymmetric/rsa.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,352 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import abc
+from fractions import gcd
+
+import six
+
+from cryptography import utils
+from cryptography.exceptions import UnsupportedAlgorithm, _Reasons
+from cryptography.hazmat.backends.interfaces import RSABackend
+
+
+@six.add_metaclass(abc.ABCMeta)
+class RSAPrivateKey(object):
+    @abc.abstractmethod
+    def signer(self, padding, algorithm):
+        """
+        Returns an AsymmetricSignatureContext used for signing data.
+        """
+
+    @abc.abstractmethod
+    def decrypt(self, ciphertext, padding):
+        """
+        Decrypts the provided ciphertext.
+        """
+
+    @abc.abstractproperty
+    def key_size(self):
+        """
+        The bit length of the public modulus.
+        """
+
+    @abc.abstractmethod
+    def public_key(self):
+        """
+        The RSAPublicKey associated with this private key.
+        """
+
+
+@six.add_metaclass(abc.ABCMeta)
+class RSAPrivateKeyWithSerialization(RSAPrivateKey):
+    @abc.abstractmethod
+    def private_numbers(self):
+        """
+        Returns an RSAPrivateNumbers.
+        """
+
+    @abc.abstractmethod
+    def private_bytes(self, encoding, format, encryption_algorithm):
+        """
+        Returns the key serialized as bytes.
+        """
+
+
+@six.add_metaclass(abc.ABCMeta)
+class RSAPublicKey(object):
+    @abc.abstractmethod
+    def verifier(self, signature, padding, algorithm):
+        """
+        Returns an AsymmetricVerificationContext used for verifying signatures.
+        """
+
+    @abc.abstractmethod
+    def encrypt(self, plaintext, padding):
+        """
+        Encrypts the given plaintext.
+        """
+
+    @abc.abstractproperty
+    def key_size(self):
+        """
+        The bit length of the public modulus.
+        """
+
+    @abc.abstractmethod
+    def public_numbers(self):
+        """
+        Returns an RSAPublicNumbers
+        """
+
+    @abc.abstractmethod
+    def public_bytes(self, encoding, format):
+        """
+        Returns the key serialized as bytes.
+        """
+
+
+RSAPublicKeyWithSerialization = RSAPublicKey
+
+
+def generate_private_key(public_exponent, key_size, backend):
+    if not isinstance(backend, RSABackend):
+        raise UnsupportedAlgorithm(
+            "Backend object does not implement RSABackend.",
+            _Reasons.BACKEND_MISSING_INTERFACE
+        )
+
+    _verify_rsa_parameters(public_exponent, key_size)
+    return backend.generate_rsa_private_key(public_exponent, key_size)
+
+
+def _verify_rsa_parameters(public_exponent, key_size):
+    if public_exponent < 3:
+        raise ValueError("public_exponent must be >= 3.")
+
+    if public_exponent & 1 == 0:
+        raise ValueError("public_exponent must be odd.")
+
+    if key_size < 512:
+        raise ValueError("key_size must be at least 512-bits.")
+
+
+def _check_private_key_components(p, q, private_exponent, dmp1, dmq1, iqmp,
+                                  public_exponent, modulus):
+    if modulus < 3:
+        raise ValueError("modulus must be >= 3.")
+
+    if p >= modulus:
+        raise ValueError("p must be < modulus.")
+
+    if q >= modulus:
+        raise ValueError("q must be < modulus.")
+
+    if dmp1 >= modulus:
+        raise ValueError("dmp1 must be < modulus.")
+
+    if dmq1 >= modulus:
+        raise ValueError("dmq1 must be < modulus.")
+
+    if iqmp >= modulus:
+        raise ValueError("iqmp must be < modulus.")
+
+    if private_exponent >= modulus:
+        raise ValueError("private_exponent must be < modulus.")
+
+    if public_exponent < 3 or public_exponent >= modulus:
+        raise ValueError("public_exponent must be >= 3 and < modulus.")
+
+    if public_exponent & 1 == 0:
+        raise ValueError("public_exponent must be odd.")
+
+    if dmp1 & 1 == 0:
+        raise ValueError("dmp1 must be odd.")
+
+    if dmq1 & 1 == 0:
+        raise ValueError("dmq1 must be odd.")
+
+    if p * q != modulus:
+        raise ValueError("p*q must equal modulus.")
+
+
+def _check_public_key_components(e, n):
+    if n < 3:
+        raise ValueError("n must be >= 3.")
+
+    if e < 3 or e >= n:
+        raise ValueError("e must be >= 3 and < n.")
+
+    if e & 1 == 0:
+        raise ValueError("e must be odd.")
+
+
+def _modinv(e, m):
+    """
+    Modular Multiplicative Inverse. Returns x such that: (x*e) mod m == 1
+    """
+    x1, y1, x2, y2 = 1, 0, 0, 1
+    a, b = e, m
+    while b > 0:
+        q, r = divmod(a, b)
+        xn, yn = x1 - q * x2, y1 - q * y2
+        a, b, x1, y1, x2, y2 = b, r, x2, y2, xn, yn
+    return x1 % m
+
+
+def rsa_crt_iqmp(p, q):
+    """
+    Compute the CRT (q ** -1) % p value from RSA primes p and q.
+    """
+    return _modinv(q, p)
+
+
+def rsa_crt_dmp1(private_exponent, p):
+    """
+    Compute the CRT private_exponent % (p - 1) value from the RSA
+    private_exponent and p.
+    """
+    return private_exponent % (p - 1)
+
+
+def rsa_crt_dmq1(private_exponent, q):
+    """
+    Compute the CRT private_exponent % (q - 1) value from the RSA
+    private_exponent and q.
+    """
+    return private_exponent % (q - 1)
+
+
+# Controls the number of iterations rsa_recover_prime_factors will perform
+# to obtain the prime factors. Each iteration increments by 2 so the actual
+# maximum attempts is half this number.
+_MAX_RECOVERY_ATTEMPTS = 1000
+
+
+def rsa_recover_prime_factors(n, e, d):
+    """
+    Compute factors p and q from the private exponent d. We assume that n has
+    no more than two factors. This function is adapted from code in PyCrypto.
+    """
+    # See 8.2.2(i) in Handbook of Applied Cryptography.
+    ktot = d * e - 1
+    # The quantity d*e-1 is a multiple of phi(n), even,
+    # and can be represented as t*2^s.
+    t = ktot
+    while t % 2 == 0:
+        t = t // 2
+    # Cycle through all multiplicative inverses in Zn.
+    # The algorithm is non-deterministic, but there is a 50% chance
+    # any candidate a leads to successful factoring.
+    # See "Digitalized Signatures and Public Key Functions as Intractable
+    # as Factorization", M. Rabin, 1979
+    spotted = False
+    a = 2
+    while not spotted and a < _MAX_RECOVERY_ATTEMPTS:
+        k = t
+        # Cycle through all values a^{t*2^i}=a^k
+        while k < ktot:
+            cand = pow(a, k, n)
+            # Check if a^k is a non-trivial root of unity (mod n)
+            if cand != 1 and cand != (n - 1) and pow(cand, 2, n) == 1:
+                # We have found a number such that (cand-1)(cand+1)=0 (mod n).
+                # Either of the terms divides n.
+                p = gcd(cand + 1, n)
+                spotted = True
+                break
+            k *= 2
+        # This value was not any good... let's try another!
+        a += 2
+    if not spotted:
+        raise ValueError("Unable to compute factors p and q from exponent d.")
+    # Found !
+    q, r = divmod(n, p)
+    assert r == 0
+
+    return (p, q)
+
+
+class RSAPrivateNumbers(object):
+    def __init__(self, p, q, d, dmp1, dmq1, iqmp,
+                 public_numbers):
+        if (
+            not isinstance(p, six.integer_types) or
+            not isinstance(q, six.integer_types) or
+            not isinstance(d, six.integer_types) or
+            not isinstance(dmp1, six.integer_types) or
+            not isinstance(dmq1, six.integer_types) or
+            not isinstance(iqmp, six.integer_types)
+        ):
+            raise TypeError(
+                "RSAPrivateNumbers p, q, d, dmp1, dmq1, iqmp arguments must"
+                " all be an integers."
+            )
+
+        if not isinstance(public_numbers, RSAPublicNumbers):
+            raise TypeError(
+                "RSAPrivateNumbers public_numbers must be an RSAPublicNumbers"
+                " instance."
+            )
+
+        self._p = p
+        self._q = q
+        self._d = d
+        self._dmp1 = dmp1
+        self._dmq1 = dmq1
+        self._iqmp = iqmp
+        self._public_numbers = public_numbers
+
+    p = utils.read_only_property("_p")
+    q = utils.read_only_property("_q")
+    d = utils.read_only_property("_d")
+    dmp1 = utils.read_only_property("_dmp1")
+    dmq1 = utils.read_only_property("_dmq1")
+    iqmp = utils.read_only_property("_iqmp")
+    public_numbers = utils.read_only_property("_public_numbers")
+
+    def private_key(self, backend):
+        return backend.load_rsa_private_numbers(self)
+
+    def __eq__(self, other):
+        if not isinstance(other, RSAPrivateNumbers):
+            return NotImplemented
+
+        return (
+            self.p == other.p and
+            self.q == other.q and
+            self.d == other.d and
+            self.dmp1 == other.dmp1 and
+            self.dmq1 == other.dmq1 and
+            self.iqmp == other.iqmp and
+            self.public_numbers == other.public_numbers
+        )
+
+    def __ne__(self, other):
+        return not self == other
+
+    def __hash__(self):
+        return hash((
+            self.p,
+            self.q,
+            self.d,
+            self.dmp1,
+            self.dmq1,
+            self.iqmp,
+            self.public_numbers,
+        ))
+
+
+class RSAPublicNumbers(object):
+    def __init__(self, e, n):
+        if (
+            not isinstance(e, six.integer_types) or
+            not isinstance(n, six.integer_types)
+        ):
+            raise TypeError("RSAPublicNumbers arguments must be integers.")
+
+        self._e = e
+        self._n = n
+
+    e = utils.read_only_property("_e")
+    n = utils.read_only_property("_n")
+
+    def public_key(self, backend):
+        return backend.load_rsa_public_numbers(self)
+
+    def __repr__(self):
+        return "<RSAPublicNumbers(e={0.e}, n={0.n})>".format(self)
+
+    def __eq__(self, other):
+        if not isinstance(other, RSAPublicNumbers):
+            return NotImplemented
+
+        return self.e == other.e and self.n == other.n
+
+    def __ne__(self, other):
+        return not self == other
+
+    def __hash__(self):
+        return hash((self.e, self.n))
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/asymmetric/utils.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/asymmetric/utils.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/asymmetric/utils.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/asymmetric/utils.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,73 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import warnings
+
+from pyasn1.codec.der import decoder, encoder
+from pyasn1.error import PyAsn1Error
+from pyasn1.type import namedtype, univ
+
+import six
+
+from cryptography import utils
+
+
+class _DSSSigValue(univ.Sequence):
+    componentType = namedtype.NamedTypes(
+        namedtype.NamedType('r', univ.Integer()),
+        namedtype.NamedType('s', univ.Integer())
+    )
+
+
+def decode_rfc6979_signature(signature):
+    warnings.warn(
+        "decode_rfc6979_signature is deprecated and will "
+        "be removed in a future version, use decode_dss_signature instead "
+        "instead.",
+        utils.DeprecatedIn10,
+        stacklevel=2
+    )
+    return decode_dss_signature(signature)
+
+
+def decode_dss_signature(signature):
+    try:
+        data, remaining = decoder.decode(signature, asn1Spec=_DSSSigValue())
+    except PyAsn1Error:
+        raise ValueError("Invalid signature data. Unable to decode ASN.1")
+
+    if remaining:
+        raise ValueError(
+            "The signature contains bytes after the end of the ASN.1 sequence."
+        )
+
+    r = int(data.getComponentByName('r'))
+    s = int(data.getComponentByName('s'))
+    return (r, s)
+
+
+def encode_rfc6979_signature(r, s):
+    warnings.warn(
+        "encode_rfc6979_signature is deprecated and will "
+        "be removed in a future version, use encode_dss_signature instead "
+        "instead.",
+        utils.DeprecatedIn10,
+        stacklevel=2
+    )
+    return encode_dss_signature(r, s)
+
+
+def encode_dss_signature(r, s):
+    if (
+        not isinstance(r, six.integer_types) or
+        not isinstance(s, six.integer_types)
+    ):
+        raise ValueError("Both r and s must be integers")
+
+    sig = _DSSSigValue()
+    sig.setComponentByName('r', r)
+    sig.setComponentByName('s', s)
+    return encoder.encode(sig)
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/ciphers/algorithms.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/ciphers/algorithms.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/ciphers/algorithms.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/ciphers/algorithms.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,140 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+from cryptography import utils
+from cryptography.hazmat.primitives.ciphers import (
+    BlockCipherAlgorithm, CipherAlgorithm
+)
+
+
+def _verify_key_size(algorithm, key):
+    # Verify that the key size matches the expected key size
+    if len(key) * 8 not in algorithm.key_sizes:
+        raise ValueError("Invalid key size ({0}) for {1}.".format(
+            len(key) * 8, algorithm.name
+        ))
+    return key
+
+
+@utils.register_interface(BlockCipherAlgorithm)
+@utils.register_interface(CipherAlgorithm)
+class AES(object):
+    name = "AES"
+    block_size = 128
+    key_sizes = frozenset([128, 192, 256])
+
+    def __init__(self, key):
+        self.key = _verify_key_size(self, key)
+
+    @property
+    def key_size(self):
+        return len(self.key) * 8
+
+
+@utils.register_interface(BlockCipherAlgorithm)
+@utils.register_interface(CipherAlgorithm)
+class Camellia(object):
+    name = "camellia"
+    block_size = 128
+    key_sizes = frozenset([128, 192, 256])
+
+    def __init__(self, key):
+        self.key = _verify_key_size(self, key)
+
+    @property
+    def key_size(self):
+        return len(self.key) * 8
+
+
+@utils.register_interface(BlockCipherAlgorithm)
+@utils.register_interface(CipherAlgorithm)
+class TripleDES(object):
+    name = "3DES"
+    block_size = 64
+    key_sizes = frozenset([64, 128, 192])
+
+    def __init__(self, key):
+        if len(key) == 8:
+            key += key + key
+        elif len(key) == 16:
+            key += key[:8]
+        self.key = _verify_key_size(self, key)
+
+    @property
+    def key_size(self):
+        return len(self.key) * 8
+
+
+@utils.register_interface(BlockCipherAlgorithm)
+@utils.register_interface(CipherAlgorithm)
+class Blowfish(object):
+    name = "Blowfish"
+    block_size = 64
+    key_sizes = frozenset(range(32, 449, 8))
+
+    def __init__(self, key):
+        self.key = _verify_key_size(self, key)
+
+    @property
+    def key_size(self):
+        return len(self.key) * 8
+
+
+@utils.register_interface(BlockCipherAlgorithm)
+@utils.register_interface(CipherAlgorithm)
+class CAST5(object):
+    name = "CAST5"
+    block_size = 64
+    key_sizes = frozenset(range(40, 129, 8))
+
+    def __init__(self, key):
+        self.key = _verify_key_size(self, key)
+
+    @property
+    def key_size(self):
+        return len(self.key) * 8
+
+
+@utils.register_interface(CipherAlgorithm)
+class ARC4(object):
+    name = "RC4"
+    key_sizes = frozenset([40, 56, 64, 80, 128, 192, 256])
+
+    def __init__(self, key):
+        self.key = _verify_key_size(self, key)
+
+    @property
+    def key_size(self):
+        return len(self.key) * 8
+
+
+@utils.register_interface(CipherAlgorithm)
+class IDEA(object):
+    name = "IDEA"
+    block_size = 64
+    key_sizes = frozenset([128])
+
+    def __init__(self, key):
+        self.key = _verify_key_size(self, key)
+
+    @property
+    def key_size(self):
+        return len(self.key) * 8
+
+
+@utils.register_interface(BlockCipherAlgorithm)
+@utils.register_interface(CipherAlgorithm)
+class SEED(object):
+    name = "SEED"
+    block_size = 128
+    key_sizes = frozenset([128])
+
+    def __init__(self, key):
+        self.key = _verify_key_size(self, key)
+
+    @property
+    def key_size(self):
+        return len(self.key) * 8
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/ciphers/base.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/ciphers/base.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/ciphers/base.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/ciphers/base.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,203 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import abc
+
+import six
+
+from cryptography import utils
+from cryptography.exceptions import (
+    AlreadyFinalized, AlreadyUpdated, NotYetFinalized, UnsupportedAlgorithm,
+    _Reasons
+)
+from cryptography.hazmat.backends.interfaces import CipherBackend
+from cryptography.hazmat.primitives.ciphers import modes
+
+
+@six.add_metaclass(abc.ABCMeta)
+class CipherAlgorithm(object):
+    @abc.abstractproperty
+    def name(self):
+        """
+        A string naming this mode (e.g. "AES", "Camellia").
+        """
+
+    @abc.abstractproperty
+    def key_size(self):
+        """
+        The size of the key being used as an integer in bits (e.g. 128, 256).
+        """
+
+
+@six.add_metaclass(abc.ABCMeta)
+class BlockCipherAlgorithm(object):
+    @abc.abstractproperty
+    def block_size(self):
+        """
+        The size of a block as an integer in bits (e.g. 64, 128).
+        """
+
+
+@six.add_metaclass(abc.ABCMeta)
+class CipherContext(object):
+    @abc.abstractmethod
+    def update(self, data):
+        """
+        Processes the provided bytes through the cipher and returns the results
+        as bytes.
+        """
+
+    @abc.abstractmethod
+    def finalize(self):
+        """
+        Returns the results of processing the final block as bytes.
+        """
+
+
+@six.add_metaclass(abc.ABCMeta)
+class AEADCipherContext(object):
+    @abc.abstractmethod
+    def authenticate_additional_data(self, data):
+        """
+        Authenticates the provided bytes.
+        """
+
+
+@six.add_metaclass(abc.ABCMeta)
+class AEADEncryptionContext(object):
+    @abc.abstractproperty
+    def tag(self):
+        """
+        Returns tag bytes. This is only available after encryption is
+        finalized.
+        """
+
+
+class Cipher(object):
+    def __init__(self, algorithm, mode, backend):
+        if not isinstance(backend, CipherBackend):
+            raise UnsupportedAlgorithm(
+                "Backend object does not implement CipherBackend.",
+                _Reasons.BACKEND_MISSING_INTERFACE
+            )
+
+        if not isinstance(algorithm, CipherAlgorithm):
+            raise TypeError("Expected interface of CipherAlgorithm.")
+
+        if mode is not None:
+            mode.validate_for_algorithm(algorithm)
+
+        self.algorithm = algorithm
+        self.mode = mode
+        self._backend = backend
+
+    def encryptor(self):
+        if isinstance(self.mode, modes.ModeWithAuthenticationTag):
+            if self.mode.tag is not None:
+                raise ValueError(
+                    "Authentication tag must be None when encrypting."
+                )
+        ctx = self._backend.create_symmetric_encryption_ctx(
+            self.algorithm, self.mode
+        )
+        return self._wrap_ctx(ctx, encrypt=True)
+
+    def decryptor(self):
+        if isinstance(self.mode, modes.ModeWithAuthenticationTag):
+            if self.mode.tag is None:
+                raise ValueError(
+                    "Authentication tag must be provided when decrypting."
+                )
+        ctx = self._backend.create_symmetric_decryption_ctx(
+            self.algorithm, self.mode
+        )
+        return self._wrap_ctx(ctx, encrypt=False)
+
+    def _wrap_ctx(self, ctx, encrypt):
+        if isinstance(self.mode, modes.ModeWithAuthenticationTag):
+            if encrypt:
+                return _AEADEncryptionContext(ctx)
+            else:
+                return _AEADCipherContext(ctx)
+        else:
+            return _CipherContext(ctx)
+
+
+@utils.register_interface(CipherContext)
+class _CipherContext(object):
+    def __init__(self, ctx):
+        self._ctx = ctx
+
+    def update(self, data):
+        if self._ctx is None:
+            raise AlreadyFinalized("Context was already finalized.")
+        return self._ctx.update(data)
+
+    def finalize(self):
+        if self._ctx is None:
+            raise AlreadyFinalized("Context was already finalized.")
+        data = self._ctx.finalize()
+        self._ctx = None
+        return data
+
+
+@utils.register_interface(AEADCipherContext)
+@utils.register_interface(CipherContext)
+class _AEADCipherContext(object):
+    def __init__(self, ctx):
+        self._ctx = ctx
+        self._bytes_processed = 0
+        self._aad_bytes_processed = 0
+        self._tag = None
+        self._updated = False
+
+    def update(self, data):
+        if self._ctx is None:
+            raise AlreadyFinalized("Context was already finalized.")
+        self._updated = True
+        self._bytes_processed += len(data)
+        if self._bytes_processed > self._ctx._mode._MAX_ENCRYPTED_BYTES:
+            raise ValueError(
+                "{0} has a maximum encrypted byte limit of {1}".format(
+                    self._ctx._mode.name, self._ctx._mode._MAX_ENCRYPTED_BYTES
+                )
+            )
+
+        return self._ctx.update(data)
+
+    def finalize(self):
+        if self._ctx is None:
+            raise AlreadyFinalized("Context was already finalized.")
+        data = self._ctx.finalize()
+        self._tag = self._ctx.tag
+        self._ctx = None
+        return data
+
+    def authenticate_additional_data(self, data):
+        if self._ctx is None:
+            raise AlreadyFinalized("Context was already finalized.")
+        if self._updated:
+            raise AlreadyUpdated("Update has been called on this context.")
+
+        self._aad_bytes_processed += len(data)
+        if self._aad_bytes_processed > self._ctx._mode._MAX_AAD_BYTES:
+            raise ValueError(
+                "{0} has a maximum AAD byte limit of {0}".format(
+                    self._ctx._mode.name, self._ctx._mode._MAX_AAD_BYTES
+                )
+            )
+
+        self._ctx.authenticate_additional_data(data)
+
+
+@utils.register_interface(AEADEncryptionContext)
+class _AEADEncryptionContext(_AEADCipherContext):
+    @property
+    def tag(self):
+        if self._ctx is not None:
+            raise NotYetFinalized("You must finalize encryption before "
+                                  "getting the tag.")
+        return self._tag
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/ciphers/__init__.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/ciphers/__init__.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/ciphers/__init__.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/ciphers/__init__.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,20 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+from cryptography.hazmat.primitives.ciphers.base import (
+    AEADCipherContext, AEADEncryptionContext, BlockCipherAlgorithm, Cipher,
+    CipherAlgorithm, CipherContext
+)
+
+
+__all__ = [
+    "Cipher",
+    "CipherAlgorithm",
+    "BlockCipherAlgorithm",
+    "CipherContext",
+    "AEADCipherContext",
+    "AEADEncryptionContext",
+]
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/ciphers/modes.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/ciphers/modes.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/ciphers/modes.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/ciphers/modes.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,164 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import abc
+
+import six
+
+from cryptography import utils
+
+
+@six.add_metaclass(abc.ABCMeta)
+class Mode(object):
+    @abc.abstractproperty
+    def name(self):
+        """
+        A string naming this mode (e.g. "ECB", "CBC").
+        """
+
+    @abc.abstractmethod
+    def validate_for_algorithm(self, algorithm):
+        """
+        Checks that all the necessary invariants of this (mode, algorithm)
+        combination are met.
+        """
+
+
+@six.add_metaclass(abc.ABCMeta)
+class ModeWithInitializationVector(object):
+    @abc.abstractproperty
+    def initialization_vector(self):
+        """
+        The value of the initialization vector for this mode as bytes.
+        """
+
+
+@six.add_metaclass(abc.ABCMeta)
+class ModeWithNonce(object):
+    @abc.abstractproperty
+    def nonce(self):
+        """
+        The value of the nonce for this mode as bytes.
+        """
+
+
+@six.add_metaclass(abc.ABCMeta)
+class ModeWithAuthenticationTag(object):
+    @abc.abstractproperty
+    def tag(self):
+        """
+        The value of the tag supplied to the constructor of this mode.
+        """
+
+
+def _check_iv_length(self, algorithm):
+    if len(self.initialization_vector) * 8 != algorithm.block_size:
+        raise ValueError("Invalid IV size ({0}) for {1}.".format(
+            len(self.initialization_vector), self.name
+        ))
+
+
+@utils.register_interface(Mode)
+@utils.register_interface(ModeWithInitializationVector)
+class CBC(object):
+    name = "CBC"
+
+    def __init__(self, initialization_vector):
+        self._initialization_vector = initialization_vector
+
+    initialization_vector = utils.read_only_property("_initialization_vector")
+    validate_for_algorithm = _check_iv_length
+
+
+@utils.register_interface(Mode)
+class ECB(object):
+    name = "ECB"
+
+    def validate_for_algorithm(self, algorithm):
+        pass
+
+
+@utils.register_interface(Mode)
+@utils.register_interface(ModeWithInitializationVector)
+class OFB(object):
+    name = "OFB"
+
+    def __init__(self, initialization_vector):
+        self._initialization_vector = initialization_vector
+
+    initialization_vector = utils.read_only_property("_initialization_vector")
+    validate_for_algorithm = _check_iv_length
+
+
+@utils.register_interface(Mode)
+@utils.register_interface(ModeWithInitializationVector)
+class CFB(object):
+    name = "CFB"
+
+    def __init__(self, initialization_vector):
+        self._initialization_vector = initialization_vector
+
+    initialization_vector = utils.read_only_property("_initialization_vector")
+    validate_for_algorithm = _check_iv_length
+
+
+@utils.register_interface(Mode)
+@utils.register_interface(ModeWithInitializationVector)
+class CFB8(object):
+    name = "CFB8"
+
+    def __init__(self, initialization_vector):
+        self._initialization_vector = initialization_vector
+
+    initialization_vector = utils.read_only_property("_initialization_vector")
+    validate_for_algorithm = _check_iv_length
+
+
+@utils.register_interface(Mode)
+@utils.register_interface(ModeWithNonce)
+class CTR(object):
+    name = "CTR"
+
+    def __init__(self, nonce):
+        self._nonce = nonce
+
+    nonce = utils.read_only_property("_nonce")
+
+    def validate_for_algorithm(self, algorithm):
+        if len(self.nonce) * 8 != algorithm.block_size:
+            raise ValueError("Invalid nonce size ({0}) for {1}.".format(
+                len(self.nonce), self.name
+            ))
+
+
+@utils.register_interface(Mode)
+@utils.register_interface(ModeWithInitializationVector)
+@utils.register_interface(ModeWithAuthenticationTag)
+class GCM(object):
+    name = "GCM"
+    _MAX_ENCRYPTED_BYTES = (2 ** 39 - 256) // 8
+    _MAX_AAD_BYTES = (2 ** 64) // 8
+
+    def __init__(self, initialization_vector, tag=None, min_tag_length=16):
+        # len(initialization_vector) must in [1, 2 ** 64), but it's impossible
+        # to actually construct a bytes object that large, so we don't check
+        # for it
+        if min_tag_length < 4:
+            raise ValueError("min_tag_length must be >= 4")
+        if tag is not None and len(tag) < min_tag_length:
+            raise ValueError(
+                "Authentication tag must be {0} bytes or longer.".format(
+                    min_tag_length)
+            )
+
+        self._initialization_vector = initialization_vector
+        self._tag = tag
+
+    tag = utils.read_only_property("_tag")
+    initialization_vector = utils.read_only_property("_initialization_vector")
+
+    def validate_for_algorithm(self, algorithm):
+        pass
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/cmac.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/cmac.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/cmac.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/cmac.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,66 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+from cryptography import utils
+from cryptography.exceptions import (
+    AlreadyFinalized, UnsupportedAlgorithm, _Reasons
+)
+from cryptography.hazmat.backends.interfaces import CMACBackend
+from cryptography.hazmat.primitives import ciphers, interfaces
+
+
+@utils.register_interface(interfaces.MACContext)
+class CMAC(object):
+    def __init__(self, algorithm, backend, ctx=None):
+        if not isinstance(backend, CMACBackend):
+            raise UnsupportedAlgorithm(
+                "Backend object does not implement CMACBackend.",
+                _Reasons.BACKEND_MISSING_INTERFACE
+            )
+
+        if not isinstance(algorithm, ciphers.BlockCipherAlgorithm):
+            raise TypeError(
+                "Expected instance of BlockCipherAlgorithm."
+            )
+        self._algorithm = algorithm
+
+        self._backend = backend
+        if ctx is None:
+            self._ctx = self._backend.create_cmac_ctx(self._algorithm)
+        else:
+            self._ctx = ctx
+
+    def update(self, data):
+        if self._ctx is None:
+            raise AlreadyFinalized("Context was already finalized.")
+        if not isinstance(data, bytes):
+            raise TypeError("data must be bytes.")
+        self._ctx.update(data)
+
+    def finalize(self):
+        if self._ctx is None:
+            raise AlreadyFinalized("Context was already finalized.")
+        digest = self._ctx.finalize()
+        self._ctx = None
+        return digest
+
+    def verify(self, signature):
+        if not isinstance(signature, bytes):
+            raise TypeError("signature must be bytes.")
+        if self._ctx is None:
+            raise AlreadyFinalized("Context was already finalized.")
+
+        ctx, self._ctx = self._ctx, None
+        ctx.verify(signature)
+
+    def copy(self):
+        if self._ctx is None:
+            raise AlreadyFinalized("Context was already finalized.")
+        return CMAC(
+            self._algorithm,
+            backend=self._backend,
+            ctx=self._ctx.copy()
+        )
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/constant_time.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/constant_time.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/constant_time.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/constant_time.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,26 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import hmac
+
+from cryptography.hazmat.bindings._constant_time import lib
+
+
+if hasattr(hmac, "compare_digest"):
+    def bytes_eq(a, b):
+        if not isinstance(a, bytes) or not isinstance(b, bytes):
+            raise TypeError("a and b must be bytes.")
+
+        return hmac.compare_digest(a, b)
+
+else:
+    def bytes_eq(a, b):
+        if not isinstance(a, bytes) or not isinstance(b, bytes):
+            raise TypeError("a and b must be bytes.")
+
+        return lib.Cryptography_constant_time_bytes_eq(
+            a, len(a), b, len(b)
+        ) == 1
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/hashes.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/hashes.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/hashes.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/hashes.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,163 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import abc
+
+import six
+
+from cryptography import utils
+from cryptography.exceptions import (
+    AlreadyFinalized, UnsupportedAlgorithm, _Reasons
+)
+from cryptography.hazmat.backends.interfaces import HashBackend
+
+
+@six.add_metaclass(abc.ABCMeta)
+class HashAlgorithm(object):
+    @abc.abstractproperty
+    def name(self):
+        """
+        A string naming this algorithm (e.g. "sha256", "md5").
+        """
+
+    @abc.abstractproperty
+    def digest_size(self):
+        """
+        The size of the resulting digest in bytes.
+        """
+
+    @abc.abstractproperty
+    def block_size(self):
+        """
+        The internal block size of the hash algorithm in bytes.
+        """
+
+
+@six.add_metaclass(abc.ABCMeta)
+class HashContext(object):
+    @abc.abstractproperty
+    def algorithm(self):
+        """
+        A HashAlgorithm that will be used by this context.
+        """
+
+    @abc.abstractmethod
+    def update(self, data):
+        """
+        Processes the provided bytes through the hash.
+        """
+
+    @abc.abstractmethod
+    def finalize(self):
+        """
+        Finalizes the hash context and returns the hash digest as bytes.
+        """
+
+    @abc.abstractmethod
+    def copy(self):
+        """
+        Return a HashContext that is a copy of the current context.
+        """
+
+
+@utils.register_interface(HashContext)
+class Hash(object):
+    def __init__(self, algorithm, backend, ctx=None):
+        if not isinstance(backend, HashBackend):
+            raise UnsupportedAlgorithm(
+                "Backend object does not implement HashBackend.",
+                _Reasons.BACKEND_MISSING_INTERFACE
+            )
+
+        if not isinstance(algorithm, HashAlgorithm):
+            raise TypeError("Expected instance of hashes.HashAlgorithm.")
+        self._algorithm = algorithm
+
+        self._backend = backend
+
+        if ctx is None:
+            self._ctx = self._backend.create_hash_ctx(self.algorithm)
+        else:
+            self._ctx = ctx
+
+    algorithm = utils.read_only_property("_algorithm")
+
+    def update(self, data):
+        if self._ctx is None:
+            raise AlreadyFinalized("Context was already finalized.")
+        if not isinstance(data, bytes):
+            raise TypeError("data must be bytes.")
+        self._ctx.update(data)
+
+    def copy(self):
+        if self._ctx is None:
+            raise AlreadyFinalized("Context was already finalized.")
+        return Hash(
+            self.algorithm, backend=self._backend, ctx=self._ctx.copy()
+        )
+
+    def finalize(self):
+        if self._ctx is None:
+            raise AlreadyFinalized("Context was already finalized.")
+        digest = self._ctx.finalize()
+        self._ctx = None
+        return digest
+
+
+@utils.register_interface(HashAlgorithm)
+class SHA1(object):
+    name = "sha1"
+    digest_size = 20
+    block_size = 64
+
+
+@utils.register_interface(HashAlgorithm)
+class SHA224(object):
+    name = "sha224"
+    digest_size = 28
+    block_size = 64
+
+
+@utils.register_interface(HashAlgorithm)
+class SHA256(object):
+    name = "sha256"
+    digest_size = 32
+    block_size = 64
+
+
+@utils.register_interface(HashAlgorithm)
+class SHA384(object):
+    name = "sha384"
+    digest_size = 48
+    block_size = 128
+
+
+@utils.register_interface(HashAlgorithm)
+class SHA512(object):
+    name = "sha512"
+    digest_size = 64
+    block_size = 128
+
+
+@utils.register_interface(HashAlgorithm)
+class RIPEMD160(object):
+    name = "ripemd160"
+    digest_size = 20
+    block_size = 64
+
+
+@utils.register_interface(HashAlgorithm)
+class Whirlpool(object):
+    name = "whirlpool"
+    digest_size = 64
+    block_size = 64
+
+
+@utils.register_interface(HashAlgorithm)
+class MD5(object):
+    name = "md5"
+    digest_size = 16
+    block_size = 64
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/hmac.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/hmac.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/hmac.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/hmac.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,69 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+from cryptography import utils
+from cryptography.exceptions import (
+    AlreadyFinalized, UnsupportedAlgorithm, _Reasons
+)
+from cryptography.hazmat.backends.interfaces import HMACBackend
+from cryptography.hazmat.primitives import hashes, interfaces
+
+
+@utils.register_interface(interfaces.MACContext)
+@utils.register_interface(hashes.HashContext)
+class HMAC(object):
+    def __init__(self, key, algorithm, backend, ctx=None):
+        if not isinstance(backend, HMACBackend):
+            raise UnsupportedAlgorithm(
+                "Backend object does not implement HMACBackend.",
+                _Reasons.BACKEND_MISSING_INTERFACE
+            )
+
+        if not isinstance(algorithm, hashes.HashAlgorithm):
+            raise TypeError("Expected instance of hashes.HashAlgorithm.")
+        self._algorithm = algorithm
+
+        self._backend = backend
+        self._key = key
+        if ctx is None:
+            self._ctx = self._backend.create_hmac_ctx(key, self.algorithm)
+        else:
+            self._ctx = ctx
+
+    algorithm = utils.read_only_property("_algorithm")
+
+    def update(self, data):
+        if self._ctx is None:
+            raise AlreadyFinalized("Context was already finalized.")
+        if not isinstance(data, bytes):
+            raise TypeError("data must be bytes.")
+        self._ctx.update(data)
+
+    def copy(self):
+        if self._ctx is None:
+            raise AlreadyFinalized("Context was already finalized.")
+        return HMAC(
+            self._key,
+            self.algorithm,
+            backend=self._backend,
+            ctx=self._ctx.copy()
+        )
+
+    def finalize(self):
+        if self._ctx is None:
+            raise AlreadyFinalized("Context was already finalized.")
+        digest = self._ctx.finalize()
+        self._ctx = None
+        return digest
+
+    def verify(self, signature):
+        if not isinstance(signature, bytes):
+            raise TypeError("signature must be bytes.")
+        if self._ctx is None:
+            raise AlreadyFinalized("Context was already finalized.")
+
+        ctx, self._ctx = self._ctx, None
+        ctx.verify(signature)
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/__init__.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/__init__.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/__init__.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/__init__.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,5 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/interfaces/__init__.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/interfaces/__init__.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/interfaces/__init__.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/interfaces/__init__.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,37 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import abc
+
+import six
+
+
+@six.add_metaclass(abc.ABCMeta)
+class MACContext(object):
+    @abc.abstractmethod
+    def update(self, data):
+        """
+        Processes the provided bytes.
+        """
+
+    @abc.abstractmethod
+    def finalize(self):
+        """
+        Returns the message authentication code as bytes.
+        """
+
+    @abc.abstractmethod
+    def copy(self):
+        """
+        Return a MACContext that is a copy of the current context.
+        """
+
+    @abc.abstractmethod
+    def verify(self, signature):
+        """
+        Checks if the generated message authentication code matches the
+        signature.
+        """
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/kdf/concatkdf.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/kdf/concatkdf.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/kdf/concatkdf.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/kdf/concatkdf.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,125 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import struct
+
+from cryptography import utils
+from cryptography.exceptions import (
+    AlreadyFinalized, InvalidKey, UnsupportedAlgorithm, _Reasons
+)
+from cryptography.hazmat.backends.interfaces import HMACBackend
+from cryptography.hazmat.backends.interfaces import HashBackend
+from cryptography.hazmat.primitives import constant_time, hashes, hmac
+from cryptography.hazmat.primitives.kdf import KeyDerivationFunction
+
+
+def _int_to_u32be(n):
+    return struct.pack('>I', n)
+
+
+def _common_args_checks(algorithm, length, otherinfo):
+    max_length = algorithm.digest_size * (2 ** 32 - 1)
+    if length > max_length:
+        raise ValueError(
+            "Can not derive keys larger than {0} bits.".format(
+                max_length
+            ))
+    if not (otherinfo is None or isinstance(otherinfo, bytes)):
+        raise TypeError("otherinfo must be bytes.")
+
+
+def _concatkdf_derive(key_material, length, auxfn, otherinfo):
+    if not isinstance(key_material, bytes):
+        raise TypeError("key_material must be bytes.")
+
+    output = [b""]
+    outlen = 0
+    counter = 1
+
+    while (length > outlen):
+        h = auxfn()
+        h.update(_int_to_u32be(counter))
+        h.update(key_material)
+        h.update(otherinfo)
+        output.append(h.finalize())
+        outlen += len(output[-1])
+        counter += 1
+
+    return b"".join(output)[:length]
+
+
+@utils.register_interface(KeyDerivationFunction)
+class ConcatKDFHash(object):
+    def __init__(self, algorithm, length, otherinfo, backend):
+
+        _common_args_checks(algorithm, length, otherinfo)
+        self._algorithm = algorithm
+        self._length = length
+        self._otherinfo = otherinfo
+        if self._otherinfo is None:
+            self._otherinfo = b""
+
+        if not isinstance(backend, HashBackend):
+            raise UnsupportedAlgorithm(
+                "Backend object does not implement HashBackend.",
+                _Reasons.BACKEND_MISSING_INTERFACE
+            )
+        self._backend = backend
+        self._used = False
+
+    def _hash(self):
+        return hashes.Hash(self._algorithm, self._backend)
+
+    def derive(self, key_material):
+        if self._used:
+            raise AlreadyFinalized
+        self._used = True
+        return _concatkdf_derive(key_material, self._length,
+                                 self._hash, self._otherinfo)
+
+    def verify(self, key_material, expected_key):
+        if not constant_time.bytes_eq(self.derive(key_material), expected_key):
+            raise InvalidKey
+
+
+@utils.register_interface(KeyDerivationFunction)
+class ConcatKDFHMAC(object):
+    def __init__(self, algorithm, length, salt, otherinfo, backend):
+
+        _common_args_checks(algorithm, length, otherinfo)
+        self._algorithm = algorithm
+        self._length = length
+        self._otherinfo = otherinfo
+        if self._otherinfo is None:
+            self._otherinfo = b""
+
+        if not (salt is None or isinstance(salt, bytes)):
+            raise TypeError("salt must be bytes.")
+        if salt is None:
+            salt = b"\x00" * algorithm.block_size
+        self._salt = salt
+
+        if not isinstance(backend, HMACBackend):
+            raise UnsupportedAlgorithm(
+                "Backend object does not implement HMACBackend.",
+                _Reasons.BACKEND_MISSING_INTERFACE
+            )
+        self._backend = backend
+        self._used = False
+
+    def _hmac(self):
+        return hmac.HMAC(self._salt, self._algorithm, self._backend)
+
+    def derive(self, key_material):
+        if self._used:
+            raise AlreadyFinalized
+        self._used = True
+        return _concatkdf_derive(key_material, self._length,
+                                 self._hmac, self._otherinfo)
+
+    def verify(self, key_material, expected_key):
+        if not constant_time.bytes_eq(self.derive(key_material), expected_key):
+            raise InvalidKey
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/kdf/hkdf.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/kdf/hkdf.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/kdf/hkdf.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/kdf/hkdf.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,116 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import six
+
+from cryptography import utils
+from cryptography.exceptions import (
+    AlreadyFinalized, InvalidKey, UnsupportedAlgorithm, _Reasons
+)
+from cryptography.hazmat.backends.interfaces import HMACBackend
+from cryptography.hazmat.primitives import constant_time, hmac
+from cryptography.hazmat.primitives.kdf import KeyDerivationFunction
+
+
+@utils.register_interface(KeyDerivationFunction)
+class HKDF(object):
+    def __init__(self, algorithm, length, salt, info, backend):
+        if not isinstance(backend, HMACBackend):
+            raise UnsupportedAlgorithm(
+                "Backend object does not implement HMACBackend.",
+                _Reasons.BACKEND_MISSING_INTERFACE
+            )
+
+        self._algorithm = algorithm
+
+        if not (salt is None or isinstance(salt, bytes)):
+            raise TypeError("salt must be bytes.")
+
+        if salt is None:
+            salt = b"\x00" * (self._algorithm.digest_size // 8)
+
+        self._salt = salt
+
+        self._backend = backend
+
+        self._hkdf_expand = HKDFExpand(self._algorithm, length, info, backend)
+
+    def _extract(self, key_material):
+        h = hmac.HMAC(self._salt, self._algorithm, backend=self._backend)
+        h.update(key_material)
+        return h.finalize()
+
+    def derive(self, key_material):
+        if not isinstance(key_material, bytes):
+            raise TypeError("key_material must be bytes.")
+
+        return self._hkdf_expand.derive(self._extract(key_material))
+
+    def verify(self, key_material, expected_key):
+        if not constant_time.bytes_eq(self.derive(key_material), expected_key):
+            raise InvalidKey
+
+
+@utils.register_interface(KeyDerivationFunction)
+class HKDFExpand(object):
+    def __init__(self, algorithm, length, info, backend):
+        if not isinstance(backend, HMACBackend):
+            raise UnsupportedAlgorithm(
+                "Backend object does not implement HMACBackend.",
+                _Reasons.BACKEND_MISSING_INTERFACE
+            )
+
+        self._algorithm = algorithm
+
+        self._backend = backend
+
+        max_length = 255 * (algorithm.digest_size // 8)
+
+        if length > max_length:
+            raise ValueError(
+                "Can not derive keys larger than {0} octets.".format(
+                    max_length
+                ))
+
+        self._length = length
+
+        if not (info is None or isinstance(info, bytes)):
+            raise TypeError("info must be bytes.")
+
+        if info is None:
+            info = b""
+
+        self._info = info
+
+        self._used = False
+
+    def _expand(self, key_material):
+        output = [b""]
+        counter = 1
+
+        while (self._algorithm.digest_size // 8) * len(output) < self._length:
+            h = hmac.HMAC(key_material, self._algorithm, backend=self._backend)
+            h.update(output[-1])
+            h.update(self._info)
+            h.update(six.int2byte(counter))
+            output.append(h.finalize())
+            counter += 1
+
+        return b"".join(output)[:self._length]
+
+    def derive(self, key_material):
+        if not isinstance(key_material, bytes):
+            raise TypeError("key_material must be bytes.")
+
+        if self._used:
+            raise AlreadyFinalized
+
+        self._used = True
+        return self._expand(key_material)
+
+    def verify(self, key_material, expected_key):
+        if not constant_time.bytes_eq(self.derive(key_material), expected_key):
+            raise InvalidKey
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/kdf/__init__.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/kdf/__init__.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/kdf/__init__.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/kdf/__init__.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,26 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import abc
+
+import six
+
+
+@six.add_metaclass(abc.ABCMeta)
+class KeyDerivationFunction(object):
+    @abc.abstractmethod
+    def derive(self, key_material):
+        """
+        Deterministically generates and returns a new key based on the existing
+        key material.
+        """
+
+    @abc.abstractmethod
+    def verify(self, key_material, expected_key):
+        """
+        Checks whether the key generated by the key material matches the
+        expected derived key. Raises an exception if they do not match.
+        """
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/kdf/pbkdf2.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/kdf/pbkdf2.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/kdf/pbkdf2.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/kdf/pbkdf2.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,58 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+from cryptography import utils
+from cryptography.exceptions import (
+    AlreadyFinalized, InvalidKey, UnsupportedAlgorithm, _Reasons
+)
+from cryptography.hazmat.backends.interfaces import PBKDF2HMACBackend
+from cryptography.hazmat.primitives import constant_time
+from cryptography.hazmat.primitives.kdf import KeyDerivationFunction
+
+
+@utils.register_interface(KeyDerivationFunction)
+class PBKDF2HMAC(object):
+    def __init__(self, algorithm, length, salt, iterations, backend):
+        if not isinstance(backend, PBKDF2HMACBackend):
+            raise UnsupportedAlgorithm(
+                "Backend object does not implement PBKDF2HMACBackend.",
+                _Reasons.BACKEND_MISSING_INTERFACE
+            )
+
+        if not backend.pbkdf2_hmac_supported(algorithm):
+            raise UnsupportedAlgorithm(
+                "{0} is not supported for PBKDF2 by this backend.".format(
+                    algorithm.name),
+                _Reasons.UNSUPPORTED_HASH
+            )
+        self._used = False
+        self._algorithm = algorithm
+        self._length = length
+        if not isinstance(salt, bytes):
+            raise TypeError("salt must be bytes.")
+        self._salt = salt
+        self._iterations = iterations
+        self._backend = backend
+
+    def derive(self, key_material):
+        if self._used:
+            raise AlreadyFinalized("PBKDF2 instances can only be used once.")
+        self._used = True
+
+        if not isinstance(key_material, bytes):
+            raise TypeError("key_material must be bytes.")
+        return self._backend.derive_pbkdf2_hmac(
+            self._algorithm,
+            self._length,
+            self._salt,
+            self._iterations,
+            key_material
+        )
+
+    def verify(self, key_material, expected_key):
+        derived_key = self.derive(key_material)
+        if not constant_time.bytes_eq(derived_key, expected_key):
+            raise InvalidKey("Keys do not match.")
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/kdf/x963kdf.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/kdf/x963kdf.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/kdf/x963kdf.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/kdf/x963kdf.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,70 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import struct
+
+from cryptography import utils
+from cryptography.exceptions import (
+    AlreadyFinalized, InvalidKey, UnsupportedAlgorithm, _Reasons
+)
+from cryptography.hazmat.backends.interfaces import HashBackend
+from cryptography.hazmat.primitives import constant_time, hashes
+from cryptography.hazmat.primitives.kdf import KeyDerivationFunction
+
+
+def _int_to_u32be(n):
+    return struct.pack('>I', n)
+
+
+@utils.register_interface(KeyDerivationFunction)
+class X963KDF(object):
+    def __init__(self, algorithm, length, sharedinfo, backend):
+
+        max_len = algorithm.digest_size * (2 ** 32 - 1)
+        if length > max_len:
+            raise ValueError(
+                "Can not derive keys larger than {0} bits.".format(max_len))
+        if not (sharedinfo is None or isinstance(sharedinfo, bytes)):
+            raise TypeError("sharedinfo must be bytes.")
+        self._algorithm = algorithm
+        self._length = length
+        self._sharedinfo = sharedinfo
+
+        if not isinstance(backend, HashBackend):
+            raise UnsupportedAlgorithm(
+                "Backend object does not implement HashBackend.",
+                _Reasons.BACKEND_MISSING_INTERFACE
+            )
+        self._backend = backend
+        self._used = False
+
+    def derive(self, key_material):
+        if self._used:
+            raise AlreadyFinalized
+        self._used = True
+
+        if not isinstance(key_material, bytes):
+            raise TypeError("key_material must be bytes.")
+
+        output = [b""]
+        outlen = 0
+        counter = 1
+
+        while self._length > outlen:
+            h = hashes.Hash(self._algorithm, self._backend)
+            h.update(key_material)
+            h.update(_int_to_u32be(counter))
+            if self._sharedinfo is not None:
+                h.update(self._sharedinfo)
+            output.append(h.finalize())
+            outlen += len(output[-1])
+            counter += 1
+
+        return b"".join(output)[:self._length]
+
+    def verify(self, key_material, expected_key):
+        if not constant_time.bytes_eq(self.derive(key_material), expected_key):
+            raise InvalidKey
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/keywrap.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/keywrap.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/keywrap.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/keywrap.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,85 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import struct
+
+from cryptography.hazmat.primitives.ciphers import Cipher
+from cryptography.hazmat.primitives.ciphers.algorithms import AES
+from cryptography.hazmat.primitives.ciphers.modes import ECB
+from cryptography.hazmat.primitives.constant_time import bytes_eq
+
+
+def aes_key_wrap(wrapping_key, key_to_wrap, backend):
+    if len(wrapping_key) not in [16, 24, 32]:
+        raise ValueError("The wrapping key must be a valid AES key length")
+
+    if len(key_to_wrap) < 16:
+        raise ValueError("The key to wrap must be at least 16 bytes")
+
+    if len(key_to_wrap) % 8 != 0:
+        raise ValueError("The key to wrap must be a multiple of 8 bytes")
+
+    # RFC 3394 Key Wrap - 2.2.1 (index method)
+    encryptor = Cipher(AES(wrapping_key), ECB(), backend).encryptor()
+    a = b"\xa6\xa6\xa6\xa6\xa6\xa6\xa6\xa6"
+    r = [key_to_wrap[i:i + 8] for i in range(0, len(key_to_wrap), 8)]
+    n = len(r)
+    for j in range(6):
+        for i in range(n):
+            # every encryption operation is a discrete 16 byte chunk (because
+            # AES has a 128-bit block size) and since we're using ECB it is
+            # safe to reuse the encryptor for the entire operation
+            b = encryptor.update(a + r[i])
+            # pack/unpack are safe as these are always 64-bit chunks
+            a = struct.pack(
+                ">Q", struct.unpack(">Q", b[:8])[0] ^ ((n * j) + i + 1)
+            )
+            r[i] = b[-8:]
+
+    assert encryptor.finalize() == b""
+
+    return a + b"".join(r)
+
+
+def aes_key_unwrap(wrapping_key, wrapped_key, backend):
+    if len(wrapped_key) < 24:
+        raise ValueError("Must be at least 24 bytes")
+
+    if len(wrapped_key) % 8 != 0:
+        raise ValueError("The wrapped key must be a multiple of 8 bytes")
+
+    if len(wrapping_key) not in [16, 24, 32]:
+        raise ValueError("The wrapping key must be a valid AES key length")
+
+    # Implement RFC 3394 Key Unwrap - 2.2.2 (index method)
+    decryptor = Cipher(AES(wrapping_key), ECB(), backend).decryptor()
+    aiv = b"\xa6\xa6\xa6\xa6\xa6\xa6\xa6\xa6"
+
+    r = [wrapped_key[i:i + 8] for i in range(0, len(wrapped_key), 8)]
+    a = r.pop(0)
+    n = len(r)
+    for j in reversed(range(6)):
+        for i in reversed(range(n)):
+            # pack/unpack are safe as these are always 64-bit chunks
+            atr = struct.pack(
+                ">Q", struct.unpack(">Q", a)[0] ^ ((n * j) + i + 1)
+            ) + r[i]
+            # every decryption operation is a discrete 16 byte chunk so
+            # it is safe to reuse the decryptor for the entire operation
+            b = decryptor.update(atr)
+            a = b[:8]
+            r[i] = b[-8:]
+
+    assert decryptor.finalize() == b""
+
+    if not bytes_eq(a, aiv):
+        raise InvalidUnwrap()
+
+    return b"".join(r)
+
+
+class InvalidUnwrap(Exception):
+    pass
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/padding.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/padding.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/padding.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/padding.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,124 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import abc
+
+import six
+
+from cryptography import utils
+from cryptography.exceptions import AlreadyFinalized
+from cryptography.hazmat.bindings._padding import lib
+
+
+@six.add_metaclass(abc.ABCMeta)
+class PaddingContext(object):
+    @abc.abstractmethod
+    def update(self, data):
+        """
+        Pads the provided bytes and returns any available data as bytes.
+        """
+
+    @abc.abstractmethod
+    def finalize(self):
+        """
+        Finalize the padding, returns bytes.
+        """
+
+
+class PKCS7(object):
+    def __init__(self, block_size):
+        if not (0 <= block_size < 256):
+            raise ValueError("block_size must be in range(0, 256).")
+
+        if block_size % 8 != 0:
+            raise ValueError("block_size must be a multiple of 8.")
+
+        self.block_size = block_size
+
+    def padder(self):
+        return _PKCS7PaddingContext(self.block_size)
+
+    def unpadder(self):
+        return _PKCS7UnpaddingContext(self.block_size)
+
+
+@utils.register_interface(PaddingContext)
+class _PKCS7PaddingContext(object):
+    def __init__(self, block_size):
+        self.block_size = block_size
+        # TODO: more copies than necessary, we should use zero-buffer (#193)
+        self._buffer = b""
+
+    def update(self, data):
+        if self._buffer is None:
+            raise AlreadyFinalized("Context was already finalized.")
+
+        if not isinstance(data, bytes):
+            raise TypeError("data must be bytes.")
+
+        self._buffer += data
+
+        finished_blocks = len(self._buffer) // (self.block_size // 8)
+
+        result = self._buffer[:finished_blocks * (self.block_size // 8)]
+        self._buffer = self._buffer[finished_blocks * (self.block_size // 8):]
+
+        return result
+
+    def finalize(self):
+        if self._buffer is None:
+            raise AlreadyFinalized("Context was already finalized.")
+
+        pad_size = self.block_size // 8 - len(self._buffer)
+        result = self._buffer + six.int2byte(pad_size) * pad_size
+        self._buffer = None
+        return result
+
+
+@utils.register_interface(PaddingContext)
+class _PKCS7UnpaddingContext(object):
+    def __init__(self, block_size):
+        self.block_size = block_size
+        # TODO: more copies than necessary, we should use zero-buffer (#193)
+        self._buffer = b""
+
+    def update(self, data):
+        if self._buffer is None:
+            raise AlreadyFinalized("Context was already finalized.")
+
+        if not isinstance(data, bytes):
+            raise TypeError("data must be bytes.")
+
+        self._buffer += data
+
+        finished_blocks = max(
+            len(self._buffer) // (self.block_size // 8) - 1,
+            0
+        )
+
+        result = self._buffer[:finished_blocks * (self.block_size // 8)]
+        self._buffer = self._buffer[finished_blocks * (self.block_size // 8):]
+
+        return result
+
+    def finalize(self):
+        if self._buffer is None:
+            raise AlreadyFinalized("Context was already finalized.")
+
+        if len(self._buffer) != self.block_size // 8:
+            raise ValueError("Invalid padding bytes.")
+
+        valid = lib.Cryptography_check_pkcs7_padding(
+            self._buffer, self.block_size // 8
+        )
+
+        if not valid:
+            raise ValueError("Invalid padding bytes.")
+
+        pad_size = six.indexbytes(self._buffer, -1)
+        res = self._buffer[:-pad_size]
+        self._buffer = None
+        return res
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/serialization.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/serialization.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/serialization.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/serialization.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,188 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import abc
+import base64
+import struct
+from enum import Enum
+
+import six
+
+from cryptography import utils
+from cryptography.exceptions import UnsupportedAlgorithm
+from cryptography.hazmat.primitives.asymmetric import dsa, ec, rsa
+
+
+def load_pem_private_key(data, password, backend):
+    return backend.load_pem_private_key(data, password)
+
+
+def load_pem_public_key(data, backend):
+    return backend.load_pem_public_key(data)
+
+
+def load_der_private_key(data, password, backend):
+    return backend.load_der_private_key(data, password)
+
+
+def load_der_public_key(data, backend):
+    return backend.load_der_public_key(data)
+
+
+def load_ssh_public_key(data, backend):
+    key_parts = data.split(b' ', 2)
+
+    if len(key_parts) < 2:
+        raise ValueError(
+            'Key is not in the proper format or contains extra data.')
+
+    key_type = key_parts[0]
+
+    if key_type == b'ssh-rsa':
+        loader = _load_ssh_rsa_public_key
+    elif key_type == b'ssh-dss':
+        loader = _load_ssh_dss_public_key
+    elif key_type in [
+        b'ecdsa-sha2-nistp256', b'ecdsa-sha2-nistp384', b'ecdsa-sha2-nistp521',
+    ]:
+        loader = _load_ssh_ecdsa_public_key
+    else:
+        raise UnsupportedAlgorithm('Key type is not supported.')
+
+    key_body = key_parts[1]
+
+    try:
+        decoded_data = base64.b64decode(key_body)
+    except TypeError:
+        raise ValueError('Key is not in the proper format.')
+
+    inner_key_type, rest = _read_next_string(decoded_data)
+
+    if inner_key_type != key_type:
+        raise ValueError(
+            'Key header and key body contain different key type values.'
+        )
+
+    return loader(key_type, rest, backend)
+
+
+def _load_ssh_rsa_public_key(key_type, decoded_data, backend):
+    e, rest = _read_next_mpint(decoded_data)
+    n, rest = _read_next_mpint(rest)
+
+    if rest:
+        raise ValueError('Key body contains extra bytes.')
+
+    return rsa.RSAPublicNumbers(e, n).public_key(backend)
+
+
+def _load_ssh_dss_public_key(key_type, decoded_data, backend):
+    p, rest = _read_next_mpint(decoded_data)
+    q, rest = _read_next_mpint(rest)
+    g, rest = _read_next_mpint(rest)
+    y, rest = _read_next_mpint(rest)
+
+    if rest:
+        raise ValueError('Key body contains extra bytes.')
+
+    parameter_numbers = dsa.DSAParameterNumbers(p, q, g)
+    public_numbers = dsa.DSAPublicNumbers(y, parameter_numbers)
+
+    return public_numbers.public_key(backend)
+
+
+def _load_ssh_ecdsa_public_key(expected_key_type, decoded_data, backend):
+    curve_name, rest = _read_next_string(decoded_data)
+    data, rest = _read_next_string(rest)
+
+    if expected_key_type != b"ecdsa-sha2-" + curve_name:
+        raise ValueError(
+            'Key header and key body contain different key type values.'
+        )
+
+    if rest:
+        raise ValueError('Key body contains extra bytes.')
+
+    curve = {
+        b"nistp256": ec.SECP256R1,
+        b"nistp384": ec.SECP384R1,
+        b"nistp521": ec.SECP521R1,
+    }[curve_name]()
+
+    if six.indexbytes(data, 0) != 4:
+        raise NotImplementedError(
+            "Compressed elliptic curve points are not supported"
+        )
+
+    # key_size is in bits, and sometimes it's not evenly divisible by 8, so we
+    # add 7 to round up the number of bytes.
+    if len(data) != 1 + 2 * ((curve.key_size + 7) // 8):
+        raise ValueError("Malformed key bytes")
+
+    x = utils.int_from_bytes(
+        data[1:1 + (curve.key_size + 7) // 8], byteorder='big'
+    )
+    y = utils.int_from_bytes(
+        data[1 + (curve.key_size + 7) // 8:], byteorder='big'
+    )
+    return ec.EllipticCurvePublicNumbers(x, y, curve).public_key(backend)
+
+
+def _read_next_string(data):
+    """
+    Retrieves the next RFC 4251 string value from the data.
+
+    While the RFC calls these strings, in Python they are bytes objects.
+    """
+    str_len, = struct.unpack('>I', data[:4])
+    return data[4:4 + str_len], data[4 + str_len:]
+
+
+def _read_next_mpint(data):
+    """
+    Reads the next mpint from the data.
+
+    Currently, all mpints are interpreted as unsigned.
+    """
+    mpint_data, rest = _read_next_string(data)
+
+    return (
+        utils.int_from_bytes(mpint_data, byteorder='big', signed=False), rest
+    )
+
+
+class Encoding(Enum):
+    PEM = "PEM"
+    DER = "DER"
+
+
+class PrivateFormat(Enum):
+    PKCS8 = "PKCS8"
+    TraditionalOpenSSL = "TraditionalOpenSSL"
+
+
+class PublicFormat(Enum):
+    SubjectPublicKeyInfo = "X.509 subjectPublicKeyInfo with PKCS#1"
+    PKCS1 = "Raw PKCS#1"
+
+
+@six.add_metaclass(abc.ABCMeta)
+class KeySerializationEncryption(object):
+    pass
+
+
+@utils.register_interface(KeySerializationEncryption)
+class BestAvailableEncryption(object):
+    def __init__(self, password):
+        if not isinstance(password, bytes) or len(password) == 0:
+            raise ValueError("Password must be 1 or more bytes.")
+
+        self.password = password
+
+
+@utils.register_interface(KeySerializationEncryption)
+class NoEncryption(object):
+    pass
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/twofactor/hotp.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/twofactor/hotp.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/twofactor/hotp.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/twofactor/hotp.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,67 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import struct
+
+import six
+
+from cryptography.exceptions import (
+    UnsupportedAlgorithm, _Reasons
+)
+from cryptography.hazmat.backends.interfaces import HMACBackend
+from cryptography.hazmat.primitives import constant_time, hmac
+from cryptography.hazmat.primitives.hashes import SHA1, SHA256, SHA512
+from cryptography.hazmat.primitives.twofactor import InvalidToken
+from cryptography.hazmat.primitives.twofactor.utils import _generate_uri
+
+
+class HOTP(object):
+    def __init__(self, key, length, algorithm, backend):
+        if not isinstance(backend, HMACBackend):
+            raise UnsupportedAlgorithm(
+                "Backend object does not implement HMACBackend.",
+                _Reasons.BACKEND_MISSING_INTERFACE
+            )
+
+        if len(key) < 16:
+            raise ValueError("Key length has to be at least 128 bits.")
+
+        if not isinstance(length, six.integer_types):
+            raise TypeError("Length parameter must be an integer type.")
+
+        if length < 6 or length > 8:
+            raise ValueError("Length of HOTP has to be between 6 to 8.")
+
+        if not isinstance(algorithm, (SHA1, SHA256, SHA512)):
+            raise TypeError("Algorithm must be SHA1, SHA256 or SHA512.")
+
+        self._key = key
+        self._length = length
+        self._algorithm = algorithm
+        self._backend = backend
+
+    def generate(self, counter):
+        truncated_value = self._dynamic_truncate(counter)
+        hotp = truncated_value % (10 ** self._length)
+        return "{0:0{1}}".format(hotp, self._length).encode()
+
+    def verify(self, hotp, counter):
+        if not constant_time.bytes_eq(self.generate(counter), hotp):
+            raise InvalidToken("Supplied HOTP value does not match.")
+
+    def _dynamic_truncate(self, counter):
+        ctx = hmac.HMAC(self._key, self._algorithm, self._backend)
+        ctx.update(struct.pack(">Q", counter))
+        hmac_value = ctx.finalize()
+
+        offset = six.indexbytes(hmac_value, len(hmac_value) - 1) & 0b1111
+        p = hmac_value[offset:offset + 4]
+        return struct.unpack(">I", p)[0] & 0x7fffffff
+
+    def get_provisioning_uri(self, account_name, counter, issuer):
+        return _generate_uri(self, "hotp", account_name, issuer, [
+            ("counter", int(counter)),
+        ])
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/twofactor/__init__.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/twofactor/__init__.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/twofactor/__init__.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/twofactor/__init__.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,9 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+
+class InvalidToken(Exception):
+    pass
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/twofactor/totp.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/twofactor/totp.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/twofactor/totp.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/twofactor/totp.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,39 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+from cryptography.exceptions import (
+    UnsupportedAlgorithm, _Reasons
+)
+from cryptography.hazmat.backends.interfaces import HMACBackend
+from cryptography.hazmat.primitives import constant_time
+from cryptography.hazmat.primitives.twofactor import InvalidToken
+from cryptography.hazmat.primitives.twofactor.hotp import HOTP
+from cryptography.hazmat.primitives.twofactor.utils import _generate_uri
+
+
+class TOTP(object):
+    def __init__(self, key, length, algorithm, time_step, backend):
+        if not isinstance(backend, HMACBackend):
+            raise UnsupportedAlgorithm(
+                "Backend object does not implement HMACBackend.",
+                _Reasons.BACKEND_MISSING_INTERFACE
+            )
+
+        self._time_step = time_step
+        self._hotp = HOTP(key, length, algorithm, backend)
+
+    def generate(self, time):
+        counter = int(time / self._time_step)
+        return self._hotp.generate(counter)
+
+    def verify(self, totp, time):
+        if not constant_time.bytes_eq(self.generate(time), totp):
+            raise InvalidToken("Supplied TOTP value does not match.")
+
+    def get_provisioning_uri(self, account_name, issuer):
+        return _generate_uri(self._hotp, "totp", account_name, issuer, [
+            ("period", int(self._time_step)),
+        ])
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/twofactor/utils.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/twofactor/utils.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/twofactor/utils.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/hazmat/primitives/twofactor/utils.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,30 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import base64
+
+from six.moves.urllib.parse import quote, urlencode
+
+
+def _generate_uri(hotp, type_name, account_name, issuer, extra_parameters):
+    parameters = [
+        ("digits", hotp._length),
+        ("secret", base64.b32encode(hotp._key)),
+        ("algorithm", hotp._algorithm.name.upper()),
+    ]
+
+    if issuer is not None:
+        parameters.append(("issuer", issuer))
+
+    parameters.extend(extra_parameters)
+
+    uriparts = {
+        "type": type_name,
+        "label": ("%s:%s" % (quote(issuer), quote(account_name)) if issuer
+                  else quote(account_name)),
+        "parameters": urlencode(parameters),
+    }
+    return "otpauth://{type}/{label}?{parameters}".format(**uriparts)
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/__init__.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/__init__.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/__init__.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/__init__.py	2015-11-19 05:01:40.000000000 +0100
@@ -0,0 +1,26 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import sys
+import warnings
+
+from cryptography.__about__ import (
+    __author__, __copyright__, __email__, __license__, __summary__, __title__,
+    __uri__, __version__
+)
+
+
+__all__ = [
+    "__title__", "__summary__", "__uri__", "__version__", "__author__",
+    "__email__", "__license__", "__copyright__",
+]
+
+if sys.version_info[:2] == (2, 6):
+    warnings.warn(
+        "Python 2.6 is no longer supported by the Python core team, please "
+        "upgrade your Python.",
+        DeprecationWarning
+    )
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/utils.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/utils.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/utils.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/utils.py	2015-11-19 05:01:40.000000000 +0100
@@ -0,0 +1,127 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import abc
+import binascii
+import inspect
+import struct
+import sys
+import warnings
+
+
+DeprecatedIn09 = DeprecationWarning
+DeprecatedIn10 = PendingDeprecationWarning
+
+
+def read_only_property(name):
+    return property(lambda self: getattr(self, name))
+
+
+def register_interface(iface):
+    def register_decorator(klass):
+        verify_interface(iface, klass)
+        iface.register(klass)
+        return klass
+    return register_decorator
+
+
+if hasattr(int, "from_bytes"):
+    int_from_bytes = int.from_bytes
+else:
+    def int_from_bytes(data, byteorder, signed=False):
+        assert byteorder == 'big'
+        assert not signed
+
+        if len(data) % 4 != 0:
+            data = (b'\x00' * (4 - (len(data) % 4))) + data
+
+        result = 0
+
+        while len(data) > 0:
+            digit, = struct.unpack('>I', data[:4])
+            result = (result << 32) + digit
+            data = data[4:]
+
+        return result
+
+
+def int_to_bytes(integer, length=None):
+    hex_string = '%x' % integer
+    if length is None:
+        n = len(hex_string)
+    else:
+        n = length * 2
+    return binascii.unhexlify(hex_string.zfill(n + (n & 1)))
+
+
+class InterfaceNotImplemented(Exception):
+    pass
+
+
+if hasattr(inspect, "signature"):
+    signature = inspect.signature
+else:
+    signature = inspect.getargspec
+
+
+def verify_interface(iface, klass):
+    for method in iface.__abstractmethods__:
+        if not hasattr(klass, method):
+            raise InterfaceNotImplemented(
+                "{0} is missing a {1!r} method".format(klass, method)
+            )
+        if isinstance(getattr(iface, method), abc.abstractproperty):
+            # Can't properly verify these yet.
+            continue
+        sig = signature(getattr(iface, method))
+        actual = signature(getattr(klass, method))
+        if sig != actual:
+            raise InterfaceNotImplemented(
+                "{0}.{1}'s signature differs from the expected. Expected: "
+                "{2!r}. Received: {3!r}".format(
+                    klass, method, sig, actual
+                )
+            )
+
+
+if sys.version_info >= (2, 7):
+    def bit_length(x):
+        return x.bit_length()
+else:
+    def bit_length(x):
+        return len(bin(x)) - (2 + (x <= 0))
+
+
+class _DeprecatedValue(object):
+    def __init__(self, value, message, warning_class):
+        self.value = value
+        self.message = message
+        self.warning_class = warning_class
+
+
+class _ModuleWithDeprecations(object):
+    def __init__(self, module):
+        self.__dict__["_module"] = module
+
+    def __getattr__(self, attr):
+        obj = getattr(self._module, attr)
+        if isinstance(obj, _DeprecatedValue):
+            warnings.warn(obj.message, obj.warning_class, stacklevel=2)
+            obj = obj.value
+        return obj
+
+    def __setattr__(self, attr, value):
+        setattr(self._module, attr, value)
+
+    def __dir__(self):
+        return ["_module"] + dir(self._module)
+
+
+def deprecated(value, module_name, message, warning_class):
+    module = sys.modules[module_name]
+    if not isinstance(module, _ModuleWithDeprecations):
+        sys.modules[module_name] = module = _ModuleWithDeprecations(module)
+    return _DeprecatedValue(value, message, warning_class)
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/x509/base.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/x509/base.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/x509/base.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/x509/base.py	2015-11-19 05:01:40.000000000 +0100
@@ -0,0 +1,467 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import abc
+import datetime
+from enum import Enum
+
+import six
+
+from cryptography import utils
+from cryptography.hazmat.primitives.asymmetric import dsa, ec, rsa
+from cryptography.x509.extensions import Extension, ExtensionType
+from cryptography.x509.name import Name
+
+
+_UNIX_EPOCH = datetime.datetime(1970, 1, 1)
+
+
+class Version(Enum):
+    v1 = 0
+    v3 = 2
+
+
+def load_pem_x509_certificate(data, backend):
+    return backend.load_pem_x509_certificate(data)
+
+
+def load_der_x509_certificate(data, backend):
+    return backend.load_der_x509_certificate(data)
+
+
+def load_pem_x509_csr(data, backend):
+    return backend.load_pem_x509_csr(data)
+
+
+def load_der_x509_csr(data, backend):
+    return backend.load_der_x509_csr(data)
+
+
+def load_pem_x509_crl(data, backend):
+    return backend.load_pem_x509_crl(data)
+
+
+def load_der_x509_crl(data, backend):
+    return backend.load_der_x509_crl(data)
+
+
+class InvalidVersion(Exception):
+    def __init__(self, msg, parsed_version):
+        super(InvalidVersion, self).__init__(msg)
+        self.parsed_version = parsed_version
+
+
+@six.add_metaclass(abc.ABCMeta)
+class Certificate(object):
+    @abc.abstractmethod
+    def fingerprint(self, algorithm):
+        """
+        Returns bytes using digest passed.
+        """
+
+    @abc.abstractproperty
+    def serial(self):
+        """
+        Returns certificate serial number
+        """
+
+    @abc.abstractproperty
+    def version(self):
+        """
+        Returns the certificate version
+        """
+
+    @abc.abstractmethod
+    def public_key(self):
+        """
+        Returns the public key
+        """
+
+    @abc.abstractproperty
+    def not_valid_before(self):
+        """
+        Not before time (represented as UTC datetime)
+        """
+
+    @abc.abstractproperty
+    def not_valid_after(self):
+        """
+        Not after time (represented as UTC datetime)
+        """
+
+    @abc.abstractproperty
+    def issuer(self):
+        """
+        Returns the issuer name object.
+        """
+
+    @abc.abstractproperty
+    def subject(self):
+        """
+        Returns the subject name object.
+        """
+
+    @abc.abstractproperty
+    def signature_hash_algorithm(self):
+        """
+        Returns a HashAlgorithm corresponding to the type of the digest signed
+        in the certificate.
+        """
+
+    @abc.abstractproperty
+    def extensions(self):
+        """
+        Returns an Extensions object.
+        """
+
+    @abc.abstractmethod
+    def __eq__(self, other):
+        """
+        Checks equality.
+        """
+
+    @abc.abstractmethod
+    def __ne__(self, other):
+        """
+        Checks not equal.
+        """
+
+    @abc.abstractmethod
+    def __hash__(self):
+        """
+        Computes a hash.
+        """
+
+    @abc.abstractmethod
+    def public_bytes(self, encoding):
+        """
+        Serializes the certificate to PEM or DER format.
+        """
+
+
+@six.add_metaclass(abc.ABCMeta)
+class CertificateRevocationList(object):
+
+    @abc.abstractmethod
+    def fingerprint(self, algorithm):
+        """
+        Returns bytes using digest passed.
+        """
+
+    @abc.abstractproperty
+    def signature_hash_algorithm(self):
+        """
+        Returns a HashAlgorithm corresponding to the type of the digest signed
+        in the certificate.
+        """
+
+    @abc.abstractproperty
+    def issuer(self):
+        """
+        Returns the X509Name with the issuer of this CRL.
+        """
+
+    @abc.abstractproperty
+    def next_update(self):
+        """
+        Returns the date of next update for this CRL.
+        """
+
+    @abc.abstractproperty
+    def last_update(self):
+        """
+        Returns the date of last update for this CRL.
+        """
+
+    @abc.abstractproperty
+    def extensions(self):
+        """
+        Returns an Extensions object containing a list of CRL extensions.
+        """
+
+    @abc.abstractmethod
+    def __eq__(self, other):
+        """
+        Checks equality.
+        """
+
+    @abc.abstractmethod
+    def __ne__(self, other):
+        """
+        Checks not equal.
+        """
+
+
+@six.add_metaclass(abc.ABCMeta)
+class CertificateSigningRequest(object):
+    @abc.abstractmethod
+    def __eq__(self, other):
+        """
+        Checks equality.
+        """
+
+    @abc.abstractmethod
+    def __ne__(self, other):
+        """
+        Checks not equal.
+        """
+
+    @abc.abstractmethod
+    def __hash__(self):
+        """
+        Computes a hash.
+        """
+
+    @abc.abstractmethod
+    def public_key(self):
+        """
+        Returns the public key
+        """
+
+    @abc.abstractproperty
+    def subject(self):
+        """
+        Returns the subject name object.
+        """
+
+    @abc.abstractproperty
+    def signature_hash_algorithm(self):
+        """
+        Returns a HashAlgorithm corresponding to the type of the digest signed
+        in the certificate.
+        """
+
+    @abc.abstractproperty
+    def extensions(self):
+        """
+        Returns the extensions in the signing request.
+        """
+
+    @abc.abstractmethod
+    def public_bytes(self, encoding):
+        """
+        Encodes the request to PEM or DER format.
+        """
+
+
+@six.add_metaclass(abc.ABCMeta)
+class RevokedCertificate(object):
+    @abc.abstractproperty
+    def serial_number(self):
+        """
+        Returns the serial number of the revoked certificate.
+        """
+
+    @abc.abstractproperty
+    def revocation_date(self):
+        """
+        Returns the date of when this certificate was revoked.
+        """
+
+    @abc.abstractproperty
+    def extensions(self):
+        """
+        Returns an Extensions object containing a list of Revoked extensions.
+        """
+
+
+class CertificateSigningRequestBuilder(object):
+    def __init__(self, subject_name=None, extensions=[]):
+        """
+        Creates an empty X.509 certificate request (v1).
+        """
+        self._subject_name = subject_name
+        self._extensions = extensions
+
+    def subject_name(self, name):
+        """
+        Sets the certificate requestor's distinguished name.
+        """
+        if not isinstance(name, Name):
+            raise TypeError('Expecting x509.Name object.')
+        if self._subject_name is not None:
+            raise ValueError('The subject name may only be set once.')
+        return CertificateSigningRequestBuilder(name, self._extensions)
+
+    def add_extension(self, extension, critical):
+        """
+        Adds an X.509 extension to the certificate request.
+        """
+        if not isinstance(extension, ExtensionType):
+            raise TypeError("extension must be an ExtensionType")
+
+        extension = Extension(extension.oid, critical, extension)
+
+        # TODO: This is quadratic in the number of extensions
+        for e in self._extensions:
+            if e.oid == extension.oid:
+                raise ValueError('This extension has already been set.')
+        return CertificateSigningRequestBuilder(
+            self._subject_name, self._extensions + [extension]
+        )
+
+    def sign(self, private_key, algorithm, backend):
+        """
+        Signs the request using the requestor's private key.
+        """
+        if self._subject_name is None:
+            raise ValueError("A CertificateSigningRequest must have a subject")
+        return backend.create_x509_csr(self, private_key, algorithm)
+
+
+class CertificateBuilder(object):
+    def __init__(self, issuer_name=None, subject_name=None,
+                 public_key=None, serial_number=None, not_valid_before=None,
+                 not_valid_after=None, extensions=[]):
+        self._version = Version.v3
+        self._issuer_name = issuer_name
+        self._subject_name = subject_name
+        self._public_key = public_key
+        self._serial_number = serial_number
+        self._not_valid_before = not_valid_before
+        self._not_valid_after = not_valid_after
+        self._extensions = extensions
+
+    def issuer_name(self, name):
+        """
+        Sets the CA's distinguished name.
+        """
+        if not isinstance(name, Name):
+            raise TypeError('Expecting x509.Name object.')
+        if self._issuer_name is not None:
+            raise ValueError('The issuer name may only be set once.')
+        return CertificateBuilder(
+            name, self._subject_name, self._public_key,
+            self._serial_number, self._not_valid_before,
+            self._not_valid_after, self._extensions
+        )
+
+    def subject_name(self, name):
+        """
+        Sets the requestor's distinguished name.
+        """
+        if not isinstance(name, Name):
+            raise TypeError('Expecting x509.Name object.')
+        if self._subject_name is not None:
+            raise ValueError('The subject name may only be set once.')
+        return CertificateBuilder(
+            self._issuer_name, name, self._public_key,
+            self._serial_number, self._not_valid_before,
+            self._not_valid_after, self._extensions
+        )
+
+    def public_key(self, key):
+        """
+        Sets the requestor's public key (as found in the signing request).
+        """
+        if not isinstance(key, (dsa.DSAPublicKey, rsa.RSAPublicKey,
+                                ec.EllipticCurvePublicKey)):
+            raise TypeError('Expecting one of DSAPublicKey, RSAPublicKey,'
+                            ' or EllipticCurvePublicKey.')
+        if self._public_key is not None:
+            raise ValueError('The public key may only be set once.')
+        return CertificateBuilder(
+            self._issuer_name, self._subject_name, key,
+            self._serial_number, self._not_valid_before,
+            self._not_valid_after, self._extensions
+        )
+
+    def serial_number(self, number):
+        """
+        Sets the certificate serial number.
+        """
+        if not isinstance(number, six.integer_types):
+            raise TypeError('Serial number must be of integral type.')
+        if self._serial_number is not None:
+            raise ValueError('The serial number may only be set once.')
+        if number < 0:
+            raise ValueError('The serial number should be non-negative.')
+        if utils.bit_length(number) > 160:  # As defined in RFC 5280
+            raise ValueError('The serial number should not be more than 160 '
+                             'bits.')
+        return CertificateBuilder(
+            self._issuer_name, self._subject_name,
+            self._public_key, number, self._not_valid_before,
+            self._not_valid_after, self._extensions
+        )
+
+    def not_valid_before(self, time):
+        """
+        Sets the certificate activation time.
+        """
+        if not isinstance(time, datetime.datetime):
+            raise TypeError('Expecting datetime object.')
+        if self._not_valid_before is not None:
+            raise ValueError('The not valid before may only be set once.')
+        if time <= _UNIX_EPOCH:
+            raise ValueError('The not valid before date must be after the unix'
+                             ' epoch (1970 January 1).')
+        return CertificateBuilder(
+            self._issuer_name, self._subject_name,
+            self._public_key, self._serial_number, time,
+            self._not_valid_after, self._extensions
+        )
+
+    def not_valid_after(self, time):
+        """
+        Sets the certificate expiration time.
+        """
+        if not isinstance(time, datetime.datetime):
+            raise TypeError('Expecting datetime object.')
+        if self._not_valid_after is not None:
+            raise ValueError('The not valid after may only be set once.')
+        if time <= _UNIX_EPOCH:
+            raise ValueError('The not valid after date must be after the unix'
+                             ' epoch (1970 January 1).')
+        return CertificateBuilder(
+            self._issuer_name, self._subject_name,
+            self._public_key, self._serial_number, self._not_valid_before,
+            time, self._extensions
+        )
+
+    def add_extension(self, extension, critical):
+        """
+        Adds an X.509 extension to the certificate.
+        """
+        if not isinstance(extension, ExtensionType):
+            raise TypeError("extension must be an ExtensionType")
+
+        extension = Extension(extension.oid, critical, extension)
+
+        # TODO: This is quadratic in the number of extensions
+        for e in self._extensions:
+            if e.oid == extension.oid:
+                raise ValueError('This extension has already been set.')
+
+        return CertificateBuilder(
+            self._issuer_name, self._subject_name,
+            self._public_key, self._serial_number, self._not_valid_before,
+            self._not_valid_after, self._extensions + [extension]
+        )
+
+    def sign(self, private_key, algorithm, backend):
+        """
+        Signs the certificate using the CA's private key.
+        """
+        if self._subject_name is None:
+            raise ValueError("A certificate must have a subject name")
+
+        if self._issuer_name is None:
+            raise ValueError("A certificate must have an issuer name")
+
+        if self._serial_number is None:
+            raise ValueError("A certificate must have a serial number")
+
+        if self._not_valid_before is None:
+            raise ValueError("A certificate must have a not valid before time")
+
+        if self._not_valid_after is None:
+            raise ValueError("A certificate must have a not valid after time")
+
+        if self._public_key is None:
+            raise ValueError("A certificate must have a public key")
+
+        return backend.create_x509_certificate(self, private_key, algorithm)
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/x509/extensions.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/x509/extensions.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/x509/extensions.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/x509/extensions.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,924 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import abc
+import hashlib
+import ipaddress
+from enum import Enum
+
+from pyasn1.codec.der import decoder
+from pyasn1.type import namedtype, univ
+
+import six
+
+from cryptography import utils
+from cryptography.hazmat.primitives import constant_time, serialization
+from cryptography.x509.general_name import GeneralName, IPAddress, OtherName
+from cryptography.x509.name import Name
+from cryptography.x509.oid import (
+    AuthorityInformationAccessOID, ExtensionOID, ObjectIdentifier
+)
+
+
+class _SubjectPublicKeyInfo(univ.Sequence):
+    componentType = namedtype.NamedTypes(
+        namedtype.NamedType('algorithm', univ.Sequence()),
+        namedtype.NamedType('subjectPublicKey', univ.BitString())
+    )
+
+
+def _key_identifier_from_public_key(public_key):
+    # This is a very slow way to do this.
+    serialized = public_key.public_bytes(
+        serialization.Encoding.DER,
+        serialization.PublicFormat.SubjectPublicKeyInfo
+    )
+    spki, remaining = decoder.decode(
+        serialized, asn1Spec=_SubjectPublicKeyInfo()
+    )
+    assert not remaining
+    # the univ.BitString object is a tuple of bits. We need bytes and
+    # pyasn1 really doesn't want to give them to us. To get it we'll
+    # build an integer and convert that to bytes.
+    bits = 0
+    for bit in spki.getComponentByName("subjectPublicKey"):
+        bits = bits << 1 | bit
+
+    data = utils.int_to_bytes(bits)
+    return hashlib.sha1(data).digest()
+
+
+class DuplicateExtension(Exception):
+    def __init__(self, msg, oid):
+        super(DuplicateExtension, self).__init__(msg)
+        self.oid = oid
+
+
+class UnsupportedExtension(Exception):
+    def __init__(self, msg, oid):
+        super(UnsupportedExtension, self).__init__(msg)
+        self.oid = oid
+
+
+class ExtensionNotFound(Exception):
+    def __init__(self, msg, oid):
+        super(ExtensionNotFound, self).__init__(msg)
+        self.oid = oid
+
+
+@six.add_metaclass(abc.ABCMeta)
+class ExtensionType(object):
+    @abc.abstractproperty
+    def oid(self):
+        """
+        Returns the oid associated with the given extension type.
+        """
+
+
+class Extensions(object):
+    def __init__(self, extensions):
+        self._extensions = extensions
+
+    def get_extension_for_oid(self, oid):
+        for ext in self:
+            if ext.oid == oid:
+                return ext
+
+        raise ExtensionNotFound("No {0} extension was found".format(oid), oid)
+
+    def get_extension_for_class(self, extclass):
+        for ext in self:
+            if isinstance(ext.value, extclass):
+                return ext
+
+        raise ExtensionNotFound(
+            "No {0} extension was found".format(extclass), extclass.oid
+        )
+
+    def __iter__(self):
+        return iter(self._extensions)
+
+    def __len__(self):
+        return len(self._extensions)
+
+    def __repr__(self):
+        return (
+            "<Extensions({0})>".format(self._extensions)
+        )
+
+
+@utils.register_interface(ExtensionType)
+class AuthorityKeyIdentifier(object):
+    oid = ExtensionOID.AUTHORITY_KEY_IDENTIFIER
+
+    def __init__(self, key_identifier, authority_cert_issuer,
+                 authority_cert_serial_number):
+        if authority_cert_issuer or authority_cert_serial_number:
+            if not authority_cert_issuer or not authority_cert_serial_number:
+                raise ValueError(
+                    "authority_cert_issuer and authority_cert_serial_number "
+                    "must both be present or both None"
+                )
+
+            if not all(
+                isinstance(x, GeneralName) for x in authority_cert_issuer
+            ):
+                raise TypeError(
+                    "authority_cert_issuer must be a list of GeneralName "
+                    "objects"
+                )
+
+            if not isinstance(authority_cert_serial_number, six.integer_types):
+                raise TypeError(
+                    "authority_cert_serial_number must be an integer"
+                )
+
+        self._key_identifier = key_identifier
+        self._authority_cert_issuer = authority_cert_issuer
+        self._authority_cert_serial_number = authority_cert_serial_number
+
+    @classmethod
+    def from_issuer_public_key(cls, public_key):
+        digest = _key_identifier_from_public_key(public_key)
+        return cls(
+            key_identifier=digest,
+            authority_cert_issuer=None,
+            authority_cert_serial_number=None
+        )
+
+    def __repr__(self):
+        return (
+            "<AuthorityKeyIdentifier(key_identifier={0.key_identifier!r}, "
+            "authority_cert_issuer={0.authority_cert_issuer}, "
+            "authority_cert_serial_number={0.authority_cert_serial_number}"
+            ")>".format(self)
+        )
+
+    def __eq__(self, other):
+        if not isinstance(other, AuthorityKeyIdentifier):
+            return NotImplemented
+
+        return (
+            self.key_identifier == other.key_identifier and
+            self.authority_cert_issuer == other.authority_cert_issuer and
+            self.authority_cert_serial_number ==
+            other.authority_cert_serial_number
+        )
+
+    def __ne__(self, other):
+        return not self == other
+
+    key_identifier = utils.read_only_property("_key_identifier")
+    authority_cert_issuer = utils.read_only_property("_authority_cert_issuer")
+    authority_cert_serial_number = utils.read_only_property(
+        "_authority_cert_serial_number"
+    )
+
+
+@utils.register_interface(ExtensionType)
+class SubjectKeyIdentifier(object):
+    oid = ExtensionOID.SUBJECT_KEY_IDENTIFIER
+
+    def __init__(self, digest):
+        self._digest = digest
+
+    @classmethod
+    def from_public_key(cls, public_key):
+        return cls(_key_identifier_from_public_key(public_key))
+
+    digest = utils.read_only_property("_digest")
+
+    def __repr__(self):
+        return "<SubjectKeyIdentifier(digest={0!r})>".format(self.digest)
+
+    def __eq__(self, other):
+        if not isinstance(other, SubjectKeyIdentifier):
+            return NotImplemented
+
+        return constant_time.bytes_eq(self.digest, other.digest)
+
+    def __ne__(self, other):
+        return not self == other
+
+
+@utils.register_interface(ExtensionType)
+class AuthorityInformationAccess(object):
+    oid = ExtensionOID.AUTHORITY_INFORMATION_ACCESS
+
+    def __init__(self, descriptions):
+        if not all(isinstance(x, AccessDescription) for x in descriptions):
+            raise TypeError(
+                "Every item in the descriptions list must be an "
+                "AccessDescription"
+            )
+
+        self._descriptions = descriptions
+
+    def __iter__(self):
+        return iter(self._descriptions)
+
+    def __len__(self):
+        return len(self._descriptions)
+
+    def __repr__(self):
+        return "<AuthorityInformationAccess({0})>".format(self._descriptions)
+
+    def __eq__(self, other):
+        if not isinstance(other, AuthorityInformationAccess):
+            return NotImplemented
+
+        return self._descriptions == other._descriptions
+
+    def __ne__(self, other):
+        return not self == other
+
+
+class AccessDescription(object):
+    def __init__(self, access_method, access_location):
+        if not (access_method == AuthorityInformationAccessOID.OCSP or
+                access_method == AuthorityInformationAccessOID.CA_ISSUERS):
+            raise ValueError(
+                "access_method must be OID_OCSP or OID_CA_ISSUERS"
+            )
+
+        if not isinstance(access_location, GeneralName):
+            raise TypeError("access_location must be a GeneralName")
+
+        self._access_method = access_method
+        self._access_location = access_location
+
+    def __repr__(self):
+        return (
+            "<AccessDescription(access_method={0.access_method}, access_locati"
+            "on={0.access_location})>".format(self)
+        )
+
+    def __eq__(self, other):
+        if not isinstance(other, AccessDescription):
+            return NotImplemented
+
+        return (
+            self.access_method == other.access_method and
+            self.access_location == other.access_location
+        )
+
+    def __ne__(self, other):
+        return not self == other
+
+    access_method = utils.read_only_property("_access_method")
+    access_location = utils.read_only_property("_access_location")
+
+
+@utils.register_interface(ExtensionType)
+class BasicConstraints(object):
+    oid = ExtensionOID.BASIC_CONSTRAINTS
+
+    def __init__(self, ca, path_length):
+        if not isinstance(ca, bool):
+            raise TypeError("ca must be a boolean value")
+
+        if path_length is not None and not ca:
+            raise ValueError("path_length must be None when ca is False")
+
+        if (
+            path_length is not None and
+            (not isinstance(path_length, six.integer_types) or path_length < 0)
+        ):
+            raise TypeError(
+                "path_length must be a non-negative integer or None"
+            )
+
+        self._ca = ca
+        self._path_length = path_length
+
+    ca = utils.read_only_property("_ca")
+    path_length = utils.read_only_property("_path_length")
+
+    def __repr__(self):
+        return ("<BasicConstraints(ca={0.ca}, "
+                "path_length={0.path_length})>").format(self)
+
+    def __eq__(self, other):
+        if not isinstance(other, BasicConstraints):
+            return NotImplemented
+
+        return self.ca == other.ca and self.path_length == other.path_length
+
+    def __ne__(self, other):
+        return not self == other
+
+
+@utils.register_interface(ExtensionType)
+class CRLDistributionPoints(object):
+    oid = ExtensionOID.CRL_DISTRIBUTION_POINTS
+
+    def __init__(self, distribution_points):
+        if not all(
+            isinstance(x, DistributionPoint) for x in distribution_points
+        ):
+            raise TypeError(
+                "distribution_points must be a list of DistributionPoint "
+                "objects"
+            )
+
+        self._distribution_points = distribution_points
+
+    def __iter__(self):
+        return iter(self._distribution_points)
+
+    def __len__(self):
+        return len(self._distribution_points)
+
+    def __repr__(self):
+        return "<CRLDistributionPoints({0})>".format(self._distribution_points)
+
+    def __eq__(self, other):
+        if not isinstance(other, CRLDistributionPoints):
+            return NotImplemented
+
+        return self._distribution_points == other._distribution_points
+
+    def __ne__(self, other):
+        return not self == other
+
+
+class DistributionPoint(object):
+    def __init__(self, full_name, relative_name, reasons, crl_issuer):
+        if full_name and relative_name:
+            raise ValueError(
+                "You cannot provide both full_name and relative_name, at "
+                "least one must be None."
+            )
+
+        if full_name and not all(
+            isinstance(x, GeneralName) for x in full_name
+        ):
+            raise TypeError(
+                "full_name must be a list of GeneralName objects"
+            )
+
+        if relative_name and not isinstance(relative_name, Name):
+            raise TypeError("relative_name must be a Name")
+
+        if crl_issuer and not all(
+            isinstance(x, GeneralName) for x in crl_issuer
+        ):
+            raise TypeError(
+                "crl_issuer must be None or a list of general names"
+            )
+
+        if reasons and (not isinstance(reasons, frozenset) or not all(
+            isinstance(x, ReasonFlags) for x in reasons
+        )):
+            raise TypeError("reasons must be None or frozenset of ReasonFlags")
+
+        if reasons and (
+            ReasonFlags.unspecified in reasons or
+            ReasonFlags.remove_from_crl in reasons
+        ):
+            raise ValueError(
+                "unspecified and remove_from_crl are not valid reasons in a "
+                "DistributionPoint"
+            )
+
+        if reasons and not crl_issuer and not (full_name or relative_name):
+            raise ValueError(
+                "You must supply crl_issuer, full_name, or relative_name when "
+                "reasons is not None"
+            )
+
+        self._full_name = full_name
+        self._relative_name = relative_name
+        self._reasons = reasons
+        self._crl_issuer = crl_issuer
+
+    def __repr__(self):
+        return (
+            "<DistributionPoint(full_name={0.full_name}, relative_name={0.rela"
+            "tive_name}, reasons={0.reasons}, crl_issuer={0.crl_is"
+            "suer})>".format(self)
+        )
+
+    def __eq__(self, other):
+        if not isinstance(other, DistributionPoint):
+            return NotImplemented
+
+        return (
+            self.full_name == other.full_name and
+            self.relative_name == other.relative_name and
+            self.reasons == other.reasons and
+            self.crl_issuer == other.crl_issuer
+        )
+
+    def __ne__(self, other):
+        return not self == other
+
+    full_name = utils.read_only_property("_full_name")
+    relative_name = utils.read_only_property("_relative_name")
+    reasons = utils.read_only_property("_reasons")
+    crl_issuer = utils.read_only_property("_crl_issuer")
+
+
+class ReasonFlags(Enum):
+    unspecified = "unspecified"
+    key_compromise = "keyCompromise"
+    ca_compromise = "cACompromise"
+    affiliation_changed = "affiliationChanged"
+    superseded = "superseded"
+    cessation_of_operation = "cessationOfOperation"
+    certificate_hold = "certificateHold"
+    privilege_withdrawn = "privilegeWithdrawn"
+    aa_compromise = "aACompromise"
+    remove_from_crl = "removeFromCRL"
+
+
+@utils.register_interface(ExtensionType)
+class CertificatePolicies(object):
+    oid = ExtensionOID.CERTIFICATE_POLICIES
+
+    def __init__(self, policies):
+        if not all(isinstance(x, PolicyInformation) for x in policies):
+            raise TypeError(
+                "Every item in the policies list must be a "
+                "PolicyInformation"
+            )
+
+        self._policies = policies
+
+    def __iter__(self):
+        return iter(self._policies)
+
+    def __len__(self):
+        return len(self._policies)
+
+    def __repr__(self):
+        return "<CertificatePolicies({0})>".format(self._policies)
+
+    def __eq__(self, other):
+        if not isinstance(other, CertificatePolicies):
+            return NotImplemented
+
+        return self._policies == other._policies
+
+    def __ne__(self, other):
+        return not self == other
+
+
+class PolicyInformation(object):
+    def __init__(self, policy_identifier, policy_qualifiers):
+        if not isinstance(policy_identifier, ObjectIdentifier):
+            raise TypeError("policy_identifier must be an ObjectIdentifier")
+
+        self._policy_identifier = policy_identifier
+        if policy_qualifiers and not all(
+            isinstance(
+                x, (six.text_type, UserNotice)
+            ) for x in policy_qualifiers
+        ):
+            raise TypeError(
+                "policy_qualifiers must be a list of strings and/or UserNotice"
+                " objects or None"
+            )
+
+        self._policy_qualifiers = policy_qualifiers
+
+    def __repr__(self):
+        return (
+            "<PolicyInformation(policy_identifier={0.policy_identifier}, polic"
+            "y_qualifiers={0.policy_qualifiers})>".format(self)
+        )
+
+    def __eq__(self, other):
+        if not isinstance(other, PolicyInformation):
+            return NotImplemented
+
+        return (
+            self.policy_identifier == other.policy_identifier and
+            self.policy_qualifiers == other.policy_qualifiers
+        )
+
+    def __ne__(self, other):
+        return not self == other
+
+    policy_identifier = utils.read_only_property("_policy_identifier")
+    policy_qualifiers = utils.read_only_property("_policy_qualifiers")
+
+
+class UserNotice(object):
+    def __init__(self, notice_reference, explicit_text):
+        if notice_reference and not isinstance(
+            notice_reference, NoticeReference
+        ):
+            raise TypeError(
+                "notice_reference must be None or a NoticeReference"
+            )
+
+        self._notice_reference = notice_reference
+        self._explicit_text = explicit_text
+
+    def __repr__(self):
+        return (
+            "<UserNotice(notice_reference={0.notice_reference}, explicit_text="
+            "{0.explicit_text!r})>".format(self)
+        )
+
+    def __eq__(self, other):
+        if not isinstance(other, UserNotice):
+            return NotImplemented
+
+        return (
+            self.notice_reference == other.notice_reference and
+            self.explicit_text == other.explicit_text
+        )
+
+    def __ne__(self, other):
+        return not self == other
+
+    notice_reference = utils.read_only_property("_notice_reference")
+    explicit_text = utils.read_only_property("_explicit_text")
+
+
+class NoticeReference(object):
+    def __init__(self, organization, notice_numbers):
+        self._organization = organization
+        if not isinstance(notice_numbers, list) or not all(
+            isinstance(x, int) for x in notice_numbers
+        ):
+            raise TypeError(
+                "notice_numbers must be a list of integers"
+            )
+
+        self._notice_numbers = notice_numbers
+
+    def __repr__(self):
+        return (
+            "<NoticeReference(organization={0.organization!r}, notice_numbers="
+            "{0.notice_numbers})>".format(self)
+        )
+
+    def __eq__(self, other):
+        if not isinstance(other, NoticeReference):
+            return NotImplemented
+
+        return (
+            self.organization == other.organization and
+            self.notice_numbers == other.notice_numbers
+        )
+
+    def __ne__(self, other):
+        return not self == other
+
+    organization = utils.read_only_property("_organization")
+    notice_numbers = utils.read_only_property("_notice_numbers")
+
+
+@utils.register_interface(ExtensionType)
+class ExtendedKeyUsage(object):
+    oid = ExtensionOID.EXTENDED_KEY_USAGE
+
+    def __init__(self, usages):
+        if not all(isinstance(x, ObjectIdentifier) for x in usages):
+            raise TypeError(
+                "Every item in the usages list must be an ObjectIdentifier"
+            )
+
+        self._usages = usages
+
+    def __iter__(self):
+        return iter(self._usages)
+
+    def __len__(self):
+        return len(self._usages)
+
+    def __repr__(self):
+        return "<ExtendedKeyUsage({0})>".format(self._usages)
+
+    def __eq__(self, other):
+        if not isinstance(other, ExtendedKeyUsage):
+            return NotImplemented
+
+        return self._usages == other._usages
+
+    def __ne__(self, other):
+        return not self == other
+
+
+@utils.register_interface(ExtensionType)
+class OCSPNoCheck(object):
+    oid = ExtensionOID.OCSP_NO_CHECK
+
+
+@utils.register_interface(ExtensionType)
+class InhibitAnyPolicy(object):
+    oid = ExtensionOID.INHIBIT_ANY_POLICY
+
+    def __init__(self, skip_certs):
+        if not isinstance(skip_certs, six.integer_types):
+            raise TypeError("skip_certs must be an integer")
+
+        if skip_certs < 0:
+            raise ValueError("skip_certs must be a non-negative integer")
+
+        self._skip_certs = skip_certs
+
+    def __repr__(self):
+        return "<InhibitAnyPolicy(skip_certs={0.skip_certs})>".format(self)
+
+    def __eq__(self, other):
+        if not isinstance(other, InhibitAnyPolicy):
+            return NotImplemented
+
+        return self.skip_certs == other.skip_certs
+
+    def __ne__(self, other):
+        return not self == other
+
+    skip_certs = utils.read_only_property("_skip_certs")
+
+
+@utils.register_interface(ExtensionType)
+class KeyUsage(object):
+    oid = ExtensionOID.KEY_USAGE
+
+    def __init__(self, digital_signature, content_commitment, key_encipherment,
+                 data_encipherment, key_agreement, key_cert_sign, crl_sign,
+                 encipher_only, decipher_only):
+        if not key_agreement and (encipher_only or decipher_only):
+            raise ValueError(
+                "encipher_only and decipher_only can only be true when "
+                "key_agreement is true"
+            )
+
+        self._digital_signature = digital_signature
+        self._content_commitment = content_commitment
+        self._key_encipherment = key_encipherment
+        self._data_encipherment = data_encipherment
+        self._key_agreement = key_agreement
+        self._key_cert_sign = key_cert_sign
+        self._crl_sign = crl_sign
+        self._encipher_only = encipher_only
+        self._decipher_only = decipher_only
+
+    digital_signature = utils.read_only_property("_digital_signature")
+    content_commitment = utils.read_only_property("_content_commitment")
+    key_encipherment = utils.read_only_property("_key_encipherment")
+    data_encipherment = utils.read_only_property("_data_encipherment")
+    key_agreement = utils.read_only_property("_key_agreement")
+    key_cert_sign = utils.read_only_property("_key_cert_sign")
+    crl_sign = utils.read_only_property("_crl_sign")
+
+    @property
+    def encipher_only(self):
+        if not self.key_agreement:
+            raise ValueError(
+                "encipher_only is undefined unless key_agreement is true"
+            )
+        else:
+            return self._encipher_only
+
+    @property
+    def decipher_only(self):
+        if not self.key_agreement:
+            raise ValueError(
+                "decipher_only is undefined unless key_agreement is true"
+            )
+        else:
+            return self._decipher_only
+
+    def __repr__(self):
+        try:
+            encipher_only = self.encipher_only
+            decipher_only = self.decipher_only
+        except ValueError:
+            encipher_only = None
+            decipher_only = None
+
+        return ("<KeyUsage(digital_signature={0.digital_signature}, "
+                "content_commitment={0.content_commitment}, "
+                "key_encipherment={0.key_encipherment}, "
+                "data_encipherment={0.data_encipherment}, "
+                "key_agreement={0.key_agreement}, "
+                "key_cert_sign={0.key_cert_sign}, crl_sign={0.crl_sign}, "
+                "encipher_only={1}, decipher_only={2})>").format(
+                    self, encipher_only, decipher_only)
+
+    def __eq__(self, other):
+        if not isinstance(other, KeyUsage):
+            return NotImplemented
+
+        return (
+            self.digital_signature == other.digital_signature and
+            self.content_commitment == other.content_commitment and
+            self.key_encipherment == other.key_encipherment and
+            self.data_encipherment == other.data_encipherment and
+            self.key_agreement == other.key_agreement and
+            self.key_cert_sign == other.key_cert_sign and
+            self.crl_sign == other.crl_sign and
+            self._encipher_only == other._encipher_only and
+            self._decipher_only == other._decipher_only
+        )
+
+    def __ne__(self, other):
+        return not self == other
+
+
+@utils.register_interface(ExtensionType)
+class NameConstraints(object):
+    oid = ExtensionOID.NAME_CONSTRAINTS
+
+    def __init__(self, permitted_subtrees, excluded_subtrees):
+        if permitted_subtrees is not None:
+            if not all(
+                isinstance(x, GeneralName) for x in permitted_subtrees
+            ):
+                raise TypeError(
+                    "permitted_subtrees must be a list of GeneralName objects "
+                    "or None"
+                )
+
+            self._validate_ip_name(permitted_subtrees)
+
+        if excluded_subtrees is not None:
+            if not all(
+                isinstance(x, GeneralName) for x in excluded_subtrees
+            ):
+                raise TypeError(
+                    "excluded_subtrees must be a list of GeneralName objects "
+                    "or None"
+                )
+
+            self._validate_ip_name(excluded_subtrees)
+
+        if permitted_subtrees is None and excluded_subtrees is None:
+            raise ValueError(
+                "At least one of permitted_subtrees and excluded_subtrees "
+                "must not be None"
+            )
+
+        self._permitted_subtrees = permitted_subtrees
+        self._excluded_subtrees = excluded_subtrees
+
+    def __eq__(self, other):
+        if not isinstance(other, NameConstraints):
+            return NotImplemented
+
+        return (
+            self.excluded_subtrees == other.excluded_subtrees and
+            self.permitted_subtrees == other.permitted_subtrees
+        )
+
+    def __ne__(self, other):
+        return not self == other
+
+    def _validate_ip_name(self, tree):
+        if any(isinstance(name, IPAddress) and not isinstance(
+            name.value, (ipaddress.IPv4Network, ipaddress.IPv6Network)
+        ) for name in tree):
+            raise TypeError(
+                "IPAddress name constraints must be an IPv4Network or"
+                " IPv6Network object"
+            )
+
+    def __repr__(self):
+        return (
+            u"<NameConstraints(permitted_subtrees={0.permitted_subtrees}, "
+            u"excluded_subtrees={0.excluded_subtrees})>".format(self)
+        )
+
+    permitted_subtrees = utils.read_only_property("_permitted_subtrees")
+    excluded_subtrees = utils.read_only_property("_excluded_subtrees")
+
+
+class Extension(object):
+    def __init__(self, oid, critical, value):
+        if not isinstance(oid, ObjectIdentifier):
+            raise TypeError(
+                "oid argument must be an ObjectIdentifier instance."
+            )
+
+        if not isinstance(critical, bool):
+            raise TypeError("critical must be a boolean value")
+
+        self._oid = oid
+        self._critical = critical
+        self._value = value
+
+    oid = utils.read_only_property("_oid")
+    critical = utils.read_only_property("_critical")
+    value = utils.read_only_property("_value")
+
+    def __repr__(self):
+        return ("<Extension(oid={0.oid}, critical={0.critical}, "
+                "value={0.value})>").format(self)
+
+    def __eq__(self, other):
+        if not isinstance(other, Extension):
+            return NotImplemented
+
+        return (
+            self.oid == other.oid and
+            self.critical == other.critical and
+            self.value == other.value
+        )
+
+    def __ne__(self, other):
+        return not self == other
+
+
+class GeneralNames(object):
+    def __init__(self, general_names):
+        if not all(isinstance(x, GeneralName) for x in general_names):
+            raise TypeError(
+                "Every item in the general_names list must be an "
+                "object conforming to the GeneralName interface"
+            )
+
+        self._general_names = general_names
+
+    def __iter__(self):
+        return iter(self._general_names)
+
+    def __len__(self):
+        return len(self._general_names)
+
+    def get_values_for_type(self, type):
+        # Return the value of each GeneralName, except for OtherName instances
+        # which we return directly because it has two important properties not
+        # just one value.
+        objs = (i for i in self if isinstance(i, type))
+        if type != OtherName:
+            objs = (i.value for i in objs)
+        return list(objs)
+
+    def __repr__(self):
+        return "<GeneralNames({0})>".format(self._general_names)
+
+    def __eq__(self, other):
+        if not isinstance(other, GeneralNames):
+            return NotImplemented
+
+        return self._general_names == other._general_names
+
+    def __ne__(self, other):
+        return not self == other
+
+
+@utils.register_interface(ExtensionType)
+class SubjectAlternativeName(object):
+    oid = ExtensionOID.SUBJECT_ALTERNATIVE_NAME
+
+    def __init__(self, general_names):
+        self._general_names = GeneralNames(general_names)
+
+    def __iter__(self):
+        return iter(self._general_names)
+
+    def __len__(self):
+        return len(self._general_names)
+
+    def get_values_for_type(self, type):
+        return self._general_names.get_values_for_type(type)
+
+    def __repr__(self):
+        return "<SubjectAlternativeName({0})>".format(self._general_names)
+
+    def __eq__(self, other):
+        if not isinstance(other, SubjectAlternativeName):
+            return NotImplemented
+
+        return self._general_names == other._general_names
+
+    def __ne__(self, other):
+        return not self == other
+
+
+@utils.register_interface(ExtensionType)
+class IssuerAlternativeName(object):
+    oid = ExtensionOID.ISSUER_ALTERNATIVE_NAME
+
+    def __init__(self, general_names):
+        self._general_names = GeneralNames(general_names)
+
+    def __iter__(self):
+        return iter(self._general_names)
+
+    def __len__(self):
+        return len(self._general_names)
+
+    def get_values_for_type(self, type):
+        return self._general_names.get_values_for_type(type)
+
+    def __repr__(self):
+        return "<IssuerAlternativeName({0})>".format(self._general_names)
+
+    def __eq__(self, other):
+        if not isinstance(other, IssuerAlternativeName):
+            return NotImplemented
+
+        return self._general_names == other._general_names
+
+    def __ne__(self, other):
+        return not self == other
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/x509/general_name.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/x509/general_name.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/x509/general_name.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/x509/general_name.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,265 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import abc
+import ipaddress
+from email.utils import parseaddr
+
+import idna
+
+import six
+
+from six.moves import urllib_parse
+
+from cryptography import utils
+from cryptography.x509.name import Name
+from cryptography.x509.oid import ObjectIdentifier
+
+
+_GENERAL_NAMES = {
+    0: "otherName",
+    1: "rfc822Name",
+    2: "dNSName",
+    3: "x400Address",
+    4: "directoryName",
+    5: "ediPartyName",
+    6: "uniformResourceIdentifier",
+    7: "iPAddress",
+    8: "registeredID",
+}
+
+
+class UnsupportedGeneralNameType(Exception):
+    def __init__(self, msg, type):
+        super(UnsupportedGeneralNameType, self).__init__(msg)
+        self.type = type
+
+
+@six.add_metaclass(abc.ABCMeta)
+class GeneralName(object):
+    @abc.abstractproperty
+    def value(self):
+        """
+        Return the value of the object
+        """
+
+
+@utils.register_interface(GeneralName)
+class RFC822Name(object):
+    def __init__(self, value):
+        if not isinstance(value, six.text_type):
+            raise TypeError("value must be a unicode string")
+
+        name, address = parseaddr(value)
+        parts = address.split(u"@")
+        if name or not address:
+            # parseaddr has found a name (e.g. Name <email>) or the entire
+            # value is an empty string.
+            raise ValueError("Invalid rfc822name value")
+        elif len(parts) == 1:
+            # Single label email name. This is valid for local delivery.
+            # No IDNA encoding needed since there is no domain component.
+            encoded = address.encode("ascii")
+        else:
+            # A normal email of the form user@domain.com. Let's attempt to
+            # encode the domain component and reconstruct the address.
+            encoded = parts[0].encode("ascii") + b"@" + idna.encode(parts[1])
+
+        self._value = value
+        self._encoded = encoded
+
+    value = utils.read_only_property("_value")
+
+    def __repr__(self):
+        return "<RFC822Name(value={0})>".format(self.value)
+
+    def __eq__(self, other):
+        if not isinstance(other, RFC822Name):
+            return NotImplemented
+
+        return self.value == other.value
+
+    def __ne__(self, other):
+        return not self == other
+
+
+@utils.register_interface(GeneralName)
+class DNSName(object):
+    def __init__(self, value):
+        if not isinstance(value, six.text_type):
+            raise TypeError("value must be a unicode string")
+
+        self._value = value
+
+    value = utils.read_only_property("_value")
+
+    def __repr__(self):
+        return "<DNSName(value={0})>".format(self.value)
+
+    def __eq__(self, other):
+        if not isinstance(other, DNSName):
+            return NotImplemented
+
+        return self.value == other.value
+
+    def __ne__(self, other):
+        return not self == other
+
+
+@utils.register_interface(GeneralName)
+class UniformResourceIdentifier(object):
+    def __init__(self, value):
+        if not isinstance(value, six.text_type):
+            raise TypeError("value must be a unicode string")
+
+        parsed = urllib_parse.urlparse(value)
+        if not parsed.hostname:
+            netloc = ""
+        elif parsed.port:
+            netloc = (
+                idna.encode(parsed.hostname) +
+                ":{0}".format(parsed.port).encode("ascii")
+            ).decode("ascii")
+        else:
+            netloc = idna.encode(parsed.hostname).decode("ascii")
+
+        # Note that building a URL in this fashion means it should be
+        # semantically indistinguishable from the original but is not
+        # guaranteed to be exactly the same.
+        uri = urllib_parse.urlunparse((
+            parsed.scheme,
+            netloc,
+            parsed.path,
+            parsed.params,
+            parsed.query,
+            parsed.fragment
+        )).encode("ascii")
+
+        self._value = value
+        self._encoded = uri
+
+    value = utils.read_only_property("_value")
+
+    def __repr__(self):
+        return "<UniformResourceIdentifier(value={0})>".format(self.value)
+
+    def __eq__(self, other):
+        if not isinstance(other, UniformResourceIdentifier):
+            return NotImplemented
+
+        return self.value == other.value
+
+    def __ne__(self, other):
+        return not self == other
+
+
+@utils.register_interface(GeneralName)
+class DirectoryName(object):
+    def __init__(self, value):
+        if not isinstance(value, Name):
+            raise TypeError("value must be a Name")
+
+        self._value = value
+
+    value = utils.read_only_property("_value")
+
+    def __repr__(self):
+        return "<DirectoryName(value={0})>".format(self.value)
+
+    def __eq__(self, other):
+        if not isinstance(other, DirectoryName):
+            return NotImplemented
+
+        return self.value == other.value
+
+    def __ne__(self, other):
+        return not self == other
+
+
+@utils.register_interface(GeneralName)
+class RegisteredID(object):
+    def __init__(self, value):
+        if not isinstance(value, ObjectIdentifier):
+            raise TypeError("value must be an ObjectIdentifier")
+
+        self._value = value
+
+    value = utils.read_only_property("_value")
+
+    def __repr__(self):
+        return "<RegisteredID(value={0})>".format(self.value)
+
+    def __eq__(self, other):
+        if not isinstance(other, RegisteredID):
+            return NotImplemented
+
+        return self.value == other.value
+
+    def __ne__(self, other):
+        return not self == other
+
+
+@utils.register_interface(GeneralName)
+class IPAddress(object):
+    def __init__(self, value):
+        if not isinstance(
+            value,
+            (
+                ipaddress.IPv4Address,
+                ipaddress.IPv6Address,
+                ipaddress.IPv4Network,
+                ipaddress.IPv6Network
+            )
+        ):
+            raise TypeError(
+                "value must be an instance of ipaddress.IPv4Address, "
+                "ipaddress.IPv6Address, ipaddress.IPv4Network, or "
+                "ipaddress.IPv6Network"
+            )
+
+        self._value = value
+
+    value = utils.read_only_property("_value")
+
+    def __repr__(self):
+        return "<IPAddress(value={0})>".format(self.value)
+
+    def __eq__(self, other):
+        if not isinstance(other, IPAddress):
+            return NotImplemented
+
+        return self.value == other.value
+
+    def __ne__(self, other):
+        return not self == other
+
+
+@utils.register_interface(GeneralName)
+class OtherName(object):
+    def __init__(self, type_id, value):
+        if not isinstance(type_id, ObjectIdentifier):
+            raise TypeError("type_id must be an ObjectIdentifier")
+        if not isinstance(value, bytes):
+            raise TypeError("value must be a binary string")
+
+        self._type_id = type_id
+        self._value = value
+
+    type_id = utils.read_only_property("_type_id")
+    value = utils.read_only_property("_value")
+
+    def __repr__(self):
+        return "<OtherName(type_id={0}, value={1!r})>".format(
+            self.type_id, self.value)
+
+    def __eq__(self, other):
+        if not isinstance(other, OtherName):
+            return NotImplemented
+
+        return self.type_id == other.type_id and self.value == other.value
+
+    def __ne__(self, other):
+        return not self == other
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/x509/__init__.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/x509/__init__.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/x509/__init__.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/x509/__init__.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,163 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+from cryptography.x509.base import (
+    Certificate, CertificateBuilder, CertificateRevocationList,
+    CertificateSigningRequest, CertificateSigningRequestBuilder,
+    InvalidVersion, RevokedCertificate,
+    Version, load_der_x509_certificate, load_der_x509_crl, load_der_x509_csr,
+    load_pem_x509_certificate, load_pem_x509_crl, load_pem_x509_csr,
+)
+from cryptography.x509.extensions import (
+    AccessDescription, AuthorityInformationAccess,
+    AuthorityKeyIdentifier, BasicConstraints, CRLDistributionPoints,
+    CertificatePolicies, DistributionPoint, DuplicateExtension,
+    ExtendedKeyUsage, Extension, ExtensionNotFound, ExtensionType, Extensions,
+    GeneralNames, InhibitAnyPolicy, IssuerAlternativeName, KeyUsage,
+    NameConstraints, NoticeReference, OCSPNoCheck, PolicyInformation,
+    ReasonFlags, SubjectAlternativeName, SubjectKeyIdentifier,
+    UnsupportedExtension, UserNotice
+)
+from cryptography.x509.general_name import (
+    DNSName, DirectoryName, GeneralName, IPAddress, OtherName, RFC822Name,
+    RegisteredID, UniformResourceIdentifier, UnsupportedGeneralNameType,
+    _GENERAL_NAMES
+)
+from cryptography.x509.name import Name, NameAttribute
+from cryptography.x509.oid import (
+    AuthorityInformationAccessOID, CRLExtensionOID, CertificatePoliciesOID,
+    ExtendedKeyUsageOID, ExtensionOID, NameOID, ObjectIdentifier,
+    SignatureAlgorithmOID, _SIG_OIDS_TO_HASH
+)
+
+
+OID_AUTHORITY_INFORMATION_ACCESS = ExtensionOID.AUTHORITY_INFORMATION_ACCESS
+OID_AUTHORITY_KEY_IDENTIFIER = ExtensionOID.AUTHORITY_KEY_IDENTIFIER
+OID_BASIC_CONSTRAINTS = ExtensionOID.BASIC_CONSTRAINTS
+OID_CERTIFICATE_POLICIES = ExtensionOID.CERTIFICATE_POLICIES
+OID_CRL_DISTRIBUTION_POINTS = ExtensionOID.CRL_DISTRIBUTION_POINTS
+OID_EXTENDED_KEY_USAGE = ExtensionOID.EXTENDED_KEY_USAGE
+OID_FRESHEST_CRL = ExtensionOID.FRESHEST_CRL
+OID_INHIBIT_ANY_POLICY = ExtensionOID.INHIBIT_ANY_POLICY
+OID_ISSUER_ALTERNATIVE_NAME = ExtensionOID.ISSUER_ALTERNATIVE_NAME
+OID_KEY_USAGE = ExtensionOID.KEY_USAGE
+OID_NAME_CONSTRAINTS = ExtensionOID.NAME_CONSTRAINTS
+OID_OCSP_NO_CHECK = ExtensionOID.OCSP_NO_CHECK
+OID_POLICY_CONSTRAINTS = ExtensionOID.POLICY_CONSTRAINTS
+OID_POLICY_MAPPINGS = ExtensionOID.POLICY_MAPPINGS
+OID_SUBJECT_ALTERNATIVE_NAME = ExtensionOID.SUBJECT_ALTERNATIVE_NAME
+OID_SUBJECT_DIRECTORY_ATTRIBUTES = ExtensionOID.SUBJECT_DIRECTORY_ATTRIBUTES
+OID_SUBJECT_INFORMATION_ACCESS = ExtensionOID.SUBJECT_INFORMATION_ACCESS
+OID_SUBJECT_KEY_IDENTIFIER = ExtensionOID.SUBJECT_KEY_IDENTIFIER
+
+OID_DSA_WITH_SHA1 = SignatureAlgorithmOID.DSA_WITH_SHA1
+OID_DSA_WITH_SHA224 = SignatureAlgorithmOID.DSA_WITH_SHA224
+OID_DSA_WITH_SHA256 = SignatureAlgorithmOID.DSA_WITH_SHA256
+OID_ECDSA_WITH_SHA1 = SignatureAlgorithmOID.ECDSA_WITH_SHA1
+OID_ECDSA_WITH_SHA224 = SignatureAlgorithmOID.ECDSA_WITH_SHA224
+OID_ECDSA_WITH_SHA256 = SignatureAlgorithmOID.ECDSA_WITH_SHA256
+OID_ECDSA_WITH_SHA384 = SignatureAlgorithmOID.ECDSA_WITH_SHA384
+OID_ECDSA_WITH_SHA512 = SignatureAlgorithmOID.ECDSA_WITH_SHA512
+OID_RSA_WITH_MD5 = SignatureAlgorithmOID.RSA_WITH_MD5
+OID_RSA_WITH_SHA1 = SignatureAlgorithmOID.RSA_WITH_SHA1
+OID_RSA_WITH_SHA224 = SignatureAlgorithmOID.RSA_WITH_SHA224
+OID_RSA_WITH_SHA256 = SignatureAlgorithmOID.RSA_WITH_SHA256
+OID_RSA_WITH_SHA384 = SignatureAlgorithmOID.RSA_WITH_SHA384
+OID_RSA_WITH_SHA512 = SignatureAlgorithmOID.RSA_WITH_SHA512
+
+OID_COMMON_NAME = NameOID.COMMON_NAME
+OID_COUNTRY_NAME = NameOID.COUNTRY_NAME
+OID_DOMAIN_COMPONENT = NameOID.DOMAIN_COMPONENT
+OID_DN_QUALIFIER = NameOID.DN_QUALIFIER
+OID_EMAIL_ADDRESS = NameOID.EMAIL_ADDRESS
+OID_GENERATION_QUALIFIER = NameOID.GENERATION_QUALIFIER
+OID_GIVEN_NAME = NameOID.GIVEN_NAME
+OID_LOCALITY_NAME = NameOID.LOCALITY_NAME
+OID_ORGANIZATIONAL_UNIT_NAME = NameOID.ORGANIZATIONAL_UNIT_NAME
+OID_ORGANIZATION_NAME = NameOID.ORGANIZATION_NAME
+OID_PSEUDONYM = NameOID.PSEUDONYM
+OID_SERIAL_NUMBER = NameOID.SERIAL_NUMBER
+OID_STATE_OR_PROVINCE_NAME = NameOID.STATE_OR_PROVINCE_NAME
+OID_SURNAME = NameOID.SURNAME
+OID_TITLE = NameOID.TITLE
+
+OID_CLIENT_AUTH = ExtendedKeyUsageOID.CLIENT_AUTH
+OID_CODE_SIGNING = ExtendedKeyUsageOID.CODE_SIGNING
+OID_EMAIL_PROTECTION = ExtendedKeyUsageOID.EMAIL_PROTECTION
+OID_OCSP_SIGNING = ExtendedKeyUsageOID.OCSP_SIGNING
+OID_SERVER_AUTH = ExtendedKeyUsageOID.SERVER_AUTH
+OID_TIME_STAMPING = ExtendedKeyUsageOID.TIME_STAMPING
+
+OID_ANY_POLICY = CertificatePoliciesOID.ANY_POLICY
+OID_CPS_QUALIFIER = CertificatePoliciesOID.CPS_QUALIFIER
+OID_CPS_USER_NOTICE = CertificatePoliciesOID.CPS_USER_NOTICE
+
+OID_CERTIFICATE_ISSUER = CRLExtensionOID.CERTIFICATE_ISSUER
+OID_CRL_REASON = CRLExtensionOID.CRL_REASON
+OID_INVALIDITY_DATE = CRLExtensionOID.INVALIDITY_DATE
+
+OID_CA_ISSUERS = AuthorityInformationAccessOID.CA_ISSUERS
+OID_OCSP = AuthorityInformationAccessOID.OCSP
+
+
+__all__ = [
+    "load_pem_x509_certificate",
+    "load_der_x509_certificate",
+    "load_pem_x509_csr",
+    "load_der_x509_csr",
+    "load_pem_x509_crl",
+    "load_der_x509_crl",
+    "InvalidVersion",
+    "DuplicateExtension",
+    "UnsupportedExtension",
+    "ExtensionNotFound",
+    "UnsupportedGeneralNameType",
+    "NameAttribute",
+    "Name",
+    "ObjectIdentifier",
+    "ExtensionType",
+    "Extensions",
+    "Extension",
+    "ExtendedKeyUsage",
+    "OCSPNoCheck",
+    "BasicConstraints",
+    "KeyUsage",
+    "AuthorityInformationAccess",
+    "AccessDescription",
+    "CertificatePolicies",
+    "PolicyInformation",
+    "UserNotice",
+    "NoticeReference",
+    "SubjectKeyIdentifier",
+    "NameConstraints",
+    "CRLDistributionPoints",
+    "DistributionPoint",
+    "ReasonFlags",
+    "InhibitAnyPolicy",
+    "SubjectAlternativeName",
+    "IssuerAlternativeName",
+    "AuthorityKeyIdentifier",
+    "GeneralNames",
+    "GeneralName",
+    "RFC822Name",
+    "DNSName",
+    "UniformResourceIdentifier",
+    "RegisteredID",
+    "DirectoryName",
+    "IPAddress",
+    "OtherName",
+    "Certificate",
+    "CertificateRevocationList",
+    "CertificateSigningRequest",
+    "RevokedCertificate",
+    "CertificateSigningRequestBuilder",
+    "CertificateBuilder",
+    "Version",
+    "_SIG_OIDS_TO_HASH",
+    "OID_CA_ISSUERS",
+    "OID_OCSP",
+    "_GENERAL_NAMES",
+]
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/x509/name.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/x509/name.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/x509/name.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/x509/name.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,78 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import six
+
+from cryptography import utils
+from cryptography.x509.oid import ObjectIdentifier
+
+
+class NameAttribute(object):
+    def __init__(self, oid, value):
+        if not isinstance(oid, ObjectIdentifier):
+            raise TypeError(
+                "oid argument must be an ObjectIdentifier instance."
+            )
+
+        if not isinstance(value, six.text_type):
+            raise TypeError(
+                "value argument must be a text type."
+            )
+
+        self._oid = oid
+        self._value = value
+
+    oid = utils.read_only_property("_oid")
+    value = utils.read_only_property("_value")
+
+    def __eq__(self, other):
+        if not isinstance(other, NameAttribute):
+            return NotImplemented
+
+        return (
+            self.oid == other.oid and
+            self.value == other.value
+        )
+
+    def __ne__(self, other):
+        return not self == other
+
+    def __hash__(self):
+        return hash((self.oid, self.value))
+
+    def __repr__(self):
+        return "<NameAttribute(oid={0.oid}, value={0.value!r})>".format(self)
+
+
+class Name(object):
+    def __init__(self, attributes):
+        self._attributes = attributes
+
+    def get_attributes_for_oid(self, oid):
+        return [i for i in self if i.oid == oid]
+
+    def __eq__(self, other):
+        if not isinstance(other, Name):
+            return NotImplemented
+
+        return self._attributes == other._attributes
+
+    def __ne__(self, other):
+        return not self == other
+
+    def __hash__(self):
+        # TODO: this is relatively expensive, if this looks like a bottleneck
+        # for you, consider optimizing!
+        return hash(tuple(self._attributes))
+
+    def __iter__(self):
+        return iter(self._attributes)
+
+    def __len__(self):
+        return len(self._attributes)
+
+    def __repr__(self):
+        return "<Name({0!r})>".format(self._attributes)
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/x509/oid.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/x509/oid.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/x509/oid.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography/x509/oid.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,199 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+from cryptography import utils
+from cryptography.hazmat.primitives import hashes
+
+
+class ObjectIdentifier(object):
+    def __init__(self, dotted_string):
+        self._dotted_string = dotted_string
+
+    def __eq__(self, other):
+        if not isinstance(other, ObjectIdentifier):
+            return NotImplemented
+
+        return self.dotted_string == other.dotted_string
+
+    def __ne__(self, other):
+        return not self == other
+
+    def __repr__(self):
+        return "<ObjectIdentifier(oid={0}, name={1})>".format(
+            self.dotted_string,
+            self._name
+        )
+
+    def __hash__(self):
+        return hash(self.dotted_string)
+
+    @property
+    def _name(self):
+        return _OID_NAMES.get(self, "Unknown OID")
+
+    dotted_string = utils.read_only_property("_dotted_string")
+
+
+class ExtensionOID(object):
+    SUBJECT_DIRECTORY_ATTRIBUTES = ObjectIdentifier("2.5.29.9")
+    SUBJECT_KEY_IDENTIFIER = ObjectIdentifier("2.5.29.14")
+    KEY_USAGE = ObjectIdentifier("2.5.29.15")
+    SUBJECT_ALTERNATIVE_NAME = ObjectIdentifier("2.5.29.17")
+    ISSUER_ALTERNATIVE_NAME = ObjectIdentifier("2.5.29.18")
+    BASIC_CONSTRAINTS = ObjectIdentifier("2.5.29.19")
+    NAME_CONSTRAINTS = ObjectIdentifier("2.5.29.30")
+    CRL_DISTRIBUTION_POINTS = ObjectIdentifier("2.5.29.31")
+    CERTIFICATE_POLICIES = ObjectIdentifier("2.5.29.32")
+    POLICY_MAPPINGS = ObjectIdentifier("2.5.29.33")
+    AUTHORITY_KEY_IDENTIFIER = ObjectIdentifier("2.5.29.35")
+    POLICY_CONSTRAINTS = ObjectIdentifier("2.5.29.36")
+    EXTENDED_KEY_USAGE = ObjectIdentifier("2.5.29.37")
+    FRESHEST_CRL = ObjectIdentifier("2.5.29.46")
+    INHIBIT_ANY_POLICY = ObjectIdentifier("2.5.29.54")
+    AUTHORITY_INFORMATION_ACCESS = ObjectIdentifier("1.3.6.1.5.5.7.1.1")
+    SUBJECT_INFORMATION_ACCESS = ObjectIdentifier("1.3.6.1.5.5.7.1.11")
+    OCSP_NO_CHECK = ObjectIdentifier("1.3.6.1.5.5.7.48.1.5")
+
+
+class CRLExtensionOID(object):
+    CERTIFICATE_ISSUER = ObjectIdentifier("2.5.29.29")
+    CRL_REASON = ObjectIdentifier("2.5.29.21")
+    INVALIDITY_DATE = ObjectIdentifier("2.5.29.24")
+
+
+class NameOID(object):
+    COMMON_NAME = ObjectIdentifier("2.5.4.3")
+    COUNTRY_NAME = ObjectIdentifier("2.5.4.6")
+    LOCALITY_NAME = ObjectIdentifier("2.5.4.7")
+    STATE_OR_PROVINCE_NAME = ObjectIdentifier("2.5.4.8")
+    ORGANIZATION_NAME = ObjectIdentifier("2.5.4.10")
+    ORGANIZATIONAL_UNIT_NAME = ObjectIdentifier("2.5.4.11")
+    SERIAL_NUMBER = ObjectIdentifier("2.5.4.5")
+    SURNAME = ObjectIdentifier("2.5.4.4")
+    GIVEN_NAME = ObjectIdentifier("2.5.4.42")
+    TITLE = ObjectIdentifier("2.5.4.12")
+    GENERATION_QUALIFIER = ObjectIdentifier("2.5.4.44")
+    DN_QUALIFIER = ObjectIdentifier("2.5.4.46")
+    PSEUDONYM = ObjectIdentifier("2.5.4.65")
+    DOMAIN_COMPONENT = ObjectIdentifier("0.9.2342.19200300.100.1.25")
+    EMAIL_ADDRESS = ObjectIdentifier("1.2.840.113549.1.9.1")
+
+
+class SignatureAlgorithmOID(object):
+    RSA_WITH_MD5 = ObjectIdentifier("1.2.840.113549.1.1.4")
+    RSA_WITH_SHA1 = ObjectIdentifier("1.2.840.113549.1.1.5")
+    RSA_WITH_SHA224 = ObjectIdentifier("1.2.840.113549.1.1.14")
+    RSA_WITH_SHA256 = ObjectIdentifier("1.2.840.113549.1.1.11")
+    RSA_WITH_SHA384 = ObjectIdentifier("1.2.840.113549.1.1.12")
+    RSA_WITH_SHA512 = ObjectIdentifier("1.2.840.113549.1.1.13")
+    ECDSA_WITH_SHA1 = ObjectIdentifier("1.2.840.10045.4.1")
+    ECDSA_WITH_SHA224 = ObjectIdentifier("1.2.840.10045.4.3.1")
+    ECDSA_WITH_SHA256 = ObjectIdentifier("1.2.840.10045.4.3.2")
+    ECDSA_WITH_SHA384 = ObjectIdentifier("1.2.840.10045.4.3.3")
+    ECDSA_WITH_SHA512 = ObjectIdentifier("1.2.840.10045.4.3.4")
+    DSA_WITH_SHA1 = ObjectIdentifier("1.2.840.10040.4.3")
+    DSA_WITH_SHA224 = ObjectIdentifier("2.16.840.1.101.3.4.3.1")
+    DSA_WITH_SHA256 = ObjectIdentifier("2.16.840.1.101.3.4.3.2")
+
+_SIG_OIDS_TO_HASH = {
+    SignatureAlgorithmOID.RSA_WITH_MD5.dotted_string: hashes.MD5(),
+    SignatureAlgorithmOID.RSA_WITH_SHA1.dotted_string: hashes.SHA1(),
+    SignatureAlgorithmOID.RSA_WITH_SHA224.dotted_string: hashes.SHA224(),
+    SignatureAlgorithmOID.RSA_WITH_SHA256.dotted_string: hashes.SHA256(),
+    SignatureAlgorithmOID.RSA_WITH_SHA384.dotted_string: hashes.SHA384(),
+    SignatureAlgorithmOID.RSA_WITH_SHA512.dotted_string: hashes.SHA512(),
+    SignatureAlgorithmOID.ECDSA_WITH_SHA1.dotted_string: hashes.SHA1(),
+    SignatureAlgorithmOID.ECDSA_WITH_SHA224.dotted_string: hashes.SHA224(),
+    SignatureAlgorithmOID.ECDSA_WITH_SHA256.dotted_string: hashes.SHA256(),
+    SignatureAlgorithmOID.ECDSA_WITH_SHA384.dotted_string: hashes.SHA384(),
+    SignatureAlgorithmOID.ECDSA_WITH_SHA512.dotted_string: hashes.SHA512(),
+    SignatureAlgorithmOID.DSA_WITH_SHA1.dotted_string: hashes.SHA1(),
+    SignatureAlgorithmOID.DSA_WITH_SHA224.dotted_string: hashes.SHA224(),
+    SignatureAlgorithmOID.DSA_WITH_SHA256.dotted_string: hashes.SHA256()
+}
+
+
+class ExtendedKeyUsageOID(object):
+    SERVER_AUTH = ObjectIdentifier("1.3.6.1.5.5.7.3.1")
+    CLIENT_AUTH = ObjectIdentifier("1.3.6.1.5.5.7.3.2")
+    CODE_SIGNING = ObjectIdentifier("1.3.6.1.5.5.7.3.3")
+    EMAIL_PROTECTION = ObjectIdentifier("1.3.6.1.5.5.7.3.4")
+    TIME_STAMPING = ObjectIdentifier("1.3.6.1.5.5.7.3.8")
+    OCSP_SIGNING = ObjectIdentifier("1.3.6.1.5.5.7.3.9")
+
+
+class AuthorityInformationAccessOID(object):
+    CA_ISSUERS = ObjectIdentifier("1.3.6.1.5.5.7.48.2")
+    OCSP = ObjectIdentifier("1.3.6.1.5.5.7.48.1")
+
+
+class CertificatePoliciesOID(object):
+    CPS_QUALIFIER = ObjectIdentifier("1.3.6.1.5.5.7.2.1")
+    CPS_USER_NOTICE = ObjectIdentifier("1.3.6.1.5.5.7.2.2")
+    ANY_POLICY = ObjectIdentifier("2.5.29.32.0")
+
+_OID_NAMES = {
+    NameOID.COMMON_NAME: "commonName",
+    NameOID.COUNTRY_NAME: "countryName",
+    NameOID.LOCALITY_NAME: "localityName",
+    NameOID.STATE_OR_PROVINCE_NAME: "stateOrProvinceName",
+    NameOID.ORGANIZATION_NAME: "organizationName",
+    NameOID.ORGANIZATIONAL_UNIT_NAME: "organizationalUnitName",
+    NameOID.SERIAL_NUMBER: "serialNumber",
+    NameOID.SURNAME: "surname",
+    NameOID.GIVEN_NAME: "givenName",
+    NameOID.TITLE: "title",
+    NameOID.GENERATION_QUALIFIER: "generationQualifier",
+    NameOID.DN_QUALIFIER: "dnQualifier",
+    NameOID.PSEUDONYM: "pseudonym",
+    NameOID.DOMAIN_COMPONENT: "domainComponent",
+    NameOID.EMAIL_ADDRESS: "emailAddress",
+    SignatureAlgorithmOID.RSA_WITH_MD5: "md5WithRSAEncryption",
+    SignatureAlgorithmOID.RSA_WITH_SHA1: "sha1WithRSAEncryption",
+    SignatureAlgorithmOID.RSA_WITH_SHA224: "sha224WithRSAEncryption",
+    SignatureAlgorithmOID.RSA_WITH_SHA256: "sha256WithRSAEncryption",
+    SignatureAlgorithmOID.RSA_WITH_SHA384: "sha384WithRSAEncryption",
+    SignatureAlgorithmOID.RSA_WITH_SHA512: "sha512WithRSAEncryption",
+    SignatureAlgorithmOID.ECDSA_WITH_SHA1: "ecdsa-with-SHA1",
+    SignatureAlgorithmOID.ECDSA_WITH_SHA224: "ecdsa-with-SHA224",
+    SignatureAlgorithmOID.ECDSA_WITH_SHA256: "ecdsa-with-SHA256",
+    SignatureAlgorithmOID.ECDSA_WITH_SHA384: "ecdsa-with-SHA384",
+    SignatureAlgorithmOID.ECDSA_WITH_SHA512: "ecdsa-with-SHA512",
+    SignatureAlgorithmOID.DSA_WITH_SHA1: "dsa-with-sha1",
+    SignatureAlgorithmOID.DSA_WITH_SHA224: "dsa-with-sha224",
+    SignatureAlgorithmOID.DSA_WITH_SHA256: "dsa-with-sha256",
+    ExtendedKeyUsageOID.SERVER_AUTH: "serverAuth",
+    ExtendedKeyUsageOID.CLIENT_AUTH: "clientAuth",
+    ExtendedKeyUsageOID.CODE_SIGNING: "codeSigning",
+    ExtendedKeyUsageOID.EMAIL_PROTECTION: "emailProtection",
+    ExtendedKeyUsageOID.TIME_STAMPING: "timeStamping",
+    ExtendedKeyUsageOID.OCSP_SIGNING: "OCSPSigning",
+    ExtensionOID.SUBJECT_DIRECTORY_ATTRIBUTES: "subjectDirectoryAttributes",
+    ExtensionOID.SUBJECT_KEY_IDENTIFIER: "subjectKeyIdentifier",
+    ExtensionOID.KEY_USAGE: "keyUsage",
+    ExtensionOID.SUBJECT_ALTERNATIVE_NAME: "subjectAltName",
+    ExtensionOID.ISSUER_ALTERNATIVE_NAME: "issuerAltName",
+    ExtensionOID.BASIC_CONSTRAINTS: "basicConstraints",
+    CRLExtensionOID.CRL_REASON: "cRLReason",
+    CRLExtensionOID.INVALIDITY_DATE: "invalidityDate",
+    CRLExtensionOID.CERTIFICATE_ISSUER: "certificateIssuer",
+    ExtensionOID.NAME_CONSTRAINTS: "nameConstraints",
+    ExtensionOID.CRL_DISTRIBUTION_POINTS: "cRLDistributionPoints",
+    ExtensionOID.CERTIFICATE_POLICIES: "certificatePolicies",
+    ExtensionOID.POLICY_MAPPINGS: "policyMappings",
+    ExtensionOID.AUTHORITY_KEY_IDENTIFIER: "authorityKeyIdentifier",
+    ExtensionOID.POLICY_CONSTRAINTS: "policyConstraints",
+    ExtensionOID.EXTENDED_KEY_USAGE: "extendedKeyUsage",
+    ExtensionOID.FRESHEST_CRL: "freshestCRL",
+    ExtensionOID.INHIBIT_ANY_POLICY: "inhibitAnyPolicy",
+    ExtensionOID.AUTHORITY_INFORMATION_ACCESS: "authorityInfoAccess",
+    ExtensionOID.SUBJECT_INFORMATION_ACCESS: "subjectInfoAccess",
+    ExtensionOID.OCSP_NO_CHECK: "OCSPNoCheck",
+    AuthorityInformationAccessOID.OCSP: "OCSP",
+    AuthorityInformationAccessOID.CA_ISSUERS: "caIssuers",
+    CertificatePoliciesOID.CPS_QUALIFIER: "id-qt-cps",
+    CertificatePoliciesOID.CPS_USER_NOTICE: "id-qt-unotice",
+}
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography.egg-info/dependency_links.txt hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography.egg-info/dependency_links.txt
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography.egg-info/dependency_links.txt	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography.egg-info/dependency_links.txt	2015-11-19 05:02:00.000000000 +0100
@@ -0,0 +1 @@
+
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography.egg-info/entry_points.txt hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography.egg-info/entry_points.txt
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography.egg-info/entry_points.txt	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography.egg-info/entry_points.txt	2015-11-19 05:02:00.000000000 +0100
@@ -0,0 +1,4 @@
+[cryptography.backends]
+commoncrypto = cryptography.hazmat.backends.commoncrypto:backend
+openssl = cryptography.hazmat.backends.openssl:backend
+
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography.egg-info/not-zip-safe hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography.egg-info/not-zip-safe
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography.egg-info/not-zip-safe	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography.egg-info/not-zip-safe	2015-11-19 05:02:00.000000000 +0100
@@ -0,0 +1 @@
+
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography.egg-info/PKG-INFO hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography.egg-info/PKG-INFO
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography.egg-info/PKG-INFO	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography.egg-info/PKG-INFO	2015-11-19 05:02:00.000000000 +0100
@@ -0,0 +1,85 @@
+Metadata-Version: 1.1
+Name: cryptography
+Version: 1.1.1
+Summary: cryptography is a package which provides cryptographic recipes and primitives to Python developers.
+Home-page: https://github.com/pyca/cryptography
+Author: The cryptography developers
+Author-email: cryptography-dev@python.org
+License: BSD or Apache License, Version 2.0
+Description: Cryptography
+        ============
+        
+        .. image:: https://img.shields.io/pypi/v/cryptography.svg
+            :target: https://pypi.python.org/pypi/cryptography/
+            :alt: Latest Version
+        
+        .. image:: https://readthedocs.org/projects/cryptography/badge/?version=latest
+            :target: https://cryptography.io
+            :alt: Latest Docs
+        
+        .. image:: https://travis-ci.org/pyca/cryptography.svg?branch=master
+            :target: https://travis-ci.org/pyca/cryptography
+        
+        .. image:: https://codecov.io/github/pyca/cryptography/coverage.svg?branch=master
+            :target: https://codecov.io/github/pyca/cryptography?branch=master
+        
+        
+        ``cryptography`` is a package which provides cryptographic recipes and
+        primitives to Python developers.  Our goal is for it to be your "cryptographic
+        standard library". It supports Python 2.6-2.7, Python 3.3+, and PyPy 2.6+.
+        
+        ``cryptography`` includes both high level recipes, and low level interfaces to
+        common cryptographic algorithms such as symmetric ciphers, message digests and
+        key derivation functions. For example, to encrypt something with
+        ``cryptography``'s high level symmetric encryption recipe:
+        
+        .. code-block:: pycon
+        
+            >>> from cryptography.fernet import Fernet
+            >>> # Put this somewhere safe!
+            >>> key = Fernet.generate_key()
+            >>> f = Fernet(key)
+            >>> token = f.encrypt(b"A really secret message. Not for prying eyes.")
+            >>> token
+            '...'
+            >>> f.decrypt(token)
+            'A really secret message. Not for prying eyes.'
+        
+        You can find more information in the `documentation`_.
+        
+        Discussion
+        ~~~~~~~~~~
+        
+        If you run into bugs, you can file them in our `issue tracker`_.
+        
+        We maintain a `cryptography-dev`_ mailing list for development discussion.
+        
+        You can also join ``#cryptography-dev`` on Freenode to ask questions or get
+        involved.
+        
+        
+        .. _`documentation`: https://cryptography.io/
+        .. _`issue tracker`: https://github.com/pyca/cryptography/issues
+        .. _`cryptography-dev`: https://mail.python.org/mailman/listinfo/cryptography-dev
+        
+Platform: UNKNOWN
+Classifier: Intended Audience :: Developers
+Classifier: License :: OSI Approved :: Apache Software License
+Classifier: License :: OSI Approved :: BSD License
+Classifier: Natural Language :: English
+Classifier: Operating System :: MacOS :: MacOS X
+Classifier: Operating System :: POSIX
+Classifier: Operating System :: POSIX :: BSD
+Classifier: Operating System :: POSIX :: Linux
+Classifier: Operating System :: Microsoft :: Windows
+Classifier: Programming Language :: Python
+Classifier: Programming Language :: Python :: 2
+Classifier: Programming Language :: Python :: 2.6
+Classifier: Programming Language :: Python :: 2.7
+Classifier: Programming Language :: Python :: 3
+Classifier: Programming Language :: Python :: 3.3
+Classifier: Programming Language :: Python :: 3.4
+Classifier: Programming Language :: Python :: 3.5
+Classifier: Programming Language :: Python :: Implementation :: CPython
+Classifier: Programming Language :: Python :: Implementation :: PyPy
+Classifier: Topic :: Security :: Cryptography
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography.egg-info/requires.txt hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography.egg-info/requires.txt
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography.egg-info/requires.txt	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography.egg-info/requires.txt	2015-11-19 05:02:00.000000000 +0100
@@ -0,0 +1,7 @@
+idna>=2.0
+pyasn1>=0.1.8
+six>=1.4.1
+setuptools
+enum34
+ipaddress
+cffi>=1.1.0
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography.egg-info/SOURCES.txt hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography.egg-info/SOURCES.txt
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography.egg-info/SOURCES.txt	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography.egg-info/SOURCES.txt	2015-11-19 05:02:01.000000000 +0100
@@ -0,0 +1,259 @@
+AUTHORS.rst
+CHANGELOG.rst
+CONTRIBUTING.rst
+LICENSE
+LICENSE.APACHE
+LICENSE.BSD
+MANIFEST.in
+README.rst
+setup.py
+docs/Makefile
+docs/api-stability.rst
+docs/changelog.rst
+docs/community.rst
+docs/conf.py
+docs/cryptography-docs.py
+docs/doing-a-release.rst
+docs/exceptions.rst
+docs/faq.rst
+docs/fernet.rst
+docs/glossary.rst
+docs/index.rst
+docs/installation.rst
+docs/limitations.rst
+docs/make.bat
+docs/random-numbers.rst
+docs/security.rst
+docs/spelling_wordlist.txt
+docs/_static/.keep
+docs/development/c-bindings.rst
+docs/development/getting-started.rst
+docs/development/index.rst
+docs/development/reviewing-patches.rst
+docs/development/submitting-patches.rst
+docs/development/test-vectors.rst
+docs/development/custom-vectors/cast5.rst
+docs/development/custom-vectors/idea.rst
+docs/development/custom-vectors/secp256k1.rst
+docs/development/custom-vectors/seed.rst
+docs/development/custom-vectors/cast5/generate_cast5.py
+docs/development/custom-vectors/cast5/verify_cast5.go
+docs/development/custom-vectors/idea/generate_idea.py
+docs/development/custom-vectors/idea/verify_idea.py
+docs/development/custom-vectors/secp256k1/generate_secp256k1.py
+docs/development/custom-vectors/secp256k1/verify_secp256k1.py
+docs/development/custom-vectors/seed/generate_seed.py
+docs/development/custom-vectors/seed/verify_seed.py
+docs/hazmat/backends/commoncrypto.rst
+docs/hazmat/backends/index.rst
+docs/hazmat/backends/interfaces.rst
+docs/hazmat/backends/multibackend.rst
+docs/hazmat/backends/openssl.rst
+docs/hazmat/bindings/commoncrypto.rst
+docs/hazmat/bindings/index.rst
+docs/hazmat/bindings/openssl.rst
+docs/hazmat/primitives/constant-time.rst
+docs/hazmat/primitives/cryptographic-hashes.rst
+docs/hazmat/primitives/index.rst
+docs/hazmat/primitives/interfaces.rst
+docs/hazmat/primitives/key-derivation-functions.rst
+docs/hazmat/primitives/keywrap.rst
+docs/hazmat/primitives/padding.rst
+docs/hazmat/primitives/symmetric-encryption.rst
+docs/hazmat/primitives/twofactor.rst
+docs/hazmat/primitives/asymmetric/dh.rst
+docs/hazmat/primitives/asymmetric/dsa.rst
+docs/hazmat/primitives/asymmetric/ec.rst
+docs/hazmat/primitives/asymmetric/index.rst
+docs/hazmat/primitives/asymmetric/interfaces.rst
+docs/hazmat/primitives/asymmetric/rsa.rst
+docs/hazmat/primitives/asymmetric/serialization.rst
+docs/hazmat/primitives/asymmetric/utils.rst
+docs/hazmat/primitives/mac/cmac.rst
+docs/hazmat/primitives/mac/hmac.rst
+docs/hazmat/primitives/mac/index.rst
+docs/x509/index.rst
+docs/x509/reference.rst
+docs/x509/tutorial.rst
+src/_cffi_src/__init__.py
+src/_cffi_src/build_commoncrypto.py
+src/_cffi_src/build_constant_time.py
+src/_cffi_src/build_openssl.py
+src/_cffi_src/build_padding.py
+src/_cffi_src/utils.py
+src/_cffi_src/commoncrypto/__init__.py
+src/_cffi_src/commoncrypto/cf.py
+src/_cffi_src/commoncrypto/common_cryptor.py
+src/_cffi_src/commoncrypto/common_digest.py
+src/_cffi_src/commoncrypto/common_hmac.py
+src/_cffi_src/commoncrypto/common_key_derivation.py
+src/_cffi_src/commoncrypto/common_symmetric_key_wrap.py
+src/_cffi_src/commoncrypto/secimport.py
+src/_cffi_src/commoncrypto/secitem.py
+src/_cffi_src/commoncrypto/seckey.py
+src/_cffi_src/commoncrypto/seckeychain.py
+src/_cffi_src/commoncrypto/sectransform.py
+src/_cffi_src/hazmat_src/constant_time.c
+src/_cffi_src/hazmat_src/constant_time.h
+src/_cffi_src/hazmat_src/padding.c
+src/_cffi_src/hazmat_src/padding.h
+src/_cffi_src/openssl/__init__.py
+src/_cffi_src/openssl/aes.py
+src/_cffi_src/openssl/asn1.py
+src/_cffi_src/openssl/bignum.py
+src/_cffi_src/openssl/bio.py
+src/_cffi_src/openssl/cmac.py
+src/_cffi_src/openssl/cms.py
+src/_cffi_src/openssl/conf.py
+src/_cffi_src/openssl/crypto.py
+src/_cffi_src/openssl/dh.py
+src/_cffi_src/openssl/dsa.py
+src/_cffi_src/openssl/ec.py
+src/_cffi_src/openssl/ecdh.py
+src/_cffi_src/openssl/ecdsa.py
+src/_cffi_src/openssl/engine.py
+src/_cffi_src/openssl/err.py
+src/_cffi_src/openssl/evp.py
+src/_cffi_src/openssl/hmac.py
+src/_cffi_src/openssl/nid.py
+src/_cffi_src/openssl/objects.py
+src/_cffi_src/openssl/opensslv.py
+src/_cffi_src/openssl/pem.py
+src/_cffi_src/openssl/pkcs12.py
+src/_cffi_src/openssl/pkcs7.py
+src/_cffi_src/openssl/rand.py
+src/_cffi_src/openssl/rsa.py
+src/_cffi_src/openssl/ssl.py
+src/_cffi_src/openssl/x509.py
+src/_cffi_src/openssl/x509_vfy.py
+src/_cffi_src/openssl/x509name.py
+src/_cffi_src/openssl/x509v3.py
+src/cryptography/__about__.py
+src/cryptography/__init__.py
+src/cryptography/exceptions.py
+src/cryptography/fernet.py
+src/cryptography/utils.py
+src/cryptography.egg-info/PKG-INFO
+src/cryptography.egg-info/SOURCES.txt
+src/cryptography.egg-info/dependency_links.txt
+src/cryptography.egg-info/entry_points.txt
+src/cryptography.egg-info/not-zip-safe
+src/cryptography.egg-info/requires.txt
+src/cryptography.egg-info/top_level.txt
+src/cryptography/hazmat/__init__.py
+src/cryptography/hazmat/backends/__init__.py
+src/cryptography/hazmat/backends/interfaces.py
+src/cryptography/hazmat/backends/multibackend.py
+src/cryptography/hazmat/backends/commoncrypto/__init__.py
+src/cryptography/hazmat/backends/commoncrypto/backend.py
+src/cryptography/hazmat/backends/commoncrypto/ciphers.py
+src/cryptography/hazmat/backends/commoncrypto/hashes.py
+src/cryptography/hazmat/backends/commoncrypto/hmac.py
+src/cryptography/hazmat/backends/openssl/__init__.py
+src/cryptography/hazmat/backends/openssl/backend.py
+src/cryptography/hazmat/backends/openssl/ciphers.py
+src/cryptography/hazmat/backends/openssl/cmac.py
+src/cryptography/hazmat/backends/openssl/dsa.py
+src/cryptography/hazmat/backends/openssl/ec.py
+src/cryptography/hazmat/backends/openssl/hashes.py
+src/cryptography/hazmat/backends/openssl/hmac.py
+src/cryptography/hazmat/backends/openssl/rsa.py
+src/cryptography/hazmat/backends/openssl/utils.py
+src/cryptography/hazmat/backends/openssl/x509.py
+src/cryptography/hazmat/bindings/__init__.py
+src/cryptography/hazmat/bindings/commoncrypto/__init__.py
+src/cryptography/hazmat/bindings/commoncrypto/binding.py
+src/cryptography/hazmat/bindings/openssl/__init__.py
+src/cryptography/hazmat/bindings/openssl/_conditional.py
+src/cryptography/hazmat/bindings/openssl/binding.py
+src/cryptography/hazmat/primitives/__init__.py
+src/cryptography/hazmat/primitives/cmac.py
+src/cryptography/hazmat/primitives/constant_time.py
+src/cryptography/hazmat/primitives/hashes.py
+src/cryptography/hazmat/primitives/hmac.py
+src/cryptography/hazmat/primitives/keywrap.py
+src/cryptography/hazmat/primitives/padding.py
+src/cryptography/hazmat/primitives/serialization.py
+src/cryptography/hazmat/primitives/asymmetric/__init__.py
+src/cryptography/hazmat/primitives/asymmetric/dh.py
+src/cryptography/hazmat/primitives/asymmetric/dsa.py
+src/cryptography/hazmat/primitives/asymmetric/ec.py
+src/cryptography/hazmat/primitives/asymmetric/padding.py
+src/cryptography/hazmat/primitives/asymmetric/rsa.py
+src/cryptography/hazmat/primitives/asymmetric/utils.py
+src/cryptography/hazmat/primitives/ciphers/__init__.py
+src/cryptography/hazmat/primitives/ciphers/algorithms.py
+src/cryptography/hazmat/primitives/ciphers/base.py
+src/cryptography/hazmat/primitives/ciphers/modes.py
+src/cryptography/hazmat/primitives/interfaces/__init__.py
+src/cryptography/hazmat/primitives/kdf/__init__.py
+src/cryptography/hazmat/primitives/kdf/concatkdf.py
+src/cryptography/hazmat/primitives/kdf/hkdf.py
+src/cryptography/hazmat/primitives/kdf/pbkdf2.py
+src/cryptography/hazmat/primitives/kdf/x963kdf.py
+src/cryptography/hazmat/primitives/twofactor/__init__.py
+src/cryptography/hazmat/primitives/twofactor/hotp.py
+src/cryptography/hazmat/primitives/twofactor/totp.py
+src/cryptography/hazmat/primitives/twofactor/utils.py
+src/cryptography/x509/__init__.py
+src/cryptography/x509/base.py
+src/cryptography/x509/extensions.py
+src/cryptography/x509/general_name.py
+src/cryptography/x509/name.py
+src/cryptography/x509/oid.py
+tests/__init__.py
+tests/conftest.py
+tests/test_fernet.py
+tests/test_interfaces.py
+tests/test_utils.py
+tests/test_warnings.py
+tests/test_x509.py
+tests/test_x509_ext.py
+tests/utils.py
+tests/hazmat/__init__.py
+tests/hazmat/backends/__init__.py
+tests/hazmat/backends/test_commoncrypto.py
+tests/hazmat/backends/test_multibackend.py
+tests/hazmat/backends/test_openssl.py
+tests/hazmat/bindings/test_commoncrypto.py
+tests/hazmat/bindings/test_openssl.py
+tests/hazmat/primitives/__init__.py
+tests/hazmat/primitives/fixtures_dsa.py
+tests/hazmat/primitives/fixtures_rsa.py
+tests/hazmat/primitives/test_3des.py
+tests/hazmat/primitives/test_aes.py
+tests/hazmat/primitives/test_arc4.py
+tests/hazmat/primitives/test_asym_utils.py
+tests/hazmat/primitives/test_block.py
+tests/hazmat/primitives/test_blowfish.py
+tests/hazmat/primitives/test_camellia.py
+tests/hazmat/primitives/test_cast5.py
+tests/hazmat/primitives/test_ciphers.py
+tests/hazmat/primitives/test_cmac.py
+tests/hazmat/primitives/test_concatkdf.py
+tests/hazmat/primitives/test_constant_time.py
+tests/hazmat/primitives/test_dh.py
+tests/hazmat/primitives/test_dsa.py
+tests/hazmat/primitives/test_ec.py
+tests/hazmat/primitives/test_hash_vectors.py
+tests/hazmat/primitives/test_hashes.py
+tests/hazmat/primitives/test_hkdf.py
+tests/hazmat/primitives/test_hkdf_vectors.py
+tests/hazmat/primitives/test_hmac.py
+tests/hazmat/primitives/test_hmac_vectors.py
+tests/hazmat/primitives/test_idea.py
+tests/hazmat/primitives/test_keywrap.py
+tests/hazmat/primitives/test_padding.py
+tests/hazmat/primitives/test_pbkdf2hmac.py
+tests/hazmat/primitives/test_pbkdf2hmac_vectors.py
+tests/hazmat/primitives/test_rsa.py
+tests/hazmat/primitives/test_seed.py
+tests/hazmat/primitives/test_serialization.py
+tests/hazmat/primitives/test_x963_vectors.py
+tests/hazmat/primitives/test_x963kdf.py
+tests/hazmat/primitives/utils.py
+tests/hazmat/primitives/twofactor/__init__.py
+tests/hazmat/primitives/twofactor/test_hotp.py
+tests/hazmat/primitives/twofactor/test_totp.py
+tests/hypothesis/__init__.py
+tests/hypothesis/test_fernet.py
\ Kein Zeilenumbruch am Dateiende.
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography.egg-info/top_level.txt hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography.egg-info/top_level.txt
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/src/cryptography.egg-info/top_level.txt	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/src/cryptography.egg-info/top_level.txt	2015-11-19 05:02:00.000000000 +0100
@@ -0,0 +1 @@
+cryptography
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/conftest.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/conftest.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/conftest.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/conftest.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,46 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import pytest
+
+from cryptography.hazmat.backends import _available_backends
+
+from .utils import check_backend_support, select_backends, skip_if_empty
+
+
+def pytest_generate_tests(metafunc):
+    if "backend" in metafunc.fixturenames:
+        names = metafunc.config.getoption("--backend")
+        selected_backends = select_backends(names, _available_backends())
+
+        filtered_backends = []
+        required = metafunc.function.requires_backend_interface
+        required_interfaces = [
+            mark.kwargs["interface"] for mark in required
+        ]
+        for backend in selected_backends:
+            if all(
+                isinstance(backend, iface) for iface in required_interfaces
+            ):
+                filtered_backends.append(backend)
+
+        # If you pass an empty list to parametrize Bad Things(tm) happen
+        # as of pytest 2.6.4 when the test also has a parametrize decorator
+        skip_if_empty(filtered_backends, required_interfaces)
+
+        metafunc.parametrize("backend", filtered_backends)
+
+
+@pytest.mark.trylast
+def pytest_runtest_setup(item):
+    check_backend_support(item)
+
+
+def pytest_addoption(parser):
+    parser.addoption(
+        "--backend", action="store", metavar="NAME",
+        help="Only run tests matching the backend NAME."
+    )
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/backends/__init__.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/backends/__init__.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/backends/__init__.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/backends/__init__.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,5 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/backends/test_commoncrypto.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/backends/test_commoncrypto.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/backends/test_commoncrypto.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/backends/test_commoncrypto.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,61 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import pytest
+
+from cryptography import utils
+from cryptography.exceptions import InternalError, _Reasons
+from cryptography.hazmat.backends import _available_backends
+from cryptography.hazmat.primitives.ciphers import Cipher, CipherAlgorithm
+from cryptography.hazmat.primitives.ciphers.algorithms import AES
+from cryptography.hazmat.primitives.ciphers.modes import CBC, GCM
+
+from ...utils import raises_unsupported_algorithm
+
+
+@utils.register_interface(CipherAlgorithm)
+class DummyCipher(object):
+    name = "dummy-cipher"
+    block_size = None
+    key_size = None
+
+
+@pytest.mark.skipif("commoncrypto" not in
+                    [i.name for i in _available_backends()],
+                    reason="CommonCrypto not available")
+class TestCommonCrypto(object):
+    def test_supports_cipher(self):
+        from cryptography.hazmat.backends.commoncrypto.backend import backend
+        assert backend.cipher_supported(None, None) is False
+
+    def test_register_duplicate_cipher_adapter(self):
+        from cryptography.hazmat.backends.commoncrypto.backend import backend
+        with pytest.raises(ValueError):
+            backend._register_cipher_adapter(
+                AES, backend._lib.kCCAlgorithmAES128,
+                CBC, backend._lib.kCCModeCBC
+            )
+
+    def test_handle_response(self):
+        from cryptography.hazmat.backends.commoncrypto.backend import backend
+
+        with pytest.raises(ValueError):
+            backend._check_cipher_response(backend._lib.kCCAlignmentError)
+
+        with pytest.raises(InternalError):
+            backend._check_cipher_response(backend._lib.kCCMemoryFailure)
+
+        with pytest.raises(InternalError):
+            backend._check_cipher_response(backend._lib.kCCDecodeError)
+
+    def test_nonexistent_aead_cipher(self):
+        from cryptography.hazmat.backends.commoncrypto.backend import Backend
+        b = Backend()
+        cipher = Cipher(
+            DummyCipher(), GCM(b"fake_iv_here"), backend=b,
+        )
+        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_CIPHER):
+            cipher.encryptor()
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/backends/test_multibackend.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/backends/test_multibackend.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/backends/test_multibackend.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/backends/test_multibackend.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,536 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+from cryptography import utils
+from cryptography.exceptions import (
+    UnsupportedAlgorithm, _Reasons
+)
+from cryptography.hazmat.backends.interfaces import (
+    CMACBackend, CipherBackend, DERSerializationBackend, DSABackend,
+    EllipticCurveBackend, HMACBackend, HashBackend, PBKDF2HMACBackend,
+    PEMSerializationBackend, RSABackend, X509Backend
+)
+from cryptography.hazmat.backends.multibackend import MultiBackend
+from cryptography.hazmat.primitives import cmac, hashes, hmac
+from cryptography.hazmat.primitives.asymmetric import ec, padding
+from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
+
+from ...utils import raises_unsupported_algorithm
+
+
+@utils.register_interface(CipherBackend)
+class DummyCipherBackend(object):
+    def __init__(self, supported_ciphers):
+        self._ciphers = supported_ciphers
+
+    def cipher_supported(self, cipher, mode):
+        return (type(cipher), type(mode)) in self._ciphers
+
+    def create_symmetric_encryption_ctx(self, cipher, mode):
+        if not self.cipher_supported(cipher, mode):
+            raise UnsupportedAlgorithm("", _Reasons.UNSUPPORTED_CIPHER)
+
+    def create_symmetric_decryption_ctx(self, cipher, mode):
+        if not self.cipher_supported(cipher, mode):
+            raise UnsupportedAlgorithm("", _Reasons.UNSUPPORTED_CIPHER)
+
+
+@utils.register_interface(HashBackend)
+class DummyHashBackend(object):
+    def __init__(self, supported_algorithms):
+        self._algorithms = supported_algorithms
+
+    def hash_supported(self, algorithm):
+        return type(algorithm) in self._algorithms
+
+    def create_hash_ctx(self, algorithm):
+        if not self.hash_supported(algorithm):
+            raise UnsupportedAlgorithm("", _Reasons.UNSUPPORTED_HASH)
+
+
+@utils.register_interface(HMACBackend)
+class DummyHMACBackend(object):
+    def __init__(self, supported_algorithms):
+        self._algorithms = supported_algorithms
+
+    def hmac_supported(self, algorithm):
+        return type(algorithm) in self._algorithms
+
+    def create_hmac_ctx(self, key, algorithm):
+        if not self.hmac_supported(algorithm):
+            raise UnsupportedAlgorithm("", _Reasons.UNSUPPORTED_HASH)
+
+
+@utils.register_interface(PBKDF2HMACBackend)
+class DummyPBKDF2HMACBackend(object):
+    def __init__(self, supported_algorithms):
+        self._algorithms = supported_algorithms
+
+    def pbkdf2_hmac_supported(self, algorithm):
+        return type(algorithm) in self._algorithms
+
+    def derive_pbkdf2_hmac(self, algorithm, length, salt, iterations,
+                           key_material):
+        if not self.pbkdf2_hmac_supported(algorithm):
+            raise UnsupportedAlgorithm("", _Reasons.UNSUPPORTED_HASH)
+
+
+@utils.register_interface(RSABackend)
+class DummyRSABackend(object):
+    def generate_rsa_private_key(self, public_exponent, key_size):
+        pass
+
+    def rsa_padding_supported(self, padding):
+        pass
+
+    def generate_rsa_parameters_supported(self, public_exponent, key_size):
+        pass
+
+    def load_rsa_private_numbers(self, numbers):
+        pass
+
+    def load_rsa_public_numbers(self, numbers):
+        pass
+
+
+@utils.register_interface(DSABackend)
+class DummyDSABackend(object):
+    def generate_dsa_parameters(self, key_size):
+        pass
+
+    def generate_dsa_private_key(self, parameters):
+        pass
+
+    def generate_dsa_private_key_and_parameters(self, key_size):
+        pass
+
+    def dsa_hash_supported(self, algorithm):
+        pass
+
+    def dsa_parameters_supported(self, p, q, g):
+        pass
+
+    def load_dsa_private_numbers(self, numbers):
+        pass
+
+    def load_dsa_public_numbers(self, numbers):
+        pass
+
+    def load_dsa_parameter_numbers(self, numbers):
+        pass
+
+
+@utils.register_interface(CMACBackend)
+class DummyCMACBackend(object):
+    def __init__(self, supported_algorithms):
+        self._algorithms = supported_algorithms
+
+    def cmac_algorithm_supported(self, algorithm):
+        return type(algorithm) in self._algorithms
+
+    def create_cmac_ctx(self, algorithm):
+        if not self.cmac_algorithm_supported(algorithm):
+            raise UnsupportedAlgorithm("", _Reasons.UNSUPPORTED_CIPHER)
+
+
+@utils.register_interface(EllipticCurveBackend)
+class DummyEllipticCurveBackend(object):
+    def __init__(self, supported_curves):
+        self._curves = supported_curves
+
+    def elliptic_curve_supported(self, curve):
+        return any(
+            isinstance(curve, curve_type)
+            for curve_type in self._curves
+        )
+
+    def elliptic_curve_signature_algorithm_supported(
+        self, signature_algorithm, curve
+    ):
+        return (
+            isinstance(signature_algorithm, ec.ECDSA) and
+            self.elliptic_curve_supported(curve)
+        )
+
+    def generate_elliptic_curve_private_key(self, curve):
+        if not self.elliptic_curve_supported(curve):
+            raise UnsupportedAlgorithm(_Reasons.UNSUPPORTED_ELLIPTIC_CURVE)
+
+    def load_elliptic_curve_private_numbers(self, numbers):
+        if not self.elliptic_curve_supported(numbers.public_numbers.curve):
+            raise UnsupportedAlgorithm(_Reasons.UNSUPPORTED_ELLIPTIC_CURVE)
+
+    def load_elliptic_curve_public_numbers(self, numbers):
+        if not self.elliptic_curve_supported(numbers.curve):
+            raise UnsupportedAlgorithm(_Reasons.UNSUPPORTED_ELLIPTIC_CURVE)
+
+    def elliptic_curve_exchange_algorithm_supported(self, algorithm, curve):
+        return (
+            isinstance(algorithm, ec.ECDH) and
+            self.elliptic_curve_supported(curve)
+        )
+
+
+@utils.register_interface(PEMSerializationBackend)
+class DummyPEMSerializationBackend(object):
+    def load_pem_private_key(self, data, password):
+        pass
+
+    def load_pem_public_key(self, data):
+        pass
+
+
+@utils.register_interface(DERSerializationBackend)
+class DummyDERSerializationBackend(object):
+    def load_der_private_key(self, data, password):
+        pass
+
+    def load_der_public_key(self, data):
+        pass
+
+
+@utils.register_interface(X509Backend)
+class DummyX509Backend(object):
+    def load_pem_x509_certificate(self, data):
+        pass
+
+    def load_der_x509_certificate(self, data):
+        pass
+
+    def load_pem_x509_crl(self, data):
+        pass
+
+    def load_der_x509_crl(self, data):
+        pass
+
+    def load_pem_x509_csr(self, data):
+        pass
+
+    def load_der_x509_csr(self, data):
+        pass
+
+    def create_x509_csr(self, builder, private_key, algorithm):
+        pass
+
+    def create_x509_certificate(self, builder, private_key, algorithm):
+        pass
+
+
+class TestMultiBackend(object):
+    def test_ciphers(self):
+        backend = MultiBackend([
+            DummyHashBackend([]),
+            DummyCipherBackend([
+                (algorithms.AES, modes.CBC),
+            ])
+        ])
+        assert backend.cipher_supported(
+            algorithms.AES(b"\x00" * 16), modes.CBC(b"\x00" * 16)
+        )
+        assert not backend.cipher_supported(
+            algorithms.TripleDES(b"\x00" * 16), modes.CBC(b"\x00" * 16)
+        )
+
+        cipher = Cipher(
+            algorithms.AES(b"\x00" * 16),
+            modes.CBC(b"\x00" * 16),
+            backend=backend
+        )
+        cipher.encryptor()
+        cipher.decryptor()
+
+        cipher = Cipher(
+            algorithms.Camellia(b"\x00" * 16),
+            modes.CBC(b"\x00" * 16),
+            backend=backend
+        )
+        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_CIPHER):
+            cipher.encryptor()
+        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_CIPHER):
+            cipher.decryptor()
+
+    def test_hashes(self):
+        backend = MultiBackend([
+            DummyHashBackend([hashes.MD5])
+        ])
+        assert backend.hash_supported(hashes.MD5())
+        assert not backend.hash_supported(hashes.SHA256())
+
+        hashes.Hash(hashes.MD5(), backend=backend)
+
+        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_HASH):
+            hashes.Hash(hashes.SHA1(), backend=backend)
+
+    def test_hmac(self):
+        backend = MultiBackend([
+            DummyHMACBackend([hashes.MD5])
+        ])
+        assert backend.hmac_supported(hashes.MD5())
+        assert not backend.hmac_supported(hashes.SHA256())
+
+        hmac.HMAC(b"", hashes.MD5(), backend=backend)
+
+        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_HASH):
+            hmac.HMAC(b"", hashes.SHA1(), backend=backend)
+
+    def test_pbkdf2(self):
+        backend = MultiBackend([
+            DummyPBKDF2HMACBackend([hashes.MD5])
+        ])
+        assert backend.pbkdf2_hmac_supported(hashes.MD5())
+
+        backend.derive_pbkdf2_hmac(hashes.MD5(), 10, b"", 10, b"")
+
+        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_HASH):
+            backend.derive_pbkdf2_hmac(hashes.SHA1(), 10, b"", 10, b"")
+
+    def test_rsa(self):
+        backend = MultiBackend([
+            DummyRSABackend()
+        ])
+
+        backend.generate_rsa_private_key(
+            key_size=1024, public_exponent=65537
+        )
+
+        backend.rsa_padding_supported(padding.PKCS1v15())
+
+        backend.generate_rsa_parameters_supported(65537, 1024)
+
+        backend.load_rsa_private_numbers("private_numbers")
+
+        backend.load_rsa_public_numbers("public_numbers")
+
+        backend = MultiBackend([])
+        with raises_unsupported_algorithm(
+            _Reasons.UNSUPPORTED_PUBLIC_KEY_ALGORITHM
+        ):
+            backend.generate_rsa_private_key(key_size=1024, public_exponent=3)
+
+        with raises_unsupported_algorithm(
+            _Reasons.UNSUPPORTED_PUBLIC_KEY_ALGORITHM
+        ):
+            backend.rsa_padding_supported(padding.PKCS1v15())
+
+        with raises_unsupported_algorithm(
+            _Reasons.UNSUPPORTED_PUBLIC_KEY_ALGORITHM
+        ):
+            backend.generate_rsa_parameters_supported(65537, 1024)
+
+        with raises_unsupported_algorithm(
+            _Reasons.UNSUPPORTED_PUBLIC_KEY_ALGORITHM
+        ):
+            backend.load_rsa_private_numbers("private_numbers")
+
+        with raises_unsupported_algorithm(
+            _Reasons.UNSUPPORTED_PUBLIC_KEY_ALGORITHM
+        ):
+            backend.load_rsa_public_numbers("public_numbers")
+
+    def test_dsa(self):
+        backend = MultiBackend([
+            DummyDSABackend()
+        ])
+
+        backend.generate_dsa_parameters(key_size=1024)
+
+        parameters = object()
+        backend.generate_dsa_private_key(parameters)
+        backend.generate_dsa_private_key_and_parameters(key_size=1024)
+
+        backend.dsa_hash_supported(hashes.SHA1())
+        backend.dsa_parameters_supported(1, 2, 3)
+        backend.load_dsa_private_numbers("numbers")
+        backend.load_dsa_public_numbers("numbers")
+        backend.load_dsa_parameter_numbers("numbers")
+
+        backend = MultiBackend([])
+        with raises_unsupported_algorithm(
+            _Reasons.UNSUPPORTED_PUBLIC_KEY_ALGORITHM
+        ):
+            backend.generate_dsa_parameters(key_size=1024)
+
+        with raises_unsupported_algorithm(
+            _Reasons.UNSUPPORTED_PUBLIC_KEY_ALGORITHM
+        ):
+            backend.generate_dsa_private_key(parameters)
+
+        with raises_unsupported_algorithm(
+            _Reasons.UNSUPPORTED_PUBLIC_KEY_ALGORITHM
+        ):
+            backend.generate_dsa_private_key_and_parameters(key_size=1024)
+
+        with raises_unsupported_algorithm(
+            _Reasons.UNSUPPORTED_PUBLIC_KEY_ALGORITHM
+        ):
+            backend.dsa_hash_supported(hashes.SHA1())
+
+        with raises_unsupported_algorithm(
+            _Reasons.UNSUPPORTED_PUBLIC_KEY_ALGORITHM
+        ):
+            backend.dsa_parameters_supported('p', 'q', 'g')
+
+        with raises_unsupported_algorithm(
+            _Reasons.UNSUPPORTED_PUBLIC_KEY_ALGORITHM
+        ):
+            backend.load_dsa_private_numbers("numbers")
+
+        with raises_unsupported_algorithm(
+            _Reasons.UNSUPPORTED_PUBLIC_KEY_ALGORITHM
+        ):
+            backend.load_dsa_public_numbers("numbers")
+
+        with raises_unsupported_algorithm(
+            _Reasons.UNSUPPORTED_PUBLIC_KEY_ALGORITHM
+        ):
+            backend.load_dsa_parameter_numbers("numbers")
+
+    def test_cmac(self):
+        backend = MultiBackend([
+            DummyCMACBackend([algorithms.AES])
+        ])
+
+        fake_key = b"\x00" * 16
+
+        assert backend.cmac_algorithm_supported(algorithms.AES(fake_key))
+        assert not backend.cmac_algorithm_supported(
+            algorithms.TripleDES(fake_key)
+        )
+
+        cmac.CMAC(algorithms.AES(fake_key), backend)
+
+        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_CIPHER):
+            cmac.CMAC(algorithms.TripleDES(fake_key), backend)
+
+    def test_elliptic_curve(self):
+        backend = MultiBackend([
+            DummyEllipticCurveBackend([
+                ec.SECT283K1
+            ])
+        ])
+
+        assert backend.elliptic_curve_supported(ec.SECT283K1()) is True
+
+        assert backend.elliptic_curve_signature_algorithm_supported(
+            ec.ECDSA(hashes.SHA256()),
+            ec.SECT283K1()
+        ) is True
+
+        backend.generate_elliptic_curve_private_key(ec.SECT283K1())
+
+        backend.load_elliptic_curve_private_numbers(
+            ec.EllipticCurvePrivateNumbers(
+                1,
+                ec.EllipticCurvePublicNumbers(
+                    2,
+                    3,
+                    ec.SECT283K1()
+                )
+            )
+        )
+
+        backend.load_elliptic_curve_public_numbers(
+            ec.EllipticCurvePublicNumbers(
+                2,
+                3,
+                ec.SECT283K1()
+            )
+        )
+
+        assert backend.elliptic_curve_supported(ec.SECT163K1()) is False
+
+        assert backend.elliptic_curve_signature_algorithm_supported(
+            ec.ECDSA(hashes.SHA256()),
+            ec.SECT163K1()
+        ) is False
+
+        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_ELLIPTIC_CURVE):
+            backend.generate_elliptic_curve_private_key(ec.SECT163K1())
+
+        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_ELLIPTIC_CURVE):
+            backend.load_elliptic_curve_private_numbers(
+                ec.EllipticCurvePrivateNumbers(
+                    1,
+                    ec.EllipticCurvePublicNumbers(
+                        2,
+                        3,
+                        ec.SECT163K1()
+                    )
+                )
+            )
+
+        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_ELLIPTIC_CURVE):
+            backend.load_elliptic_curve_public_numbers(
+                ec.EllipticCurvePublicNumbers(
+                    2,
+                    3,
+                    ec.SECT163K1()
+                )
+            )
+
+        assert backend.elliptic_curve_exchange_algorithm_supported(
+            ec.ECDH(), ec.SECT283K1()
+        )
+        backend2 = MultiBackend([DummyEllipticCurveBackend([])])
+        assert not backend2.elliptic_curve_exchange_algorithm_supported(
+            ec.ECDH(), ec.SECT163K1()
+        )
+
+    def test_pem_serialization_backend(self):
+        backend = MultiBackend([DummyPEMSerializationBackend()])
+
+        backend.load_pem_private_key(b"keydata", None)
+        backend.load_pem_public_key(b"keydata")
+
+        backend = MultiBackend([])
+        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_SERIALIZATION):
+            backend.load_pem_private_key(b"keydata", None)
+        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_SERIALIZATION):
+            backend.load_pem_public_key(b"keydata")
+
+    def test_der_serialization_backend(self):
+        backend = MultiBackend([DummyDERSerializationBackend()])
+
+        backend.load_der_private_key(b"keydata", None)
+        backend.load_der_public_key(b"keydata")
+
+        backend = MultiBackend([])
+        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_SERIALIZATION):
+            backend.load_der_private_key(b"keydata", None)
+        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_SERIALIZATION):
+            backend.load_der_public_key(b"keydata")
+
+    def test_x509_backend(self):
+        backend = MultiBackend([DummyX509Backend()])
+
+        backend.load_pem_x509_certificate(b"certdata")
+        backend.load_der_x509_certificate(b"certdata")
+        backend.load_pem_x509_crl(b"crldata")
+        backend.load_der_x509_crl(b"crldata")
+        backend.load_pem_x509_csr(b"reqdata")
+        backend.load_der_x509_csr(b"reqdata")
+        backend.create_x509_csr(object(), b"privatekey", hashes.SHA1())
+        backend.create_x509_certificate(object(), b"privatekey", hashes.SHA1())
+
+        backend = MultiBackend([])
+        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_X509):
+            backend.load_pem_x509_certificate(b"certdata")
+        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_X509):
+            backend.load_der_x509_certificate(b"certdata")
+        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_X509):
+            backend.load_pem_x509_crl(b"crldata")
+        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_X509):
+            backend.load_der_x509_crl(b"crldata")
+        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_X509):
+            backend.load_pem_x509_csr(b"reqdata")
+        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_X509):
+            backend.load_der_x509_csr(b"reqdata")
+        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_X509):
+            backend.create_x509_csr(object(), b"privatekey", hashes.SHA1())
+        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_X509):
+            backend.create_x509_certificate(
+                object(), b"privatekey", hashes.SHA1()
+            )
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/backends/test_openssl.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/backends/test_openssl.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/backends/test_openssl.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/backends/test_openssl.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,571 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import os
+import subprocess
+import sys
+import textwrap
+
+import pretend
+
+import pytest
+
+from cryptography import utils
+from cryptography.exceptions import InternalError, _Reasons
+from cryptography.hazmat.backends.interfaces import RSABackend
+from cryptography.hazmat.backends.openssl.backend import (
+    Backend, backend
+)
+from cryptography.hazmat.backends.openssl.ec import _sn_to_elliptic_curve
+from cryptography.hazmat.primitives import hashes, serialization
+from cryptography.hazmat.primitives.asymmetric import dsa, ec, padding
+from cryptography.hazmat.primitives.ciphers import (
+    BlockCipherAlgorithm, Cipher, CipherAlgorithm
+)
+from cryptography.hazmat.primitives.ciphers.algorithms import AES
+from cryptography.hazmat.primitives.ciphers.modes import CBC, CTR, Mode
+
+from ..primitives.fixtures_dsa import DSA_KEY_2048
+from ..primitives.fixtures_rsa import RSA_KEY_2048, RSA_KEY_512
+from ..primitives.test_ec import _skip_curve_unsupported
+from ...utils import load_vectors_from_file, raises_unsupported_algorithm
+
+
+def skip_if_libre_ssl(openssl_version):
+    if u'LibreSSL' in openssl_version:
+        pytest.skip("LibreSSL hard-codes RAND_bytes to use arc4random.")
+
+
+class TestLibreSkip(object):
+    def test_skip_no(self):
+        assert skip_if_libre_ssl(u"OpenSSL 0.9.8zf 19 Mar 2015") is None
+
+    def test_skip_yes(self):
+        with pytest.raises(pytest.skip.Exception):
+            skip_if_libre_ssl(u"LibreSSL 2.1.6")
+
+
+@utils.register_interface(Mode)
+class DummyMode(object):
+    name = "dummy-mode"
+
+    def validate_for_algorithm(self, algorithm):
+        pass
+
+
+@utils.register_interface(CipherAlgorithm)
+class DummyCipher(object):
+    name = "dummy-cipher"
+    key_size = None
+
+
+@utils.register_interface(padding.AsymmetricPadding)
+class DummyPadding(object):
+    name = "dummy-cipher"
+
+
+@utils.register_interface(hashes.HashAlgorithm)
+class DummyHash(object):
+    name = "dummy-hash"
+    block_size = None
+    digest_size = None
+
+
+class DummyMGF(object):
+    _salt_length = 0
+
+
+class TestOpenSSL(object):
+    def test_backend_exists(self):
+        assert backend
+
+    def test_openssl_version_text(self):
+        """
+        This test checks the value of OPENSSL_VERSION_TEXT.
+
+        Unfortunately, this define does not appear to have a
+        formal content definition, so for now we'll test to see
+        if it starts with OpenSSL or LibreSSL as that appears
+        to be true for every OpenSSL-alike.
+        """
+        assert (
+            backend.openssl_version_text().startswith("OpenSSL") or
+            backend.openssl_version_text().startswith("LibreSSL")
+        )
+
+    def test_supports_cipher(self):
+        assert backend.cipher_supported(None, None) is False
+
+    def test_aes_ctr_always_available(self):
+        # AES CTR should always be available in both 0.9.8 and 1.0.0+
+        assert backend.cipher_supported(AES(b"\x00" * 16),
+                                        CTR(b"\x00" * 16)) is True
+
+    def test_register_duplicate_cipher_adapter(self):
+        with pytest.raises(ValueError):
+            backend.register_cipher_adapter(AES, CBC, None)
+
+    @pytest.mark.parametrize("mode", [DummyMode(), None])
+    def test_nonexistent_cipher(self, mode):
+        b = Backend()
+        b.register_cipher_adapter(
+            DummyCipher,
+            type(mode),
+            lambda backend, cipher, mode: backend._ffi.NULL
+        )
+        cipher = Cipher(
+            DummyCipher(), mode, backend=b,
+        )
+        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_CIPHER):
+            cipher.encryptor()
+
+    def test_openssl_assert(self):
+        backend.openssl_assert(True)
+        with pytest.raises(InternalError):
+            backend.openssl_assert(False)
+
+    def test_consume_errors(self):
+        for i in range(10):
+            backend._lib.ERR_put_error(backend._lib.ERR_LIB_EVP, 0, 0,
+                                       b"test_openssl.py", -1)
+
+        assert backend._lib.ERR_peek_error() != 0
+
+        errors = backend._consume_errors()
+
+        assert backend._lib.ERR_peek_error() == 0
+        assert len(errors) == 10
+
+    def test_ssl_ciphers_registered(self):
+        meth = backend._lib.TLSv1_method()
+        ctx = backend._lib.SSL_CTX_new(meth)
+        assert ctx != backend._ffi.NULL
+        backend._lib.SSL_CTX_free(ctx)
+
+    def test_evp_ciphers_registered(self):
+        cipher = backend._lib.EVP_get_cipherbyname(b"aes-256-cbc")
+        assert cipher != backend._ffi.NULL
+
+    def test_error_strings_loaded(self):
+        # returns a value in a static buffer
+        err = backend._lib.ERR_error_string(101183626, backend._ffi.NULL)
+        assert backend._ffi.string(err) == (
+            b"error:0607F08A:digital envelope routines:EVP_EncryptFinal_ex:"
+            b"data not multiple of block length"
+        )
+
+    def test_unknown_error_in_cipher_finalize(self):
+        cipher = Cipher(AES(b"\0" * 16), CBC(b"\0" * 16), backend=backend)
+        enc = cipher.encryptor()
+        enc.update(b"\0")
+        backend._lib.ERR_put_error(0, 0, 1,
+                                   b"test_openssl.py", -1)
+        with pytest.raises(InternalError):
+            enc.finalize()
+
+    def test_derive_pbkdf2_raises_unsupported_on_old_openssl(self):
+        if backend.pbkdf2_hmac_supported(hashes.SHA256()):
+            pytest.skip("Requires an older OpenSSL")
+        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_HASH):
+            backend.derive_pbkdf2_hmac(hashes.SHA256(), 10, b"", 1000, b"")
+
+    @pytest.mark.skipif(
+        backend._lib.OPENSSL_VERSION_NUMBER >= 0x1000000f,
+        reason="Requires an older OpenSSL. Must be < 1.0.0"
+    )
+    def test_large_key_size_on_old_openssl(self):
+        with pytest.raises(ValueError):
+            dsa.generate_parameters(2048, backend=backend)
+
+        with pytest.raises(ValueError):
+            dsa.generate_parameters(3072, backend=backend)
+
+    @pytest.mark.skipif(
+        backend._lib.OPENSSL_VERSION_NUMBER < 0x1000000f,
+        reason="Requires a newer OpenSSL. Must be >= 1.0.0"
+    )
+    def test_large_key_size_on_new_openssl(self):
+        parameters = dsa.generate_parameters(2048, backend)
+        param_num = parameters.parameter_numbers()
+        assert utils.bit_length(param_num.p) == 2048
+        parameters = dsa.generate_parameters(3072, backend)
+        param_num = parameters.parameter_numbers()
+        assert utils.bit_length(param_num.p) == 3072
+
+    def test_int_to_bn(self):
+        value = (2 ** 4242) - 4242
+        bn = backend._int_to_bn(value)
+        assert bn != backend._ffi.NULL
+        bn = backend._ffi.gc(bn, backend._lib.BN_free)
+
+        assert bn
+        assert backend._bn_to_int(bn) == value
+
+    def test_int_to_bn_inplace(self):
+        value = (2 ** 4242) - 4242
+        bn_ptr = backend._lib.BN_new()
+        assert bn_ptr != backend._ffi.NULL
+        bn_ptr = backend._ffi.gc(bn_ptr, backend._lib.BN_free)
+        bn = backend._int_to_bn(value, bn_ptr)
+
+        assert bn == bn_ptr
+        assert backend._bn_to_int(bn_ptr) == value
+
+    def test_bn_to_int(self):
+        bn = backend._int_to_bn(0)
+        assert backend._bn_to_int(bn) == 0
+
+    def test_actual_osrandom_bytes(self, monkeypatch):
+        skip_if_libre_ssl(backend.openssl_version_text())
+        sample_data = (b"\x01\x02\x03\x04" * 4)
+        length = len(sample_data)
+
+        def notrandom(size):
+            assert size == length
+            return sample_data
+        monkeypatch.setattr(os, "urandom", notrandom)
+        buf = backend._ffi.new("char[]", length)
+        backend._lib.RAND_bytes(buf, length)
+        assert backend._ffi.buffer(buf)[0:length] == sample_data
+
+
+class TestOpenSSLRandomEngine(object):
+    def teardown_method(self, method):
+        # we need to reset state to being default. backend is a shared global
+        # for all these tests.
+        backend.activate_osrandom_engine()
+        current_default = backend._lib.ENGINE_get_default_RAND()
+        name = backend._lib.ENGINE_get_name(current_default)
+        assert name == backend._binding._osrandom_engine_name
+
+    def test_osrandom_engine_is_default(self, tmpdir):
+        engine_printer = textwrap.dedent(
+            """
+            import sys
+            from cryptography.hazmat.backends.openssl.backend import backend
+
+            e = backend._lib.ENGINE_get_default_RAND()
+            name = backend._lib.ENGINE_get_name(e)
+            sys.stdout.write(backend._ffi.string(name).decode('ascii'))
+            res = backend._lib.ENGINE_free(e)
+            assert res == 1
+            """
+        )
+        engine_name = tmpdir.join('engine_name')
+
+        # If we're running tests via ``python setup.py test`` in a clean
+        # environment then all of our dependencies are going to be installed
+        # into either the current directory or the .eggs directory. However the
+        # subprocess won't know to activate these dependencies, so we'll get it
+        # to do so by passing our entire sys.path into the subprocess via the
+        # PYTHONPATH environment variable.
+        env = os.environ.copy()
+        env["PYTHONPATH"] = os.pathsep.join(sys.path)
+
+        with engine_name.open('w') as out:
+            subprocess.check_call(
+                [sys.executable, "-c", engine_printer],
+                env=env,
+                stdout=out
+            )
+
+        osrandom_engine_name = backend._ffi.string(
+            backend._binding._osrandom_engine_name
+        )
+
+        assert engine_name.read().encode('ascii') == osrandom_engine_name
+
+    def test_osrandom_sanity_check(self):
+        # This test serves as a check against catastrophic failure.
+        buf = backend._ffi.new("char[]", 500)
+        res = backend._lib.RAND_bytes(buf, 500)
+        assert res == 1
+        assert backend._ffi.buffer(buf)[:] != "\x00" * 500
+
+    def test_activate_osrandom_no_default(self):
+        backend.activate_builtin_random()
+        e = backend._lib.ENGINE_get_default_RAND()
+        assert e == backend._ffi.NULL
+        backend.activate_osrandom_engine()
+        e = backend._lib.ENGINE_get_default_RAND()
+        name = backend._lib.ENGINE_get_name(e)
+        assert name == backend._binding._osrandom_engine_name
+        res = backend._lib.ENGINE_free(e)
+        assert res == 1
+
+    def test_activate_builtin_random(self):
+        e = backend._lib.ENGINE_get_default_RAND()
+        assert e != backend._ffi.NULL
+        name = backend._lib.ENGINE_get_name(e)
+        assert name == backend._binding._osrandom_engine_name
+        res = backend._lib.ENGINE_free(e)
+        assert res == 1
+        backend.activate_builtin_random()
+        e = backend._lib.ENGINE_get_default_RAND()
+        assert e == backend._ffi.NULL
+
+    def test_activate_builtin_random_already_active(self):
+        backend.activate_builtin_random()
+        e = backend._lib.ENGINE_get_default_RAND()
+        assert e == backend._ffi.NULL
+        backend.activate_builtin_random()
+        e = backend._lib.ENGINE_get_default_RAND()
+        assert e == backend._ffi.NULL
+
+    def test_activate_osrandom_already_default(self):
+        e = backend._lib.ENGINE_get_default_RAND()
+        name = backend._lib.ENGINE_get_name(e)
+        assert name == backend._binding._osrandom_engine_name
+        res = backend._lib.ENGINE_free(e)
+        assert res == 1
+        backend.activate_osrandom_engine()
+        e = backend._lib.ENGINE_get_default_RAND()
+        name = backend._lib.ENGINE_get_name(e)
+        assert name == backend._binding._osrandom_engine_name
+        res = backend._lib.ENGINE_free(e)
+        assert res == 1
+
+
+class TestOpenSSLRSA(object):
+    def test_generate_rsa_parameters_supported(self):
+        assert backend.generate_rsa_parameters_supported(1, 1024) is False
+        assert backend.generate_rsa_parameters_supported(4, 1024) is False
+        assert backend.generate_rsa_parameters_supported(3, 1024) is True
+        assert backend.generate_rsa_parameters_supported(3, 511) is False
+
+    def test_generate_bad_public_exponent(self):
+        with pytest.raises(ValueError):
+            backend.generate_rsa_private_key(public_exponent=1, key_size=2048)
+
+        with pytest.raises(ValueError):
+            backend.generate_rsa_private_key(public_exponent=4, key_size=2048)
+
+    def test_cant_generate_insecure_tiny_key(self):
+        with pytest.raises(ValueError):
+            backend.generate_rsa_private_key(public_exponent=65537,
+                                             key_size=511)
+
+        with pytest.raises(ValueError):
+            backend.generate_rsa_private_key(public_exponent=65537,
+                                             key_size=256)
+
+    @pytest.mark.skipif(
+        backend._lib.OPENSSL_VERSION_NUMBER >= 0x1000100f,
+        reason="Requires an older OpenSSL. Must be < 1.0.1"
+    )
+    def test_non_sha1_pss_mgf1_hash_algorithm_on_old_openssl(self):
+        private_key = RSA_KEY_512.private_key(backend)
+        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_HASH):
+            private_key.signer(
+                padding.PSS(
+                    mgf=padding.MGF1(
+                        algorithm=hashes.SHA256(),
+                    ),
+                    salt_length=padding.PSS.MAX_LENGTH
+                ),
+                hashes.SHA1()
+            )
+        public_key = private_key.public_key()
+        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_HASH):
+            public_key.verifier(
+                b"sig",
+                padding.PSS(
+                    mgf=padding.MGF1(
+                        algorithm=hashes.SHA256(),
+                    ),
+                    salt_length=padding.PSS.MAX_LENGTH
+                ),
+                hashes.SHA1()
+            )
+
+    def test_rsa_padding_unsupported_pss_mgf1_hash(self):
+        assert backend.rsa_padding_supported(
+            padding.PSS(mgf=padding.MGF1(DummyHash()), salt_length=0)
+        ) is False
+
+    def test_rsa_padding_unsupported(self):
+        assert backend.rsa_padding_supported(DummyPadding()) is False
+
+    def test_rsa_padding_supported_pkcs1v15(self):
+        assert backend.rsa_padding_supported(padding.PKCS1v15()) is True
+
+    def test_rsa_padding_supported_pss(self):
+        assert backend.rsa_padding_supported(
+            padding.PSS(mgf=padding.MGF1(hashes.SHA1()), salt_length=0)
+        ) is True
+
+    def test_rsa_padding_supported_oaep(self):
+        assert backend.rsa_padding_supported(
+            padding.OAEP(
+                mgf=padding.MGF1(algorithm=hashes.SHA1()),
+                algorithm=hashes.SHA1(),
+                label=None
+            ),
+        ) is True
+
+    def test_rsa_padding_unsupported_mgf(self):
+        assert backend.rsa_padding_supported(
+            padding.OAEP(
+                mgf=DummyMGF(),
+                algorithm=hashes.SHA1(),
+                label=None
+            ),
+        ) is False
+
+        assert backend.rsa_padding_supported(
+            padding.PSS(mgf=DummyMGF(), salt_length=0)
+        ) is False
+
+    def test_unsupported_mgf1_hash_algorithm_decrypt(self):
+        private_key = RSA_KEY_512.private_key(backend)
+        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_HASH):
+            private_key.decrypt(
+                b"0" * 64,
+                padding.OAEP(
+                    mgf=padding.MGF1(algorithm=hashes.SHA256()),
+                    algorithm=hashes.SHA1(),
+                    label=None
+                )
+            )
+
+    def test_unsupported_oaep_hash_algorithm_decrypt(self):
+        private_key = RSA_KEY_512.private_key(backend)
+        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_HASH):
+            private_key.decrypt(
+                b"0" * 64,
+                padding.OAEP(
+                    mgf=padding.MGF1(algorithm=hashes.SHA1()),
+                    algorithm=hashes.SHA256(),
+                    label=None
+                )
+            )
+
+    def test_unsupported_oaep_label_decrypt(self):
+        private_key = RSA_KEY_512.private_key(backend)
+        with pytest.raises(ValueError):
+            private_key.decrypt(
+                b"0" * 64,
+                padding.OAEP(
+                    mgf=padding.MGF1(algorithm=hashes.SHA1()),
+                    algorithm=hashes.SHA1(),
+                    label=b"label"
+                )
+            )
+
+
+@pytest.mark.skipif(
+    backend._lib.OPENSSL_VERSION_NUMBER <= 0x10001000,
+    reason="Requires an OpenSSL version >= 1.0.1"
+)
+class TestOpenSSLCMAC(object):
+    def test_unsupported_cipher(self):
+        @utils.register_interface(BlockCipherAlgorithm)
+        class FakeAlgorithm(object):
+            block_size = 64
+
+        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_CIPHER):
+            backend.create_cmac_ctx(FakeAlgorithm())
+
+
+class TestOpenSSLCreateX509CSR(object):
+    @pytest.mark.skipif(
+        backend._lib.OPENSSL_VERSION_NUMBER >= 0x10001000,
+        reason="Requires an older OpenSSL. Must be < 1.0.1"
+    )
+    def test_unsupported_dsa_keys(self):
+        private_key = DSA_KEY_2048.private_key(backend)
+
+        with pytest.raises(NotImplementedError):
+            backend.create_x509_csr(object(), private_key, hashes.SHA1())
+
+    @pytest.mark.skipif(
+        backend._lib.OPENSSL_VERSION_NUMBER >= 0x10001000,
+        reason="Requires an older OpenSSL. Must be < 1.0.1"
+    )
+    def test_unsupported_ec_keys(self):
+        _skip_curve_unsupported(backend, ec.SECP256R1())
+        private_key = ec.generate_private_key(ec.SECP256R1(), backend)
+
+        with pytest.raises(NotImplementedError):
+            backend.create_x509_csr(object(), private_key, hashes.SHA1())
+
+
+class TestOpenSSLSignX509Certificate(object):
+    def test_requires_certificate_builder(self):
+        private_key = RSA_KEY_2048.private_key(backend)
+
+        with pytest.raises(TypeError):
+            backend.create_x509_certificate(object(), private_key, DummyHash())
+
+
+class TestOpenSSLSerialisationWithOpenSSL(object):
+    def test_pem_password_cb_buffer_too_small(self):
+        ffi_cb, cb = backend._pem_password_cb(b"aa")
+        assert cb(None, 1, False, None) == 0
+
+    def test_unsupported_evp_pkey_type(self):
+        key = pretend.stub(type="unsupported")
+        with raises_unsupported_algorithm(None):
+            backend._evp_pkey_to_private_key(key)
+        with raises_unsupported_algorithm(None):
+            backend._evp_pkey_to_public_key(key)
+
+    def test_very_long_pem_serialization_password(self):
+        password = "x" * 1024
+
+        with pytest.raises(ValueError):
+            load_vectors_from_file(
+                os.path.join(
+                    "asymmetric", "Traditional_OpenSSL_Serialization",
+                    "key1.pem"
+                ),
+                lambda pemfile: (
+                    backend.load_pem_private_key(
+                        pemfile.read().encode(), password
+                    )
+                )
+            )
+
+
+class DummyLibrary(object):
+    Cryptography_HAS_EC = 0
+
+
+class TestOpenSSLEllipticCurve(object):
+    def test_elliptic_curve_supported(self, monkeypatch):
+        monkeypatch.setattr(backend, "_lib", DummyLibrary())
+
+        assert backend.elliptic_curve_supported(None) is False
+
+    def test_elliptic_curve_signature_algorithm_supported(self, monkeypatch):
+        monkeypatch.setattr(backend, "_lib", DummyLibrary())
+
+        assert backend.elliptic_curve_signature_algorithm_supported(
+            None, None
+        ) is False
+
+    def test_sn_to_elliptic_curve_not_supported(self):
+        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_ELLIPTIC_CURVE):
+            _sn_to_elliptic_curve(backend, b"fake")
+
+    def test_elliptic_curve_exchange_algorithm_supported(self, monkeypatch):
+        monkeypatch.setattr(backend, "_lib", DummyLibrary())
+        assert not backend.elliptic_curve_exchange_algorithm_supported(
+            ec.ECDH(), ec.SECP256R1()
+        )
+
+
+@pytest.mark.requires_backend_interface(interface=RSABackend)
+class TestRSAPEMSerialization(object):
+    def test_password_length_limit(self):
+        password = b"x" * 1024
+        key = RSA_KEY_2048.private_key(backend)
+        with pytest.raises(ValueError):
+            key.private_bytes(
+                serialization.Encoding.PEM,
+                serialization.PrivateFormat.PKCS8,
+                serialization.BestAvailableEncryption(password)
+            )
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/bindings/test_commoncrypto.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/bindings/test_commoncrypto.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/bindings/test_commoncrypto.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/bindings/test_commoncrypto.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,26 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import pytest
+
+
+ccbinding = pytest.importorskip(
+    "cryptography.hazmat.bindings.commoncrypto.binding"
+)
+
+
+class TestCommonCrypto(object):
+    def test_binding_loads(self):
+        binding = ccbinding.Binding()
+        assert binding
+        assert binding.lib
+        assert binding.ffi
+
+    def test_binding_returns_same_lib(self):
+        binding = ccbinding.Binding()
+        binding2 = ccbinding.Binding()
+        assert binding.lib == binding2.lib
+        assert binding.ffi == binding2.ffi
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/bindings/test_openssl.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/bindings/test_openssl.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/bindings/test_openssl.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/bindings/test_openssl.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,151 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import pytest
+
+from cryptography.hazmat.bindings.openssl.binding import Binding
+
+
+class TestOpenSSL(object):
+    def test_binding_loads(self):
+        binding = Binding()
+        assert binding
+        assert binding.lib
+        assert binding.ffi
+
+    def test_crypto_lock_init(self):
+        b = Binding()
+        b.init_static_locks()
+        lock_cb = b.lib.CRYPTO_get_locking_callback()
+        assert lock_cb != b.ffi.NULL
+
+    def _skip_if_not_fallback_lock(self, b):
+        # only run this test if we are using our locking cb
+        original_cb = b.lib.CRYPTO_get_locking_callback()
+        if original_cb != b._lock_cb_handle:
+            pytest.skip(
+                "Not using the fallback Python locking callback "
+                "implementation. Probably because import _ssl set one"
+            )
+
+    def test_fallback_crypto_lock_via_openssl_api(self):
+        b = Binding()
+        b.init_static_locks()
+
+        self._skip_if_not_fallback_lock(b)
+
+        # check that the lock state changes appropriately
+        lock = b._locks[b.lib.CRYPTO_LOCK_SSL]
+
+        # starts out unlocked
+        assert lock.acquire(False)
+        lock.release()
+
+        b.lib.CRYPTO_lock(
+            b.lib.CRYPTO_LOCK | b.lib.CRYPTO_READ,
+            b.lib.CRYPTO_LOCK_SSL, b.ffi.NULL, 0
+        )
+
+        # becomes locked
+        assert not lock.acquire(False)
+
+        b.lib.CRYPTO_lock(
+            b.lib.CRYPTO_UNLOCK | b.lib.CRYPTO_READ,
+            b.lib.CRYPTO_LOCK_SSL, b.ffi.NULL, 0
+        )
+
+        # then unlocked
+        assert lock.acquire(False)
+        lock.release()
+
+    def test_fallback_crypto_lock_via_binding_api(self):
+        b = Binding()
+        b.init_static_locks()
+
+        self._skip_if_not_fallback_lock(b)
+
+        lock = b._locks[b.lib.CRYPTO_LOCK_SSL]
+
+        with pytest.raises(RuntimeError):
+            b._lock_cb(0, b.lib.CRYPTO_LOCK_SSL, "<test>", 1)
+
+        # errors shouldn't cause locking
+        assert lock.acquire(False)
+        lock.release()
+
+        b._lock_cb(b.lib.CRYPTO_LOCK | b.lib.CRYPTO_READ,
+                   b.lib.CRYPTO_LOCK_SSL, "<test>", 1)
+        # locked
+        assert not lock.acquire(False)
+
+        b._lock_cb(b.lib.CRYPTO_UNLOCK | b.lib.CRYPTO_READ,
+                   b.lib.CRYPTO_LOCK_SSL, "<test>", 1)
+        # unlocked
+        assert lock.acquire(False)
+        lock.release()
+
+    def test_add_engine_more_than_once(self):
+        b = Binding()
+        b._register_osrandom_engine()
+        assert b.lib.ERR_get_error() == 0
+
+    def test_ssl_ctx_options(self):
+        # Test that we're properly handling 32-bit unsigned on all platforms.
+        b = Binding()
+        assert b.lib.SSL_OP_ALL > 0
+        ctx = b.lib.SSL_CTX_new(b.lib.TLSv1_method())
+        ctx = b.ffi.gc(ctx, b.lib.SSL_CTX_free)
+        current_options = b.lib.SSL_CTX_get_options(ctx)
+        resp = b.lib.SSL_CTX_set_options(ctx, b.lib.SSL_OP_ALL)
+        expected_options = current_options | b.lib.SSL_OP_ALL
+        assert resp == expected_options
+        assert b.lib.SSL_CTX_get_options(ctx) == expected_options
+
+    def test_ssl_options(self):
+        # Test that we're properly handling 32-bit unsigned on all platforms.
+        b = Binding()
+        assert b.lib.SSL_OP_ALL > 0
+        ctx = b.lib.SSL_CTX_new(b.lib.TLSv1_method())
+        ctx = b.ffi.gc(ctx, b.lib.SSL_CTX_free)
+        ssl = b.lib.SSL_new(ctx)
+        ssl = b.ffi.gc(ssl, b.lib.SSL_free)
+        current_options = b.lib.SSL_get_options(ssl)
+        resp = b.lib.SSL_set_options(ssl, b.lib.SSL_OP_ALL)
+        expected_options = current_options | b.lib.SSL_OP_ALL
+        assert resp == expected_options
+        assert b.lib.SSL_get_options(ssl) == expected_options
+
+    def test_ssl_mode(self):
+        # Test that we're properly handling 32-bit unsigned on all platforms.
+        b = Binding()
+        assert b.lib.SSL_OP_ALL > 0
+        ctx = b.lib.SSL_CTX_new(b.lib.TLSv1_method())
+        ctx = b.ffi.gc(ctx, b.lib.SSL_CTX_free)
+        ssl = b.lib.SSL_new(ctx)
+        ssl = b.ffi.gc(ssl, b.lib.SSL_free)
+        current_options = b.lib.SSL_get_mode(ssl)
+        resp = b.lib.SSL_set_mode(ssl, b.lib.SSL_OP_ALL)
+        expected_options = current_options | b.lib.SSL_OP_ALL
+        assert resp == expected_options
+        assert b.lib.SSL_get_mode(ssl) == expected_options
+
+    def test_conditional_removal(self):
+        b = Binding()
+        if b.lib.OPENSSL_VERSION_NUMBER >= 0x10000000:
+            assert b.lib.X509_V_ERR_DIFFERENT_CRL_SCOPE
+            assert b.lib.X509_V_ERR_CRL_PATH_VALIDATION_ERROR
+        else:
+            with pytest.raises(AttributeError):
+                b.lib.X509_V_ERR_DIFFERENT_CRL_SCOPE
+
+            with pytest.raises(AttributeError):
+                b.lib.X509_V_ERR_CRL_PATH_VALIDATION_ERROR
+
+        if b.lib.OPENSSL_VERSION_NUMBER >= 0x10001000:
+            assert b.lib.CMAC_Init
+        else:
+            with pytest.raises(AttributeError):
+                b.lib.CMAC_Init
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/__init__.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/__init__.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/__init__.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/__init__.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,5 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/fixtures_dsa.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/fixtures_dsa.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/fixtures_dsa.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/fixtures_dsa.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,152 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+from cryptography.hazmat.primitives.asymmetric.dsa import (
+    DSAParameterNumbers, DSAPrivateNumbers, DSAPublicNumbers
+)
+
+
+DSA_KEY_1024 = DSAPrivateNumbers(
+    public_numbers=DSAPublicNumbers(
+        parameter_numbers=DSAParameterNumbers(
+            p=int(
+                'd38311e2cd388c3ed698e82fdf88eb92b5a9a483dc88005d4b725ef34'
+                '1eabb47cf8a7a8a41e792a156b7ce97206c4f9c5ce6fc5ae7912102b6'
+                'b502e59050b5b21ce263dddb2044b652236f4d42ab4b5d6aa73189cef'
+                '1ace778d7845a5c1c1c7147123188f8dc551054ee162b634d60f097f7'
+                '19076640e20980a0093113a8bd73', 16
+            ),
+            q=int('96c5390a8b612c0e422bb2b0ea194a3ec935a281', 16),
+            g=int(
+                '06b7861abbd35cc89e79c52f68d20875389b127361ca66822138ce499'
+                '1d2b862259d6b4548a6495b195aa0e0b6137ca37eb23b94074d3c3d30'
+                '0042bdf15762812b6333ef7b07ceba78607610fcc9ee68491dbc1e34c'
+                'd12615474e52b18bc934fb00c61d39e7da8902291c4434a4e2224c3f4'
+                'fd9f93cd6f4f17fc076341a7e7d9', 16
+            )
+        ),
+        y=int(
+            '6f26d98d41de7d871b6381851c9d91fa03942092ab6097e76422070edb71d'
+            'b44ff568280fdb1709f8fc3feab39f1f824adaeb2a298088156ac31af1aa0'
+            '4bf54f475bdcfdcf2f8a2dd973e922d83e76f016558617603129b21c70bf7'
+            'd0e5dc9e68fe332e295b65876eb9a12fe6fca9f1a1ce80204646bf99b5771'
+            'd249a6fea627', 16
+        )
+    ),
+    x=int('8185fee9cc7c0e91fd85503274f1cd5a3fd15a49', 16)
+)
+
+DSA_KEY_2048 = DSAPrivateNumbers(
+    public_numbers=DSAPublicNumbers(
+        parameter_numbers=DSAParameterNumbers(
+            p=int(
+                'ea1fb1af22881558ef93be8a5f8653c5a559434c49c8c2c12ace5e9c4'
+                '1434c9cf0a8e9498acb0f4663c08b4484eace845f6fb17dac62c98e70'
+                '6af0fc74e4da1c6c2b3fbf5a1d58ff82fc1a66f3e8b12252c40278fff'
+                '9dd7f102eed2cb5b7323ebf1908c234d935414dded7f8d244e54561b0'
+                'dca39b301de8c49da9fb23df33c6182e3f983208c560fb5119fbf78eb'
+                'e3e6564ee235c6a15cbb9ac247baba5a423bc6582a1a9d8a2b4f0e9e3'
+                'd9dbac122f750dd754325135257488b1f6ecabf21bff2947fe0d3b2cb'
+                '7ffe67f4e7fcdf1214f6053e72a5bb0dd20a0e9fe6db2df0a908c36e9'
+                '5e60bf49ca4368b8b892b9c79f61ef91c47567c40e1f80ac5aa66ef7',
+                16
+            ),
+            q=int(
+                '8ec73f3761caf5fdfe6e4e82098bf10f898740dcb808204bf6b18f507'
+                '192c19d', 16
+            ),
+            g=int(
+                'e4c4eca88415b23ecf811c96e48cd24200fe916631a68a684e6ccb6b1'
+                '913413d344d1d8d84a333839d88eee431521f6e357c16e6a93be111a9'
+                '8076739cd401bab3b9d565bf4fb99e9d185b1e14d61c93700133f908b'
+                'ae03e28764d107dcd2ea7674217622074bb19efff482f5f5c1a86d555'
+                '1b2fc68d1c6e9d8011958ef4b9c2a3a55d0d3c882e6ad7f9f0f3c6156'
+                '8f78d0706b10a26f23b4f197c322b825002284a0aca91807bba98ece9'
+                '12b80e10cdf180cf99a35f210c1655fbfdd74f13b1b5046591f840387'
+                '3d12239834dd6c4eceb42bf7482e1794a1601357b629ddfa971f2ed27'
+                '3b146ec1ca06d0adf55dd91d65c37297bda78c6d210c0bc26e558302',
+                16
+            )
+        ),
+        y=int(
+            '6b32e31ab9031dc4dd0b5039a78d07826687ab087ae6de4736f5b0434e125'
+            '3092e8a0b231f9c87f3fc8a4cb5634eb194bf1b638b7a7889620ce6711567'
+            'e36aa36cda4604cfaa601a45918371d4ccf68d8b10a50a0460eb1dc0fff62'
+            'ef5e6ee4d473e18ea4a66c196fb7e677a49b48241a0b4a97128eff30fa437'
+            '050501a584f8771e7280d26d5af30784039159c11ebfea10b692fd0a58215'
+            'eeb18bff117e13f08db792ed4151a218e4bed8dddfb0793225bd1e9773505'
+            '166f4bd8cedbb286ea28232972da7bae836ba97329ba6b0a36508e50a52a7'
+            '675e476d4d4137eae13f22a9d2fefde708ba8f34bf336c6e76331761e4b06'
+            '17633fe7ec3f23672fb19d27', 16
+        )
+    ),
+    x=int(
+        '405772da6e90d809e77d5de796562a2dd4dfd10ef00a83a3aba6bd818a0348a1',
+        16
+    )
+)
+
+DSA_KEY_3072 = DSAPrivateNumbers(
+    public_numbers=DSAPublicNumbers(
+        parameter_numbers=DSAParameterNumbers(
+            p=int(
+                'f335666dd1339165af8b9a5e3835adfe15c158e4c3c7bd53132e7d582'
+                '8c352f593a9a787760ce34b789879941f2f01f02319f6ae0b756f1a84'
+                '2ba54c85612ed632ee2d79ef17f06b77c641b7b080aff52a03fc2462e'
+                '80abc64d223723c236deeb7d201078ec01ca1fbc1763139e25099a84e'
+                'c389159c409792080736bd7caa816b92edf23f2c351f90074aa5ea265'
+                '1b372f8b58a0a65554db2561d706a63685000ac576b7e4562e262a142'
+                '85a9c6370b290e4eb7757527d80b6c0fd5df831d36f3d1d35f12ab060'
+                '548de1605fd15f7c7aafed688b146a02c945156e284f5b71282045aba'
+                '9844d48b5df2e9e7a5887121eae7d7b01db7cdf6ff917cd8eb50c6bf1'
+                'd54f90cce1a491a9c74fea88f7e7230b047d16b5a6027881d6f154818'
+                'f06e513faf40c8814630e4e254f17a47bfe9cb519b98289935bf17673'
+                'ae4c8033504a20a898d0032ee402b72d5986322f3bdfb27400561f747'
+                '6cd715eaabb7338b854e51fc2fa026a5a579b6dcea1b1c0559c13d3c1'
+                '136f303f4b4d25ad5b692229957', 16
+            ),
+            q=int(
+                'd3eba6521240694015ef94412e08bf3cf8d635a455a398d6f210f6169'
+                '041653b', 16
+            ),
+            g=int(
+                'ce84b30ddf290a9f787a7c2f1ce92c1cbf4ef400e3cd7ce4978db2104'
+                'd7394b493c18332c64cec906a71c3778bd93341165dee8e6cd4ca6f13'
+                'afff531191194ada55ecf01ff94d6cf7c4768b82dd29cd131aaf202ae'
+                'fd40e564375285c01f3220af4d70b96f1395420d778228f1461f5d0b8'
+                'e47357e87b1fe3286223b553e3fc9928f16ae3067ded6721bedf1d1a0'
+                '1bfd22b9ae85fce77820d88cdf50a6bde20668ad77a707d1c60fcc5d5'
+                '1c9de488610d0285eb8ff721ff141f93a9fb23c1d1f7654c07c46e588'
+                '36d1652828f71057b8aff0b0778ef2ca934ea9d0f37daddade2d823a4'
+                'd8e362721082e279d003b575ee59fd050d105dfd71cd63154efe431a0'
+                '869178d9811f4f231dc5dcf3b0ec0f2b0f9896c32ec6c7ee7d60aa971'
+                '09e09224907328d4e6acd10117e45774406c4c947da8020649c3168f6'
+                '90e0bd6e91ac67074d1d436b58ae374523deaf6c93c1e6920db4a080b'
+                '744804bb073cecfe83fa9398cf150afa286dc7eb7949750cf5001ce10'
+                '4e9187f7e16859afa8fd0d775ae', 16
+            )
+        ),
+        y=int(
+            '814824e435e1e6f38daa239aad6dad21033afce6a3ebd35c1359348a0f241'
+            '8871968c2babfc2baf47742148828f8612183178f126504da73566b6bab33'
+            'ba1f124c15aa461555c2451d86c94ee21c3e3fc24c55527e01b1f03adcdd8'
+            'ec5cb08082803a7b6a829c3e99eeb332a2cf5c035b0ce0078d3d414d31fa4'
+            '7e9726be2989b8d06da2e6cd363f5a7d1515e3f4925e0b32adeae3025cc5a'
+            '996f6fd27494ea408763de48f3bb39f6a06514b019899b312ec570851637b'
+            '8865cff3a52bf5d54ad5a19e6e400a2d33251055d0a440b50d53f4791391d'
+            'c754ad02b9eab74c46b4903f9d76f824339914db108057af7cde657d41766'
+            'a99991ac8787694f4185d6f91d7627048f827b405ec67bf2fe56141c4c581'
+            'd8c317333624e073e5879a82437cb0c7b435c0ce434e15965db1315d64895'
+            '991e6bbe7dac040c42052408bbc53423fd31098248a58f8a67da3a39895cd'
+            '0cc927515d044c1e3cb6a3259c3d0da354cce89ea3552c59609db10ee9899'
+            '86527436af21d9485ddf25f90f7dff6d2bae', 16
+        )
+    ),
+    x=int(
+        'b2764c46113983777d3e7e97589f1303806d14ad9f2f1ef033097de954b17706',
+        16
+    )
+)
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/fixtures_rsa.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/fixtures_rsa.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/fixtures_rsa.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/fixtures_rsa.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,531 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+from cryptography.hazmat.primitives.asymmetric.rsa import (
+    RSAPrivateNumbers, RSAPublicNumbers
+)
+
+
+RSA_KEY_512 = RSAPrivateNumbers(
+    p=int(
+        "d57846898d5c0de249c08467586cb458fa9bc417cdf297f73cfc52281b787cd9", 16
+    ),
+    q=int(
+        "d10f71229e87e010eb363db6a85fd07df72d985b73c42786191f2ce9134afb2d", 16
+    ),
+    d=int(
+        "272869352cacf9c866c4e107acc95d4c608ca91460a93d28588d51cfccc07f449"
+        "18bbe7660f9f16adc2b4ed36ca310ef3d63b79bd447456e3505736a45a6ed21", 16
+    ),
+    dmp1=int(
+        "addff2ec7564c6b64bc670d250b6f24b0b8db6b2810099813b7e7658cecf5c39", 16
+    ),
+    dmq1=int(
+        "463ae9c6b77aedcac1397781e50e4afc060d4b216dc2778494ebe42a6850c81", 16
+    ),
+    iqmp=int(
+        "54deef8548f65cad1d411527a32dcb8e712d3e128e4e0ff118663fae82a758f4", 16
+    ),
+    public_numbers=RSAPublicNumbers(
+        e=65537,
+        n=int(
+            "ae5411f963c50e3267fafcf76381c8b1e5f7b741fdb2a544bcf48bd607b10c991"
+            "90caeb8011dc22cf83d921da55ec32bd05cac3ee02ca5e1dbef93952850b525",
+            16
+        ),
+    )
+)
+
+RSA_KEY_512_ALT = RSAPrivateNumbers(
+    p=int(
+        "febe19c29a0b50fefa4f7b1832f84df1caf9be8242da25c9d689e18226e67ce5",
+        16),
+    q=int(
+        "eb616c639dd999feda26517e1c77b6878f363fe828c4e6670ec1787f28b1e731",
+        16),
+    d=int(
+        "80edecfde704a806445a4cc782b85d3f36f17558f385654ea767f006470fdfcbda5e2"
+        "206839289d3f419b4e4fb8e1acee1b4fb9c591f69b64ec83937f5829241", 16),
+    dmp1=int(
+        "7f4fa06e2a3077a54691cc5216bf13ad40a4b9fa3dd0ea4bca259487484baea5",
+        16),
+    dmq1=int(
+        "35eaa70d5a8711c352ed1c15ab27b0e3f46614d575214535ae279b166597fac1",
+        16),
+    iqmp=int(
+        "cc1f272de6846851ec80cb89a02dbac78f44b47bc08f53b67b4651a3acde8b19",
+        16),
+    public_numbers=RSAPublicNumbers(
+        e=65537,
+        n=int(
+            "ea397388b999ef0f7e7416fa000367efd9a0ba0deddd3f8160d1c36d62267f210"
+            "fbd9c97abeb6654450ff03e7601b8caa6c6f4cba18f0b52c179d17e8f258ad5",
+            16),
+    )
+)
+
+RSA_KEY_522 = RSAPrivateNumbers(
+    p=int(
+        "1a8aab9a069f92b52fdf05824f2846223dc27adfc806716a247a77d4c36885e4bf",
+        16),
+    q=int(
+        "19e8d620d177ec54cdb733bb1915e72ef644b1202b889ceb524613efa49c07eb4f",
+        16),
+    d=int(
+        "10b8a7c0a92c1ae2d678097d69db3bfa966b541fb857468291d48d1b52397ea2bac0d"
+        "4370c159015c7219e3806a01bbafaffdd46f86e3da1e2d1fe80a0369ccd745", 16),
+    dmp1=int(
+        "3eb6277f66e6e2dcf89f1b8529431f730839dbd9a3e49555159bc8470eee886e5",
+        16),
+    dmq1=int(
+        "184b4d74aa54c361e51eb23fee4eae5e4786b37b11b6e0447af9c0b9c4e4953c5b",
+        16),
+    iqmp=int(
+        "f80e9ab4fa7b35d0d232ef51c4736d1f2dcf2c7b1dd8716211b1bf1337e74f8ae",
+        16),
+    public_numbers=RSAPublicNumbers(
+        e=65537,
+        n=int(
+            "2afaea0e0bb6fca037da7d190b5270a6c665bc18e7a456f7e69beaac4433db748"
+            "ba99acdd14697e453bca596eb35b47f2d48f1f85ef08ce5109dad557a9cf85ebf"
+            "1", 16),
+    ),
+)
+
+RSA_KEY_599 = RSAPrivateNumbers(
+    p=int(
+        "cf95d20be0c7af69f4b3d909f65d858c26d1a7ef34da8e3977f4fa230580e58814b54"
+        "24be99", 16),
+    q=int(
+        "6052be4b28debd4265fe12ace5aa4a0c4eb8d63ff8853c66824b35622161eb48a3bc8"
+        "c3ada5", 16),
+    d=int(
+        "69d9adc465e61585d3142d7cc8dd30605e8d1cbbf31009bc2cd5538dc40528d5d68ee"
+        "fe6a42d23674b6ec76e192351bf368c8968f0392110bf1c2825dbcff071270b80adcc"
+        "fa1d19d00a1", 16),
+    dmp1=int(
+        "a86d10edde456687fba968b1f298d2e07226adb1221b2a466a93f3d83280f0bb46c20"
+        "2b6811", 16),
+    dmq1=int(
+        "40d570e08611e6b1da94b95d46f8e7fe80be48f7a5ff8838375b08039514a399b11c2"
+        "80735", 16),
+    iqmp=int(
+        "cd051cb0ea68b88765c041262ace2ec4db11dab14afd192742e34d5da3328637fabdf"
+        "bae26e", 16),
+    public_numbers=RSAPublicNumbers(
+        e=65537,
+        n=int(
+            "4e1b470fe00642426f3808e74c959632dd67855a4c503c5b7876ccf4dc7f6a1a4"
+            "9107b90d26daf0a7879a6858218345fbc6e59f01cd095ca5647c27c25265e6c47"
+            "4fea89537191c7073d9d", 16),
+    )
+)
+
+RSA_KEY_745 = RSAPrivateNumbers(
+    p=int(
+        "1c5a0cfe9a86debd19eca33ba961f15bc598aa7983a545ce775b933afc89eb51bcf90"
+        "836257fdd060d4b383240241d", 16
+    ),
+    q=int(
+        "fb2634f657f82ee6b70553382c4e2ed26b947c97ce2f0016f1b282cf2998184ad0527"
+        "a9eead826dd95fe06b57a025", 16
+    ),
+    d=int(
+        "402f30f976bc07d15ff0779abff127b20a8b6b1d0024cc2ad8b6762d38f174f81e792"
+        "3b49d80bdbdd80d9675cbc7b2793ec199a0430eb5c84604dacfdb29259ae6a1a44676"
+        "22f0b23d4cb0f5cb1db4b8173c8d9d3e57a74dbd200d2141", 16),
+    dmp1=int(
+        "e5e95b7751a6649f199be21bef7a51c9e49821d945b6fc5f538b4a670d8762c375b00"
+        "8e70f31d52b3ea2bd14c3101", 16),
+    dmq1=int(
+        "12b85d5843645f72990fcf8d2f58408b34b3a3b9d9078dd527fceb5d2fb7839008092"
+        "dd4aca2a1fb00542801dcef5", 16),
+    iqmp=int(
+        "5672740d947f621fc7969e3a44ec26736f3f819863d330e63e9409e139d20753551ac"
+        "c16544dd2bdadb9dee917440", 16),
+    public_numbers=RSAPublicNumbers(
+        e=65537,
+        n=int(
+            "1bd085f92237774d34013b477ceebbb2f2feca71118db9b7429341477947e7b1d"
+            "04e8c43ede3c52bb25781af58d4ff81289f301eac62dc3bcd7dafd7a4d5304e9f"
+            "308e766952fbf2b62373e66611fa53189987dbef9f7243dcbbeb25831", 16),
+    )
+)
+
+RSA_KEY_768 = RSAPrivateNumbers(
+    p=int(
+        "f80c0061b607f93206b68e208906498d68c6e396faf457150cf975c8f849848465869"
+        "7ecd402313397088044c4c2071b", 16),
+    q=int(
+        "e5b5dbecc93c6d306fc14e6aa9737f9be2728bc1a326a8713d2849b34c1cb54c63468"
+        "3a68abb1d345dbf15a3c492cf55", 16),
+    d=int(
+        "d44601442255ffa331212c60385b5e898555c75c0272632ff42d57c4b16ca97dbca9f"
+        "d6d99cd2c9fd298df155ed5141b4be06c651934076133331d4564d73faed7ce98e283"
+        "2f7ce3949bc183be7e7ca34f6dd04a9098b6c73649394b0a76c541", 16),
+    dmp1=int(
+        "a5763406fa0b65929661ce7b2b8c73220e43a5ebbfe99ff15ddf464fd238105ad4f2a"
+        "c83818518d70627d8908703bb03", 16),
+    dmq1=int(
+        "cb467a9ef899a39a685aecd4d0ad27b0bfdc53b68075363c373d8eb2bed8eccaf3533"
+        "42f4db735a9e087b7539c21ba9d", 16),
+    iqmp=int(
+        "5fe86bd3aee0c4d09ef11e0530a78a4534c9b833422813b5c934a450c8e564d8097a0"
+        "6fd74f1ebe2d5573782093f587a", 16),
+    public_numbers=RSAPublicNumbers(
+        e=65537,
+        n=int(
+            "de92f1eb5f4abf426b6cac9dd1e9bf57132a4988b4ed3f8aecc15e251028bd6df"
+            "46eb97c711624af7db15e6430894d1b640c13929329241ee094f5a4fe1a20bc9b"
+            "75232320a72bc567207ec54d6b48dccb19737cf63acc1021abb337f19130f7",
+            16),
+    )
+)
+
+RSA_KEY_1024 = RSAPrivateNumbers(
+    p=int(
+        "ea4d9d9a1a068be44b9a5f8f6de0512b2c5ba1fb804a4655babba688e6e890b347c1a"
+        "7426685a929337f513ae4256f0b7e5022d642237f960c5b24b96bee8e51", 16),
+    q=int(
+        "cffb33e400d6f08b410d69deb18a85cf0ed88fcca9f32d6f2f66c62143d49aff92c11"
+        "4de937d4f1f62d4635ee89af99ce86d38a2b05310f3857c7b5d586ac8f9", 16),
+    d=int(
+        "3d12d46d04ce942fb99be7bf30587b8cd3e21d75a2720e7bda1b867f1d418d91d8b9f"
+        "e1c00181fdde94f2faf33b4e6f800a1b3ae3b972ccb6d5079dcb6c794070ac8306d59"
+        "c00b58b7a9a81122a6b055832de7c72334a07494d8e7c9fbeed2cc37e011d9e6bfc6e"
+        "9bcddbef7f0f5771d9cf82cd4b268c97ec684575c24b6c881", 16),
+    dmp1=int(
+        "470f2b11257b7ec9ca34136f487f939e6861920ad8a9ae132a02e74af5dceaa5b4c98"
+        "2949ccb44b67e2bcad2f58674db237fe250e0d62b47b28fa1dfaa603b41", 16),
+    dmq1=int(
+        "c616e8317d6b3ae8272973709b80e8397256697ff14ea03389de454f619f99915a617"
+        "45319fefbe154ec1d49441a772c2f63f7d15c478199afc60469bfd0d561", 16),
+    iqmp=int(
+        "d15e7c9ad357dfcd5dbdc8427680daf1006761bcfba93a7f86589ad88832a8d564b1c"
+        "d4291a658c96fbaea7ca588795820902d85caebd49c2d731e3fe0243130", 16),
+    public_numbers=RSAPublicNumbers(
+        e=65537,
+        n=int(
+            "be5aac07456d990133ebce69c06b48845b972ab1ad9f134bc5683c6b5489b5119"
+            "ede07be3bed0e355d48e0dfab1e4fb5187adf42d7d3fb0401c082acb8481bf17f"
+            "0e871f8877be04c3a1197d40aa260e2e0c48ed3fd2b93dc3fc0867591f67f3cd6"
+            "0a77adee1d68a8c3730a5702485f6ac9ede7f0fd2918e037ee4cc1fc1b4c9",
+            16),
+    )
+)
+
+RSA_KEY_1025 = RSAPrivateNumbers(
+    p=int(
+        "18e9bfb7071725da04d31c103fa3563648c69def43a204989214eb57b0c8b299f9ef3"
+        "5dda79a62d8d67fd2a9b69fbd8d0490aa2edc1e111a2b8eb7c737bb691a5", 16),
+    q=int(
+        "d8eccaeeb95815f3079d13685f3f72ca2bf2550b349518049421375df88ca9bbb4ba8"
+        "cb0e3502203c9eeae174112509153445d251313e4711a102818c66fcbb7", 16),
+    d=int(
+        "fe9ac54910b8b1bc948a03511c54cab206a1d36d50d591124109a48abb7480977ccb0"
+        "47b4d4f1ce7b0805df2d4fa3fe425f49b78535a11f4b87a4eba0638b3340c23d4e6b2"
+        "1ecebe9d5364ea6ead2d47b27836019e6ecb407000a50dc95a8614c9d0031a6e3a524"
+        "d2345cfb76e15c1f69d5ba35bdfb6ec63bcb115a757ef79d9", 16),
+    dmp1=int(
+        "18537e81006a68ea76d590cc88e73bd26bc38d09c977959748e5265c0ce21c0b5fd26"
+        "53d975f97ef759b809f791487a8fff1264bf561627fb4527a3f0bbb72c85", 16),
+    dmq1=int(
+        "c807eac5a1f1e1239f04b04dd16eff9a00565127a91046fa89e1eb5d6301cace85447"
+        "4d1f47b0332bd35b4214b66e9166953241538f761f30d969272ee214f17", 16),
+    iqmp=int(
+        "133aa74dd41fe70fa244f07d0c4091a22f8c8f0134fe6aea9ec8b55383b758fefe358"
+        "2beec36eca91715eee7d21931f24fa9e97e8e3a50f9cd0f731574a5eafcc", 16),
+    public_numbers=RSAPublicNumbers(
+        e=65537,
+        n=int(
+            "151c44fed756370fb2d4a0e6ec7dcac84068ca459b6aaf22daf902dca72c77563"
+            "bf276fe3523f38f5ddaf3ea9aa88486a9d8760ff732489075862bee0e599de5c5"
+            "f509b4519f4f446521bad15cd279a498fe1e89107ce0d237e3103d7c5eb801666"
+            "42e2924b152aebff97b71fdd2d68ebb45034cc784e2e822ff6d1edf98af3f3",
+            16),
+    )
+)
+
+RSA_KEY_1026 = RSAPrivateNumbers(
+    p=int(
+        "1fcbfb8719c5bdb5fe3eb0937c76bb096e750b9442dfe31d6a877a13aed2a6a4e9f79"
+        "40f815f1c307dd6bc2b4b207bb6fe5be3a15bd2875a957492ce197cdedb1", 16),
+    q=int(
+        "1f704a0f6b8966dd52582fdc08227dd3dbaeaa781918b41144b692711091b4ca4eb62"
+        "985c3513853828ce8739001dfba9a9a7f1a23cbcaf74280be925e2e7b50d", 16),
+    d=int(
+        "c67975e35a1d0d0b3ebfca736262cf91990cb31cf4ac473c0c816f3bc2720bcba2475"
+        "e8d0de8535d257816c0fc53afc1b597eada8b229069d6ef2792fc23f59ffb4dc6c3d9"
+        "0a3c462082025a4cba7561296dd3d8870c4440d779406f00879afe2c681e7f5ee055e"
+        "ff829e6e55883ec20830c72300762e6e3a333d94b4dbe4501", 16),
+    dmp1=int(
+        "314730ca7066c55d086a9fbdf3670ef7cef816b9efea8b514b882ae9d647217cf41d7"
+        "e9989269dc9893d02e315cb81f058c49043c2cac47adea58bdf5e20e841", 16),
+    dmq1=int(
+        "1da28a9d687ff7cfeebc2439240de7505a8796376968c8ec723a2b669af8ce53d9c88"
+        "af18540bd78b2da429014923fa435f22697ac60812d7ca9c17a557f394cd", 16),
+    iqmp=int(
+        "727947b57b8a36acd85180522f1b381bce5fdbd962743b3b14af98a36771a80f58ddd"
+        "62675d72a5935190da9ddc6fd6d6d5e9e9f805a2e92ab8d56b820493cdf", 16),
+    public_numbers=RSAPublicNumbers(
+        e=65537,
+        n=int(
+            "3e7a5e6483e55eb8b723f9c46732d21b0af9e06a4a1099962d67a35ee3f62e312"
+            "9cfae6ab0446da18e26f33e1d753bc1cc03585c100cf0ab5ef056695706fc8b0c"
+            "9c710cd73fe6e5beda70f515a96fabd3cc5ac49efcb2594b220ff3b603fcd927f"
+            "6a0838ef04bf52f3ed9eab801f09e5aed1613ddeb946ed0fbb02060b3a36fd",
+            16),
+    )
+)
+
+RSA_KEY_1027 = RSAPrivateNumbers(
+    p=int(
+        "30135e54cfb072c3d3eaf2000f3ed92ceafc85efc867b9d4bf5612f2978c432040093"
+        "4829f741c0f002b54af2a4433ff872b6321ef00ff1e72cba4e0ced937c7d", 16),
+    q=int(
+        "1d01a8aead6f86b78c875f18edd74214e06535d65da054aeb8e1851d6f3319b4fb6d8"
+        "6b01e07d19f8261a1ded7dc08116345509ab9790e3f13e65c037e5bb7e27", 16),
+    d=int(
+        "21cf4477df79561c7818731da9b9c88cd793f1b4b8e175bd0bfb9c0941a4dc648ecf1"
+        "6d96b35166c9ea116f4c2eb33ce1c231e641a37c25e54c17027bdec08ddafcb83642e"
+        "795a0dd133155ccc5eed03b6e745930d9ac7cfe91f9045149f33295af03a2198c660f"
+        "08d8150d13ce0e2eb02f21ac75d63b55822f77bd5be8d07619", 16),
+    dmp1=int(
+        "173fb695931e845179511c18b546b265cb79b517c135902377281bdf9f34205e1f399"
+        "4603ad63e9f6e7885ea73a929f03fa0d6bed943051ce76cddde2d89d434d", 16),
+    dmq1=int(
+        "10956b387b2621327da0c3c8ffea2af8be967ee25163222746c28115a406e632a7f12"
+        "5a9397224f1fa5c116cd3a313e5c508d31db2deb83b6e082d213e33f7fcf", 16),
+    iqmp=int(
+        "234f833949f2c0d797bc6a0e906331e17394fa8fbc8449395766d3a8d222cf6167c48"
+        "8e7fe1fe9721d3e3b699a595c8e6f063d92bd840dbc84d763b2b37002109", 16),
+    public_numbers=RSAPublicNumbers(
+        e=65537,
+        n=int(
+            "57281707d7f9b1369c117911758980e32c05b133ac52c225bcf68b79157ff47ea"
+            "0a5ae9f579ef1fd7e42937f921eb3123c4a045cc47a2159fbbf904783e654954c"
+            "42294c30a95c15db7c7b91f136244e548f62474b137087346c5522e54f226f49d"
+            "6c93bc58cb39972e41bde452bb3ae9d60eb93e5e1ce91d222138d9890c7d0b",
+            16),
+    )
+)
+
+RSA_KEY_1028 = RSAPrivateNumbers(
+    p=int(
+        "359d17378fae8e9160097daee78a206bd52efe1b757c12a6da8026cc4fc4bb2620f12"
+        "b8254f4db6aed8228be8ee3e5a27ec7d31048602f01edb00befd209e8c75", 16),
+    q=int(
+        "33a2e70b93d397c46e63b273dcd3dcfa64291342a6ce896e1ec8f1c0edc44106550f3"
+        "c06e7d3ca6ea29eccf3f6ab5ac6235c265313d6ea8e8767e6a343f616581", 16),
+    d=int(
+        "880640088d331aa5c0f4cf2887809a420a2bc086e671e6ffe4e47a8c80792c038a314"
+        "9a8e45ef9a72816ab45b36e3af6800351067a6b2751843d4232413146bb575491463a"
+        "8addd06ce3d1bcf7028ec6c5d938c545a20f0a40214b5c574ca7e840062b2b5f8ed49"
+        "4b144bb2113677c4b10519177fee1d4f5fb8a1c159b0b47c01", 16),
+    dmp1=int(
+        "75f8c52dad2c1cea26b8bba63236ee4059489e3d2db766136098bcc6b67fde8f77cd3"
+        "640035107bfb1ffc6480983cfb84fe0c3be008424ebc968a7db7e01f005", 16),
+    dmq1=int(
+        "3893c59469e4ede5cd0e6ff9837ca023ba9b46ff40c60ccf1bec10f7d38db5b1ba817"
+        "6c41a3f750ec4203b711455aca06d1e0adffc5cffa42bb92c7cb77a6c01", 16),
+    iqmp=int(
+        "ad32aafae3c962ac25459856dc8ef1f733c3df697eced29773677f435d186cf759d1a"
+        "5563dd421ec47b4d7e7f12f29647c615166d9c43fc49001b29089344f65", 16),
+    public_numbers=RSAPublicNumbers(
+        e=65537,
+        n=int(
+            "ad0696bef71597eb3a88e135d83c596930cac73868fbd7e6b2d64f34eea5c28cc"
+            "e3510c68073954d3ba4deb38643e7a820a4cf06e75f7f82eca545d412bd637819"
+            "45c28d406e95a6cced5ae924a8bfa4f3def3e0250d91246c269ec40c89c93a85a"
+            "cd3770ba4d2e774732f43abe94394de43fb57f93ca25f7a59d75d400a3eff5",
+            16),
+    )
+)
+
+RSA_KEY_1029 = RSAPrivateNumbers(
+    p=int(
+        "66f33e513c0b6b6adbf041d037d9b1f0ebf8de52812a3ac397a963d3f71ba64b3ad04"
+        "e4d4b5e377e6fa22febcac292c907dc8dcfe64c807fd9a7e3a698850d983", 16),
+    q=int(
+        "3b47a89a19022461dcc2d3c05b501ee76955e8ce3cf821beb4afa85a21a26fd7203db"
+        "deb8941f1c60ada39fd6799f6c07eb8554113f1020460ec40e93cd5f6b21", 16),
+    d=int(
+        "280c42af8b1c719821f2f6e2bf5f3dd53c81b1f3e1e7cc4fce6e2f830132da0665bde"
+        "bc1e307106b112b52ad5754867dddd028116cf4471bc14a58696b99524b1ad8f05b31"
+        "cf47256e54ab4399b6a073b2c0452441438dfddf47f3334c13c5ec86ece4d33409056"
+        "139328fafa992fb5f5156f25f9b21d3e1c37f156d963d97e41", 16),
+    dmp1=int(
+        "198c7402a4ec10944c50ab8488d7b5991c767e75eb2817bd427dff10335ae141fa2e8"
+        "7c016dc22d975cac229b9ffdf7d943ddfd3a04b8bf82e83c3b32c5698b11", 16),
+    dmq1=int(
+        "15fd30c7687b68ef7c2a30cdeb913ec56c4757c218cf9a04d995470797ee5f3a17558"
+        "fbb6d00af245d2631d893b382da48a72bc8a613024289895952ab245b0c1", 16),
+    iqmp=int(
+        "4f8fde17e84557a3f4e242d889e898545ab55a1a8e075c9bb0220173ccffe84659abe"
+        "a235104f82e32750309389d4a52af57dbb6e48d831917b6efeb190176570", 16),
+    public_numbers=RSAPublicNumbers(
+        e=65537,
+        n=int(
+            "17d6e0a09aa5b2d003e51f43b9c37ffde74688f5e3b709fd02ef375cb6b8d15e2"
+            "99a9f74981c3eeaaf947d5c2d64a1a80f5c5108a49a715c3f7be95a016b8d3300"
+            "965ead4a4df76e642d761526803e9434d4ec61b10cb50526d4dcaef02593085de"
+            "d8c331c1b27b200a45628403065efcb2c0a0ca1f75d648d40a007fbfbf2cae3",
+            16),
+    )
+)
+
+RSA_KEY_1030 = RSAPrivateNumbers(
+    p=int(
+        "6f4ac8a8172ef1154cf7f80b5e91de723c35a4c512860bfdbafcc3b994a2384bf7796"
+        "3a2dd0480c7e04d5d418629651a0de8979add6f47b23da14c27a682b69c9", 16),
+    q=int(
+        "65a9f83e07dea5b633e036a9dccfb32c46bf53c81040a19c574c3680838fc6d28bde9"
+        "55c0ff18b30481d4ab52a9f5e9f835459b1348bbb563ad90b15a682fadb3", 16),
+    d=int(
+        "290db707b3e1a96445ae8ea93af55a9f211a54ebe52995c2eb28085d1e3f09c986e73"
+        "a00010c8e4785786eaaa5c85b98444bd93b585d0c24363ccc22c482e150a3fd900176"
+        "86968e4fa20423ae72823b0049defceccb39bb34aa4ef64e6b14463b76d6a871c859e"
+        "37285455b94b8e1527d1525b1682ac6f7c8fd79d576c55318c1", 16),
+    dmp1=int(
+        "23f7fa84010225dea98297032dac5d45745a2e07976605681acfe87e0920a8ab3caf5"
+        "9d9602f3d63dc0584f75161fd8fff20c626c21c5e02a85282276a74628a9", 16),
+    dmq1=int(
+        "18ebb657765464a8aa44bf019a882b72a2110a77934c54915f70e6375088b10331982"
+        "962bce1c7edd8ef9d3d95aa2566d2a99da6ebab890b95375919408d00f33", 16),
+    iqmp=int(
+        "3d59d208743c74054151002d77dcdfc55af3d41357e89af88d7eef2767be54c290255"
+        "9258d85cf2a1083c035a33e65a1ca46dc8b706847c1c6434cef7b71a9dae", 16),
+    public_numbers=RSAPublicNumbers(
+        e=65537,
+        n=int(
+            "2c326574320818a6a8cb6b3328e2d6c1ba2a3f09b6eb2bc543c03ab18eb5efdaa"
+            "8fcdbb6b4e12168304f587999f9d96a421fc80cb933a490df85d25883e6a88750"
+            "d6bd8b3d4117251eee8f45e70e6daac7dbbd92a9103c623a09355cf00e3f16168"
+            "e38b9c4cb5b368deabbed8df466bc6835eaba959bc1c2f4ec32a09840becc8b",
+            16),
+    )
+)
+
+RSA_KEY_1031 = RSAPrivateNumbers(
+    p=int(
+        "c0958c08e50137db989fb7cc93abf1984543e2f955d4f43fb2967f40105e79274c852"
+        "293fa06ce63ca8436155e475ed6d1f73fea4c8e2516cc79153e3dc83e897", 16),
+    q=int(
+        "78cae354ea5d6862e5d71d20273b7cddb8cdfab25478fe865180676b04250685c4d03"
+        "30c216574f7876a7b12dfe69f1661d3b0cea6c2c0dcfb84050f817afc28d", 16),
+    d=int(
+        "1d55cc02b17a5d25bfb39f2bc58389004d0d7255051507f75ef347cdf5519d1a00f4b"
+        "d235ce4171bfab7bdb7a6dcfae1cf41433fb7da5923cc84f15a675c0b83492c95dd99"
+        "a9fc157aea352ffdcbb5d59dbc3662171d5838d69f130678ee27841a79ef64f679ce9"
+        "3821fa69c03f502244c04b737edad8967def8022a144feaab29", 16),
+    dmp1=int(
+        "5b1c2504ec3a984f86b4414342b5bcf59a0754f13adf25b2a0edbc43f5ba8c3cc061d"
+        "80b03e5866d059968f0d10a98deaeb4f7830436d76b22cf41f2914e13eff", 16),
+    dmq1=int(
+        "6c361e1819691ab5d67fb2a8f65c958d301cdf24d90617c68ec7005edfb4a7b638cde"
+        "79d4b61cfba5c86e8c0ccf296bc7f611cb8d4ae0e072a0f68552ec2d5995", 16),
+    iqmp=int(
+        "b7d61945fdc8b92e075b15554bab507fa8a18edd0a18da373ec6c766c71eece61136a"
+        "84b90b6d01741d40458bfad17a9bee9d4a8ed2f6e270782dc3bf5d58b56e", 16),
+    public_numbers=RSAPublicNumbers(
+        e=65537,
+        n=int(
+            "5adebaa926ea11fb635879487fdd53dcfbb391a11ac7279bb3b4877c9b811370a"
+            "9f73da0690581691626d8a7cf5d972cced9c2091ccf999024b23b4e6dc6d99f80"
+            "a454737dec0caffaebe4a3fac250ed02079267c8f39620b5ae3e125ca35338522"
+            "dc9353ecac19cb2fe3b9e3a9291619dbb1ea3a7c388e9ee6469fbf5fb22892b",
+            16),
+    )
+)
+
+RSA_KEY_1536 = RSAPrivateNumbers(
+    p=int(
+        "f1a65fa4e2aa6e7e2b560251e8a4cd65b625ad9f04f6571785782d1c213d91c961637"
+        "0c572f2783caf2899f7fb690cf99a0184257fbd4b071b212c88fb348279a5387e61f1"
+        "17e9c62980c45ea863fa9292087c0f66ecdcde6443d5a37268bf71", 16),
+    q=int(
+        "e54c2cbc3839b1da6ae6fea45038d986d6f523a3ae76051ba20583aab711ea5965cf5"
+        "3cf54128cc9573f7460bba0fd6758a57aaf240c391790fb38ab473d83ef735510c53d"
+        "1d10c31782e8fd7da42615e33565745c30a5e6ceb2a3ae0666cc35", 16),
+    d=int(
+        "7bcad87e23da2cb2a8c328883fabce06e1f8e9b776c8bf253ad9884e6200e3bd9bd3b"
+        "a2cbe87d3854527bf005ba5d878c5b0fa20cfb0a2a42884ae95ca12bf7304285e9214"
+        "5e992f7006c7c0ae839ad550da495b143bec0f4806c7f44caed45f3ccc6dc44cfaf30"
+        "7abdb757e3d28e41c2d21366835c0a41e50a95af490ac03af061d2feb36ac0afb87be"
+        "a13fb0f0c5a410727ebedb286c77f9469473fae27ef2c836da6071ef7efc1647f1233"
+        "4009a89eecb09a8287abc8c2afd1ddd9a1b0641", 16),
+    dmp1=int(
+        "a845366cd6f9df1f34861bef7594ed025aa83a12759e245f58adaa9bdff9c3befb760"
+        "75d3701e90038e888eec9bf092df63400152cb25fc07effc6c74c45f0654ccbde15cd"
+        "90dd5504298a946fa5cf22a956072da27a6602e6c6e5c97f2db9c1", 16),
+    dmq1=int(
+        "28b0c1e78cdac03310717992d321a3888830ec6829978c048156152d805b4f8919c61"
+        "70b5dd204e5ddf3c6c53bc6aff15d0bd09faff7f351b94abb9db980b31f150a6d7573"
+        "08eb66938f89a5225cb4dd817a824c89e7a0293b58fc2eefb7e259", 16),
+    iqmp=int(
+        "6c1536c0e16e42a094b6caaf50231ba81916871497d73dcbbbd4bdeb9e60cae0413b3"
+        "8143b5d680275b29ed7769fe5577e4f9b3647ddb064941120914526d64d80016d2eb7"
+        "dc362da7c569623157f3d7cff8347f11494bf5c048d77e28d3f515", 16),
+    public_numbers=RSAPublicNumbers(
+        e=65537,
+        n=int(
+            "d871bb2d27672e54fc62c4680148cbdf848438da804e2c48b5a9c9f9daf6cc6e8"
+            "ea7d2296f25064537a9a542aef3dd449ea75774238d4da02c353d1bee70013dcc"
+            "c248ceef4050160705c188043c8559bf6dbfb6c4bb382eda4e9547575a8227d5b"
+            "3c0a7088391364cf9f018d8bea053b226ec65e8cdbeaf48a071d0074860a734b1"
+            "cb7d2146d43014b20776dea42f7853a54690e6cbbf3331a9f43763cfe2a51c329"
+            "3bea3b2eebec0d8e43eb317a443afe541107d886e5243c096091543ae65", 16),
+    )
+)
+
+RSA_KEY_2048 = RSAPrivateNumbers(
+    p=int(
+        "e14202e58c5f7446648d75e5dc465781f661f6b73000c080368afcfb21377f4ef19da"
+        "845d4ef9bc6b151f6d9f34629103f2e57615f9ba0a3a2fbb035069e1d63b4bb0e78ad"
+        "dad1ec3c6f87e25c877a1c4c1972098e09158ef7b9bc163852a18d44a70b7b31a03dc"
+        "2614fd9ab7bf002cba79054544af3bfbdb6aed06c7b24e6ab", 16),
+    q=int(
+        "dbe2bea1ff92599bd19f9d045d6ce62250c05cfeac5117f3cf3e626cb696e3d886379"
+        "557d5a57b7476f9cf886accfd40508a805fe3b45a78e1a8a125e516cda91640ee6398"
+        "ec5a39d3e6b177ef12ab00d07907a17640e4ca454fd8487da3c4ffa0d5c2a5edb1221"
+        "1c8e33c7ee9fa6753771fd111ec04b8317f86693eb2928c89", 16),
+    d=int(
+        "aef17f80f2653bc30539f26dd4c82ed6abc1d1b53bc0abcdbee47e9a8ab433abde865"
+        "9fcfae1244d22de6ad333c95aee7d47f30b6815065ac3322744d3ea75058002cd1b29"
+        "3141ee2a6dc682342432707080071bd2131d6262cab07871c28aa5238b87173fb78c3"
+        "7f9c7bcd18c12e8971bb77fd9fa3e0792fec18d8d9bed0b03ba02b263606f24dbace1"
+        "c8263ce2802a769a090e993fd49abc50c3d3c78c29bee2de0c98055d2f102f1c5684b"
+        "8dddee611d5205392d8e8dd61a15bf44680972a87f040a611a149271eeb2573f8bf6f"
+        "627dfa70e77def2ee6584914fa0290e041349ea0999cdff3e493365885b906cbcf195"
+        "843345809a85098cca90fea014a21", 16),
+    dmp1=int(
+        "9ba56522ffcfa5244eae805c87cc0303461f82be29691b9a7c15a5a050df6c143c575"
+        "7c288d3d7ab7f32c782e9d9fcddc10a604e6425c0e5d0e46069035d95a923646d276d"
+        "d9d95b8696fa29ab0de18e53f6f119310f8dd9efca62f0679291166fed8cbd5f18fe1"
+        "3a5f1ead1d71d8c90f40382818c18c8d069be793dbc094f69", 16),
+    dmq1=int(
+        "a8d4a0aaa2212ccc875796a81353da1fdf00d46676c88d2b96a4bfcdd924622d8e607"
+        "f3ac1c01dda7ebfb0a97dd7875c2a7b2db6728fb827b89c519f5716fb3228f4121647"
+        "04b30253c17de2289e9cce3343baa82eb404f789e094a094577a9b0c5314f1725fdf5"
+        "8e87611ad20da331bd30b8aebc7dc97d0e9a9ba8579772c9", 16),
+    iqmp=int(
+        "17bd5ef638c49440d1853acb3fa63a5aca28cb7f94ed350db7001c8445da8943866a7"
+        "0936e1ee2716c98b484e357cc054d82fbbd98d42f880695d38a1dd4eb096f629b9417"
+        "aca47e6de5da9f34e60e8a0ffd7e35be74deeef67298d94b3e0db73fc4b7a4cb360c8"
+        "9d2117a0bfd9434d37dc7c027d6b01e5295c875015510917d", 16),
+    public_numbers=RSAPublicNumbers(
+        e=65537,
+        n=int(
+            "c17afc7e77474caa5aa83036158a3ffbf7b5216851ba2230e5d6abfcc1c6cfef5"
+            "9e923ea1330bc593b73802ab608a6e4a3306523a3116ba5aa3966145174e13b6c"
+            "49e9b78062e449d72efb10fd49e91fa08b96d051e782e9f5abc5b5a6f7984827a"
+            "db8e73da00f22b2efdcdb76eab46edad98ed65662743fdc6c0e336a5d0cdbaa7d"
+            "c29e53635e24c87a5b2c4215968063cdeb68a972babbc1e3cff00fb9a80e372a4"
+            "d0c2c920d1e8cee333ce470dc2e8145adb05bf29aee1d24f141e8cc784989c587"
+            "fc6fbacd979f3f2163c1d7299b365bc72ffe2848e967aed1e48dcc515b3a50ed4"
+            "de04fd053846ca10a223b10cc841cc80fdebee44f3114c13e886af583", 16),
+    )
+)
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/__init__.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/__init__.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/__init__.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/__init__.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,5 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_3des.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_3des.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_3des.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_3des.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,205 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+"""
+Test using the NIST Test Vectors
+"""
+
+from __future__ import absolute_import, division, print_function
+
+import binascii
+import os
+
+import pytest
+
+from cryptography.hazmat.backends.interfaces import CipherBackend
+from cryptography.hazmat.primitives.ciphers import algorithms, modes
+
+from .utils import generate_encrypt_test
+from ...utils import load_nist_vectors
+
+
+@pytest.mark.supported(
+    only_if=lambda backend: backend.cipher_supported(
+        algorithms.TripleDES("\x00" * 8), modes.CBC("\x00" * 8)
+    ),
+    skip_message="Does not support TripleDES CBC",
+)
+@pytest.mark.requires_backend_interface(interface=CipherBackend)
+class TestTripleDESModeCBC(object):
+    test_KAT = generate_encrypt_test(
+        load_nist_vectors,
+        os.path.join("ciphers", "3DES", "CBC"),
+        [
+            "TCBCinvperm.rsp",
+            "TCBCpermop.rsp",
+            "TCBCsubtab.rsp",
+            "TCBCvarkey.rsp",
+            "TCBCvartext.rsp",
+        ],
+        lambda keys, **kwargs: algorithms.TripleDES(binascii.unhexlify(keys)),
+        lambda iv, **kwargs: modes.CBC(binascii.unhexlify(iv)),
+    )
+
+    test_MMT = generate_encrypt_test(
+        load_nist_vectors,
+        os.path.join("ciphers", "3DES", "CBC"),
+        [
+            "TCBCMMT1.rsp",
+            "TCBCMMT2.rsp",
+            "TCBCMMT3.rsp",
+        ],
+        lambda key1, key2, key3, **kwargs: algorithms.TripleDES(
+            binascii.unhexlify(key1 + key2 + key3)
+        ),
+        lambda iv, **kwargs: modes.CBC(binascii.unhexlify(iv)),
+    )
+
+
+@pytest.mark.supported(
+    only_if=lambda backend: backend.cipher_supported(
+        algorithms.TripleDES("\x00" * 8), modes.OFB("\x00" * 8)
+    ),
+    skip_message="Does not support TripleDES OFB",
+)
+@pytest.mark.requires_backend_interface(interface=CipherBackend)
+class TestTripleDESModeOFB(object):
+    test_KAT = generate_encrypt_test(
+        load_nist_vectors,
+        os.path.join("ciphers", "3DES", "OFB"),
+        [
+            "TOFBpermop.rsp",
+            "TOFBsubtab.rsp",
+            "TOFBvarkey.rsp",
+            "TOFBvartext.rsp",
+            "TOFBinvperm.rsp",
+        ],
+        lambda keys, **kwargs: algorithms.TripleDES(binascii.unhexlify(keys)),
+        lambda iv, **kwargs: modes.OFB(binascii.unhexlify(iv)),
+    )
+
+    test_MMT = generate_encrypt_test(
+        load_nist_vectors,
+        os.path.join("ciphers", "3DES", "OFB"),
+        [
+            "TOFBMMT1.rsp",
+            "TOFBMMT2.rsp",
+            "TOFBMMT3.rsp",
+        ],
+        lambda key1, key2, key3, **kwargs: algorithms.TripleDES(
+            binascii.unhexlify(key1 + key2 + key3)
+        ),
+        lambda iv, **kwargs: modes.OFB(binascii.unhexlify(iv)),
+    )
+
+
+@pytest.mark.supported(
+    only_if=lambda backend: backend.cipher_supported(
+        algorithms.TripleDES("\x00" * 8), modes.CFB("\x00" * 8)
+    ),
+    skip_message="Does not support TripleDES CFB",
+)
+@pytest.mark.requires_backend_interface(interface=CipherBackend)
+class TestTripleDESModeCFB(object):
+    test_KAT = generate_encrypt_test(
+        load_nist_vectors,
+        os.path.join("ciphers", "3DES", "CFB"),
+        [
+            "TCFB64invperm.rsp",
+            "TCFB64permop.rsp",
+            "TCFB64subtab.rsp",
+            "TCFB64varkey.rsp",
+            "TCFB64vartext.rsp",
+        ],
+        lambda keys, **kwargs: algorithms.TripleDES(binascii.unhexlify(keys)),
+        lambda iv, **kwargs: modes.CFB(binascii.unhexlify(iv)),
+    )
+
+    test_MMT = generate_encrypt_test(
+        load_nist_vectors,
+        os.path.join("ciphers", "3DES", "CFB"),
+        [
+            "TCFB64MMT1.rsp",
+            "TCFB64MMT2.rsp",
+            "TCFB64MMT3.rsp",
+        ],
+        lambda key1, key2, key3, **kwargs: algorithms.TripleDES(
+            binascii.unhexlify(key1 + key2 + key3)
+        ),
+        lambda iv, **kwargs: modes.CFB(binascii.unhexlify(iv)),
+    )
+
+
+@pytest.mark.supported(
+    only_if=lambda backend: backend.cipher_supported(
+        algorithms.TripleDES("\x00" * 8), modes.CFB8("\x00" * 8)
+    ),
+    skip_message="Does not support TripleDES CFB8",
+)
+@pytest.mark.requires_backend_interface(interface=CipherBackend)
+class TestTripleDESModeCFB8(object):
+    test_KAT = generate_encrypt_test(
+        load_nist_vectors,
+        os.path.join("ciphers", "3DES", "CFB"),
+        [
+            "TCFB8invperm.rsp",
+            "TCFB8permop.rsp",
+            "TCFB8subtab.rsp",
+            "TCFB8varkey.rsp",
+            "TCFB8vartext.rsp",
+        ],
+        lambda keys, **kwargs: algorithms.TripleDES(binascii.unhexlify(keys)),
+        lambda iv, **kwargs: modes.CFB8(binascii.unhexlify(iv)),
+    )
+
+    test_MMT = generate_encrypt_test(
+        load_nist_vectors,
+        os.path.join("ciphers", "3DES", "CFB"),
+        [
+            "TCFB8MMT1.rsp",
+            "TCFB8MMT2.rsp",
+            "TCFB8MMT3.rsp",
+        ],
+        lambda key1, key2, key3, **kwargs: algorithms.TripleDES(
+            binascii.unhexlify(key1 + key2 + key3)
+        ),
+        lambda iv, **kwargs: modes.CFB8(binascii.unhexlify(iv)),
+    )
+
+
+@pytest.mark.supported(
+    only_if=lambda backend: backend.cipher_supported(
+        algorithms.TripleDES("\x00" * 8), modes.ECB()
+    ),
+    skip_message="Does not support TripleDES ECB",
+)
+@pytest.mark.requires_backend_interface(interface=CipherBackend)
+class TestTripleDESModeECB(object):
+    test_KAT = generate_encrypt_test(
+        load_nist_vectors,
+        os.path.join("ciphers", "3DES", "ECB"),
+        [
+            "TECBinvperm.rsp",
+            "TECBpermop.rsp",
+            "TECBsubtab.rsp",
+            "TECBvarkey.rsp",
+            "TECBvartext.rsp",
+        ],
+        lambda keys, **kwargs: algorithms.TripleDES(binascii.unhexlify(keys)),
+        lambda **kwargs: modes.ECB(),
+    )
+
+    test_MMT = generate_encrypt_test(
+        load_nist_vectors,
+        os.path.join("ciphers", "3DES", "ECB"),
+        [
+            "TECBMMT1.rsp",
+            "TECBMMT2.rsp",
+            "TECBMMT3.rsp",
+        ],
+        lambda key1, key2, key3, **kwargs: algorithms.TripleDES(
+            binascii.unhexlify(key1 + key2 + key3)
+        ),
+        lambda **kwargs: modes.ECB(),
+    )
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_aes.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_aes.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_aes.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_aes.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,305 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import binascii
+import os
+
+import pytest
+
+from cryptography.hazmat.backends.interfaces import CipherBackend
+from cryptography.hazmat.primitives.ciphers import algorithms, base, modes
+
+from .utils import generate_aead_test, generate_encrypt_test
+from ...utils import load_nist_vectors
+
+
+@pytest.mark.supported(
+    only_if=lambda backend: backend.cipher_supported(
+        algorithms.AES("\x00" * 16), modes.CBC("\x00" * 16)
+    ),
+    skip_message="Does not support AES CBC",
+)
+@pytest.mark.requires_backend_interface(interface=CipherBackend)
+class TestAESModeCBC(object):
+    test_CBC = generate_encrypt_test(
+        load_nist_vectors,
+        os.path.join("ciphers", "AES", "CBC"),
+        [
+            "CBCGFSbox128.rsp",
+            "CBCGFSbox192.rsp",
+            "CBCGFSbox256.rsp",
+            "CBCKeySbox128.rsp",
+            "CBCKeySbox192.rsp",
+            "CBCKeySbox256.rsp",
+            "CBCVarKey128.rsp",
+            "CBCVarKey192.rsp",
+            "CBCVarKey256.rsp",
+            "CBCVarTxt128.rsp",
+            "CBCVarTxt192.rsp",
+            "CBCVarTxt256.rsp",
+            "CBCMMT128.rsp",
+            "CBCMMT192.rsp",
+            "CBCMMT256.rsp",
+        ],
+        lambda key, **kwargs: algorithms.AES(binascii.unhexlify(key)),
+        lambda iv, **kwargs: modes.CBC(binascii.unhexlify(iv)),
+    )
+
+
+@pytest.mark.supported(
+    only_if=lambda backend: backend.cipher_supported(
+        algorithms.AES("\x00" * 16), modes.ECB()
+    ),
+    skip_message="Does not support AES ECB",
+)
+@pytest.mark.requires_backend_interface(interface=CipherBackend)
+class TestAESModeECB(object):
+    test_ECB = generate_encrypt_test(
+        load_nist_vectors,
+        os.path.join("ciphers", "AES", "ECB"),
+        [
+            "ECBGFSbox128.rsp",
+            "ECBGFSbox192.rsp",
+            "ECBGFSbox256.rsp",
+            "ECBKeySbox128.rsp",
+            "ECBKeySbox192.rsp",
+            "ECBKeySbox256.rsp",
+            "ECBVarKey128.rsp",
+            "ECBVarKey192.rsp",
+            "ECBVarKey256.rsp",
+            "ECBVarTxt128.rsp",
+            "ECBVarTxt192.rsp",
+            "ECBVarTxt256.rsp",
+            "ECBMMT128.rsp",
+            "ECBMMT192.rsp",
+            "ECBMMT256.rsp",
+        ],
+        lambda key, **kwargs: algorithms.AES(binascii.unhexlify(key)),
+        lambda **kwargs: modes.ECB(),
+    )
+
+
+@pytest.mark.supported(
+    only_if=lambda backend: backend.cipher_supported(
+        algorithms.AES("\x00" * 16), modes.OFB("\x00" * 16)
+    ),
+    skip_message="Does not support AES OFB",
+)
+@pytest.mark.requires_backend_interface(interface=CipherBackend)
+class TestAESModeOFB(object):
+    test_OFB = generate_encrypt_test(
+        load_nist_vectors,
+        os.path.join("ciphers", "AES", "OFB"),
+        [
+            "OFBGFSbox128.rsp",
+            "OFBGFSbox192.rsp",
+            "OFBGFSbox256.rsp",
+            "OFBKeySbox128.rsp",
+            "OFBKeySbox192.rsp",
+            "OFBKeySbox256.rsp",
+            "OFBVarKey128.rsp",
+            "OFBVarKey192.rsp",
+            "OFBVarKey256.rsp",
+            "OFBVarTxt128.rsp",
+            "OFBVarTxt192.rsp",
+            "OFBVarTxt256.rsp",
+            "OFBMMT128.rsp",
+            "OFBMMT192.rsp",
+            "OFBMMT256.rsp",
+        ],
+        lambda key, **kwargs: algorithms.AES(binascii.unhexlify(key)),
+        lambda iv, **kwargs: modes.OFB(binascii.unhexlify(iv)),
+    )
+
+
+@pytest.mark.supported(
+    only_if=lambda backend: backend.cipher_supported(
+        algorithms.AES("\x00" * 16), modes.CFB("\x00" * 16)
+    ),
+    skip_message="Does not support AES CFB",
+)
+@pytest.mark.requires_backend_interface(interface=CipherBackend)
+class TestAESModeCFB(object):
+    test_CFB = generate_encrypt_test(
+        load_nist_vectors,
+        os.path.join("ciphers", "AES", "CFB"),
+        [
+            "CFB128GFSbox128.rsp",
+            "CFB128GFSbox192.rsp",
+            "CFB128GFSbox256.rsp",
+            "CFB128KeySbox128.rsp",
+            "CFB128KeySbox192.rsp",
+            "CFB128KeySbox256.rsp",
+            "CFB128VarKey128.rsp",
+            "CFB128VarKey192.rsp",
+            "CFB128VarKey256.rsp",
+            "CFB128VarTxt128.rsp",
+            "CFB128VarTxt192.rsp",
+            "CFB128VarTxt256.rsp",
+            "CFB128MMT128.rsp",
+            "CFB128MMT192.rsp",
+            "CFB128MMT256.rsp",
+        ],
+        lambda key, **kwargs: algorithms.AES(binascii.unhexlify(key)),
+        lambda iv, **kwargs: modes.CFB(binascii.unhexlify(iv)),
+    )
+
+
+@pytest.mark.supported(
+    only_if=lambda backend: backend.cipher_supported(
+        algorithms.AES("\x00" * 16), modes.CFB8("\x00" * 16)
+    ),
+    skip_message="Does not support AES CFB8",
+)
+@pytest.mark.requires_backend_interface(interface=CipherBackend)
+class TestAESModeCFB8(object):
+    test_CFB8 = generate_encrypt_test(
+        load_nist_vectors,
+        os.path.join("ciphers", "AES", "CFB"),
+        [
+            "CFB8GFSbox128.rsp",
+            "CFB8GFSbox192.rsp",
+            "CFB8GFSbox256.rsp",
+            "CFB8KeySbox128.rsp",
+            "CFB8KeySbox192.rsp",
+            "CFB8KeySbox256.rsp",
+            "CFB8VarKey128.rsp",
+            "CFB8VarKey192.rsp",
+            "CFB8VarKey256.rsp",
+            "CFB8VarTxt128.rsp",
+            "CFB8VarTxt192.rsp",
+            "CFB8VarTxt256.rsp",
+            "CFB8MMT128.rsp",
+            "CFB8MMT192.rsp",
+            "CFB8MMT256.rsp",
+        ],
+        lambda key, **kwargs: algorithms.AES(binascii.unhexlify(key)),
+        lambda iv, **kwargs: modes.CFB8(binascii.unhexlify(iv)),
+    )
+
+
+@pytest.mark.supported(
+    only_if=lambda backend: backend.cipher_supported(
+        algorithms.AES("\x00" * 16), modes.CTR("\x00" * 16)
+    ),
+    skip_message="Does not support AES CTR",
+)
+@pytest.mark.requires_backend_interface(interface=CipherBackend)
+class TestAESModeCTR(object):
+    test_CTR = generate_encrypt_test(
+        load_nist_vectors,
+        os.path.join("ciphers", "AES", "CTR"),
+        ["aes-128-ctr.txt", "aes-192-ctr.txt", "aes-256-ctr.txt"],
+        lambda key, **kwargs: algorithms.AES(binascii.unhexlify(key)),
+        lambda iv, **kwargs: modes.CTR(binascii.unhexlify(iv)),
+    )
+
+
+@pytest.mark.supported(
+    only_if=lambda backend: backend.cipher_supported(
+        algorithms.AES("\x00" * 16), modes.GCM("\x00" * 12)
+    ),
+    skip_message="Does not support AES GCM",
+)
+@pytest.mark.requires_backend_interface(interface=CipherBackend)
+class TestAESModeGCM(object):
+    test_GCM = generate_aead_test(
+        load_nist_vectors,
+        os.path.join("ciphers", "AES", "GCM"),
+        [
+            "gcmDecrypt128.rsp",
+            "gcmDecrypt192.rsp",
+            "gcmDecrypt256.rsp",
+            "gcmEncryptExtIV128.rsp",
+            "gcmEncryptExtIV192.rsp",
+            "gcmEncryptExtIV256.rsp",
+        ],
+        algorithms.AES,
+        modes.GCM,
+    )
+
+    def test_gcm_tag_with_only_aad(self, backend):
+        key = binascii.unhexlify(b"5211242698bed4774a090620a6ca56f3")
+        iv = binascii.unhexlify(b"b1e1349120b6e832ef976f5d")
+        aad = binascii.unhexlify(b"b6d729aab8e6416d7002b9faa794c410d8d2f193")
+        tag = binascii.unhexlify(b"0f247e7f9c2505de374006738018493b")
+
+        cipher = base.Cipher(
+            algorithms.AES(key),
+            modes.GCM(iv),
+            backend=backend
+        )
+        encryptor = cipher.encryptor()
+        encryptor.authenticate_additional_data(aad)
+        encryptor.finalize()
+        assert encryptor.tag == tag
+
+    def test_gcm_ciphertext_with_no_aad(self, backend):
+        key = binascii.unhexlify(b"e98b72a9881a84ca6b76e0f43e68647a")
+        iv = binascii.unhexlify(b"8b23299fde174053f3d652ba")
+        ct = binascii.unhexlify(b"5a3c1cf1985dbb8bed818036fdd5ab42")
+        tag = binascii.unhexlify(b"23c7ab0f952b7091cd324835043b5eb5")
+        pt = binascii.unhexlify(b"28286a321293253c3e0aa2704a278032")
+
+        cipher = base.Cipher(
+            algorithms.AES(key),
+            modes.GCM(iv),
+            backend=backend
+        )
+        encryptor = cipher.encryptor()
+        computed_ct = encryptor.update(pt) + encryptor.finalize()
+        assert computed_ct == ct
+        assert encryptor.tag == tag
+
+    def test_gcm_ciphertext_limit(self, backend):
+        encryptor = base.Cipher(
+            algorithms.AES(b"\x00" * 16),
+            modes.GCM(b"\x01" * 16),
+            backend=backend
+        ).encryptor()
+        encryptor._bytes_processed = modes.GCM._MAX_ENCRYPTED_BYTES - 16
+        encryptor.update(b"0" * 16)
+        assert (
+            encryptor._bytes_processed == modes.GCM._MAX_ENCRYPTED_BYTES
+        )
+        with pytest.raises(ValueError):
+            encryptor.update(b"0")
+
+    def test_gcm_aad_limit(self, backend):
+        encryptor = base.Cipher(
+            algorithms.AES(b"\x00" * 16),
+            modes.GCM(b"\x01" * 16),
+            backend=backend
+        ).encryptor()
+        encryptor._aad_bytes_processed = modes.GCM._MAX_AAD_BYTES - 16
+        encryptor.authenticate_additional_data(b"0" * 16)
+        assert encryptor._aad_bytes_processed == modes.GCM._MAX_AAD_BYTES
+        with pytest.raises(ValueError):
+            encryptor.authenticate_additional_data(b"0")
+
+    def test_gcm_ciphertext_increments(self, backend):
+        encryptor = base.Cipher(
+            algorithms.AES(b"\x00" * 16),
+            modes.GCM(b"\x01" * 16),
+            backend=backend
+        ).encryptor()
+        encryptor.update(b"0" * 8)
+        assert encryptor._bytes_processed == 8
+        encryptor.update(b"0" * 7)
+        assert encryptor._bytes_processed == 15
+        encryptor.update(b"0" * 18)
+        assert encryptor._bytes_processed == 33
+
+    def test_gcm_aad_increments(self, backend):
+        encryptor = base.Cipher(
+            algorithms.AES(b"\x00" * 16),
+            modes.GCM(b"\x01" * 16),
+            backend=backend
+        ).encryptor()
+        encryptor.authenticate_additional_data(b"0" * 8)
+        assert encryptor._aad_bytes_processed == 8
+        encryptor.authenticate_additional_data(b"0" * 18)
+        assert encryptor._aad_bytes_processed == 26
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_arc4.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_arc4.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_arc4.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_arc4.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,40 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import binascii
+import os
+
+import pytest
+
+from cryptography.hazmat.backends.interfaces import CipherBackend
+from cryptography.hazmat.primitives.ciphers import algorithms
+
+from .utils import generate_stream_encryption_test
+from ...utils import load_nist_vectors
+
+
+@pytest.mark.supported(
+    only_if=lambda backend: backend.cipher_supported(
+        algorithms.ARC4("\x00" * 16), None
+    ),
+    skip_message="Does not support ARC4",
+)
+@pytest.mark.requires_backend_interface(interface=CipherBackend)
+class TestARC4(object):
+    test_rfc = generate_stream_encryption_test(
+        load_nist_vectors,
+        os.path.join("ciphers", "ARC4"),
+        [
+            "rfc-6229-40.txt",
+            "rfc-6229-56.txt",
+            "rfc-6229-64.txt",
+            "rfc-6229-80.txt",
+            "rfc-6229-128.txt",
+            "rfc-6229-192.txt",
+            "rfc-6229-256.txt",
+        ],
+        lambda key, **kwargs: algorithms.ARC4(binascii.unhexlify(key)),
+    )
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_asym_utils.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_asym_utils.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_asym_utils.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_asym_utils.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,78 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import pytest
+
+from cryptography.hazmat.primitives.asymmetric.utils import (
+    decode_dss_signature, decode_rfc6979_signature,
+    encode_dss_signature, encode_rfc6979_signature
+)
+
+
+def test_deprecated_rfc6979_signature():
+    sig = pytest.deprecated_call(encode_rfc6979_signature, 1, 1)
+    assert sig == b"0\x06\x02\x01\x01\x02\x01\x01"
+    decoded = pytest.deprecated_call(decode_rfc6979_signature, sig)
+    assert decoded == (1, 1)
+
+
+def test_dss_signature():
+    sig = encode_dss_signature(1, 1)
+    assert sig == b"0\x06\x02\x01\x01\x02\x01\x01"
+    assert decode_dss_signature(sig) == (1, 1)
+
+    r_s1 = (
+        1037234182290683143945502320610861668562885151617,
+        559776156650501990899426031439030258256861634312
+    )
+    sig2 = encode_dss_signature(*r_s1)
+    assert sig2 == (
+        b'0-\x02\x15\x00\xb5\xaf0xg\xfb\x8bT9\x00\x13\xccg\x02\r\xdf\x1f,\x0b'
+        b'\x81\x02\x14b\r;"\xabP1D\x0c>5\xea\xb6\xf4\x81)\x8f\x9e\x9f\x08'
+    )
+    assert decode_dss_signature(sig2) == r_s1
+
+    sig3 = encode_dss_signature(0, 0)
+    assert sig3 == b"0\x06\x02\x01\x00\x02\x01\x00"
+    assert decode_dss_signature(sig3) == (0, 0)
+
+    sig4 = encode_dss_signature(-1, 0)
+    assert sig4 == b"0\x06\x02\x01\xFF\x02\x01\x00"
+    assert decode_dss_signature(sig4) == (-1, 0)
+
+
+def test_encode_dss_non_integer():
+    with pytest.raises(ValueError):
+        encode_dss_signature("h", 3)
+
+    with pytest.raises(ValueError):
+        encode_dss_signature("3", "2")
+
+    with pytest.raises(ValueError):
+        encode_dss_signature(3, "h")
+
+    with pytest.raises(ValueError):
+        encode_dss_signature(3.3, 1.2)
+
+    with pytest.raises(ValueError):
+        encode_dss_signature("hello", "world")
+
+
+def test_decode_dss_trailing_bytes():
+    with pytest.raises(ValueError):
+        decode_dss_signature(b"0\x06\x02\x01\x01\x02\x01\x01\x00\x00\x00")
+
+
+def test_decode_dss_invalid_asn1():
+    with pytest.raises(ValueError):
+        # This byte sequence has an invalid ASN.1 sequence length as well as
+        # an invalid integer length for the second integer.
+        decode_dss_signature(b"0\x07\x02\x01\x01\x02\x02\x01")
+
+    with pytest.raises(ValueError):
+        # This is the BER "end-of-contents octets," which older versions of
+        # pyasn1 are wrongly willing to return from top-level DER decoding.
+        decode_dss_signature(b"\x00\x00")
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_block.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_block.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_block.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_block.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,193 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import binascii
+
+import pytest
+
+from cryptography import utils
+from cryptography.exceptions import (
+    AlreadyFinalized, _Reasons
+)
+from cryptography.hazmat.backends.interfaces import CipherBackend
+from cryptography.hazmat.primitives.ciphers import (
+    Cipher, algorithms, base, modes
+)
+
+from .utils import (
+    generate_aead_exception_test, generate_aead_tag_exception_test
+)
+from ...utils import raises_unsupported_algorithm
+
+
+@utils.register_interface(modes.Mode)
+class DummyMode(object):
+    name = "dummy-mode"
+
+    def validate_for_algorithm(self, algorithm):
+        pass
+
+
+@utils.register_interface(base.CipherAlgorithm)
+class DummyCipher(object):
+    name = "dummy-cipher"
+    key_size = None
+
+
+@pytest.mark.requires_backend_interface(interface=CipherBackend)
+class TestCipher(object):
+    def test_creates_encryptor(self, backend):
+        cipher = Cipher(
+            algorithms.AES(binascii.unhexlify(b"0" * 32)),
+            modes.CBC(binascii.unhexlify(b"0" * 32)),
+            backend
+        )
+        assert isinstance(cipher.encryptor(), base.CipherContext)
+
+    def test_creates_decryptor(self, backend):
+        cipher = Cipher(
+            algorithms.AES(binascii.unhexlify(b"0" * 32)),
+            modes.CBC(binascii.unhexlify(b"0" * 32)),
+            backend
+        )
+        assert isinstance(cipher.decryptor(), base.CipherContext)
+
+    def test_instantiate_with_non_algorithm(self, backend):
+        algorithm = object()
+        with pytest.raises(TypeError):
+            Cipher(algorithm, mode=None, backend=backend)
+
+
+@pytest.mark.requires_backend_interface(interface=CipherBackend)
+class TestCipherContext(object):
+    def test_use_after_finalize(self, backend):
+        cipher = Cipher(
+            algorithms.AES(binascii.unhexlify(b"0" * 32)),
+            modes.CBC(binascii.unhexlify(b"0" * 32)),
+            backend
+        )
+        encryptor = cipher.encryptor()
+        encryptor.update(b"a" * 16)
+        encryptor.finalize()
+        with pytest.raises(AlreadyFinalized):
+            encryptor.update(b"b" * 16)
+        with pytest.raises(AlreadyFinalized):
+            encryptor.finalize()
+        decryptor = cipher.decryptor()
+        decryptor.update(b"a" * 16)
+        decryptor.finalize()
+        with pytest.raises(AlreadyFinalized):
+            decryptor.update(b"b" * 16)
+        with pytest.raises(AlreadyFinalized):
+            decryptor.finalize()
+
+    def test_unaligned_block_encryption(self, backend):
+        cipher = Cipher(
+            algorithms.AES(binascii.unhexlify(b"0" * 32)),
+            modes.ECB(),
+            backend
+        )
+        encryptor = cipher.encryptor()
+        ct = encryptor.update(b"a" * 15)
+        assert ct == b""
+        ct += encryptor.update(b"a" * 65)
+        assert len(ct) == 80
+        ct += encryptor.finalize()
+        decryptor = cipher.decryptor()
+        pt = decryptor.update(ct[:3])
+        assert pt == b""
+        pt += decryptor.update(ct[3:])
+        assert len(pt) == 80
+        assert pt == b"a" * 80
+        decryptor.finalize()
+
+    @pytest.mark.parametrize("mode", [DummyMode(), None])
+    def test_nonexistent_cipher(self, backend, mode):
+        cipher = Cipher(
+            DummyCipher(), mode, backend
+        )
+        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_CIPHER):
+            cipher.encryptor()
+
+        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_CIPHER):
+            cipher.decryptor()
+
+    def test_incorrectly_padded(self, backend):
+        cipher = Cipher(
+            algorithms.AES(b"\x00" * 16),
+            modes.CBC(b"\x00" * 16),
+            backend
+        )
+        encryptor = cipher.encryptor()
+        encryptor.update(b"1")
+        with pytest.raises(ValueError):
+            encryptor.finalize()
+
+        decryptor = cipher.decryptor()
+        decryptor.update(b"1")
+        with pytest.raises(ValueError):
+            decryptor.finalize()
+
+
+@pytest.mark.supported(
+    only_if=lambda backend: backend.cipher_supported(
+        algorithms.AES("\x00" * 16), modes.GCM("\x00" * 12)
+    ),
+    skip_message="Does not support AES GCM",
+)
+@pytest.mark.requires_backend_interface(interface=CipherBackend)
+class TestAEADCipherContext(object):
+    test_aead_exceptions = generate_aead_exception_test(
+        algorithms.AES,
+        modes.GCM,
+    )
+    test_aead_tag_exceptions = generate_aead_tag_exception_test(
+        algorithms.AES,
+        modes.GCM,
+    )
+
+
+@pytest.mark.requires_backend_interface(interface=CipherBackend)
+class TestModeValidation(object):
+    def test_cbc(self, backend):
+        with pytest.raises(ValueError):
+            Cipher(
+                algorithms.AES(b"\x00" * 16),
+                modes.CBC(b"abc"),
+                backend,
+            )
+
+    def test_ofb(self, backend):
+        with pytest.raises(ValueError):
+            Cipher(
+                algorithms.AES(b"\x00" * 16),
+                modes.OFB(b"abc"),
+                backend,
+            )
+
+    def test_cfb(self, backend):
+        with pytest.raises(ValueError):
+            Cipher(
+                algorithms.AES(b"\x00" * 16),
+                modes.CFB(b"abc"),
+                backend,
+            )
+
+    def test_cfb8(self, backend):
+        with pytest.raises(ValueError):
+            Cipher(
+                algorithms.AES(b"\x00" * 16),
+                modes.CFB8(b"abc"),
+                backend,
+            )
+
+    def test_ctr(self, backend):
+        with pytest.raises(ValueError):
+            Cipher(
+                algorithms.AES(b"\x00" * 16),
+                modes.CTR(b"abc"),
+                backend,
+            )
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_blowfish.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_blowfish.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_blowfish.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_blowfish.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,84 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import binascii
+import os
+
+import pytest
+
+from cryptography.hazmat.backends.interfaces import CipherBackend
+from cryptography.hazmat.primitives.ciphers import algorithms, modes
+
+from .utils import generate_encrypt_test
+from ...utils import load_nist_vectors
+
+
+@pytest.mark.supported(
+    only_if=lambda backend: backend.cipher_supported(
+        algorithms.Blowfish("\x00" * 56), modes.ECB()
+    ),
+    skip_message="Does not support Blowfish ECB",
+)
+@pytest.mark.requires_backend_interface(interface=CipherBackend)
+class TestBlowfishModeECB(object):
+    test_ECB = generate_encrypt_test(
+        load_nist_vectors,
+        os.path.join("ciphers", "Blowfish"),
+        ["bf-ecb.txt"],
+        lambda key, **kwargs: algorithms.Blowfish(binascii.unhexlify(key)),
+        lambda **kwargs: modes.ECB(),
+    )
+
+
+@pytest.mark.supported(
+    only_if=lambda backend: backend.cipher_supported(
+        algorithms.Blowfish("\x00" * 56), modes.CBC("\x00" * 8)
+    ),
+    skip_message="Does not support Blowfish CBC",
+)
+@pytest.mark.requires_backend_interface(interface=CipherBackend)
+class TestBlowfishModeCBC(object):
+    test_CBC = generate_encrypt_test(
+        load_nist_vectors,
+        os.path.join("ciphers", "Blowfish"),
+        ["bf-cbc.txt"],
+        lambda key, **kwargs: algorithms.Blowfish(binascii.unhexlify(key)),
+        lambda iv, **kwargs: modes.CBC(binascii.unhexlify(iv)),
+    )
+
+
+@pytest.mark.supported(
+    only_if=lambda backend: backend.cipher_supported(
+        algorithms.Blowfish("\x00" * 56), modes.OFB("\x00" * 8)
+    ),
+    skip_message="Does not support Blowfish OFB",
+)
+@pytest.mark.requires_backend_interface(interface=CipherBackend)
+class TestBlowfishModeOFB(object):
+    test_OFB = generate_encrypt_test(
+        load_nist_vectors,
+        os.path.join("ciphers", "Blowfish"),
+        ["bf-ofb.txt"],
+        lambda key, **kwargs: algorithms.Blowfish(binascii.unhexlify(key)),
+        lambda iv, **kwargs: modes.OFB(binascii.unhexlify(iv)),
+    )
+
+
+@pytest.mark.supported(
+    only_if=lambda backend: backend.cipher_supported(
+        algorithms.Blowfish("\x00" * 56), modes.CFB("\x00" * 8)
+    ),
+    skip_message="Does not support Blowfish CFB",
+)
+@pytest.mark.requires_backend_interface(interface=CipherBackend)
+class TestBlowfishModeCFB(object):
+    test_CFB = generate_encrypt_test(
+        load_nist_vectors,
+        os.path.join("ciphers", "Blowfish"),
+        ["bf-cfb.txt"],
+        lambda key, **kwargs: algorithms.Blowfish(binascii.unhexlify(key)),
+        lambda iv, **kwargs: modes.CFB(binascii.unhexlify(iv)),
+    )
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_camellia.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_camellia.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_camellia.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_camellia.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,90 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import binascii
+import os
+
+import pytest
+
+from cryptography.hazmat.backends.interfaces import CipherBackend
+from cryptography.hazmat.primitives.ciphers import algorithms, modes
+
+from .utils import generate_encrypt_test
+from ...utils import (
+    load_cryptrec_vectors, load_nist_vectors
+)
+
+
+@pytest.mark.supported(
+    only_if=lambda backend: backend.cipher_supported(
+        algorithms.Camellia("\x00" * 16), modes.ECB()
+    ),
+    skip_message="Does not support Camellia ECB",
+)
+@pytest.mark.requires_backend_interface(interface=CipherBackend)
+class TestCamelliaModeECB(object):
+    test_ECB = generate_encrypt_test(
+        load_cryptrec_vectors,
+        os.path.join("ciphers", "Camellia"),
+        [
+            "camellia-128-ecb.txt",
+            "camellia-192-ecb.txt",
+            "camellia-256-ecb.txt"
+        ],
+        lambda key, **kwargs: algorithms.Camellia(binascii.unhexlify(key)),
+        lambda **kwargs: modes.ECB(),
+    )
+
+
+@pytest.mark.supported(
+    only_if=lambda backend: backend.cipher_supported(
+        algorithms.Camellia("\x00" * 16), modes.CBC("\x00" * 16)
+    ),
+    skip_message="Does not support Camellia CBC",
+)
+@pytest.mark.requires_backend_interface(interface=CipherBackend)
+class TestCamelliaModeCBC(object):
+    test_CBC = generate_encrypt_test(
+        load_nist_vectors,
+        os.path.join("ciphers", "Camellia"),
+        ["camellia-cbc.txt"],
+        lambda key, **kwargs: algorithms.Camellia(binascii.unhexlify(key)),
+        lambda iv, **kwargs: modes.CBC(binascii.unhexlify(iv)),
+    )
+
+
+@pytest.mark.supported(
+    only_if=lambda backend: backend.cipher_supported(
+        algorithms.Camellia("\x00" * 16), modes.OFB("\x00" * 16)
+    ),
+    skip_message="Does not support Camellia OFB",
+)
+@pytest.mark.requires_backend_interface(interface=CipherBackend)
+class TestCamelliaModeOFB(object):
+    test_OFB = generate_encrypt_test(
+        load_nist_vectors,
+        os.path.join("ciphers", "Camellia"),
+        ["camellia-ofb.txt"],
+        lambda key, **kwargs: algorithms.Camellia(binascii.unhexlify(key)),
+        lambda iv, **kwargs: modes.OFB(binascii.unhexlify(iv)),
+    )
+
+
+@pytest.mark.supported(
+    only_if=lambda backend: backend.cipher_supported(
+        algorithms.Camellia("\x00" * 16), modes.CFB("\x00" * 16)
+    ),
+    skip_message="Does not support Camellia CFB",
+)
+@pytest.mark.requires_backend_interface(interface=CipherBackend)
+class TestCamelliaModeCFB(object):
+    test_CFB = generate_encrypt_test(
+        load_nist_vectors,
+        os.path.join("ciphers", "Camellia"),
+        ["camellia-cfb.txt"],
+        lambda key, **kwargs: algorithms.Camellia(binascii.unhexlify(key)),
+        lambda iv, **kwargs: modes.CFB(binascii.unhexlify(iv)),
+    )
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_cast5.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_cast5.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_cast5.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_cast5.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,101 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import binascii
+import os
+
+import pytest
+
+from cryptography.hazmat.backends.interfaces import CipherBackend
+from cryptography.hazmat.primitives.ciphers import algorithms, modes
+
+from .utils import generate_encrypt_test
+from ...utils import load_nist_vectors
+
+
+@pytest.mark.supported(
+    only_if=lambda backend: backend.cipher_supported(
+        algorithms.CAST5("\x00" * 16), modes.ECB()
+    ),
+    skip_message="Does not support CAST5 ECB",
+)
+@pytest.mark.requires_backend_interface(interface=CipherBackend)
+class TestCAST5ModeECB(object):
+    test_ECB = generate_encrypt_test(
+        load_nist_vectors,
+        os.path.join("ciphers", "CAST5"),
+        ["cast5-ecb.txt"],
+        lambda key, **kwargs: algorithms.CAST5(binascii.unhexlify((key))),
+        lambda **kwargs: modes.ECB(),
+    )
+
+
+@pytest.mark.supported(
+    only_if=lambda backend: backend.cipher_supported(
+        algorithms.CAST5("\x00" * 16), modes.CBC("\x00" * 8)
+    ),
+    skip_message="Does not support CAST5 CBC",
+)
+@pytest.mark.requires_backend_interface(interface=CipherBackend)
+class TestCAST5ModeCBC(object):
+    test_CBC = generate_encrypt_test(
+        load_nist_vectors,
+        os.path.join("ciphers", "CAST5"),
+        ["cast5-cbc.txt"],
+        lambda key, **kwargs: algorithms.CAST5(binascii.unhexlify((key))),
+        lambda iv, **kwargs: modes.CBC(binascii.unhexlify(iv))
+    )
+
+
+@pytest.mark.supported(
+    only_if=lambda backend: backend.cipher_supported(
+        algorithms.CAST5("\x00" * 16), modes.OFB("\x00" * 8)
+    ),
+    skip_message="Does not support CAST5 OFB",
+)
+@pytest.mark.requires_backend_interface(interface=CipherBackend)
+class TestCAST5ModeOFB(object):
+    test_OFB = generate_encrypt_test(
+        load_nist_vectors,
+        os.path.join("ciphers", "CAST5"),
+        ["cast5-ofb.txt"],
+        lambda key, **kwargs: algorithms.CAST5(binascii.unhexlify((key))),
+        lambda iv, **kwargs: modes.OFB(binascii.unhexlify(iv))
+    )
+
+
+@pytest.mark.supported(
+    only_if=lambda backend: backend.cipher_supported(
+        algorithms.CAST5("\x00" * 16), modes.CFB("\x00" * 8)
+    ),
+    skip_message="Does not support CAST5 CFB",
+)
+@pytest.mark.requires_backend_interface(interface=CipherBackend)
+class TestCAST5ModeCFB(object):
+    test_CFB = generate_encrypt_test(
+        load_nist_vectors,
+        os.path.join("ciphers", "CAST5"),
+        ["cast5-cfb.txt"],
+        lambda key, **kwargs: algorithms.CAST5(binascii.unhexlify((key))),
+        lambda iv, **kwargs: modes.CFB(binascii.unhexlify(iv))
+    )
+
+
+@pytest.mark.supported(
+    only_if=lambda backend: backend.cipher_supported(
+        algorithms.CAST5("\x00" * 16), modes.CTR("\x00" * 8)
+    ),
+    skip_message="Does not support CAST5 CTR",
+)
+@pytest.mark.requires_backend_interface(interface=CipherBackend)
+class TestCAST5ModeCTR(object):
+    test_CTR = generate_encrypt_test(
+        load_nist_vectors,
+        os.path.join("ciphers", "CAST5"),
+        ["cast5-ctr.txt"],
+        lambda key, **kwargs: algorithms.CAST5(binascii.unhexlify((key))),
+        lambda iv, **kwargs: modes.CTR(binascii.unhexlify(iv))
+    )
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_ciphers.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_ciphers.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_ciphers.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_ciphers.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,135 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import binascii
+
+import pytest
+
+from cryptography.exceptions import _Reasons
+from cryptography.hazmat.primitives import ciphers
+from cryptography.hazmat.primitives.ciphers.algorithms import (
+    AES, ARC4, Blowfish, CAST5, Camellia, IDEA, SEED, TripleDES
+)
+from cryptography.hazmat.primitives.ciphers.modes import ECB
+
+from ...utils import raises_unsupported_algorithm
+
+
+class TestAES(object):
+    @pytest.mark.parametrize(("key", "keysize"), [
+        (b"0" * 32, 128),
+        (b"0" * 48, 192),
+        (b"0" * 64, 256),
+    ])
+    def test_key_size(self, key, keysize):
+        cipher = AES(binascii.unhexlify(key))
+        assert cipher.key_size == keysize
+
+    def test_invalid_key_size(self):
+        with pytest.raises(ValueError):
+            AES(binascii.unhexlify(b"0" * 12))
+
+
+class TestCamellia(object):
+    @pytest.mark.parametrize(("key", "keysize"), [
+        (b"0" * 32, 128),
+        (b"0" * 48, 192),
+        (b"0" * 64, 256),
+    ])
+    def test_key_size(self, key, keysize):
+        cipher = Camellia(binascii.unhexlify(key))
+        assert cipher.key_size == keysize
+
+    def test_invalid_key_size(self):
+        with pytest.raises(ValueError):
+            Camellia(binascii.unhexlify(b"0" * 12))
+
+
+class TestTripleDES(object):
+    @pytest.mark.parametrize("key", [
+        b"0" * 16,
+        b"0" * 32,
+        b"0" * 48,
+    ])
+    def test_key_size(self, key):
+        cipher = TripleDES(binascii.unhexlify(key))
+        assert cipher.key_size == 192
+
+    def test_invalid_key_size(self):
+        with pytest.raises(ValueError):
+            TripleDES(binascii.unhexlify(b"0" * 12))
+
+
+class TestBlowfish(object):
+    @pytest.mark.parametrize(("key", "keysize"), [
+        (b"0" * (keysize // 4), keysize) for keysize in range(32, 449, 8)
+    ])
+    def test_key_size(self, key, keysize):
+        cipher = Blowfish(binascii.unhexlify(key))
+        assert cipher.key_size == keysize
+
+    def test_invalid_key_size(self):
+        with pytest.raises(ValueError):
+            Blowfish(binascii.unhexlify(b"0" * 6))
+
+
+class TestCAST5(object):
+    @pytest.mark.parametrize(("key", "keysize"), [
+        (b"0" * (keysize // 4), keysize) for keysize in range(40, 129, 8)
+    ])
+    def test_key_size(self, key, keysize):
+        cipher = CAST5(binascii.unhexlify(key))
+        assert cipher.key_size == keysize
+
+    def test_invalid_key_size(self):
+        with pytest.raises(ValueError):
+            CAST5(binascii.unhexlify(b"0" * 34))
+
+
+class TestARC4(object):
+    @pytest.mark.parametrize(("key", "keysize"), [
+        (b"0" * 10, 40),
+        (b"0" * 14, 56),
+        (b"0" * 16, 64),
+        (b"0" * 20, 80),
+        (b"0" * 32, 128),
+        (b"0" * 48, 192),
+        (b"0" * 64, 256),
+    ])
+    def test_key_size(self, key, keysize):
+        cipher = ARC4(binascii.unhexlify(key))
+        assert cipher.key_size == keysize
+
+    def test_invalid_key_size(self):
+        with pytest.raises(ValueError):
+            ARC4(binascii.unhexlify(b"0" * 34))
+
+
+class TestIDEA(object):
+    def test_key_size(self):
+        cipher = IDEA(b"\x00" * 16)
+        assert cipher.key_size == 128
+
+    def test_invalid_key_size(self):
+        with pytest.raises(ValueError):
+            IDEA(b"\x00" * 17)
+
+
+class TestSEED(object):
+    def test_key_size(self):
+        cipher = SEED(b"\x00" * 16)
+        assert cipher.key_size == 128
+
+    def test_invalid_key_size(self):
+        with pytest.raises(ValueError):
+            SEED(b"\x00" * 17)
+
+
+def test_invalid_backend():
+    pretend_backend = object()
+
+    with raises_unsupported_algorithm(_Reasons.BACKEND_MISSING_INTERFACE):
+        ciphers.Cipher(AES(b"AAAAAAAAAAAAAAAA"), ECB, pretend_backend)
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_cmac.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_cmac.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_cmac.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_cmac.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,205 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import binascii
+
+import pretend
+
+import pytest
+
+from cryptography.exceptions import (
+    AlreadyFinalized, InvalidSignature, _Reasons
+)
+from cryptography.hazmat.backends.interfaces import CMACBackend
+from cryptography.hazmat.primitives.ciphers.algorithms import (
+    AES, ARC4, TripleDES
+)
+from cryptography.hazmat.primitives.cmac import CMAC
+
+from ..backends.test_multibackend import DummyCMACBackend
+from ...utils import (
+    load_nist_vectors, load_vectors_from_file, raises_unsupported_algorithm
+)
+
+vectors_aes128 = load_vectors_from_file(
+    "CMAC/nist-800-38b-aes128.txt", load_nist_vectors)
+
+vectors_aes192 = load_vectors_from_file(
+    "CMAC/nist-800-38b-aes192.txt", load_nist_vectors)
+
+vectors_aes256 = load_vectors_from_file(
+    "CMAC/nist-800-38b-aes256.txt", load_nist_vectors)
+
+vectors_aes = vectors_aes128 + vectors_aes192 + vectors_aes256
+
+vectors_3des = load_vectors_from_file(
+    "CMAC/nist-800-38b-3des.txt", load_nist_vectors)
+
+fake_key = b"\x00" * 16
+
+
+@pytest.mark.requires_backend_interface(interface=CMACBackend)
+class TestCMAC(object):
+    @pytest.mark.supported(
+        only_if=lambda backend: backend.cmac_algorithm_supported(
+            AES(fake_key)),
+        skip_message="Does not support CMAC."
+    )
+    @pytest.mark.parametrize("params", vectors_aes)
+    def test_aes_generate(self, backend, params):
+        key = params["key"]
+        message = params["message"]
+        output = params["output"]
+
+        cmac = CMAC(AES(binascii.unhexlify(key)), backend)
+        cmac.update(binascii.unhexlify(message))
+        assert binascii.hexlify(cmac.finalize()) == output
+
+    @pytest.mark.supported(
+        only_if=lambda backend: backend.cmac_algorithm_supported(
+            AES(fake_key)),
+        skip_message="Does not support CMAC."
+    )
+    @pytest.mark.parametrize("params", vectors_aes)
+    def test_aes_verify(self, backend, params):
+        key = params["key"]
+        message = params["message"]
+        output = params["output"]
+
+        cmac = CMAC(AES(binascii.unhexlify(key)), backend)
+        cmac.update(binascii.unhexlify(message))
+        assert cmac.verify(binascii.unhexlify(output)) is None
+
+    @pytest.mark.supported(
+        only_if=lambda backend: backend.cmac_algorithm_supported(
+            TripleDES(fake_key)),
+        skip_message="Does not support CMAC."
+    )
+    @pytest.mark.parametrize("params", vectors_3des)
+    def test_3des_generate(self, backend, params):
+        key1 = params["key1"]
+        key2 = params["key2"]
+        key3 = params["key3"]
+
+        key = key1 + key2 + key3
+
+        message = params["message"]
+        output = params["output"]
+
+        cmac = CMAC(TripleDES(binascii.unhexlify(key)), backend)
+        cmac.update(binascii.unhexlify(message))
+        assert binascii.hexlify(cmac.finalize()) == output
+
+    @pytest.mark.supported(
+        only_if=lambda backend: backend.cmac_algorithm_supported(
+            TripleDES(fake_key)),
+        skip_message="Does not support CMAC."
+    )
+    @pytest.mark.parametrize("params", vectors_3des)
+    def test_3des_verify(self, backend, params):
+        key1 = params["key1"]
+        key2 = params["key2"]
+        key3 = params["key3"]
+
+        key = key1 + key2 + key3
+
+        message = params["message"]
+        output = params["output"]
+
+        cmac = CMAC(TripleDES(binascii.unhexlify(key)), backend)
+        cmac.update(binascii.unhexlify(message))
+        assert cmac.verify(binascii.unhexlify(output)) is None
+
+    @pytest.mark.supported(
+        only_if=lambda backend: backend.cmac_algorithm_supported(
+            AES(fake_key)),
+        skip_message="Does not support CMAC."
+    )
+    def test_invalid_verify(self, backend):
+        key = b"2b7e151628aed2a6abf7158809cf4f3c"
+        cmac = CMAC(AES(key), backend)
+        cmac.update(b"6bc1bee22e409f96e93d7e117393172a")
+
+        with pytest.raises(InvalidSignature):
+            cmac.verify(b"foobar")
+
+    @pytest.mark.supported(
+        only_if=lambda backend: backend.cipher_supported(
+            ARC4(fake_key), None),
+        skip_message="Does not support CMAC."
+    )
+    def test_invalid_algorithm(self, backend):
+        key = b"0102030405"
+        with pytest.raises(TypeError):
+            CMAC(ARC4(key), backend)
+
+    @pytest.mark.supported(
+        only_if=lambda backend: backend.cmac_algorithm_supported(
+            AES(fake_key)),
+        skip_message="Does not support CMAC."
+    )
+    def test_raises_after_finalize(self, backend):
+        key = b"2b7e151628aed2a6abf7158809cf4f3c"
+        cmac = CMAC(AES(key), backend)
+        cmac.finalize()
+
+        with pytest.raises(AlreadyFinalized):
+            cmac.update(b"foo")
+
+        with pytest.raises(AlreadyFinalized):
+            cmac.copy()
+
+        with pytest.raises(AlreadyFinalized):
+            cmac.finalize()
+
+        with pytest.raises(AlreadyFinalized):
+            cmac.verify(b"")
+
+    @pytest.mark.supported(
+        only_if=lambda backend: backend.cmac_algorithm_supported(
+            AES(fake_key)),
+        skip_message="Does not support CMAC."
+    )
+    def test_verify_reject_unicode(self, backend):
+        key = b"2b7e151628aed2a6abf7158809cf4f3c"
+        cmac = CMAC(AES(key), backend)
+
+        with pytest.raises(TypeError):
+            cmac.update(u'')
+
+        with pytest.raises(TypeError):
+            cmac.verify(u'')
+
+    @pytest.mark.supported(
+        only_if=lambda backend: backend.cmac_algorithm_supported(
+            AES(fake_key)),
+        skip_message="Does not support CMAC."
+    )
+    def test_copy_with_backend(self, backend):
+        key = b"2b7e151628aed2a6abf7158809cf4f3c"
+        cmac = CMAC(AES(key), backend)
+        cmac.update(b"6bc1bee22e409f96e93d7e117393172a")
+        copy_cmac = cmac.copy()
+        assert cmac.finalize() == copy_cmac.finalize()
+
+
+def test_copy():
+    backend = DummyCMACBackend([AES])
+    copied_ctx = pretend.stub()
+    pretend_ctx = pretend.stub(copy=lambda: copied_ctx)
+    key = b"2b7e151628aed2a6abf7158809cf4f3c"
+    cmac = CMAC(AES(key), backend=backend, ctx=pretend_ctx)
+
+    assert cmac._backend is backend
+    assert cmac.copy()._backend is backend
+
+
+def test_invalid_backend():
+    key = b"2b7e151628aed2a6abf7158809cf4f3c"
+    pretend_backend = object()
+
+    with raises_unsupported_algorithm(_Reasons.BACKEND_MISSING_INTERFACE):
+        CMAC(AES(key), pretend_backend)
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_concatkdf.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_concatkdf.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_concatkdf.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_concatkdf.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,272 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import binascii
+
+import pytest
+
+from cryptography.exceptions import (
+    AlreadyFinalized, InvalidKey, _Reasons
+)
+from cryptography.hazmat.backends.interfaces import HMACBackend
+from cryptography.hazmat.backends.interfaces import HashBackend
+from cryptography.hazmat.primitives import hashes
+from cryptography.hazmat.primitives.kdf.concatkdf import ConcatKDFHMAC
+from cryptography.hazmat.primitives.kdf.concatkdf import ConcatKDFHash
+
+from ...utils import raises_unsupported_algorithm
+
+
+@pytest.mark.requires_backend_interface(interface=HashBackend)
+class TestConcatKDFHash(object):
+    def test_length_limit(self, backend):
+        big_length = hashes.SHA256().digest_size * (2 ** 32 - 1) + 1
+
+        with pytest.raises(ValueError):
+            ConcatKDFHash(hashes.SHA256(), big_length, None, backend)
+
+    def test_already_finalized(self, backend):
+        ckdf = ConcatKDFHash(hashes.SHA256(), 16, None, backend)
+
+        ckdf.derive(b"\x01" * 16)
+
+        with pytest.raises(AlreadyFinalized):
+            ckdf.derive(b"\x02" * 16)
+
+    def test_derive(self, backend):
+        prk = binascii.unhexlify(
+            b"52169af5c485dcc2321eb8d26d5efa21fb9b93c98e38412ee2484cf14f0d0d23"
+        )
+
+        okm = binascii.unhexlify(b"1c3bc9e7c4547c5191c0d478cccaed55")
+
+        oinfo = binascii.unhexlify(
+            b"a1b2c3d4e53728157e634612c12d6d5223e204aeea4341565369647bd184bcd2"
+            b"46f72971f292badaa2fe4124612cba"
+        )
+
+        ckdf = ConcatKDFHash(hashes.SHA256(), 16, oinfo, backend)
+
+        assert ckdf.derive(prk) == okm
+
+    def test_verify(self, backend):
+        prk = binascii.unhexlify(
+            b"52169af5c485dcc2321eb8d26d5efa21fb9b93c98e38412ee2484cf14f0d0d23"
+        )
+
+        okm = binascii.unhexlify(b"1c3bc9e7c4547c5191c0d478cccaed55")
+
+        oinfo = binascii.unhexlify(
+            b"a1b2c3d4e53728157e634612c12d6d5223e204aeea4341565369647bd184bcd2"
+            b"46f72971f292badaa2fe4124612cba"
+        )
+
+        ckdf = ConcatKDFHash(hashes.SHA256(), 16, oinfo, backend)
+
+        assert ckdf.verify(prk, okm) is None
+
+    def test_invalid_verify(self, backend):
+        prk = binascii.unhexlify(
+            b"52169af5c485dcc2321eb8d26d5efa21fb9b93c98e38412ee2484cf14f0d0d23"
+        )
+
+        oinfo = binascii.unhexlify(
+            b"a1b2c3d4e53728157e634612c12d6d5223e204aeea4341565369647bd184bcd2"
+            b"46f72971f292badaa2fe4124612cba"
+        )
+
+        ckdf = ConcatKDFHash(hashes.SHA256(), 16, oinfo, backend)
+
+        with pytest.raises(InvalidKey):
+            ckdf.verify(prk, b"wrong key")
+
+    def test_unicode_typeerror(self, backend):
+        with pytest.raises(TypeError):
+            ConcatKDFHash(
+                hashes.SHA256(),
+                16,
+                otherinfo=u"foo",
+                backend=backend
+            )
+
+        with pytest.raises(TypeError):
+            ckdf = ConcatKDFHash(
+                hashes.SHA256(),
+                16,
+                otherinfo=None,
+                backend=backend
+            )
+
+            ckdf.derive(u"foo")
+
+        with pytest.raises(TypeError):
+            ckdf = ConcatKDFHash(
+                hashes.SHA256(),
+                16,
+                otherinfo=None,
+                backend=backend
+            )
+
+            ckdf.verify(u"foo", b"bar")
+
+        with pytest.raises(TypeError):
+            ckdf = ConcatKDFHash(
+                hashes.SHA256(),
+                16,
+                otherinfo=None,
+                backend=backend
+            )
+
+            ckdf.verify(b"foo", u"bar")
+
+
+@pytest.mark.requires_backend_interface(interface=HMACBackend)
+class TestConcatKDFHMAC(object):
+    def test_length_limit(self, backend):
+        big_length = hashes.SHA256().digest_size * (2 ** 32 - 1) + 1
+
+        with pytest.raises(ValueError):
+            ConcatKDFHMAC(hashes.SHA256(), big_length, None, None, backend)
+
+    def test_already_finalized(self, backend):
+        ckdf = ConcatKDFHMAC(hashes.SHA256(), 16, None, None, backend)
+
+        ckdf.derive(b"\x01" * 16)
+
+        with pytest.raises(AlreadyFinalized):
+            ckdf.derive(b"\x02" * 16)
+
+    def test_derive(self, backend):
+        prk = binascii.unhexlify(
+            b"013951627c1dea63ea2d7702dd24e963eef5faac6b4af7e4"
+            b"b831cde499dff1ce45f6179f741c728aa733583b02409208"
+            b"8f0af7fce1d045edbc5790931e8d5ca79c73"
+        )
+
+        okm = binascii.unhexlify(b"64ce901db10d558661f10b6836a122a7"
+                                 b"605323ce2f39bf27eaaac8b34cf89f2f")
+
+        oinfo = binascii.unhexlify(
+            b"a1b2c3d4e55e600be5f367e0e8a465f4bf2704db00c9325c"
+            b"9fbd216d12b49160b2ae5157650f43415653696421e68e"
+        )
+
+        ckdf = ConcatKDFHMAC(hashes.SHA512(), 32, None, oinfo, backend)
+
+        assert ckdf.derive(prk) == okm
+
+    def test_derive_explicit_salt(self, backend):
+        prk = binascii.unhexlify(
+            b"013951627c1dea63ea2d7702dd24e963eef5faac6b4af7e4"
+            b"b831cde499dff1ce45f6179f741c728aa733583b02409208"
+            b"8f0af7fce1d045edbc5790931e8d5ca79c73"
+        )
+
+        okm = binascii.unhexlify(b"64ce901db10d558661f10b6836a122a7"
+                                 b"605323ce2f39bf27eaaac8b34cf89f2f")
+
+        oinfo = binascii.unhexlify(
+            b"a1b2c3d4e55e600be5f367e0e8a465f4bf2704db00c9325c"
+            b"9fbd216d12b49160b2ae5157650f43415653696421e68e"
+        )
+
+        ckdf = ConcatKDFHMAC(
+            hashes.SHA512(), 32, b"\x00" * 128, oinfo, backend
+        )
+
+        assert ckdf.derive(prk) == okm
+
+    def test_verify(self, backend):
+        prk = binascii.unhexlify(
+            b"013951627c1dea63ea2d7702dd24e963eef5faac6b4af7e4"
+            b"b831cde499dff1ce45f6179f741c728aa733583b02409208"
+            b"8f0af7fce1d045edbc5790931e8d5ca79c73"
+        )
+
+        okm = binascii.unhexlify(b"64ce901db10d558661f10b6836a122a7"
+                                 b"605323ce2f39bf27eaaac8b34cf89f2f")
+
+        oinfo = binascii.unhexlify(
+            b"a1b2c3d4e55e600be5f367e0e8a465f4bf2704db00c9325c"
+            b"9fbd216d12b49160b2ae5157650f43415653696421e68e"
+        )
+
+        ckdf = ConcatKDFHMAC(hashes.SHA512(), 32, None, oinfo, backend)
+
+        assert ckdf.verify(prk, okm) is None
+
+    def test_invalid_verify(self, backend):
+        prk = binascii.unhexlify(
+            b"013951627c1dea63ea2d7702dd24e963eef5faac6b4af7e4"
+            b"b831cde499dff1ce45f6179f741c728aa733583b02409208"
+            b"8f0af7fce1d045edbc5790931e8d5ca79c73"
+        )
+
+        oinfo = binascii.unhexlify(
+            b"a1b2c3d4e55e600be5f367e0e8a465f4bf2704db00c9325c"
+            b"9fbd216d12b49160b2ae5157650f43415653696421e68e"
+        )
+
+        ckdf = ConcatKDFHMAC(hashes.SHA512(), 32, None, oinfo, backend)
+
+        with pytest.raises(InvalidKey):
+            ckdf.verify(prk, b"wrong key")
+
+    def test_unicode_typeerror(self, backend):
+        with pytest.raises(TypeError):
+            ConcatKDFHMAC(
+                hashes.SHA256(),
+                16, salt=u"foo",
+                otherinfo=None,
+                backend=backend
+            )
+
+        with pytest.raises(TypeError):
+            ConcatKDFHMAC(
+                hashes.SHA256(),
+                16, salt=None,
+                otherinfo=u"foo",
+                backend=backend
+            )
+
+        with pytest.raises(TypeError):
+            ckdf = ConcatKDFHMAC(
+                hashes.SHA256(),
+                16, salt=None,
+                otherinfo=None,
+                backend=backend
+            )
+
+            ckdf.derive(u"foo")
+
+        with pytest.raises(TypeError):
+            ckdf = ConcatKDFHMAC(
+                hashes.SHA256(),
+                16, salt=None,
+                otherinfo=None,
+                backend=backend
+            )
+
+            ckdf.verify(u"foo", b"bar")
+
+        with pytest.raises(TypeError):
+            ckdf = ConcatKDFHMAC(
+                hashes.SHA256(),
+                16, salt=None,
+                otherinfo=None,
+                backend=backend
+            )
+
+            ckdf.verify(b"foo", u"bar")
+
+
+def test_invalid_backend():
+    pretend_backend = object()
+
+    with raises_unsupported_algorithm(_Reasons.BACKEND_MISSING_INTERFACE):
+        ConcatKDFHash(hashes.SHA256(), 16, None, pretend_backend)
+    with raises_unsupported_algorithm(_Reasons.BACKEND_MISSING_INTERFACE):
+        ConcatKDFHMAC(hashes.SHA256(), 16, None, None, pretend_backend)
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_constant_time.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_constant_time.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_constant_time.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_constant_time.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,30 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import pytest
+
+from cryptography.hazmat.primitives import constant_time
+
+
+class TestConstantTimeBytesEq(object):
+    def test_reject_unicode(self):
+        with pytest.raises(TypeError):
+            constant_time.bytes_eq(b"foo", u"foo")
+
+        with pytest.raises(TypeError):
+            constant_time.bytes_eq(u"foo", b"foo")
+
+        with pytest.raises(TypeError):
+            constant_time.bytes_eq(u"foo", u"foo")
+
+    def test_compares(self):
+        assert constant_time.bytes_eq(b"foo", b"foo") is True
+
+        assert constant_time.bytes_eq(b"foo", b"bar") is False
+
+        assert constant_time.bytes_eq(b"foobar", b"foo") is False
+
+        assert constant_time.bytes_eq(b"foo", b"foobar") is False
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_dh.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_dh.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_dh.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_dh.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,104 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import pytest
+
+from cryptography.hazmat.primitives.asymmetric import dh
+
+
+def test_dh_parameternumbers():
+    params = dh.DHParameterNumbers(
+        65537, 3
+    )
+
+    assert params.p == 65537
+    assert params.g == 3
+
+    with pytest.raises(TypeError):
+        dh.DHParameterNumbers(
+            None, 3
+        )
+
+    with pytest.raises(TypeError):
+        dh.DHParameterNumbers(
+            65537, None
+        )
+
+    with pytest.raises(TypeError):
+        dh.DHParameterNumbers(
+            None, None
+        )
+
+
+def test_dh_numbers():
+    params = dh.DHParameterNumbers(
+        65537, 3
+    )
+
+    public = dh.DHPublicNumbers(
+        1, params
+    )
+
+    assert public.parameter_numbers is params
+    assert public.y == 1
+
+    with pytest.raises(TypeError):
+        dh.DHPublicNumbers(
+            1, None
+        )
+
+    with pytest.raises(TypeError):
+        dh.DHPublicNumbers(
+            None, params
+        )
+
+    private = dh.DHPrivateNumbers(
+        1, public
+    )
+
+    assert private.public_numbers is public
+    assert private.x == 1
+
+    with pytest.raises(TypeError):
+        dh.DHPrivateNumbers(
+            1, None
+        )
+
+    with pytest.raises(TypeError):
+        dh.DHPrivateNumbers(
+            None, public
+        )
+
+
+def test_dh_parameter_numbers_equality():
+    assert dh.DHParameterNumbers(65537, 3) == dh.DHParameterNumbers(65537, 3)
+    assert dh.DHParameterNumbers(6, 3) != dh.DHParameterNumbers(65537, 3)
+    assert dh.DHParameterNumbers(65537, 0) != dh.DHParameterNumbers(65537, 3)
+    assert dh.DHParameterNumbers(65537, 0) != object()
+
+
+def test_dh_private_numbers_equality():
+    params = dh.DHParameterNumbers(65537, 3)
+    public = dh.DHPublicNumbers(1, params)
+    private = dh.DHPrivateNumbers(2, public)
+
+    assert private == dh.DHPrivateNumbers(2, public)
+    assert private != dh.DHPrivateNumbers(0, public)
+    assert private != dh.DHPrivateNumbers(2, dh.DHPublicNumbers(0, params))
+    assert private != dh.DHPrivateNumbers(
+        2, dh.DHPublicNumbers(1, dh.DHParameterNumbers(65537, 0))
+    )
+    assert private != object()
+
+
+def test_dh_public_numbers_equality():
+    params = dh.DHParameterNumbers(65537, 3)
+    public = dh.DHPublicNumbers(1, params)
+
+    assert public == dh.DHPublicNumbers(1, params)
+    assert public != dh.DHPublicNumbers(0, params)
+    assert public != dh.DHPublicNumbers(1, dh.DHParameterNumbers(65537, 0))
+    assert public != object()
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_dsa.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_dsa.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_dsa.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_dsa.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,1036 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import itertools
+import os
+
+import pytest
+
+from cryptography import utils
+from cryptography.exceptions import AlreadyFinalized, InvalidSignature
+from cryptography.hazmat.backends.interfaces import (
+    DSABackend, PEMSerializationBackend
+)
+from cryptography.hazmat.primitives import hashes, serialization
+from cryptography.hazmat.primitives.asymmetric import dsa
+from cryptography.hazmat.primitives.asymmetric.utils import (
+    encode_dss_signature
+)
+from cryptography.utils import bit_length
+
+from .fixtures_dsa import (
+    DSA_KEY_1024, DSA_KEY_2048, DSA_KEY_3072
+)
+from ...utils import (
+    load_fips_dsa_key_pair_vectors, load_fips_dsa_sig_vectors,
+    load_vectors_from_file,
+)
+
+
+@utils.register_interface(serialization.KeySerializationEncryption)
+class DummyKeyEncryption(object):
+    pass
+
+
+@pytest.mark.requires_backend_interface(interface=DSABackend)
+class TestDSA(object):
+    def test_generate_dsa_parameters(self, backend):
+        parameters = dsa.generate_parameters(1024, backend)
+        assert isinstance(parameters, dsa.DSAParameters)
+
+    def test_generate_invalid_dsa_parameters(self, backend):
+        with pytest.raises(ValueError):
+            dsa.generate_parameters(1, backend)
+
+    @pytest.mark.parametrize(
+        "vector",
+        load_vectors_from_file(
+            os.path.join(
+                "asymmetric", "DSA", "FIPS_186-3", "KeyPair.rsp"),
+            load_fips_dsa_key_pair_vectors
+        )
+    )
+    def test_generate_dsa_keys(self, vector, backend):
+        parameters = dsa.DSAParameterNumbers(
+            p=vector['p'],
+            q=vector['q'],
+            g=vector['g']
+        ).parameters(backend)
+        skey = parameters.generate_private_key()
+        numbers = skey.private_numbers()
+        skey_parameters = numbers.public_numbers.parameter_numbers
+        pkey = skey.public_key()
+        parameters = pkey.parameters()
+        parameter_numbers = parameters.parameter_numbers()
+        assert parameter_numbers.p == skey_parameters.p
+        assert parameter_numbers.q == skey_parameters.q
+        assert parameter_numbers.g == skey_parameters.g
+        assert skey_parameters.p == vector['p']
+        assert skey_parameters.q == vector['q']
+        assert skey_parameters.g == vector['g']
+        assert skey.key_size == bit_length(vector['p'])
+        assert pkey.key_size == skey.key_size
+        public_numbers = pkey.public_numbers()
+        assert numbers.public_numbers.y == public_numbers.y
+        assert numbers.public_numbers.y == pow(
+            skey_parameters.g, numbers.x, skey_parameters.p
+        )
+
+    def test_generate_dsa_private_key_and_parameters(self, backend):
+        skey = dsa.generate_private_key(1024, backend)
+        assert skey
+        numbers = skey.private_numbers()
+        skey_parameters = numbers.public_numbers.parameter_numbers
+        assert numbers.public_numbers.y == pow(
+            skey_parameters.g, numbers.x, skey_parameters.p
+        )
+
+    def test_invalid_parameters_values(self, backend):
+        # Test a p < 1024 bits in length
+        with pytest.raises(ValueError):
+            dsa.DSAParameterNumbers(
+                p=2 ** 1000,
+                q=DSA_KEY_1024.public_numbers.parameter_numbers.q,
+                g=DSA_KEY_1024.public_numbers.parameter_numbers.g,
+            ).parameters(backend)
+
+        # Test a p < 2048 bits in length
+        with pytest.raises(ValueError):
+            dsa.DSAParameterNumbers(
+                p=2 ** 2000,
+                q=DSA_KEY_2048.public_numbers.parameter_numbers.q,
+                g=DSA_KEY_2048.public_numbers.parameter_numbers.g,
+            ).parameters(backend)
+
+        # Test a p < 3072 bits in length
+        with pytest.raises(ValueError):
+            dsa.DSAParameterNumbers(
+                p=2 ** 3000,
+                q=DSA_KEY_3072.public_numbers.parameter_numbers.q,
+                g=DSA_KEY_3072.public_numbers.parameter_numbers.g,
+            ).parameters(backend)
+
+        # Test a p > 3072 bits in length
+        with pytest.raises(ValueError):
+            dsa.DSAParameterNumbers(
+                p=2 ** 3100,
+                q=DSA_KEY_3072.public_numbers.parameter_numbers.q,
+                g=DSA_KEY_3072.public_numbers.parameter_numbers.g,
+            ).parameters(backend)
+
+        # Test a q < 160 bits in length
+        with pytest.raises(ValueError):
+            dsa.DSAParameterNumbers(
+                p=DSA_KEY_1024.public_numbers.parameter_numbers.p,
+                q=2 ** 150,
+                g=DSA_KEY_1024.public_numbers.parameter_numbers.g,
+            ).parameters(backend)
+
+        # Test a q < 256 bits in length
+        with pytest.raises(ValueError):
+            dsa.DSAParameterNumbers(
+                p=DSA_KEY_2048.public_numbers.parameter_numbers.p,
+                q=2 ** 250,
+                g=DSA_KEY_2048.public_numbers.parameter_numbers.g
+            ).parameters(backend)
+
+        # Test a q > 256 bits in length
+        with pytest.raises(ValueError):
+            dsa.DSAParameterNumbers(
+                p=DSA_KEY_3072.public_numbers.parameter_numbers.p,
+                q=2 ** 260,
+                g=DSA_KEY_3072.public_numbers.parameter_numbers.g,
+            ).parameters(backend)
+
+        # Test a g < 1
+        with pytest.raises(ValueError):
+            dsa.DSAParameterNumbers(
+                p=DSA_KEY_1024.public_numbers.parameter_numbers.p,
+                q=DSA_KEY_1024.public_numbers.parameter_numbers.q,
+                g=0
+            ).parameters(backend)
+
+        # Test a g = 1
+        with pytest.raises(ValueError):
+            dsa.DSAParameterNumbers(
+                p=DSA_KEY_1024.public_numbers.parameter_numbers.p,
+                q=DSA_KEY_1024.public_numbers.parameter_numbers.q,
+                g=1
+            ).parameters(backend)
+
+        # Test a g > p
+        with pytest.raises(ValueError):
+            dsa.DSAParameterNumbers(
+                p=DSA_KEY_1024.public_numbers.parameter_numbers.p,
+                q=DSA_KEY_1024.public_numbers.parameter_numbers.q,
+                g=2 ** 1200
+            ).parameters(backend)
+
+    def test_invalid_dsa_private_key_arguments(self, backend):
+        # Test a p < 1024 bits in length
+        with pytest.raises(ValueError):
+            dsa.DSAPrivateNumbers(
+                public_numbers=dsa.DSAPublicNumbers(
+                    parameter_numbers=dsa.DSAParameterNumbers(
+                        p=2 ** 1000,
+                        q=DSA_KEY_1024.public_numbers.parameter_numbers.q,
+                        g=DSA_KEY_1024.public_numbers.parameter_numbers.g,
+                    ),
+                    y=DSA_KEY_1024.public_numbers.y
+                ),
+                x=DSA_KEY_1024.x
+            ).private_key(backend)
+
+        # Test a p < 2048 bits in length
+        with pytest.raises(ValueError):
+            dsa.DSAPrivateNumbers(
+                public_numbers=dsa.DSAPublicNumbers(
+                    parameter_numbers=dsa.DSAParameterNumbers(
+                        p=2 ** 2000,
+                        q=DSA_KEY_2048.public_numbers.parameter_numbers.q,
+                        g=DSA_KEY_2048.public_numbers.parameter_numbers.g,
+                    ),
+                    y=DSA_KEY_2048.public_numbers.y
+                ),
+                x=DSA_KEY_2048.x,
+            ).private_key(backend)
+
+        # Test a p < 3072 bits in length
+        with pytest.raises(ValueError):
+            dsa.DSAPrivateNumbers(
+                public_numbers=dsa.DSAPublicNumbers(
+                    parameter_numbers=dsa.DSAParameterNumbers(
+                        p=2 ** 3000,
+                        q=DSA_KEY_3072.public_numbers.parameter_numbers.q,
+                        g=DSA_KEY_3072.public_numbers.parameter_numbers.g,
+                    ),
+                    y=DSA_KEY_3072.public_numbers.y
+                ),
+                x=DSA_KEY_3072.x,
+            ).private_key(backend)
+
+        # Test a p > 3072 bits in length
+        with pytest.raises(ValueError):
+            dsa.DSAPrivateNumbers(
+                public_numbers=dsa.DSAPublicNumbers(
+                    parameter_numbers=dsa.DSAParameterNumbers(
+                        p=2 ** 3100,
+                        q=DSA_KEY_3072.public_numbers.parameter_numbers.q,
+                        g=DSA_KEY_3072.public_numbers.parameter_numbers.g,
+                    ),
+                    y=DSA_KEY_3072.public_numbers.y
+                ),
+                x=DSA_KEY_3072.x,
+            ).private_key(backend)
+
+        # Test a q < 160 bits in length
+        with pytest.raises(ValueError):
+            dsa.DSAPrivateNumbers(
+                public_numbers=dsa.DSAPublicNumbers(
+                    parameter_numbers=dsa.DSAParameterNumbers(
+                        p=DSA_KEY_1024.public_numbers.parameter_numbers.p,
+                        q=2 ** 150,
+                        g=DSA_KEY_1024.public_numbers.parameter_numbers.g,
+                    ),
+                    y=DSA_KEY_1024.public_numbers.y
+                ),
+                x=DSA_KEY_1024.x,
+            ).private_key(backend)
+
+        # Test a q < 256 bits in length
+        with pytest.raises(ValueError):
+            dsa.DSAPrivateNumbers(
+                public_numbers=dsa.DSAPublicNumbers(
+                    parameter_numbers=dsa.DSAParameterNumbers(
+                        p=DSA_KEY_2048.public_numbers.parameter_numbers.p,
+                        q=2 ** 250,
+                        g=DSA_KEY_2048.public_numbers.parameter_numbers.g,
+                    ),
+                    y=DSA_KEY_2048.public_numbers.y
+                ),
+                x=DSA_KEY_2048.x,
+            ).private_key(backend)
+
+        # Test a q > 256 bits in length
+        with pytest.raises(ValueError):
+            dsa.DSAPrivateNumbers(
+                public_numbers=dsa.DSAPublicNumbers(
+                    parameter_numbers=dsa.DSAParameterNumbers(
+                        p=DSA_KEY_3072.public_numbers.parameter_numbers.p,
+                        q=2 ** 260,
+                        g=DSA_KEY_3072.public_numbers.parameter_numbers.g,
+                    ),
+                    y=DSA_KEY_3072.public_numbers.y
+                ),
+                x=DSA_KEY_3072.x,
+            ).private_key(backend)
+
+        # Test a g < 1
+        with pytest.raises(ValueError):
+            dsa.DSAPrivateNumbers(
+                public_numbers=dsa.DSAPublicNumbers(
+                    parameter_numbers=dsa.DSAParameterNumbers(
+                        p=DSA_KEY_1024.public_numbers.parameter_numbers.p,
+                        q=DSA_KEY_1024.public_numbers.parameter_numbers.q,
+                        g=0,
+                    ),
+                    y=DSA_KEY_1024.public_numbers.y
+                ),
+                x=DSA_KEY_1024.x,
+            ).private_key(backend)
+
+        # Test a g = 1
+        with pytest.raises(ValueError):
+            dsa.DSAPrivateNumbers(
+                public_numbers=dsa.DSAPublicNumbers(
+                    parameter_numbers=dsa.DSAParameterNumbers(
+                        p=DSA_KEY_1024.public_numbers.parameter_numbers.p,
+                        q=DSA_KEY_1024.public_numbers.parameter_numbers.q,
+                        g=1,
+                    ),
+                    y=DSA_KEY_1024.public_numbers.y
+                ),
+                x=DSA_KEY_1024.x,
+            ).private_key(backend)
+
+        # Test a g > p
+        with pytest.raises(ValueError):
+            dsa.DSAPrivateNumbers(
+                public_numbers=dsa.DSAPublicNumbers(
+                    parameter_numbers=dsa.DSAParameterNumbers(
+                        p=DSA_KEY_1024.public_numbers.parameter_numbers.p,
+                        q=DSA_KEY_1024.public_numbers.parameter_numbers.q,
+                        g=2 ** 1200,
+                    ),
+                    y=DSA_KEY_1024.public_numbers.y
+                ),
+                x=DSA_KEY_1024.x,
+            ).private_key(backend)
+
+        # Test x = 0
+        with pytest.raises(ValueError):
+            dsa.DSAPrivateNumbers(
+                public_numbers=dsa.DSAPublicNumbers(
+                    parameter_numbers=dsa.DSAParameterNumbers(
+                        p=DSA_KEY_1024.public_numbers.parameter_numbers.p,
+                        q=DSA_KEY_1024.public_numbers.parameter_numbers.q,
+                        g=DSA_KEY_1024.public_numbers.parameter_numbers.g,
+                    ),
+                    y=DSA_KEY_1024.public_numbers.y
+                ),
+                x=0,
+            ).private_key(backend)
+
+        # Test x < 0
+        with pytest.raises(ValueError):
+            dsa.DSAPrivateNumbers(
+                public_numbers=dsa.DSAPublicNumbers(
+                    parameter_numbers=dsa.DSAParameterNumbers(
+                        p=DSA_KEY_1024.public_numbers.parameter_numbers.p,
+                        q=DSA_KEY_1024.public_numbers.parameter_numbers.q,
+                        g=DSA_KEY_1024.public_numbers.parameter_numbers.g,
+                    ),
+                    y=DSA_KEY_1024.public_numbers.y
+                ),
+                x=-2,
+            ).private_key(backend)
+
+        # Test x = q
+        with pytest.raises(ValueError):
+            dsa.DSAPrivateNumbers(
+                public_numbers=dsa.DSAPublicNumbers(
+                    parameter_numbers=dsa.DSAParameterNumbers(
+                        p=DSA_KEY_1024.public_numbers.parameter_numbers.p,
+                        q=DSA_KEY_1024.public_numbers.parameter_numbers.q,
+                        g=DSA_KEY_1024.public_numbers.parameter_numbers.g,
+                    ),
+                    y=DSA_KEY_1024.public_numbers.y
+                ),
+                x=2 ** 159,
+            ).private_key(backend)
+
+        # Test x > q
+        with pytest.raises(ValueError):
+            dsa.DSAPrivateNumbers(
+                public_numbers=dsa.DSAPublicNumbers(
+                    parameter_numbers=dsa.DSAParameterNumbers(
+                        p=DSA_KEY_1024.public_numbers.parameter_numbers.p,
+                        q=DSA_KEY_1024.public_numbers.parameter_numbers.q,
+                        g=DSA_KEY_1024.public_numbers.parameter_numbers.g,
+                    ),
+                    y=DSA_KEY_1024.public_numbers.y
+                ),
+                x=2 ** 200,
+            ).private_key(backend)
+
+        # Test y != (g ** x) % p
+        with pytest.raises(ValueError):
+            dsa.DSAPrivateNumbers(
+                public_numbers=dsa.DSAPublicNumbers(
+                    parameter_numbers=dsa.DSAParameterNumbers(
+                        p=DSA_KEY_1024.public_numbers.parameter_numbers.p,
+                        q=DSA_KEY_1024.public_numbers.parameter_numbers.q,
+                        g=DSA_KEY_1024.public_numbers.parameter_numbers.g,
+                    ),
+                    y=2 ** 100
+                ),
+                x=DSA_KEY_1024.x,
+            ).private_key(backend)
+
+        # Test a non-integer y value
+        with pytest.raises(TypeError):
+            dsa.DSAPrivateNumbers(
+                public_numbers=dsa.DSAPublicNumbers(
+                    parameter_numbers=dsa.DSAParameterNumbers(
+                        p=DSA_KEY_1024.public_numbers.parameter_numbers.p,
+                        q=DSA_KEY_1024.public_numbers.parameter_numbers.q,
+                        g=DSA_KEY_1024.public_numbers.parameter_numbers.g,
+                    ),
+                    y=None
+                ),
+                x=DSA_KEY_1024.x,
+            ).private_key(backend)
+
+        # Test a non-integer x value
+        with pytest.raises(TypeError):
+            dsa.DSAPrivateNumbers(
+                public_numbers=dsa.DSAPublicNumbers(
+                    parameter_numbers=dsa.DSAParameterNumbers(
+                        p=DSA_KEY_1024.public_numbers.parameter_numbers.p,
+                        q=DSA_KEY_1024.public_numbers.parameter_numbers.q,
+                        g=DSA_KEY_1024.public_numbers.parameter_numbers.g,
+                    ),
+                    y=DSA_KEY_1024.public_numbers.y
+                ),
+                x=None,
+            ).private_key(backend)
+
+    def test_invalid_dsa_public_key_arguments(self, backend):
+        # Test a p < 1024 bits in length
+        with pytest.raises(ValueError):
+            dsa.DSAPublicNumbers(
+                parameter_numbers=dsa.DSAParameterNumbers(
+                    p=2 ** 1000,
+                    q=DSA_KEY_1024.public_numbers.parameter_numbers.q,
+                    g=DSA_KEY_1024.public_numbers.parameter_numbers.g,
+                ),
+                y=DSA_KEY_1024.public_numbers.y
+            ).public_key(backend)
+
+        # Test a p < 2048 bits in length
+        with pytest.raises(ValueError):
+            dsa.DSAPublicNumbers(
+                parameter_numbers=dsa.DSAParameterNumbers(
+                    p=2 ** 2000,
+                    q=DSA_KEY_2048.public_numbers.parameter_numbers.q,
+                    g=DSA_KEY_2048.public_numbers.parameter_numbers.g,
+                ),
+                y=DSA_KEY_2048.public_numbers.y
+            ).public_key(backend)
+
+        # Test a p < 3072 bits in length
+        with pytest.raises(ValueError):
+            dsa.DSAPublicNumbers(
+                parameter_numbers=dsa.DSAParameterNumbers(
+                    p=2 ** 3000,
+                    q=DSA_KEY_3072.public_numbers.parameter_numbers.q,
+                    g=DSA_KEY_3072.public_numbers.parameter_numbers.g,
+                ),
+                y=DSA_KEY_3072.public_numbers.y
+            ).public_key(backend)
+
+        # Test a p > 3072 bits in length
+        with pytest.raises(ValueError):
+            dsa.DSAPublicNumbers(
+                parameter_numbers=dsa.DSAParameterNumbers(
+                    p=2 ** 3100,
+                    q=DSA_KEY_3072.public_numbers.parameter_numbers.q,
+                    g=DSA_KEY_3072.public_numbers.parameter_numbers.g,
+                ),
+                y=DSA_KEY_3072.public_numbers.y
+            ).public_key(backend)
+
+        # Test a q < 160 bits in length
+        with pytest.raises(ValueError):
+            dsa.DSAPublicNumbers(
+                parameter_numbers=dsa.DSAParameterNumbers(
+                    p=DSA_KEY_1024.public_numbers.parameter_numbers.p,
+                    q=2 ** 150,
+                    g=DSA_KEY_1024.public_numbers.parameter_numbers.g,
+                ),
+                y=DSA_KEY_1024.public_numbers.y
+            ).public_key(backend)
+
+        # Test a q < 256 bits in length
+        with pytest.raises(ValueError):
+            dsa.DSAPublicNumbers(
+                parameter_numbers=dsa.DSAParameterNumbers(
+                    p=DSA_KEY_2048.public_numbers.parameter_numbers.p,
+                    q=2 ** 250,
+                    g=DSA_KEY_2048.public_numbers.parameter_numbers.g,
+                ),
+                y=DSA_KEY_2048.public_numbers.y
+            ).public_key(backend)
+
+        # Test a q > 256 bits in length
+        with pytest.raises(ValueError):
+            dsa.DSAPublicNumbers(
+                parameter_numbers=dsa.DSAParameterNumbers(
+                    p=DSA_KEY_3072.public_numbers.parameter_numbers.p,
+                    q=2 ** 260,
+                    g=DSA_KEY_3072.public_numbers.parameter_numbers.g,
+                ),
+                y=DSA_KEY_3072.public_numbers.y
+            ).public_key(backend)
+
+        # Test a g < 1
+        with pytest.raises(ValueError):
+            dsa.DSAPublicNumbers(
+                parameter_numbers=dsa.DSAParameterNumbers(
+                    p=DSA_KEY_1024.public_numbers.parameter_numbers.p,
+                    q=DSA_KEY_1024.public_numbers.parameter_numbers.q,
+                    g=0,
+                ),
+                y=DSA_KEY_1024.public_numbers.y
+            ).public_key(backend)
+
+        # Test a g = 1
+        with pytest.raises(ValueError):
+            dsa.DSAPublicNumbers(
+                parameter_numbers=dsa.DSAParameterNumbers(
+                    p=DSA_KEY_1024.public_numbers.parameter_numbers.p,
+                    q=DSA_KEY_1024.public_numbers.parameter_numbers.q,
+                    g=1,
+                ),
+                y=DSA_KEY_1024.public_numbers.y
+            ).public_key(backend)
+
+        # Test a g > p
+        with pytest.raises(ValueError):
+            dsa.DSAPublicNumbers(
+                parameter_numbers=dsa.DSAParameterNumbers(
+                    p=DSA_KEY_1024.public_numbers.parameter_numbers.p,
+                    q=DSA_KEY_1024.public_numbers.parameter_numbers.q,
+                    g=2 ** 1200,
+                ),
+                y=DSA_KEY_1024.public_numbers.y
+            ).public_key(backend)
+
+        # Test a non-integer y value
+        with pytest.raises(TypeError):
+            dsa.DSAPublicNumbers(
+                parameter_numbers=dsa.DSAParameterNumbers(
+                    p=DSA_KEY_1024.public_numbers.parameter_numbers.p,
+                    q=DSA_KEY_1024.public_numbers.parameter_numbers.q,
+                    g=DSA_KEY_1024.public_numbers.parameter_numbers.g,
+                ),
+                y=None
+            ).public_key(backend)
+
+
+@pytest.mark.requires_backend_interface(interface=DSABackend)
+class TestDSAVerification(object):
+    _algorithms_dict = {
+        'SHA1': hashes.SHA1,
+        'SHA224': hashes.SHA224,
+        'SHA256': hashes.SHA256,
+        'SHA384': hashes.SHA384,
+        'SHA512': hashes.SHA512
+    }
+
+    @pytest.mark.parametrize(
+        "vector",
+        load_vectors_from_file(
+            os.path.join(
+                "asymmetric", "DSA", "FIPS_186-3", "SigVer.rsp"),
+            load_fips_dsa_sig_vectors
+        )
+    )
+    def test_dsa_verification(self, vector, backend):
+        digest_algorithm = vector['digest_algorithm'].replace("-", "")
+        algorithm = self._algorithms_dict[digest_algorithm]
+        if (
+            not backend.dsa_parameters_supported(
+                vector['p'], vector['q'], vector['g']
+            ) or not backend.dsa_hash_supported(algorithm)
+        ):
+            pytest.skip(
+                "{0} does not support the provided parameters".format(backend)
+            )
+
+        public_key = dsa.DSAPublicNumbers(
+            parameter_numbers=dsa.DSAParameterNumbers(
+                vector['p'], vector['q'], vector['g']
+            ),
+            y=vector['y']
+        ).public_key(backend)
+        sig = encode_dss_signature(vector['r'], vector['s'])
+        verifier = public_key.verifier(sig, algorithm())
+        verifier.update(vector['msg'])
+        if vector['result'] == "F":
+            with pytest.raises(InvalidSignature):
+                verifier.verify()
+        else:
+            verifier.verify()
+
+    def test_dsa_verify_invalid_asn1(self, backend):
+        public_key = DSA_KEY_1024.public_numbers.public_key(backend)
+        verifier = public_key.verifier(b'fakesig', hashes.SHA1())
+        verifier.update(b'fakesig')
+        with pytest.raises(InvalidSignature):
+            verifier.verify()
+
+    def test_signature_not_bytes(self, backend):
+        public_key = DSA_KEY_1024.public_numbers.public_key(backend)
+        with pytest.raises(TypeError):
+            public_key.verifier(1234, hashes.SHA1())
+
+    def test_use_after_finalize(self, backend):
+        public_key = DSA_KEY_1024.public_numbers.public_key(backend)
+        verifier = public_key.verifier(b'fakesig', hashes.SHA1())
+        verifier.update(b'irrelevant')
+        with pytest.raises(InvalidSignature):
+            verifier.verify()
+        with pytest.raises(AlreadyFinalized):
+            verifier.verify()
+        with pytest.raises(AlreadyFinalized):
+            verifier.update(b"more data")
+
+
+@pytest.mark.requires_backend_interface(interface=DSABackend)
+class TestDSASignature(object):
+    _algorithms_dict = {
+        'SHA1': hashes.SHA1,
+        'SHA224': hashes.SHA224,
+        'SHA256': hashes.SHA256,
+        'SHA384': hashes.SHA384,
+        'SHA512': hashes.SHA512}
+
+    @pytest.mark.parametrize(
+        "vector",
+        load_vectors_from_file(
+            os.path.join(
+                "asymmetric", "DSA", "FIPS_186-3", "SigGen.txt"),
+            load_fips_dsa_sig_vectors
+        )
+    )
+    def test_dsa_signing(self, vector, backend):
+        digest_algorithm = vector['digest_algorithm'].replace("-", "")
+        algorithm = self._algorithms_dict[digest_algorithm]
+        if (
+            not backend.dsa_parameters_supported(
+                vector['p'], vector['q'], vector['g']
+            ) or not backend.dsa_hash_supported(algorithm)
+        ):
+            pytest.skip(
+                "{0} does not support the provided parameters".format(backend)
+            )
+
+        private_key = dsa.DSAPrivateNumbers(
+            public_numbers=dsa.DSAPublicNumbers(
+                parameter_numbers=dsa.DSAParameterNumbers(
+                    vector['p'], vector['q'], vector['g']
+                ),
+                y=vector['y']
+            ),
+            x=vector['x']
+        ).private_key(backend)
+        signer = private_key.signer(algorithm())
+        signer.update(vector['msg'])
+        signature = signer.finalize()
+        assert signature
+
+        public_key = private_key.public_key()
+        verifier = public_key.verifier(signature, algorithm())
+        verifier.update(vector['msg'])
+        verifier.verify()
+
+    def test_use_after_finalize(self, backend):
+        private_key = DSA_KEY_1024.private_key(backend)
+        signer = private_key.signer(hashes.SHA1())
+        signer.update(b"data")
+        signer.finalize()
+        with pytest.raises(AlreadyFinalized):
+            signer.finalize()
+        with pytest.raises(AlreadyFinalized):
+            signer.update(b"more data")
+
+
+class TestDSANumbers(object):
+    def test_dsa_parameter_numbers(self):
+        parameter_numbers = dsa.DSAParameterNumbers(p=1, q=2, g=3)
+        assert parameter_numbers.p == 1
+        assert parameter_numbers.q == 2
+        assert parameter_numbers.g == 3
+
+    def test_dsa_parameter_numbers_invalid_types(self):
+        with pytest.raises(TypeError):
+            dsa.DSAParameterNumbers(p=None, q=2, g=3)
+
+        with pytest.raises(TypeError):
+            dsa.DSAParameterNumbers(p=1, q=None, g=3)
+
+        with pytest.raises(TypeError):
+            dsa.DSAParameterNumbers(p=1, q=2, g=None)
+
+    def test_dsa_public_numbers(self):
+        parameter_numbers = dsa.DSAParameterNumbers(p=1, q=2, g=3)
+        public_numbers = dsa.DSAPublicNumbers(
+            y=4,
+            parameter_numbers=parameter_numbers
+        )
+        assert public_numbers.y == 4
+        assert public_numbers.parameter_numbers == parameter_numbers
+
+    def test_dsa_public_numbers_invalid_types(self):
+        with pytest.raises(TypeError):
+            dsa.DSAPublicNumbers(y=4, parameter_numbers=None)
+
+        with pytest.raises(TypeError):
+            parameter_numbers = dsa.DSAParameterNumbers(p=1, q=2, g=3)
+            dsa.DSAPublicNumbers(y=None, parameter_numbers=parameter_numbers)
+
+    def test_dsa_private_numbers(self):
+        parameter_numbers = dsa.DSAParameterNumbers(p=1, q=2, g=3)
+        public_numbers = dsa.DSAPublicNumbers(
+            y=4,
+            parameter_numbers=parameter_numbers
+        )
+        private_numbers = dsa.DSAPrivateNumbers(
+            x=5,
+            public_numbers=public_numbers
+        )
+        assert private_numbers.x == 5
+        assert private_numbers.public_numbers == public_numbers
+
+    def test_dsa_private_numbers_invalid_types(self):
+        parameter_numbers = dsa.DSAParameterNumbers(p=1, q=2, g=3)
+        public_numbers = dsa.DSAPublicNumbers(
+            y=4,
+            parameter_numbers=parameter_numbers
+        )
+        with pytest.raises(TypeError):
+            dsa.DSAPrivateNumbers(x=4, public_numbers=None)
+
+        with pytest.raises(TypeError):
+            dsa.DSAPrivateNumbers(x=None, public_numbers=public_numbers)
+
+
+class TestDSANumberEquality(object):
+    def test_parameter_numbers_eq(self):
+        param = dsa.DSAParameterNumbers(1, 2, 3)
+        assert param == dsa.DSAParameterNumbers(1, 2, 3)
+
+    def test_parameter_numbers_ne(self):
+        param = dsa.DSAParameterNumbers(1, 2, 3)
+        assert param != dsa.DSAParameterNumbers(1, 2, 4)
+        assert param != dsa.DSAParameterNumbers(1, 1, 3)
+        assert param != dsa.DSAParameterNumbers(2, 2, 3)
+        assert param != object()
+
+    def test_public_numbers_eq(self):
+        pub = dsa.DSAPublicNumbers(1, dsa.DSAParameterNumbers(1, 2, 3))
+        assert pub == dsa.DSAPublicNumbers(1, dsa.DSAParameterNumbers(1, 2, 3))
+
+    def test_public_numbers_ne(self):
+        pub = dsa.DSAPublicNumbers(1, dsa.DSAParameterNumbers(1, 2, 3))
+        assert pub != dsa.DSAPublicNumbers(2, dsa.DSAParameterNumbers(1, 2, 3))
+        assert pub != dsa.DSAPublicNumbers(1, dsa.DSAParameterNumbers(2, 2, 3))
+        assert pub != dsa.DSAPublicNumbers(1, dsa.DSAParameterNumbers(1, 3, 3))
+        assert pub != dsa.DSAPublicNumbers(1, dsa.DSAParameterNumbers(1, 2, 4))
+        assert pub != object()
+
+    def test_private_numbers_eq(self):
+        pub = dsa.DSAPublicNumbers(1, dsa.DSAParameterNumbers(1, 2, 3))
+        priv = dsa.DSAPrivateNumbers(1, pub)
+        assert priv == dsa.DSAPrivateNumbers(
+            1, dsa.DSAPublicNumbers(
+                1, dsa.DSAParameterNumbers(1, 2, 3)
+            )
+        )
+
+    def test_private_numbers_ne(self):
+        pub = dsa.DSAPublicNumbers(1, dsa.DSAParameterNumbers(1, 2, 3))
+        priv = dsa.DSAPrivateNumbers(1, pub)
+        assert priv != dsa.DSAPrivateNumbers(
+            2, dsa.DSAPublicNumbers(
+                1, dsa.DSAParameterNumbers(1, 2, 3)
+            )
+        )
+        assert priv != dsa.DSAPrivateNumbers(
+            1, dsa.DSAPublicNumbers(
+                2, dsa.DSAParameterNumbers(1, 2, 3)
+            )
+        )
+        assert priv != dsa.DSAPrivateNumbers(
+            1, dsa.DSAPublicNumbers(
+                1, dsa.DSAParameterNumbers(2, 2, 3)
+            )
+        )
+        assert priv != dsa.DSAPrivateNumbers(
+            1, dsa.DSAPublicNumbers(
+                1, dsa.DSAParameterNumbers(1, 3, 3)
+            )
+        )
+        assert priv != dsa.DSAPrivateNumbers(
+            1, dsa.DSAPublicNumbers(
+                1, dsa.DSAParameterNumbers(1, 2, 4)
+            )
+        )
+        assert priv != object()
+
+
+@pytest.mark.requires_backend_interface(interface=DSABackend)
+@pytest.mark.requires_backend_interface(interface=PEMSerializationBackend)
+class TestDSASerialization(object):
+    @pytest.mark.parametrize(
+        ("fmt", "password"),
+        itertools.product(
+            [
+                serialization.PrivateFormat.TraditionalOpenSSL,
+                serialization.PrivateFormat.PKCS8
+            ],
+            [
+                b"s",
+                b"longerpassword",
+                b"!*$&(@#$*&($T@%_somesymbols",
+                b"\x01" * 1000,
+            ]
+        )
+    )
+    def test_private_bytes_encrypted_pem(self, backend, fmt, password):
+        key_bytes = load_vectors_from_file(
+            os.path.join("asymmetric", "PKCS8", "unenc-dsa-pkcs8.pem"),
+            lambda pemfile: pemfile.read().encode()
+        )
+        key = serialization.load_pem_private_key(key_bytes, None, backend)
+        serialized = key.private_bytes(
+            serialization.Encoding.PEM,
+            fmt,
+            serialization.BestAvailableEncryption(password)
+        )
+        loaded_key = serialization.load_pem_private_key(
+            serialized, password, backend
+        )
+        loaded_priv_num = loaded_key.private_numbers()
+        priv_num = key.private_numbers()
+        assert loaded_priv_num == priv_num
+
+    @pytest.mark.parametrize(
+        ("fmt", "password"),
+        [
+            [serialization.PrivateFormat.PKCS8, b"s"],
+            [serialization.PrivateFormat.PKCS8, b"longerpassword"],
+            [serialization.PrivateFormat.PKCS8, b"!*$&(@#$*&($T@%_somesymbol"],
+            [serialization.PrivateFormat.PKCS8, b"\x01" * 1000]
+        ]
+    )
+    def test_private_bytes_encrypted_der(self, backend, fmt, password):
+        key_bytes = load_vectors_from_file(
+            os.path.join("asymmetric", "PKCS8", "unenc-dsa-pkcs8.pem"),
+            lambda pemfile: pemfile.read().encode()
+        )
+        key = serialization.load_pem_private_key(key_bytes, None, backend)
+        serialized = key.private_bytes(
+            serialization.Encoding.DER,
+            fmt,
+            serialization.BestAvailableEncryption(password)
+        )
+        loaded_key = serialization.load_der_private_key(
+            serialized, password, backend
+        )
+        loaded_priv_num = loaded_key.private_numbers()
+        priv_num = key.private_numbers()
+        assert loaded_priv_num == priv_num
+
+    @pytest.mark.parametrize(
+        ("encoding", "fmt", "loader_func"),
+        [
+            [
+                serialization.Encoding.PEM,
+                serialization.PrivateFormat.TraditionalOpenSSL,
+                serialization.load_pem_private_key
+            ],
+            [
+                serialization.Encoding.DER,
+                serialization.PrivateFormat.TraditionalOpenSSL,
+                serialization.load_der_private_key
+            ],
+            [
+                serialization.Encoding.PEM,
+                serialization.PrivateFormat.PKCS8,
+                serialization.load_pem_private_key
+            ],
+            [
+                serialization.Encoding.DER,
+                serialization.PrivateFormat.PKCS8,
+                serialization.load_der_private_key
+            ],
+        ]
+    )
+    def test_private_bytes_unencrypted(self, backend, encoding, fmt,
+                                       loader_func):
+        key = DSA_KEY_1024.private_key(backend)
+        serialized = key.private_bytes(
+            encoding, fmt, serialization.NoEncryption()
+        )
+        loaded_key = loader_func(serialized, None, backend)
+        loaded_priv_num = loaded_key.private_numbers()
+        priv_num = key.private_numbers()
+        assert loaded_priv_num == priv_num
+
+    @pytest.mark.parametrize(
+        ("key_path", "encoding", "loader_func"),
+        [
+            [
+                os.path.join(
+                    "asymmetric",
+                    "Traditional_OpenSSL_Serialization",
+                    "dsa.1024.pem"
+                ),
+                serialization.Encoding.PEM,
+                serialization.load_pem_private_key
+            ],
+            [
+                os.path.join(
+                    "asymmetric", "DER_Serialization", "dsa.1024.der"
+                ),
+                serialization.Encoding.DER,
+                serialization.load_der_private_key
+            ],
+        ]
+    )
+    def test_private_bytes_traditional_openssl_unencrypted(
+        self, backend, key_path, encoding, loader_func
+    ):
+        key_bytes = load_vectors_from_file(
+            key_path, lambda pemfile: pemfile.read(), mode="rb"
+        )
+        key = loader_func(key_bytes, None, backend)
+        serialized = key.private_bytes(
+            encoding,
+            serialization.PrivateFormat.TraditionalOpenSSL,
+            serialization.NoEncryption()
+        )
+        assert serialized == key_bytes
+
+    def test_private_bytes_traditional_der_encrypted_invalid(self, backend):
+        key = DSA_KEY_1024.private_key(backend)
+        with pytest.raises(ValueError):
+            key.private_bytes(
+                serialization.Encoding.DER,
+                serialization.PrivateFormat.TraditionalOpenSSL,
+                serialization.BestAvailableEncryption(b"password")
+            )
+
+    def test_private_bytes_invalid_encoding(self, backend):
+        key = load_vectors_from_file(
+            os.path.join("asymmetric", "PKCS8", "unenc-dsa-pkcs8.pem"),
+            lambda pemfile: serialization.load_pem_private_key(
+                pemfile.read().encode(), None, backend
+            )
+        )
+        with pytest.raises(TypeError):
+            key.private_bytes(
+                "notencoding",
+                serialization.PrivateFormat.PKCS8,
+                serialization.NoEncryption()
+            )
+
+    def test_private_bytes_invalid_format(self, backend):
+        key = load_vectors_from_file(
+            os.path.join("asymmetric", "PKCS8", "unenc-dsa-pkcs8.pem"),
+            lambda pemfile: serialization.load_pem_private_key(
+                pemfile.read().encode(), None, backend
+            )
+        )
+        with pytest.raises(TypeError):
+            key.private_bytes(
+                serialization.Encoding.PEM,
+                "invalidformat",
+                serialization.NoEncryption()
+            )
+
+    def test_private_bytes_invalid_encryption_algorithm(self, backend):
+        key = load_vectors_from_file(
+            os.path.join("asymmetric", "PKCS8", "unenc-dsa-pkcs8.pem"),
+            lambda pemfile: serialization.load_pem_private_key(
+                pemfile.read().encode(), None, backend
+            )
+        )
+        with pytest.raises(TypeError):
+            key.private_bytes(
+                serialization.Encoding.PEM,
+                serialization.PrivateFormat.TraditionalOpenSSL,
+                "notanencalg"
+            )
+
+    def test_private_bytes_unsupported_encryption_type(self, backend):
+        key = load_vectors_from_file(
+            os.path.join("asymmetric", "PKCS8", "unenc-dsa-pkcs8.pem"),
+            lambda pemfile: serialization.load_pem_private_key(
+                pemfile.read().encode(), None, backend
+            )
+        )
+        with pytest.raises(ValueError):
+            key.private_bytes(
+                serialization.Encoding.PEM,
+                serialization.PrivateFormat.TraditionalOpenSSL,
+                DummyKeyEncryption()
+            )
+
+
+@pytest.mark.requires_backend_interface(interface=DSABackend)
+@pytest.mark.requires_backend_interface(interface=PEMSerializationBackend)
+class TestDSAPEMPublicKeySerialization(object):
+    @pytest.mark.parametrize(
+        ("key_path", "loader_func", "encoding"),
+        [
+            (
+                os.path.join("asymmetric", "PKCS8", "unenc-dsa-pkcs8.pub.pem"),
+                serialization.load_pem_public_key,
+                serialization.Encoding.PEM,
+            ), (
+                os.path.join(
+                    "asymmetric",
+                    "DER_Serialization",
+                    "unenc-dsa-pkcs8.pub.der"
+                ),
+                serialization.load_der_public_key,
+                serialization.Encoding.DER,
+            )
+        ]
+    )
+    def test_public_bytes_match(self, key_path, loader_func, encoding,
+                                backend):
+        key_bytes = load_vectors_from_file(
+            key_path, lambda pemfile: pemfile.read(), mode="rb"
+        )
+        key = loader_func(key_bytes, backend)
+        serialized = key.public_bytes(
+            encoding, serialization.PublicFormat.SubjectPublicKeyInfo,
+        )
+        assert serialized == key_bytes
+
+    def test_public_bytes_invalid_encoding(self, backend):
+        key = DSA_KEY_2048.private_key(backend).public_key()
+        with pytest.raises(TypeError):
+            key.public_bytes(
+                "notencoding",
+                serialization.PublicFormat.SubjectPublicKeyInfo
+            )
+
+    def test_public_bytes_invalid_format(self, backend):
+        key = DSA_KEY_2048.private_key(backend).public_key()
+        with pytest.raises(TypeError):
+            key.public_bytes(serialization.Encoding.PEM, "invalidformat")
+
+    def test_public_bytes_pkcs1_unsupported(self, backend):
+        key = DSA_KEY_2048.private_key(backend).public_key()
+        with pytest.raises(ValueError):
+            key.public_bytes(
+                serialization.Encoding.PEM, serialization.PublicFormat.PKCS1
+            )
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_ec.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_ec.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_ec.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_ec.py	2015-11-19 05:01:40.000000000 +0100
@@ -0,0 +1,918 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import binascii
+import itertools
+import os
+
+from binascii import hexlify
+
+import pytest
+
+from cryptography import exceptions, utils
+from cryptography.hazmat.backends.interfaces import (
+    EllipticCurveBackend, PEMSerializationBackend
+)
+from cryptography.hazmat.primitives import hashes, serialization
+from cryptography.hazmat.primitives.asymmetric import ec
+from cryptography.hazmat.primitives.asymmetric.utils import (
+    encode_rfc6979_signature
+)
+
+from ...utils import (
+    load_fips_ecdsa_key_pair_vectors, load_fips_ecdsa_signing_vectors,
+    load_kasvs_ecdh_vectors, load_vectors_from_file,
+    raises_unsupported_algorithm
+)
+
+_HASH_TYPES = {
+    "SHA-1": hashes.SHA1,
+    "SHA-224": hashes.SHA224,
+    "SHA-256": hashes.SHA256,
+    "SHA-384": hashes.SHA384,
+    "SHA-512": hashes.SHA512,
+}
+
+
+def _skip_ecdsa_vector(backend, curve_type, hash_type):
+    if not backend.elliptic_curve_signature_algorithm_supported(
+        ec.ECDSA(hash_type()),
+        curve_type()
+    ):
+        pytest.skip(
+            "ECDSA not supported with this hash {0} and curve {1}".format(
+                hash_type().name, curve_type().name
+            )
+        )
+
+
+def _skip_curve_unsupported(backend, curve):
+    if not backend.elliptic_curve_supported(curve):
+        pytest.skip(
+            "Curve {0} is not supported by this backend {1}".format(
+                curve.name, backend
+            )
+        )
+
+
+def _skip_exchange_algorithm_unsupported(backend, algorithm, curve):
+    if not backend.elliptic_curve_exchange_algorithm_supported(
+        algorithm, curve
+    ):
+        pytest.skip(
+            "Exchange algorithm is not supported by this backend {0}".format(
+                backend
+            )
+        )
+
+
+@utils.register_interface(ec.EllipticCurve)
+class DummyCurve(object):
+    name = "dummy-curve"
+    key_size = 1
+
+
+@utils.register_interface(ec.EllipticCurveSignatureAlgorithm)
+class DummySignatureAlgorithm(object):
+    algorithm = None
+
+
+@utils.register_interface(serialization.KeySerializationEncryption)
+class DummyKeyEncryption(object):
+    pass
+
+
+@pytest.mark.requires_backend_interface(interface=EllipticCurveBackend)
+def test_skip_curve_unsupported(backend):
+    with pytest.raises(pytest.skip.Exception):
+        _skip_curve_unsupported(backend, DummyCurve())
+
+
+@pytest.mark.requires_backend_interface(interface=EllipticCurveBackend)
+def test_skip_exchange_algorithm_unsupported(backend):
+    with pytest.raises(pytest.skip.Exception):
+        _skip_exchange_algorithm_unsupported(backend, ec.ECDH(), DummyCurve())
+
+
+def test_ec_numbers():
+    numbers = ec.EllipticCurvePrivateNumbers(
+        1,
+        ec.EllipticCurvePublicNumbers(
+            2, 3, DummyCurve()
+        )
+    )
+
+    assert numbers.private_value == 1
+    assert numbers.public_numbers.x == 2
+    assert numbers.public_numbers.y == 3
+    assert isinstance(numbers.public_numbers.curve, DummyCurve)
+
+    with pytest.raises(TypeError):
+        ec.EllipticCurvePrivateNumbers(
+            None,
+            ec.EllipticCurvePublicNumbers(
+                2, 3, DummyCurve()
+            )
+        )
+
+    with pytest.raises(TypeError):
+        ec.EllipticCurvePrivateNumbers(
+            1,
+            ec.EllipticCurvePublicNumbers(
+                None, 3, DummyCurve()
+            )
+        )
+
+    with pytest.raises(TypeError):
+        ec.EllipticCurvePrivateNumbers(
+            1,
+            ec.EllipticCurvePublicNumbers(
+                2, None, DummyCurve()
+            )
+        )
+
+    with pytest.raises(TypeError):
+        ec.EllipticCurvePrivateNumbers(
+            1,
+            ec.EllipticCurvePublicNumbers(
+                2, 3, None
+            )
+        )
+
+    with pytest.raises(TypeError):
+        ec.EllipticCurvePrivateNumbers(
+            1,
+            None
+        )
+
+
+def test_encode_point():
+    # secp256r1 point
+    x = int(
+        '233ea3b0027127084cd2cd336a13aeef69c598d8af61369a36454a17c6c22aec',
+        16
+    )
+    y = int(
+        '3ea2c10a84153862be4ec82940f0543f9ba866af9751a6ee79d38460b35f442e',
+        16
+    )
+    pn = ec.EllipticCurvePublicNumbers(x, y, ec.SECP256R1())
+    data = pn.encode_point()
+    assert data == binascii.unhexlify(
+        "04233ea3b0027127084cd2cd336a13aeef69c598d8af61369a36454a17c6c22ae"
+        "c3ea2c10a84153862be4ec82940f0543f9ba866af9751a6ee79d38460b35f442e"
+    )
+
+
+def test_from_encoded_point():
+    # secp256r1 point
+    data = binascii.unhexlify(
+        "04233ea3b0027127084cd2cd336a13aeef69c598d8af61369a36454a17c6c22ae"
+        "c3ea2c10a84153862be4ec82940f0543f9ba866af9751a6ee79d38460b35f442e"
+    )
+    pn = ec.EllipticCurvePublicNumbers.from_encoded_point(
+        ec.SECP256R1(), data
+    )
+    assert pn.x == int(
+        '233ea3b0027127084cd2cd336a13aeef69c598d8af61369a36454a17c6c22aec',
+        16
+    )
+    assert pn.y == int(
+        '3ea2c10a84153862be4ec82940f0543f9ba866af9751a6ee79d38460b35f442e',
+        16
+    )
+
+
+def test_from_encoded_point_invalid_length():
+    bad_data = binascii.unhexlify(
+        "04233ea3b0027127084cd2cd336a13aeef69c598d8af61369a36454a17c6c22ae"
+        "c3ea2c10a84153862be4ec82940f0543f9ba866af9751a6ee79d38460"
+    )
+    with pytest.raises(ValueError):
+        ec.EllipticCurvePublicNumbers.from_encoded_point(
+            ec.SECP384R1(), bad_data
+        )
+
+
+def test_from_encoded_point_unsupported_point_type():
+    # set to point type 2.
+    unsupported_type = binascii.unhexlify(
+        "02233ea3b0027127084cd2cd336a13aeef69c598d8af61369a36454a17c6c22a"
+    )
+    with pytest.raises(ValueError):
+        ec.EllipticCurvePublicNumbers.from_encoded_point(
+            ec.SECP256R1(), unsupported_type
+        )
+
+
+def test_from_encoded_point_not_a_curve():
+    with pytest.raises(TypeError):
+        ec.EllipticCurvePublicNumbers.from_encoded_point(
+            "notacurve", b"\x04data"
+        )
+
+
+def test_ec_public_numbers_repr():
+    pn = ec.EllipticCurvePublicNumbers(2, 3, ec.SECP256R1())
+    assert repr(pn) == "<EllipticCurvePublicNumbers(curve=secp256r1, x=2, y=3>"
+
+
+@pytest.mark.requires_backend_interface(interface=EllipticCurveBackend)
+class TestECWithNumbers(object):
+    @pytest.mark.parametrize(
+        ("vector", "hash_type"),
+        list(itertools.product(
+            load_vectors_from_file(
+                os.path.join(
+                    "asymmetric", "ECDSA", "FIPS_186-3", "KeyPair.rsp"),
+                load_fips_ecdsa_key_pair_vectors
+            ),
+            _HASH_TYPES.values()
+        ))
+    )
+    def test_with_numbers(self, backend, vector, hash_type):
+        curve_type = ec._CURVE_TYPES[vector['curve']]
+
+        _skip_ecdsa_vector(backend, curve_type, hash_type)
+
+        key = ec.EllipticCurvePrivateNumbers(
+            vector['d'],
+            ec.EllipticCurvePublicNumbers(
+                vector['x'],
+                vector['y'],
+                curve_type()
+            )
+        ).private_key(backend)
+        assert key
+
+        priv_num = key.private_numbers()
+        assert priv_num.private_value == vector['d']
+        assert priv_num.public_numbers.x == vector['x']
+        assert priv_num.public_numbers.y == vector['y']
+        assert curve_type().name == priv_num.public_numbers.curve.name
+
+
+@pytest.mark.requires_backend_interface(interface=EllipticCurveBackend)
+class TestECDSAVectors(object):
+    @pytest.mark.parametrize(
+        ("vector", "hash_type"),
+        list(itertools.product(
+            load_vectors_from_file(
+                os.path.join(
+                    "asymmetric", "ECDSA", "FIPS_186-3", "KeyPair.rsp"),
+                load_fips_ecdsa_key_pair_vectors
+            ),
+            _HASH_TYPES.values()
+        ))
+    )
+    def test_signing_with_example_keys(self, backend, vector, hash_type):
+        curve_type = ec._CURVE_TYPES[vector['curve']]
+
+        _skip_ecdsa_vector(backend, curve_type, hash_type)
+
+        key = ec.EllipticCurvePrivateNumbers(
+            vector['d'],
+            ec.EllipticCurvePublicNumbers(
+                vector['x'],
+                vector['y'],
+                curve_type()
+            )
+        ).private_key(backend)
+        assert key
+
+        pkey = key.public_key()
+        assert pkey
+
+        signer = key.signer(ec.ECDSA(hash_type()))
+        signer.update(b"YELLOW SUBMARINE")
+        signature = signer.finalize()
+
+        verifier = pkey.verifier(signature, ec.ECDSA(hash_type()))
+        verifier.update(b"YELLOW SUBMARINE")
+        verifier.verify()
+
+    @pytest.mark.parametrize(
+        "curve", ec._CURVE_TYPES.values()
+    )
+    def test_generate_vector_curves(self, backend, curve):
+        _skip_curve_unsupported(backend, curve())
+
+        key = ec.generate_private_key(curve(), backend)
+        assert key
+        assert isinstance(key.curve, curve)
+        assert key.curve.key_size
+
+        pkey = key.public_key()
+        assert pkey
+        assert isinstance(pkey.curve, curve)
+        assert key.curve.key_size == pkey.curve.key_size
+
+    def test_generate_unknown_curve(self, backend):
+        with raises_unsupported_algorithm(
+            exceptions._Reasons.UNSUPPORTED_ELLIPTIC_CURVE
+        ):
+            ec.generate_private_key(DummyCurve(), backend)
+
+        assert backend.elliptic_curve_signature_algorithm_supported(
+            ec.ECDSA(hashes.SHA256()),
+            DummyCurve()
+        ) is False
+
+    def test_unknown_signature_algoritm(self, backend):
+        _skip_curve_unsupported(backend, ec.SECP192R1())
+
+        key = ec.generate_private_key(ec.SECP192R1(), backend)
+
+        with raises_unsupported_algorithm(
+            exceptions._Reasons.UNSUPPORTED_PUBLIC_KEY_ALGORITHM
+        ):
+            key.signer(DummySignatureAlgorithm())
+
+        with raises_unsupported_algorithm(
+            exceptions._Reasons.UNSUPPORTED_PUBLIC_KEY_ALGORITHM
+        ):
+            key.public_key().verifier(b"", DummySignatureAlgorithm())
+
+        assert backend.elliptic_curve_signature_algorithm_supported(
+            DummySignatureAlgorithm(),
+            ec.SECP192R1()
+        ) is False
+
+    def test_load_invalid_ec_key_from_numbers(self, backend):
+        _skip_curve_unsupported(backend, ec.SECP256R1())
+
+        numbers = ec.EllipticCurvePrivateNumbers(
+            357646505660320080863666618182642070958081774038609089496899025506,
+            ec.EllipticCurvePublicNumbers(
+                47250808410327023131573602008345894927686381772325561185532964,
+                1120253292479243545483756778742719537373113335231773536789915,
+                ec.SECP256R1(),
+            )
+        )
+        with pytest.raises(ValueError):
+            numbers.private_key(backend)
+
+        numbers = ec.EllipticCurvePrivateNumbers(
+            357646505660320080863666618182642070958081774038609089496899025506,
+            ec.EllipticCurvePublicNumbers(
+                -4725080841032702313157360200834589492768638177232556118553296,
+                1120253292479243545483756778742719537373113335231773536789915,
+                ec.SECP256R1(),
+            )
+        )
+        with pytest.raises(ValueError):
+            numbers.private_key(backend)
+
+        numbers = ec.EllipticCurvePrivateNumbers(
+            357646505660320080863666618182642070958081774038609089496899025506,
+            ec.EllipticCurvePublicNumbers(
+                47250808410327023131573602008345894927686381772325561185532964,
+                -1120253292479243545483756778742719537373113335231773536789915,
+                ec.SECP256R1(),
+            )
+        )
+        with pytest.raises(ValueError):
+            numbers.private_key(backend)
+
+    def test_load_invalid_public_ec_key_from_numbers(self, backend):
+        _skip_curve_unsupported(backend, ec.SECP521R1())
+
+        # Bad X coordinate
+        numbers = ec.EllipticCurvePublicNumbers(
+            int("000003647356b91f8ace114c7247ecf4f4a622553fc025e04a178f179ef27"
+                "9090c184af678a4c78f635483bdd8aa544851c6ef291c1f0d6a241ebfd145"
+                "77d1d30d9903ce", 16),
+            int("000001499bc7e079322ea0fcfbd6b40103fa6a1536c2257b182db0df4b369"
+                "6ec643adf100eb4f2025d1b873f82e5a475d6e4400ba777090eeb4563a115"
+                "09e4c87319dc26", 16),
+            ec.SECP521R1()
+        )
+        with pytest.raises(ValueError):
+            numbers.public_key(backend)
+
+        # Bad Y coordinate
+        numbers = ec.EllipticCurvePublicNumbers(
+            int("0000019aadc221cc0525118ab6d5aa1f64720603de0be128cbfea0b381ad8"
+                "02a2facc6370bb58cf88b3f0c692bc654ee19d6cad198f10d4b681b396f20"
+                "d2e40603fa945b", 16),
+            int("0000025da392803a320717a08d4cb3dea932039badff363b71bdb8064e726"
+                "6c7f4f4b748d4d425347fc33e3885d34b750fa7fcd5691f4d90c89522ce33"
+                "feff5db10088a5", 16),
+            ec.SECP521R1()
+        )
+        with pytest.raises(ValueError):
+            numbers.public_key(backend)
+
+    @pytest.mark.parametrize(
+        "vector",
+        itertools.chain(
+            load_vectors_from_file(
+                os.path.join(
+                    "asymmetric", "ECDSA", "FIPS_186-3", "SigGen.txt"),
+                load_fips_ecdsa_signing_vectors
+            ),
+            load_vectors_from_file(
+                os.path.join(
+                    "asymmetric", "ECDSA", "SECP256K1", "SigGen.txt"),
+                load_fips_ecdsa_signing_vectors
+            ),
+        )
+    )
+    def test_signatures(self, backend, vector):
+        hash_type = _HASH_TYPES[vector['digest_algorithm']]
+        curve_type = ec._CURVE_TYPES[vector['curve']]
+
+        _skip_ecdsa_vector(backend, curve_type, hash_type)
+
+        key = ec.EllipticCurvePublicNumbers(
+            vector['x'],
+            vector['y'],
+            curve_type()
+        ).public_key(backend)
+
+        signature = encode_rfc6979_signature(vector['r'], vector['s'])
+
+        verifier = key.verifier(
+            signature,
+            ec.ECDSA(hash_type())
+        )
+        verifier.update(vector['message'])
+        assert verifier.verify()
+
+    @pytest.mark.parametrize(
+        "vector",
+        load_vectors_from_file(
+            os.path.join(
+                "asymmetric", "ECDSA", "FIPS_186-3", "SigVer.rsp"),
+            load_fips_ecdsa_signing_vectors
+        )
+    )
+    def test_signature_failures(self, backend, vector):
+        hash_type = _HASH_TYPES[vector['digest_algorithm']]
+        curve_type = ec._CURVE_TYPES[vector['curve']]
+
+        _skip_ecdsa_vector(backend, curve_type, hash_type)
+
+        key = ec.EllipticCurvePublicNumbers(
+            vector['x'],
+            vector['y'],
+            curve_type()
+        ).public_key(backend)
+
+        signature = encode_rfc6979_signature(vector['r'], vector['s'])
+
+        verifier = key.verifier(
+            signature,
+            ec.ECDSA(hash_type())
+        )
+        verifier.update(vector['message'])
+
+        if vector["fail"] is True:
+            with pytest.raises(exceptions.InvalidSignature):
+                verifier.verify()
+        else:
+            verifier.verify()
+
+
+class TestECNumbersEquality(object):
+    def test_public_numbers_eq(self):
+        pub = ec.EllipticCurvePublicNumbers(1, 2, ec.SECP192R1())
+        assert pub == ec.EllipticCurvePublicNumbers(1, 2, ec.SECP192R1())
+
+    def test_public_numbers_ne(self):
+        pub = ec.EllipticCurvePublicNumbers(1, 2, ec.SECP192R1())
+        assert pub != ec.EllipticCurvePublicNumbers(1, 2, ec.SECP384R1())
+        assert pub != ec.EllipticCurvePublicNumbers(1, 3, ec.SECP192R1())
+        assert pub != ec.EllipticCurvePublicNumbers(2, 2, ec.SECP192R1())
+        assert pub != object()
+
+    def test_private_numbers_eq(self):
+        pub = ec.EllipticCurvePublicNumbers(1, 2, ec.SECP192R1())
+        priv = ec.EllipticCurvePrivateNumbers(1, pub)
+        assert priv == ec.EllipticCurvePrivateNumbers(
+            1, ec.EllipticCurvePublicNumbers(1, 2, ec.SECP192R1())
+        )
+
+    def test_private_numbers_ne(self):
+        pub = ec.EllipticCurvePublicNumbers(1, 2, ec.SECP192R1())
+        priv = ec.EllipticCurvePrivateNumbers(1, pub)
+        assert priv != ec.EllipticCurvePrivateNumbers(
+            2, ec.EllipticCurvePublicNumbers(1, 2, ec.SECP192R1())
+        )
+        assert priv != ec.EllipticCurvePrivateNumbers(
+            1, ec.EllipticCurvePublicNumbers(2, 2, ec.SECP192R1())
+        )
+        assert priv != ec.EllipticCurvePrivateNumbers(
+            1, ec.EllipticCurvePublicNumbers(1, 3, ec.SECP192R1())
+        )
+        assert priv != ec.EllipticCurvePrivateNumbers(
+            1, ec.EllipticCurvePublicNumbers(1, 2, ec.SECP521R1())
+        )
+        assert priv != object()
+
+
+@pytest.mark.requires_backend_interface(interface=EllipticCurveBackend)
+@pytest.mark.requires_backend_interface(interface=PEMSerializationBackend)
+class TestECSerialization(object):
+    @pytest.mark.parametrize(
+        ("fmt", "password"),
+        itertools.product(
+            [
+                serialization.PrivateFormat.TraditionalOpenSSL,
+                serialization.PrivateFormat.PKCS8
+            ],
+            [
+                b"s",
+                b"longerpassword",
+                b"!*$&(@#$*&($T@%_somesymbols",
+                b"\x01" * 1000,
+            ]
+        )
+    )
+    def test_private_bytes_encrypted_pem(self, backend, fmt, password):
+        _skip_curve_unsupported(backend, ec.SECP256R1())
+        key_bytes = load_vectors_from_file(
+            os.path.join(
+                "asymmetric", "PKCS8", "ec_private_key.pem"),
+            lambda pemfile: pemfile.read().encode()
+        )
+        key = serialization.load_pem_private_key(key_bytes, None, backend)
+        serialized = key.private_bytes(
+            serialization.Encoding.PEM,
+            fmt,
+            serialization.BestAvailableEncryption(password)
+        )
+        loaded_key = serialization.load_pem_private_key(
+            serialized, password, backend
+        )
+        loaded_priv_num = loaded_key.private_numbers()
+        priv_num = key.private_numbers()
+        assert loaded_priv_num == priv_num
+
+    @pytest.mark.parametrize(
+        ("fmt", "password"),
+        [
+            [serialization.PrivateFormat.PKCS8, b"s"],
+            [serialization.PrivateFormat.PKCS8, b"longerpassword"],
+            [serialization.PrivateFormat.PKCS8, b"!*$&(@#$*&($T@%_somesymbol"],
+            [serialization.PrivateFormat.PKCS8, b"\x01" * 1000]
+        ]
+    )
+    def test_private_bytes_encrypted_der(self, backend, fmt, password):
+        _skip_curve_unsupported(backend, ec.SECP256R1())
+        key_bytes = load_vectors_from_file(
+            os.path.join(
+                "asymmetric", "PKCS8", "ec_private_key.pem"),
+            lambda pemfile: pemfile.read().encode()
+        )
+        key = serialization.load_pem_private_key(key_bytes, None, backend)
+        serialized = key.private_bytes(
+            serialization.Encoding.DER,
+            fmt,
+            serialization.BestAvailableEncryption(password)
+        )
+        loaded_key = serialization.load_der_private_key(
+            serialized, password, backend
+        )
+        loaded_priv_num = loaded_key.private_numbers()
+        priv_num = key.private_numbers()
+        assert loaded_priv_num == priv_num
+
+    @pytest.mark.parametrize(
+        ("encoding", "fmt", "loader_func"),
+        [
+            [
+                serialization.Encoding.PEM,
+                serialization.PrivateFormat.TraditionalOpenSSL,
+                serialization.load_pem_private_key
+            ],
+            [
+                serialization.Encoding.DER,
+                serialization.PrivateFormat.TraditionalOpenSSL,
+                serialization.load_der_private_key
+            ],
+            [
+                serialization.Encoding.PEM,
+                serialization.PrivateFormat.PKCS8,
+                serialization.load_pem_private_key
+            ],
+            [
+                serialization.Encoding.DER,
+                serialization.PrivateFormat.PKCS8,
+                serialization.load_der_private_key
+            ],
+        ]
+    )
+    def test_private_bytes_unencrypted(self, backend, encoding, fmt,
+                                       loader_func):
+        _skip_curve_unsupported(backend, ec.SECP256R1())
+        key_bytes = load_vectors_from_file(
+            os.path.join(
+                "asymmetric", "PKCS8", "ec_private_key.pem"),
+            lambda pemfile: pemfile.read().encode()
+        )
+        key = serialization.load_pem_private_key(key_bytes, None, backend)
+        serialized = key.private_bytes(
+            encoding, fmt, serialization.NoEncryption()
+        )
+        loaded_key = loader_func(serialized, None, backend)
+        loaded_priv_num = loaded_key.private_numbers()
+        priv_num = key.private_numbers()
+        assert loaded_priv_num == priv_num
+
+    @pytest.mark.parametrize(
+        ("key_path", "encoding", "loader_func"),
+        [
+            [
+                os.path.join(
+                    "asymmetric", "PEM_Serialization", "ec_private_key.pem"
+                ),
+                serialization.Encoding.PEM,
+                serialization.load_pem_private_key
+            ],
+            [
+                os.path.join(
+                    "asymmetric", "DER_Serialization", "ec_private_key.der"
+                ),
+                serialization.Encoding.DER,
+                serialization.load_der_private_key
+            ],
+        ]
+    )
+    def test_private_bytes_traditional_openssl_unencrypted(
+        self, backend, key_path, encoding, loader_func
+    ):
+        _skip_curve_unsupported(backend, ec.SECP256R1())
+        key_bytes = load_vectors_from_file(
+            key_path, lambda pemfile: pemfile.read(), mode="rb"
+        )
+        key = loader_func(key_bytes, None, backend)
+        serialized = key.private_bytes(
+            encoding,
+            serialization.PrivateFormat.TraditionalOpenSSL,
+            serialization.NoEncryption()
+        )
+        assert serialized == key_bytes
+
+    def test_private_bytes_traditional_der_encrypted_invalid(self, backend):
+        _skip_curve_unsupported(backend, ec.SECP256R1())
+        key = load_vectors_from_file(
+            os.path.join(
+                "asymmetric", "PKCS8", "ec_private_key.pem"),
+            lambda pemfile: serialization.load_pem_private_key(
+                pemfile.read().encode(), None, backend
+            )
+        )
+        with pytest.raises(ValueError):
+            key.private_bytes(
+                serialization.Encoding.DER,
+                serialization.PrivateFormat.TraditionalOpenSSL,
+                serialization.BestAvailableEncryption(b"password")
+            )
+
+    def test_private_bytes_invalid_encoding(self, backend):
+        _skip_curve_unsupported(backend, ec.SECP256R1())
+        key = load_vectors_from_file(
+            os.path.join(
+                "asymmetric", "PKCS8", "ec_private_key.pem"),
+            lambda pemfile: serialization.load_pem_private_key(
+                pemfile.read().encode(), None, backend
+            )
+        )
+        with pytest.raises(TypeError):
+            key.private_bytes(
+                "notencoding",
+                serialization.PrivateFormat.PKCS8,
+                serialization.NoEncryption()
+            )
+
+    def test_private_bytes_invalid_format(self, backend):
+        _skip_curve_unsupported(backend, ec.SECP256R1())
+        key = load_vectors_from_file(
+            os.path.join(
+                "asymmetric", "PKCS8", "ec_private_key.pem"),
+            lambda pemfile: serialization.load_pem_private_key(
+                pemfile.read().encode(), None, backend
+            )
+        )
+        with pytest.raises(TypeError):
+            key.private_bytes(
+                serialization.Encoding.PEM,
+                "invalidformat",
+                serialization.NoEncryption()
+            )
+
+    def test_private_bytes_invalid_encryption_algorithm(self, backend):
+        _skip_curve_unsupported(backend, ec.SECP256R1())
+        key = load_vectors_from_file(
+            os.path.join(
+                "asymmetric", "PKCS8", "ec_private_key.pem"),
+            lambda pemfile: serialization.load_pem_private_key(
+                pemfile.read().encode(), None, backend
+            )
+        )
+        with pytest.raises(TypeError):
+            key.private_bytes(
+                serialization.Encoding.PEM,
+                serialization.PrivateFormat.TraditionalOpenSSL,
+                "notanencalg"
+            )
+
+    def test_private_bytes_unsupported_encryption_type(self, backend):
+        _skip_curve_unsupported(backend, ec.SECP256R1())
+        key = load_vectors_from_file(
+            os.path.join(
+                "asymmetric", "PKCS8", "ec_private_key.pem"),
+            lambda pemfile: serialization.load_pem_private_key(
+                pemfile.read().encode(), None, backend
+            )
+        )
+        with pytest.raises(ValueError):
+            key.private_bytes(
+                serialization.Encoding.PEM,
+                serialization.PrivateFormat.TraditionalOpenSSL,
+                DummyKeyEncryption()
+            )
+
+    def test_public_bytes_from_derived_public_key(self, backend):
+        _skip_curve_unsupported(backend, ec.SECP256R1())
+        key = load_vectors_from_file(
+            os.path.join(
+                "asymmetric", "PKCS8", "ec_private_key.pem"),
+            lambda pemfile: serialization.load_pem_private_key(
+                pemfile.read().encode(), None, backend
+            )
+        )
+        public = key.public_key()
+        pem = public.public_bytes(
+            serialization.Encoding.PEM,
+            serialization.PublicFormat.SubjectPublicKeyInfo
+        )
+        parsed_public = serialization.load_pem_public_key(pem, backend)
+        assert parsed_public
+
+
+@pytest.mark.requires_backend_interface(interface=EllipticCurveBackend)
+@pytest.mark.requires_backend_interface(interface=PEMSerializationBackend)
+class TestEllipticCurvePEMPublicKeySerialization(object):
+    @pytest.mark.parametrize(
+        ("key_path", "loader_func", "encoding"),
+        [
+            (
+                os.path.join(
+                    "asymmetric", "PEM_Serialization", "ec_public_key.pem"
+                ),
+                serialization.load_pem_public_key,
+                serialization.Encoding.PEM,
+            ), (
+                os.path.join(
+                    "asymmetric", "DER_Serialization", "ec_public_key.der"
+                ),
+                serialization.load_der_public_key,
+                serialization.Encoding.DER,
+            )
+        ]
+    )
+    def test_public_bytes_match(self, key_path, loader_func, encoding,
+                                backend):
+        _skip_curve_unsupported(backend, ec.SECP256R1())
+        key_bytes = load_vectors_from_file(
+            key_path, lambda pemfile: pemfile.read(), mode="rb"
+        )
+        key = loader_func(key_bytes, backend)
+        serialized = key.public_bytes(
+            encoding, serialization.PublicFormat.SubjectPublicKeyInfo,
+        )
+        assert serialized == key_bytes
+
+    def test_public_bytes_invalid_encoding(self, backend):
+        _skip_curve_unsupported(backend, ec.SECP256R1())
+        key = load_vectors_from_file(
+            os.path.join(
+                "asymmetric", "PEM_Serialization", "ec_public_key.pem"
+            ),
+            lambda pemfile: serialization.load_pem_public_key(
+                pemfile.read().encode(), backend
+            )
+        )
+        with pytest.raises(TypeError):
+            key.public_bytes(
+                "notencoding",
+                serialization.PublicFormat.SubjectPublicKeyInfo
+            )
+
+    def test_public_bytes_invalid_format(self, backend):
+        _skip_curve_unsupported(backend, ec.SECP256R1())
+        key = load_vectors_from_file(
+            os.path.join(
+                "asymmetric", "PEM_Serialization", "ec_public_key.pem"
+            ),
+            lambda pemfile: serialization.load_pem_public_key(
+                pemfile.read().encode(), backend
+            )
+        )
+        with pytest.raises(TypeError):
+            key.public_bytes(serialization.Encoding.PEM, "invalidformat")
+
+    def test_public_bytes_pkcs1_unsupported(self, backend):
+        _skip_curve_unsupported(backend, ec.SECP256R1())
+        key = load_vectors_from_file(
+            os.path.join(
+                "asymmetric", "PEM_Serialization", "ec_public_key.pem"
+            ),
+            lambda pemfile: serialization.load_pem_public_key(
+                pemfile.read().encode(), backend
+            )
+        )
+        with pytest.raises(ValueError):
+            key.public_bytes(
+                serialization.Encoding.PEM, serialization.PublicFormat.PKCS1
+            )
+
+
+@pytest.mark.requires_backend_interface(interface=EllipticCurveBackend)
+class TestECDSAVerification(object):
+    def test_signature_not_bytes(self, backend):
+        _skip_curve_unsupported(backend, ec.SECP256R1())
+        key = ec.generate_private_key(ec.SECP256R1(), backend)
+        public_key = key.public_key()
+        with pytest.raises(TypeError):
+            public_key.verifier(1234, ec.ECDSA(hashes.SHA256()))
+
+
+@pytest.mark.requires_backend_interface(interface=EllipticCurveBackend)
+class TestECDHVectors(object):
+    @pytest.mark.parametrize(
+        "vector",
+        load_vectors_from_file(
+            os.path.join(
+                "asymmetric", "ECDH",
+                "KASValidityTest_ECCStaticUnified_NOKC_ZZOnly_init.fax"),
+            load_kasvs_ecdh_vectors
+        )
+    )
+    def test_key_exchange_with_vectors(self, backend, vector):
+        _skip_exchange_algorithm_unsupported(
+            backend, ec.ECDH(), ec._CURVE_TYPES[vector['curve']]
+        )
+
+        key_numbers = vector['IUT']
+        private_numbers = ec.EllipticCurvePrivateNumbers(
+            key_numbers['d'],
+            ec.EllipticCurvePublicNumbers(
+                key_numbers['x'],
+                key_numbers['y'],
+                ec._CURVE_TYPES[vector['curve']]()
+            )
+        )
+        # Errno 5 and 6 indicates a bad public key, this doesn't test the ECDH
+        # code at all
+        if vector['fail'] and vector['errno'] in [5, 6]:
+            with pytest.raises(ValueError):
+                private_numbers.private_key(backend)
+            return
+        else:
+            private_key = private_numbers.private_key(backend)
+
+        peer_numbers = vector['CAVS']
+        public_numbers = ec.EllipticCurvePublicNumbers(
+            peer_numbers['x'],
+            peer_numbers['y'],
+            ec._CURVE_TYPES[vector['curve']]()
+        )
+        # Errno 1 and 2 indicates a bad public key, this doesn't test the ECDH
+        # code at all
+        if vector['fail'] and vector['errno'] in [1, 2]:
+            with pytest.raises(ValueError):
+                public_numbers.public_key(backend)
+            return
+        else:
+            peer_pubkey = public_numbers.public_key(backend)
+
+        z = private_key.exchange(ec.ECDH(), peer_pubkey)
+        z = int(hexlify(z).decode('ascii'), 16)
+        # At this point fail indicates that one of the underlying keys was
+        # changed. This results in a non-matching derived key.
+        if vector['fail']:
+            assert z != vector['Z']
+        else:
+            assert z == vector['Z']
+
+    def test_exchange_unsupported_algorithm(self, backend):
+        _skip_curve_unsupported(backend, ec.SECP256R1())
+
+        key = load_vectors_from_file(
+            os.path.join(
+                "asymmetric", "PKCS8", "ec_private_key.pem"),
+            lambda pemfile: serialization.load_pem_private_key(
+                pemfile.read().encode(), None, backend
+            )
+        )
+
+        with raises_unsupported_algorithm(
+            exceptions._Reasons.UNSUPPORTED_EXCHANGE_ALGORITHM
+        ):
+            key.exchange(None, key.public_key())
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_hashes.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_hashes.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_hashes.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_hashes.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,173 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import pretend
+
+import pytest
+
+from cryptography import utils
+from cryptography.exceptions import AlreadyFinalized, _Reasons
+from cryptography.hazmat.backends.interfaces import HashBackend
+from cryptography.hazmat.primitives import hashes
+
+from .utils import generate_base_hash_test
+from ..backends.test_multibackend import DummyHashBackend
+from ...utils import raises_unsupported_algorithm
+
+
+@utils.register_interface(hashes.HashAlgorithm)
+class UnsupportedDummyHash(object):
+    name = "unsupported-dummy-hash"
+    block_size = None
+    digest_size = None
+
+
+@pytest.mark.requires_backend_interface(interface=HashBackend)
+class TestHashContext(object):
+    def test_hash_reject_unicode(self, backend):
+        m = hashes.Hash(hashes.SHA1(), backend=backend)
+        with pytest.raises(TypeError):
+            m.update(u"\u00FC")
+
+    def test_copy_backend_object(self):
+        backend = DummyHashBackend([hashes.SHA1])
+        copied_ctx = pretend.stub()
+        pretend_ctx = pretend.stub(copy=lambda: copied_ctx)
+        h = hashes.Hash(hashes.SHA1(), backend=backend, ctx=pretend_ctx)
+        assert h._backend is backend
+        assert h.copy()._backend is h._backend
+
+    def test_hash_algorithm_instance(self, backend):
+        with pytest.raises(TypeError):
+            hashes.Hash(hashes.SHA1, backend=backend)
+
+    def test_raises_after_finalize(self, backend):
+        h = hashes.Hash(hashes.SHA1(), backend=backend)
+        h.finalize()
+
+        with pytest.raises(AlreadyFinalized):
+            h.update(b"foo")
+
+        with pytest.raises(AlreadyFinalized):
+            h.copy()
+
+        with pytest.raises(AlreadyFinalized):
+            h.finalize()
+
+    def test_unsupported_hash(self, backend):
+        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_HASH):
+            hashes.Hash(UnsupportedDummyHash(), backend)
+
+
+@pytest.mark.supported(
+    only_if=lambda backend: backend.hash_supported(hashes.SHA1()),
+    skip_message="Does not support SHA1",
+)
+@pytest.mark.requires_backend_interface(interface=HashBackend)
+class TestSHA1(object):
+    test_SHA1 = generate_base_hash_test(
+        hashes.SHA1(),
+        digest_size=20,
+        block_size=64,
+    )
+
+
+@pytest.mark.supported(
+    only_if=lambda backend: backend.hash_supported(hashes.SHA224()),
+    skip_message="Does not support SHA224",
+)
+@pytest.mark.requires_backend_interface(interface=HashBackend)
+class TestSHA224(object):
+    test_SHA224 = generate_base_hash_test(
+        hashes.SHA224(),
+        digest_size=28,
+        block_size=64,
+    )
+
+
+@pytest.mark.supported(
+    only_if=lambda backend: backend.hash_supported(hashes.SHA256()),
+    skip_message="Does not support SHA256",
+)
+@pytest.mark.requires_backend_interface(interface=HashBackend)
+class TestSHA256(object):
+    test_SHA256 = generate_base_hash_test(
+        hashes.SHA256(),
+        digest_size=32,
+        block_size=64,
+    )
+
+
+@pytest.mark.supported(
+    only_if=lambda backend: backend.hash_supported(hashes.SHA384()),
+    skip_message="Does not support SHA384",
+)
+@pytest.mark.requires_backend_interface(interface=HashBackend)
+class TestSHA384(object):
+    test_SHA384 = generate_base_hash_test(
+        hashes.SHA384(),
+        digest_size=48,
+        block_size=128,
+    )
+
+
+@pytest.mark.supported(
+    only_if=lambda backend: backend.hash_supported(hashes.SHA512()),
+    skip_message="Does not support SHA512",
+)
+@pytest.mark.requires_backend_interface(interface=HashBackend)
+class TestSHA512(object):
+    test_SHA512 = generate_base_hash_test(
+        hashes.SHA512(),
+        digest_size=64,
+        block_size=128,
+    )
+
+
+@pytest.mark.supported(
+    only_if=lambda backend: backend.hash_supported(hashes.RIPEMD160()),
+    skip_message="Does not support RIPEMD160",
+)
+@pytest.mark.requires_backend_interface(interface=HashBackend)
+class TestRIPEMD160(object):
+    test_RIPEMD160 = generate_base_hash_test(
+        hashes.RIPEMD160(),
+        digest_size=20,
+        block_size=64,
+    )
+
+
+@pytest.mark.supported(
+    only_if=lambda backend: backend.hash_supported(hashes.Whirlpool()),
+    skip_message="Does not support Whirlpool",
+)
+@pytest.mark.requires_backend_interface(interface=HashBackend)
+class TestWhirlpool(object):
+    test_Whirlpool = generate_base_hash_test(
+        hashes.Whirlpool(),
+        digest_size=64,
+        block_size=64,
+    )
+
+
+@pytest.mark.supported(
+    only_if=lambda backend: backend.hash_supported(hashes.MD5()),
+    skip_message="Does not support MD5",
+)
+@pytest.mark.requires_backend_interface(interface=HashBackend)
+class TestMD5(object):
+    test_MD5 = generate_base_hash_test(
+        hashes.MD5(),
+        digest_size=16,
+        block_size=64,
+    )
+
+
+def test_invalid_backend():
+    pretend_backend = object()
+
+    with raises_unsupported_algorithm(_Reasons.BACKEND_MISSING_INTERFACE):
+        hashes.Hash(hashes.SHA1(), pretend_backend)
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_hash_vectors.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_hash_vectors.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_hash_vectors.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_hash_vectors.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,160 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import os
+
+import pytest
+
+from cryptography.hazmat.backends.interfaces import HashBackend
+from cryptography.hazmat.primitives import hashes
+
+from .utils import generate_hash_test, generate_long_string_hash_test
+from ...utils import load_hash_vectors
+
+
+@pytest.mark.supported(
+    only_if=lambda backend: backend.hash_supported(hashes.SHA1()),
+    skip_message="Does not support SHA1",
+)
+@pytest.mark.requires_backend_interface(interface=HashBackend)
+class TestSHA1(object):
+    test_SHA1 = generate_hash_test(
+        load_hash_vectors,
+        os.path.join("hashes", "SHA1"),
+        [
+            "SHA1LongMsg.rsp",
+            "SHA1ShortMsg.rsp",
+        ],
+        hashes.SHA1(),
+    )
+
+
+@pytest.mark.supported(
+    only_if=lambda backend: backend.hash_supported(hashes.SHA224()),
+    skip_message="Does not support SHA224",
+)
+@pytest.mark.requires_backend_interface(interface=HashBackend)
+class TestSHA224(object):
+    test_SHA224 = generate_hash_test(
+        load_hash_vectors,
+        os.path.join("hashes", "SHA2"),
+        [
+            "SHA224LongMsg.rsp",
+            "SHA224ShortMsg.rsp",
+        ],
+        hashes.SHA224(),
+    )
+
+
+@pytest.mark.supported(
+    only_if=lambda backend: backend.hash_supported(hashes.SHA256()),
+    skip_message="Does not support SHA256",
+)
+@pytest.mark.requires_backend_interface(interface=HashBackend)
+class TestSHA256(object):
+    test_SHA256 = generate_hash_test(
+        load_hash_vectors,
+        os.path.join("hashes", "SHA2"),
+        [
+            "SHA256LongMsg.rsp",
+            "SHA256ShortMsg.rsp",
+        ],
+        hashes.SHA256(),
+    )
+
+
+@pytest.mark.supported(
+    only_if=lambda backend: backend.hash_supported(hashes.SHA384()),
+    skip_message="Does not support SHA384",
+)
+@pytest.mark.requires_backend_interface(interface=HashBackend)
+class TestSHA384(object):
+    test_SHA384 = generate_hash_test(
+        load_hash_vectors,
+        os.path.join("hashes", "SHA2"),
+        [
+            "SHA384LongMsg.rsp",
+            "SHA384ShortMsg.rsp",
+        ],
+        hashes.SHA384(),
+    )
+
+
+@pytest.mark.supported(
+    only_if=lambda backend: backend.hash_supported(hashes.SHA512()),
+    skip_message="Does not support SHA512",
+)
+@pytest.mark.requires_backend_interface(interface=HashBackend)
+class TestSHA512(object):
+    test_SHA512 = generate_hash_test(
+        load_hash_vectors,
+        os.path.join("hashes", "SHA2"),
+        [
+            "SHA512LongMsg.rsp",
+            "SHA512ShortMsg.rsp",
+        ],
+        hashes.SHA512(),
+    )
+
+
+@pytest.mark.supported(
+    only_if=lambda backend: backend.hash_supported(hashes.RIPEMD160()),
+    skip_message="Does not support RIPEMD160",
+)
+@pytest.mark.requires_backend_interface(interface=HashBackend)
+class TestRIPEMD160(object):
+    test_RIPEMD160 = generate_hash_test(
+        load_hash_vectors,
+        os.path.join("hashes", "ripemd160"),
+        [
+            "ripevectors.txt",
+        ],
+        hashes.RIPEMD160(),
+    )
+
+    test_RIPEMD160_long_string = generate_long_string_hash_test(
+        hashes.RIPEMD160(),
+        "52783243c1697bdbe16d37f97f68f08325dc1528",
+    )
+
+
+@pytest.mark.supported(
+    only_if=lambda backend: backend.hash_supported(hashes.Whirlpool()),
+    skip_message="Does not support Whirlpool",
+)
+@pytest.mark.requires_backend_interface(interface=HashBackend)
+class TestWhirlpool(object):
+    test_whirlpool = generate_hash_test(
+        load_hash_vectors,
+        os.path.join("hashes", "whirlpool"),
+        [
+            "iso-test-vectors.txt",
+        ],
+        hashes.Whirlpool(),
+    )
+
+    test_whirlpool_long_string = generate_long_string_hash_test(
+        hashes.Whirlpool(),
+        ("0c99005beb57eff50a7cf005560ddf5d29057fd86b2"
+         "0bfd62deca0f1ccea4af51fc15490eddc47af32bb2b"
+         "66c34ff9ad8c6008ad677f77126953b226e4ed8b01"),
+    )
+
+
+@pytest.mark.supported(
+    only_if=lambda backend: backend.hash_supported(hashes.MD5()),
+    skip_message="Does not support MD5",
+)
+@pytest.mark.requires_backend_interface(interface=HashBackend)
+class TestMD5(object):
+    test_md5 = generate_hash_test(
+        load_hash_vectors,
+        os.path.join("hashes", "MD5"),
+        [
+            "rfc-1321.txt",
+        ],
+        hashes.MD5(),
+    )
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_hkdf.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_hkdf.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_hkdf.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_hkdf.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,209 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import binascii
+
+import pytest
+
+from cryptography.exceptions import (
+    AlreadyFinalized, InvalidKey, _Reasons
+)
+from cryptography.hazmat.backends.interfaces import HMACBackend
+from cryptography.hazmat.primitives import hashes
+from cryptography.hazmat.primitives.kdf.hkdf import HKDF, HKDFExpand
+
+from ...utils import raises_unsupported_algorithm
+
+
+@pytest.mark.requires_backend_interface(interface=HMACBackend)
+class TestHKDF(object):
+    def test_length_limit(self, backend):
+        big_length = 255 * (hashes.SHA256().digest_size // 8) + 1
+
+        with pytest.raises(ValueError):
+            HKDF(
+                hashes.SHA256(),
+                big_length,
+                salt=None,
+                info=None,
+                backend=backend
+            )
+
+    def test_already_finalized(self, backend):
+        hkdf = HKDF(
+            hashes.SHA256(),
+            16,
+            salt=None,
+            info=None,
+            backend=backend
+        )
+
+        hkdf.derive(b"\x01" * 16)
+
+        with pytest.raises(AlreadyFinalized):
+            hkdf.derive(b"\x02" * 16)
+
+        hkdf = HKDF(
+            hashes.SHA256(),
+            16,
+            salt=None,
+            info=None,
+            backend=backend
+        )
+
+        hkdf.verify(b"\x01" * 16, b"gJ\xfb{\xb1Oi\xc5sMC\xb7\xe4@\xf7u")
+
+        with pytest.raises(AlreadyFinalized):
+            hkdf.verify(b"\x02" * 16, b"gJ\xfb{\xb1Oi\xc5sMC\xb7\xe4@\xf7u")
+
+        hkdf = HKDF(
+            hashes.SHA256(),
+            16,
+            salt=None,
+            info=None,
+            backend=backend
+        )
+
+    def test_verify(self, backend):
+        hkdf = HKDF(
+            hashes.SHA256(),
+            16,
+            salt=None,
+            info=None,
+            backend=backend
+        )
+
+        hkdf.verify(b"\x01" * 16, b"gJ\xfb{\xb1Oi\xc5sMC\xb7\xe4@\xf7u")
+
+    def test_verify_invalid(self, backend):
+        hkdf = HKDF(
+            hashes.SHA256(),
+            16,
+            salt=None,
+            info=None,
+            backend=backend
+        )
+
+        with pytest.raises(InvalidKey):
+            hkdf.verify(b"\x02" * 16, b"gJ\xfb{\xb1Oi\xc5sMC\xb7\xe4@\xf7u")
+
+    def test_unicode_typeerror(self, backend):
+        with pytest.raises(TypeError):
+            HKDF(
+                hashes.SHA256(),
+                16,
+                salt=u"foo",
+                info=None,
+                backend=backend
+            )
+
+        with pytest.raises(TypeError):
+            HKDF(
+                hashes.SHA256(),
+                16,
+                salt=None,
+                info=u"foo",
+                backend=backend
+            )
+
+        with pytest.raises(TypeError):
+            hkdf = HKDF(
+                hashes.SHA256(),
+                16,
+                salt=None,
+                info=None,
+                backend=backend
+            )
+
+            hkdf.derive(u"foo")
+
+        with pytest.raises(TypeError):
+            hkdf = HKDF(
+                hashes.SHA256(),
+                16,
+                salt=None,
+                info=None,
+                backend=backend
+            )
+
+            hkdf.verify(u"foo", b"bar")
+
+        with pytest.raises(TypeError):
+            hkdf = HKDF(
+                hashes.SHA256(),
+                16,
+                salt=None,
+                info=None,
+                backend=backend
+            )
+
+            hkdf.verify(b"foo", u"bar")
+
+
+@pytest.mark.requires_backend_interface(interface=HMACBackend)
+class TestHKDFExpand(object):
+    def test_derive(self, backend):
+        prk = binascii.unhexlify(
+            b"077709362c2e32df0ddc3f0dc47bba6390b6c73bb50f9c3122ec844ad7c2b3e5"
+        )
+
+        okm = (b"3cb25f25faacd57a90434f64d0362f2a2d2d0a90cf1a5a4c5db02d56ecc4c"
+               b"5bf34007208d5b887185865")
+
+        info = binascii.unhexlify(b"f0f1f2f3f4f5f6f7f8f9")
+        hkdf = HKDFExpand(hashes.SHA256(), 42, info, backend)
+
+        assert binascii.hexlify(hkdf.derive(prk)) == okm
+
+    def test_verify(self, backend):
+        prk = binascii.unhexlify(
+            b"077709362c2e32df0ddc3f0dc47bba6390b6c73bb50f9c3122ec844ad7c2b3e5"
+        )
+
+        okm = (b"3cb25f25faacd57a90434f64d0362f2a2d2d0a90cf1a5a4c5db02d56ecc4c"
+               b"5bf34007208d5b887185865")
+
+        info = binascii.unhexlify(b"f0f1f2f3f4f5f6f7f8f9")
+        hkdf = HKDFExpand(hashes.SHA256(), 42, info, backend)
+
+        assert hkdf.verify(prk, binascii.unhexlify(okm)) is None
+
+    def test_invalid_verify(self, backend):
+        prk = binascii.unhexlify(
+            b"077709362c2e32df0ddc3f0dc47bba6390b6c73bb50f9c3122ec844ad7c2b3e5"
+        )
+
+        info = binascii.unhexlify(b"f0f1f2f3f4f5f6f7f8f9")
+        hkdf = HKDFExpand(hashes.SHA256(), 42, info, backend)
+
+        with pytest.raises(InvalidKey):
+            hkdf.verify(prk, b"wrong key")
+
+    def test_already_finalized(self, backend):
+        info = binascii.unhexlify(b"f0f1f2f3f4f5f6f7f8f9")
+        hkdf = HKDFExpand(hashes.SHA256(), 42, info, backend)
+
+        hkdf.derive(b"first")
+
+        with pytest.raises(AlreadyFinalized):
+            hkdf.derive(b"second")
+
+    def test_unicode_error(self, backend):
+        info = binascii.unhexlify(b"f0f1f2f3f4f5f6f7f8f9")
+        hkdf = HKDFExpand(hashes.SHA256(), 42, info, backend)
+
+        with pytest.raises(TypeError):
+            hkdf.derive(u"first")
+
+
+def test_invalid_backend():
+    pretend_backend = object()
+
+    with raises_unsupported_algorithm(_Reasons.BACKEND_MISSING_INTERFACE):
+        HKDF(hashes.SHA256(), 16, None, None, pretend_backend)
+
+    with raises_unsupported_algorithm(_Reasons.BACKEND_MISSING_INTERFACE):
+        HKDFExpand(hashes.SHA256(), 16, None, pretend_backend)
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_hkdf_vectors.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_hkdf_vectors.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_hkdf_vectors.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_hkdf_vectors.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,43 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import os
+
+import pytest
+
+from cryptography.hazmat.backends.interfaces import HMACBackend
+from cryptography.hazmat.primitives import hashes
+
+from .utils import generate_hkdf_test
+from ...utils import load_nist_vectors
+
+
+@pytest.mark.supported(
+    only_if=lambda backend: backend.hmac_supported(hashes.SHA1()),
+    skip_message="Does not support SHA1."
+)
+@pytest.mark.requires_backend_interface(interface=HMACBackend)
+class TestHKDFSHA1(object):
+    test_HKDFSHA1 = generate_hkdf_test(
+        load_nist_vectors,
+        os.path.join("KDF"),
+        ["rfc-5869-HKDF-SHA1.txt"],
+        hashes.SHA1()
+    )
+
+
+@pytest.mark.supported(
+    only_if=lambda backend: backend.hmac_supported(hashes.SHA256()),
+    skip_message="Does not support SHA256."
+)
+@pytest.mark.requires_backend_interface(interface=HMACBackend)
+class TestHKDFSHA256(object):
+    test_HKDFSHA1 = generate_hkdf_test(
+        load_nist_vectors,
+        os.path.join("KDF"),
+        ["rfc-5869-HKDF-SHA256.txt"],
+        hashes.SHA256()
+    )
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_hmac.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_hmac.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_hmac.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_hmac.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,105 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import pretend
+
+import pytest
+
+from cryptography import utils
+from cryptography.exceptions import (
+    AlreadyFinalized, InvalidSignature, _Reasons
+)
+from cryptography.hazmat.backends.interfaces import HMACBackend
+from cryptography.hazmat.primitives import hashes, hmac
+
+from .utils import generate_base_hmac_test
+from ..backends.test_multibackend import DummyHMACBackend
+from ...utils import raises_unsupported_algorithm
+
+
+@utils.register_interface(hashes.HashAlgorithm)
+class UnsupportedDummyHash(object):
+    name = "unsupported-dummy-hash"
+    block_size = None
+    digest_size = None
+
+
+@pytest.mark.supported(
+    only_if=lambda backend: backend.hmac_supported(hashes.MD5()),
+    skip_message="Does not support MD5",
+)
+@pytest.mark.requires_backend_interface(interface=HMACBackend)
+class TestHMACCopy(object):
+    test_copy = generate_base_hmac_test(
+        hashes.MD5(),
+    )
+
+
+@pytest.mark.requires_backend_interface(interface=HMACBackend)
+class TestHMAC(object):
+    def test_hmac_reject_unicode(self, backend):
+        h = hmac.HMAC(b"mykey", hashes.SHA1(), backend=backend)
+        with pytest.raises(TypeError):
+            h.update(u"\u00FC")
+
+    def test_copy_backend_object(self):
+        backend = DummyHMACBackend([hashes.SHA1])
+        copied_ctx = pretend.stub()
+        pretend_ctx = pretend.stub(copy=lambda: copied_ctx)
+        h = hmac.HMAC(b"key", hashes.SHA1(), backend=backend, ctx=pretend_ctx)
+        assert h._backend is backend
+        assert h.copy()._backend is backend
+
+    def test_hmac_algorithm_instance(self, backend):
+        with pytest.raises(TypeError):
+            hmac.HMAC(b"key", hashes.SHA1, backend=backend)
+
+    def test_raises_after_finalize(self, backend):
+        h = hmac.HMAC(b"key", hashes.SHA1(), backend=backend)
+        h.finalize()
+
+        with pytest.raises(AlreadyFinalized):
+            h.update(b"foo")
+
+        with pytest.raises(AlreadyFinalized):
+            h.copy()
+
+        with pytest.raises(AlreadyFinalized):
+            h.finalize()
+
+    def test_verify(self, backend):
+        h = hmac.HMAC(b'', hashes.SHA1(), backend=backend)
+        digest = h.finalize()
+
+        h = hmac.HMAC(b'', hashes.SHA1(), backend=backend)
+        h.verify(digest)
+
+        with pytest.raises(AlreadyFinalized):
+            h.verify(b'')
+
+    def test_invalid_verify(self, backend):
+        h = hmac.HMAC(b'', hashes.SHA1(), backend=backend)
+        with pytest.raises(InvalidSignature):
+            h.verify(b'')
+
+        with pytest.raises(AlreadyFinalized):
+            h.verify(b'')
+
+    def test_verify_reject_unicode(self, backend):
+        h = hmac.HMAC(b'', hashes.SHA1(), backend=backend)
+        with pytest.raises(TypeError):
+            h.verify(u'')
+
+    def test_unsupported_hash(self, backend):
+        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_HASH):
+            hmac.HMAC(b"key", UnsupportedDummyHash(), backend)
+
+
+def test_invalid_backend():
+    pretend_backend = object()
+
+    with raises_unsupported_algorithm(_Reasons.BACKEND_MISSING_INTERFACE):
+        hmac.HMAC(b"key", hashes.SHA1(), pretend_backend)
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_hmac_vectors.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_hmac_vectors.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_hmac_vectors.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_hmac_vectors.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,125 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import pytest
+
+from cryptography.hazmat.backends.interfaces import HMACBackend
+from cryptography.hazmat.primitives import hashes
+
+from .utils import generate_hmac_test
+from ...utils import load_hash_vectors
+
+
+@pytest.mark.supported(
+    only_if=lambda backend: backend.hmac_supported(hashes.MD5()),
+    skip_message="Does not support MD5",
+)
+@pytest.mark.requires_backend_interface(interface=HMACBackend)
+class TestHMACMD5(object):
+    test_hmac_md5 = generate_hmac_test(
+        load_hash_vectors,
+        "HMAC",
+        [
+            "rfc-2202-md5.txt",
+        ],
+        hashes.MD5(),
+    )
+
+
+@pytest.mark.supported(
+    only_if=lambda backend: backend.hmac_supported(hashes.SHA1()),
+    skip_message="Does not support SHA1",
+)
+@pytest.mark.requires_backend_interface(interface=HMACBackend)
+class TestHMACSHA1(object):
+    test_hmac_sha1 = generate_hmac_test(
+        load_hash_vectors,
+        "HMAC",
+        [
+            "rfc-2202-sha1.txt",
+        ],
+        hashes.SHA1(),
+    )
+
+
+@pytest.mark.supported(
+    only_if=lambda backend: backend.hmac_supported(hashes.SHA224()),
+    skip_message="Does not support SHA224",
+)
+@pytest.mark.requires_backend_interface(interface=HMACBackend)
+class TestHMACSHA224(object):
+    test_hmac_sha224 = generate_hmac_test(
+        load_hash_vectors,
+        "HMAC",
+        [
+            "rfc-4231-sha224.txt",
+        ],
+        hashes.SHA224(),
+    )
+
+
+@pytest.mark.supported(
+    only_if=lambda backend: backend.hmac_supported(hashes.SHA256()),
+    skip_message="Does not support SHA256",
+)
+@pytest.mark.requires_backend_interface(interface=HMACBackend)
+class TestHMACSHA256(object):
+    test_hmac_sha256 = generate_hmac_test(
+        load_hash_vectors,
+        "HMAC",
+        [
+            "rfc-4231-sha256.txt",
+        ],
+        hashes.SHA256(),
+    )
+
+
+@pytest.mark.supported(
+    only_if=lambda backend: backend.hmac_supported(hashes.SHA384()),
+    skip_message="Does not support SHA384",
+)
+@pytest.mark.requires_backend_interface(interface=HMACBackend)
+class TestHMACSHA384(object):
+    test_hmac_sha384 = generate_hmac_test(
+        load_hash_vectors,
+        "HMAC",
+        [
+            "rfc-4231-sha384.txt",
+        ],
+        hashes.SHA384(),
+    )
+
+
+@pytest.mark.supported(
+    only_if=lambda backend: backend.hmac_supported(hashes.SHA512()),
+    skip_message="Does not support SHA512",
+)
+@pytest.mark.requires_backend_interface(interface=HMACBackend)
+class TestHMACSHA512(object):
+    test_hmac_sha512 = generate_hmac_test(
+        load_hash_vectors,
+        "HMAC",
+        [
+            "rfc-4231-sha512.txt",
+        ],
+        hashes.SHA512(),
+    )
+
+
+@pytest.mark.supported(
+    only_if=lambda backend: backend.hmac_supported(hashes.RIPEMD160()),
+    skip_message="Does not support RIPEMD160",
+)
+@pytest.mark.requires_backend_interface(interface=HMACBackend)
+class TestHMACRIPEMD160(object):
+    test_hmac_ripemd160 = generate_hmac_test(
+        load_hash_vectors,
+        "HMAC",
+        [
+            "rfc-2286-ripemd160.txt",
+        ],
+        hashes.RIPEMD160(),
+    )
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_idea.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_idea.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_idea.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_idea.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,84 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import binascii
+import os
+
+import pytest
+
+from cryptography.hazmat.backends.interfaces import CipherBackend
+from cryptography.hazmat.primitives.ciphers import algorithms, modes
+
+from .utils import generate_encrypt_test
+from ...utils import load_nist_vectors
+
+
+@pytest.mark.supported(
+    only_if=lambda backend: backend.cipher_supported(
+        algorithms.IDEA("\x00" * 16), modes.ECB()
+    ),
+    skip_message="Does not support IDEA ECB",
+)
+@pytest.mark.requires_backend_interface(interface=CipherBackend)
+class TestIDEAModeECB(object):
+    test_ECB = generate_encrypt_test(
+        load_nist_vectors,
+        os.path.join("ciphers", "IDEA"),
+        ["idea-ecb.txt"],
+        lambda key, **kwargs: algorithms.IDEA(binascii.unhexlify((key))),
+        lambda **kwargs: modes.ECB(),
+    )
+
+
+@pytest.mark.supported(
+    only_if=lambda backend: backend.cipher_supported(
+        algorithms.IDEA("\x00" * 16), modes.CBC("\x00" * 8)
+    ),
+    skip_message="Does not support IDEA CBC",
+)
+@pytest.mark.requires_backend_interface(interface=CipherBackend)
+class TestIDEAModeCBC(object):
+    test_CBC = generate_encrypt_test(
+        load_nist_vectors,
+        os.path.join("ciphers", "IDEA"),
+        ["idea-cbc.txt"],
+        lambda key, **kwargs: algorithms.IDEA(binascii.unhexlify((key))),
+        lambda iv, **kwargs: modes.CBC(binascii.unhexlify(iv))
+    )
+
+
+@pytest.mark.supported(
+    only_if=lambda backend: backend.cipher_supported(
+        algorithms.IDEA("\x00" * 16), modes.OFB("\x00" * 8)
+    ),
+    skip_message="Does not support IDEA OFB",
+)
+@pytest.mark.requires_backend_interface(interface=CipherBackend)
+class TestIDEAModeOFB(object):
+    test_OFB = generate_encrypt_test(
+        load_nist_vectors,
+        os.path.join("ciphers", "IDEA"),
+        ["idea-ofb.txt"],
+        lambda key, **kwargs: algorithms.IDEA(binascii.unhexlify((key))),
+        lambda iv, **kwargs: modes.OFB(binascii.unhexlify(iv))
+    )
+
+
+@pytest.mark.supported(
+    only_if=lambda backend: backend.cipher_supported(
+        algorithms.IDEA("\x00" * 16), modes.CFB("\x00" * 8)
+    ),
+    skip_message="Does not support IDEA CFB",
+)
+@pytest.mark.requires_backend_interface(interface=CipherBackend)
+class TestIDEAModeCFB(object):
+    test_CFB = generate_encrypt_test(
+        load_nist_vectors,
+        os.path.join("ciphers", "IDEA"),
+        ["idea-cfb.txt"],
+        lambda key, **kwargs: algorithms.IDEA(binascii.unhexlify((key))),
+        lambda iv, **kwargs: modes.CFB(binascii.unhexlify(iv))
+    )
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_keywrap.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_keywrap.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_keywrap.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_keywrap.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,116 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import binascii
+import os
+
+import pytest
+
+from cryptography.hazmat.backends.interfaces import CipherBackend
+from cryptography.hazmat.primitives import keywrap
+from cryptography.hazmat.primitives.ciphers import algorithms, modes
+
+from .utils import _load_all_params
+from ...utils import load_nist_vectors
+
+
+@pytest.mark.requires_backend_interface(interface=CipherBackend)
+class TestAESKeyWrap(object):
+    @pytest.mark.parametrize(
+        "params",
+        _load_all_params(
+            os.path.join("keywrap", "kwtestvectors"),
+            ["KW_AE_128.txt", "KW_AE_192.txt", "KW_AE_256.txt"],
+            load_nist_vectors
+        )
+    )
+    @pytest.mark.supported(
+        only_if=lambda backend: backend.cipher_supported(
+            algorithms.AES("\x00" * 16), modes.ECB()
+        ),
+        skip_message="Does not support AES key wrap (RFC 3394) because AES-ECB"
+                     " is unsupported",
+    )
+    def test_wrap(self, backend, params):
+        wrapping_key = binascii.unhexlify(params["k"])
+        key_to_wrap = binascii.unhexlify(params["p"])
+        wrapped_key = keywrap.aes_key_wrap(wrapping_key, key_to_wrap, backend)
+        assert params["c"] == binascii.hexlify(wrapped_key)
+
+    @pytest.mark.parametrize(
+        "params",
+        _load_all_params(
+            os.path.join("keywrap", "kwtestvectors"),
+            ["KW_AD_128.txt", "KW_AD_192.txt", "KW_AD_256.txt"],
+            load_nist_vectors
+        )
+    )
+    @pytest.mark.supported(
+        only_if=lambda backend: backend.cipher_supported(
+            algorithms.AES("\x00" * 16), modes.ECB()
+        ),
+        skip_message="Does not support AES key wrap (RFC 3394) because AES-ECB"
+                     " is unsupported",
+    )
+    def test_unwrap(self, backend, params):
+        wrapping_key = binascii.unhexlify(params["k"])
+        wrapped_key = binascii.unhexlify(params["c"])
+        if params.get("fail") is True:
+            with pytest.raises(keywrap.InvalidUnwrap):
+                keywrap.aes_key_unwrap(wrapping_key, wrapped_key, backend)
+        else:
+            unwrapped_key = keywrap.aes_key_unwrap(
+                wrapping_key, wrapped_key, backend
+            )
+            assert params["p"] == binascii.hexlify(unwrapped_key)
+
+    @pytest.mark.supported(
+        only_if=lambda backend: backend.cipher_supported(
+            algorithms.AES("\x00" * 16), modes.ECB()
+        ),
+        skip_message="Does not support AES key wrap (RFC 3394) because AES-ECB"
+                     " is unsupported",
+    )
+    def test_wrap_invalid_key_length(self, backend):
+        # The wrapping key must be of length [16, 24, 32]
+        with pytest.raises(ValueError):
+            keywrap.aes_key_wrap(b"badkey", b"sixteen_byte_key", backend)
+
+    @pytest.mark.supported(
+        only_if=lambda backend: backend.cipher_supported(
+            algorithms.AES("\x00" * 16), modes.ECB()
+        ),
+        skip_message="Does not support AES key wrap (RFC 3394) because AES-ECB"
+                     " is unsupported",
+    )
+    def test_unwrap_invalid_key_length(self, backend):
+        with pytest.raises(ValueError):
+            keywrap.aes_key_unwrap(b"badkey", b"\x00" * 24, backend)
+
+    @pytest.mark.supported(
+        only_if=lambda backend: backend.cipher_supported(
+            algorithms.AES("\x00" * 16), modes.ECB()
+        ),
+        skip_message="Does not support AES key wrap (RFC 3394) because AES-ECB"
+                     " is unsupported",
+    )
+    def test_wrap_invalid_key_to_wrap_length(self, backend):
+        # Keys to wrap must be at least 16 bytes long
+        with pytest.raises(ValueError):
+            keywrap.aes_key_wrap(b"sixteen_byte_key", b"\x00" * 15, backend)
+
+        # Keys to wrap must be a multiple of 8 bytes
+        with pytest.raises(ValueError):
+            keywrap.aes_key_wrap(b"sixteen_byte_key", b"\x00" * 23, backend)
+
+    def test_unwrap_invalid_wrapped_key_length(self, backend):
+        # Keys to unwrap must be at least 24 bytes
+        with pytest.raises(ValueError):
+            keywrap.aes_key_unwrap(b"sixteen_byte_key", b"\x00" * 16, backend)
+
+        # Keys to unwrap must be a multiple of 8 bytes
+        with pytest.raises(ValueError):
+            keywrap.aes_key_unwrap(b"sixteen_byte_key", b"\x00" * 27, backend)
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_padding.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_padding.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_padding.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_padding.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,101 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import pytest
+
+from cryptography.exceptions import AlreadyFinalized
+from cryptography.hazmat.primitives import padding
+
+
+class TestPKCS7(object):
+    @pytest.mark.parametrize("size", [127, 4096, -2])
+    def test_invalid_block_size(self, size):
+        with pytest.raises(ValueError):
+            padding.PKCS7(size)
+
+    @pytest.mark.parametrize(("size", "padded"), [
+        (128, b"1111"),
+        (128, b"1111111111111111"),
+        (128, b"111111111111111\x06"),
+        (128, b""),
+        (128, b"\x06" * 6),
+        (128, b"\x00" * 16),
+    ])
+    def test_invalid_padding(self, size, padded):
+        unpadder = padding.PKCS7(size).unpadder()
+        with pytest.raises(ValueError):
+            unpadder.update(padded)
+            unpadder.finalize()
+
+    def test_non_bytes(self):
+        padder = padding.PKCS7(128).padder()
+        with pytest.raises(TypeError):
+            padder.update(u"abc")
+        unpadder = padding.PKCS7(128).unpadder()
+        with pytest.raises(TypeError):
+            unpadder.update(u"abc")
+
+    @pytest.mark.parametrize(("size", "unpadded", "padded"), [
+        (
+            128,
+            b"1111111111",
+            b"1111111111\x06\x06\x06\x06\x06\x06",
+        ),
+        (
+            128,
+            b"111111111111111122222222222222",
+            b"111111111111111122222222222222\x02\x02",
+        ),
+        (
+            128,
+            b"1" * 16,
+            b"1" * 16 + b"\x10" * 16,
+        ),
+        (
+            128,
+            b"1" * 17,
+            b"1" * 17 + b"\x0F" * 15,
+        )
+    ])
+    def test_pad(self, size, unpadded, padded):
+        padder = padding.PKCS7(size).padder()
+        result = padder.update(unpadded)
+        result += padder.finalize()
+        assert result == padded
+
+    @pytest.mark.parametrize(("size", "unpadded", "padded"), [
+        (
+            128,
+            b"1111111111",
+            b"1111111111\x06\x06\x06\x06\x06\x06",
+        ),
+        (
+            128,
+            b"111111111111111122222222222222",
+            b"111111111111111122222222222222\x02\x02",
+        ),
+    ])
+    def test_unpad(self, size, unpadded, padded):
+        unpadder = padding.PKCS7(size).unpadder()
+        result = unpadder.update(padded)
+        result += unpadder.finalize()
+        assert result == unpadded
+
+    def test_use_after_finalize(self):
+        padder = padding.PKCS7(128).padder()
+        b = padder.finalize()
+        with pytest.raises(AlreadyFinalized):
+            padder.update(b"")
+        with pytest.raises(AlreadyFinalized):
+            padder.finalize()
+
+        unpadder = padding.PKCS7(128).unpadder()
+        unpadder.update(b)
+        unpadder.finalize()
+        with pytest.raises(AlreadyFinalized):
+            unpadder.update(b"")
+        with pytest.raises(AlreadyFinalized):
+            unpadder.finalize()
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_pbkdf2hmac.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_pbkdf2hmac.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_pbkdf2hmac.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_pbkdf2hmac.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,70 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import pytest
+
+from cryptography import utils
+from cryptography.exceptions import (
+    AlreadyFinalized, InvalidKey, _Reasons
+)
+from cryptography.hazmat.backends import default_backend
+from cryptography.hazmat.primitives import hashes
+from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
+
+from ...utils import raises_unsupported_algorithm
+
+
+@utils.register_interface(hashes.HashAlgorithm)
+class DummyHash(object):
+    name = "dummy-hash"
+    block_size = None
+    digest_size = None
+
+
+class TestPBKDF2HMAC(object):
+    def test_already_finalized(self):
+        kdf = PBKDF2HMAC(hashes.SHA1(), 20, b"salt", 10, default_backend())
+        kdf.derive(b"password")
+        with pytest.raises(AlreadyFinalized):
+            kdf.derive(b"password2")
+
+        kdf = PBKDF2HMAC(hashes.SHA1(), 20, b"salt", 10, default_backend())
+        key = kdf.derive(b"password")
+        with pytest.raises(AlreadyFinalized):
+            kdf.verify(b"password", key)
+
+        kdf = PBKDF2HMAC(hashes.SHA1(), 20, b"salt", 10, default_backend())
+        kdf.verify(b"password", key)
+        with pytest.raises(AlreadyFinalized):
+            kdf.verify(b"password", key)
+
+    def test_unsupported_algorithm(self):
+        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_HASH):
+            PBKDF2HMAC(DummyHash(), 20, b"salt", 10, default_backend())
+
+    def test_invalid_key(self):
+        kdf = PBKDF2HMAC(hashes.SHA1(), 20, b"salt", 10, default_backend())
+        key = kdf.derive(b"password")
+
+        kdf = PBKDF2HMAC(hashes.SHA1(), 20, b"salt", 10, default_backend())
+        with pytest.raises(InvalidKey):
+            kdf.verify(b"password2", key)
+
+    def test_unicode_error_with_salt(self):
+        with pytest.raises(TypeError):
+            PBKDF2HMAC(hashes.SHA1(), 20, u"salt", 10, default_backend())
+
+    def test_unicode_error_with_key_material(self):
+        kdf = PBKDF2HMAC(hashes.SHA1(), 20, b"salt", 10, default_backend())
+        with pytest.raises(TypeError):
+            kdf.derive(u"unicode here")
+
+
+def test_invalid_backend():
+    pretend_backend = object()
+
+    with raises_unsupported_algorithm(_Reasons.BACKEND_MISSING_INTERFACE):
+        PBKDF2HMAC(hashes.SHA1(), 20, b"salt", 10, pretend_backend)
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_pbkdf2hmac_vectors.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_pbkdf2hmac_vectors.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_pbkdf2hmac_vectors.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_pbkdf2hmac_vectors.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,29 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import pytest
+
+from cryptography.hazmat.backends.interfaces import PBKDF2HMACBackend
+from cryptography.hazmat.primitives import hashes
+
+from .utils import generate_pbkdf2_test
+from ...utils import load_nist_vectors
+
+
+@pytest.mark.supported(
+    only_if=lambda backend: backend.pbkdf2_hmac_supported(hashes.SHA1()),
+    skip_message="Does not support SHA1 for PBKDF2HMAC",
+)
+@pytest.mark.requires_backend_interface(interface=PBKDF2HMACBackend)
+class TestPBKDF2HMACSHA1(object):
+    test_pbkdf2_sha1 = generate_pbkdf2_test(
+        load_nist_vectors,
+        "KDF",
+        [
+            "rfc-6070-PBKDF2-SHA1.txt",
+        ],
+        hashes.SHA1(),
+    )
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_rsa.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_rsa.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_rsa.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_rsa.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,1989 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import binascii
+import itertools
+import math
+import os
+
+import pytest
+
+from cryptography import utils
+from cryptography.exceptions import (
+    AlreadyFinalized, InvalidSignature, _Reasons
+)
+from cryptography.hazmat.backends.interfaces import (
+    PEMSerializationBackend, RSABackend
+)
+from cryptography.hazmat.primitives import hashes, serialization
+from cryptography.hazmat.primitives.asymmetric import padding, rsa
+from cryptography.hazmat.primitives.asymmetric.rsa import (
+    RSAPrivateNumbers, RSAPublicNumbers
+)
+
+from .fixtures_rsa import (
+    RSA_KEY_1024, RSA_KEY_1025, RSA_KEY_1026, RSA_KEY_1027, RSA_KEY_1028,
+    RSA_KEY_1029, RSA_KEY_1030, RSA_KEY_1031, RSA_KEY_1536, RSA_KEY_2048,
+    RSA_KEY_512, RSA_KEY_512_ALT, RSA_KEY_522, RSA_KEY_599, RSA_KEY_745,
+    RSA_KEY_768,
+)
+from .utils import (
+    _check_rsa_private_numbers, generate_rsa_verification_test
+)
+from ...utils import (
+    load_pkcs1_vectors, load_rsa_nist_vectors, load_vectors_from_file,
+    raises_unsupported_algorithm
+)
+
+
+@utils.register_interface(padding.AsymmetricPadding)
+class DummyPadding(object):
+    name = "UNSUPPORTED-PADDING"
+
+
+class DummyMGF(object):
+    _salt_length = 0
+
+
+@utils.register_interface(serialization.KeySerializationEncryption)
+class DummyKeyEncryption(object):
+    pass
+
+
+def _flatten_pkcs1_examples(vectors):
+    flattened_vectors = []
+    for vector in vectors:
+        examples = vector[0].pop("examples")
+        for example in examples:
+            merged_vector = (vector[0], vector[1], example)
+            flattened_vectors.append(merged_vector)
+
+    return flattened_vectors
+
+
+def test_modular_inverse():
+    p = int(
+        "d1f9f6c09fd3d38987f7970247b85a6da84907753d42ec52bc23b745093f4fff5cff3"
+        "617ce43d00121a9accc0051f519c76e08cf02fc18acfe4c9e6aea18da470a2b611d2e"
+        "56a7b35caa2c0239bc041a53cc5875ca0b668ae6377d4b23e932d8c995fd1e58ecfd8"
+        "c4b73259c0d8a54d691cca3f6fb85c8a5c1baf588e898d481", 16
+    )
+    q = int(
+        "d1519255eb8f678c86cfd06802d1fbef8b664441ac46b73d33d13a8404580a33a8e74"
+        "cb2ea2e2963125b3d454d7a922cef24dd13e55f989cbabf64255a736671f4629a47b5"
+        "b2347cfcd669133088d1c159518531025297c2d67c9da856a12e80222cd03b4c6ec0f"
+        "86c957cb7bb8de7a127b645ec9e820aa94581e4762e209f01", 16
+    )
+    assert rsa._modinv(q, p) == int(
+        "0275e06afa722999315f8f322275483e15e2fb46d827b17800f99110b269a6732748f"
+        "624a382fa2ed1ec68c99f7fc56fb60e76eea51614881f497ba7034c17dde955f92f15"
+        "772f8b2b41f3e56d88b1e096cdd293eba4eae1e82db815e0fadea0c4ec971bc6fd875"
+        "c20e67e48c31a611e98d32c6213ae4c4d7b53023b2f80c538", 16
+    )
+
+
+@pytest.mark.requires_backend_interface(interface=RSABackend)
+class TestRSA(object):
+    @pytest.mark.parametrize(
+        ("public_exponent", "key_size"),
+        itertools.product(
+            (3, 5, 65537),
+            (1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1536, 2048)
+        )
+    )
+    def test_generate_rsa_keys(self, backend, public_exponent, key_size):
+        skey = rsa.generate_private_key(public_exponent, key_size, backend)
+        assert skey.key_size == key_size
+
+        _check_rsa_private_numbers(skey.private_numbers())
+        pkey = skey.public_key()
+        assert isinstance(pkey.public_numbers(), rsa.RSAPublicNumbers)
+
+    def test_generate_bad_public_exponent(self, backend):
+        with pytest.raises(ValueError):
+            rsa.generate_private_key(public_exponent=1,
+                                     key_size=2048,
+                                     backend=backend)
+
+        with pytest.raises(ValueError):
+            rsa.generate_private_key(public_exponent=4,
+                                     key_size=2048,
+                                     backend=backend)
+
+    def test_cant_generate_insecure_tiny_key(self, backend):
+        with pytest.raises(ValueError):
+            rsa.generate_private_key(public_exponent=65537,
+                                     key_size=511,
+                                     backend=backend)
+
+        with pytest.raises(ValueError):
+            rsa.generate_private_key(public_exponent=65537,
+                                     key_size=256,
+                                     backend=backend)
+
+    @pytest.mark.parametrize(
+        "pkcs1_example",
+        load_vectors_from_file(
+            os.path.join(
+                "asymmetric", "RSA", "pkcs-1v2-1d2-vec", "pss-vect.txt"),
+            load_pkcs1_vectors
+        )
+    )
+    def test_load_pss_vect_example_keys(self, pkcs1_example):
+        secret, public = pkcs1_example
+
+        private_num = rsa.RSAPrivateNumbers(
+            p=secret["p"],
+            q=secret["q"],
+            d=secret["private_exponent"],
+            dmp1=secret["dmp1"],
+            dmq1=secret["dmq1"],
+            iqmp=secret["iqmp"],
+            public_numbers=rsa.RSAPublicNumbers(
+                e=secret["public_exponent"],
+                n=secret["modulus"]
+            )
+        )
+        _check_rsa_private_numbers(private_num)
+
+        public_num = rsa.RSAPublicNumbers(
+            e=public["public_exponent"],
+            n=public["modulus"]
+        )
+        assert public_num
+
+        public_num2 = private_num.public_numbers
+        assert public_num2
+
+        assert public_num.n == public_num2.n
+        assert public_num.e == public_num2.e
+
+
+def test_rsa_generate_invalid_backend():
+    pretend_backend = object()
+
+    with raises_unsupported_algorithm(_Reasons.BACKEND_MISSING_INTERFACE):
+        rsa.generate_private_key(65537, 2048, pretend_backend)
+
+
+@pytest.mark.requires_backend_interface(interface=RSABackend)
+class TestRSASignature(object):
+    @pytest.mark.supported(
+        only_if=lambda backend: backend.rsa_padding_supported(
+            padding.PKCS1v15()
+        ),
+        skip_message="Does not support PKCS1v1.5."
+    )
+    @pytest.mark.parametrize(
+        "pkcs1_example",
+        _flatten_pkcs1_examples(load_vectors_from_file(
+            os.path.join(
+                "asymmetric", "RSA", "pkcs1v15sign-vectors.txt"),
+            load_pkcs1_vectors
+        ))
+    )
+    def test_pkcs1v15_signing(self, pkcs1_example, backend):
+        private, public, example = pkcs1_example
+        private_key = rsa.RSAPrivateNumbers(
+            p=private["p"],
+            q=private["q"],
+            d=private["private_exponent"],
+            dmp1=private["dmp1"],
+            dmq1=private["dmq1"],
+            iqmp=private["iqmp"],
+            public_numbers=rsa.RSAPublicNumbers(
+                e=private["public_exponent"],
+                n=private["modulus"]
+            )
+        ).private_key(backend)
+        signer = private_key.signer(padding.PKCS1v15(), hashes.SHA1())
+        signer.update(binascii.unhexlify(example["message"]))
+        signature = signer.finalize()
+        assert binascii.hexlify(signature) == example["signature"]
+
+    @pytest.mark.supported(
+        only_if=lambda backend: backend.rsa_padding_supported(
+            padding.PSS(
+                mgf=padding.MGF1(hashes.SHA1()),
+                salt_length=padding.PSS.MAX_LENGTH
+            )
+        ),
+        skip_message="Does not support PSS."
+    )
+    @pytest.mark.parametrize(
+        "pkcs1_example",
+        _flatten_pkcs1_examples(load_vectors_from_file(
+            os.path.join(
+                "asymmetric", "RSA", "pkcs-1v2-1d2-vec", "pss-vect.txt"),
+            load_pkcs1_vectors
+        ))
+    )
+    def test_pss_signing(self, pkcs1_example, backend):
+        private, public, example = pkcs1_example
+        private_key = rsa.RSAPrivateNumbers(
+            p=private["p"],
+            q=private["q"],
+            d=private["private_exponent"],
+            dmp1=private["dmp1"],
+            dmq1=private["dmq1"],
+            iqmp=private["iqmp"],
+            public_numbers=rsa.RSAPublicNumbers(
+                e=private["public_exponent"],
+                n=private["modulus"]
+            )
+        ).private_key(backend)
+        public_key = rsa.RSAPublicNumbers(
+            e=public["public_exponent"],
+            n=public["modulus"]
+        ).public_key(backend)
+        signer = private_key.signer(
+            padding.PSS(
+                mgf=padding.MGF1(algorithm=hashes.SHA1()),
+                salt_length=padding.PSS.MAX_LENGTH
+            ),
+            hashes.SHA1()
+        )
+        signer.update(binascii.unhexlify(example["message"]))
+        signature = signer.finalize()
+        assert len(signature) == math.ceil(private_key.key_size / 8.0)
+        # PSS signatures contain randomness so we can't do an exact
+        # signature check. Instead we'll verify that the signature created
+        # successfully verifies.
+        verifier = public_key.verifier(
+            signature,
+            padding.PSS(
+                mgf=padding.MGF1(algorithm=hashes.SHA1()),
+                salt_length=padding.PSS.MAX_LENGTH
+            ),
+            hashes.SHA1(),
+        )
+        verifier.update(binascii.unhexlify(example["message"]))
+        verifier.verify()
+
+    @pytest.mark.parametrize(
+        "hash_alg",
+        [hashes.SHA224(), hashes.SHA256(), hashes.SHA384(), hashes.SHA512()]
+    )
+    def test_pss_signing_sha2(self, hash_alg, backend):
+        if not backend.rsa_padding_supported(
+            padding.PSS(
+                mgf=padding.MGF1(hash_alg),
+                salt_length=padding.PSS.MAX_LENGTH
+            )
+        ):
+            pytest.skip(
+                "Does not support {0} in MGF1 using PSS.".format(hash_alg.name)
+            )
+        private_key = RSA_KEY_768.private_key(backend)
+        public_key = private_key.public_key()
+        pss = padding.PSS(
+            mgf=padding.MGF1(hash_alg),
+            salt_length=padding.PSS.MAX_LENGTH
+        )
+        signer = private_key.signer(pss, hash_alg)
+        signer.update(b"testing signature")
+        signature = signer.finalize()
+        verifier = public_key.verifier(signature, pss, hash_alg)
+        verifier.update(b"testing signature")
+        verifier.verify()
+
+    @pytest.mark.supported(
+        only_if=lambda backend: (
+            backend.hash_supported(hashes.SHA512()) and
+            backend.rsa_padding_supported(
+                padding.PSS(
+                    mgf=padding.MGF1(hashes.SHA1()),
+                    salt_length=padding.PSS.MAX_LENGTH
+                )
+            )
+        ),
+        skip_message="Does not support SHA512."
+    )
+    def test_pss_minimum_key_size_for_digest(self, backend):
+        private_key = RSA_KEY_522.private_key(backend)
+        signer = private_key.signer(
+            padding.PSS(
+                mgf=padding.MGF1(hashes.SHA1()),
+                salt_length=padding.PSS.MAX_LENGTH
+            ),
+            hashes.SHA512()
+        )
+        signer.update(b"no failure")
+        signer.finalize()
+
+    @pytest.mark.supported(
+        only_if=lambda backend: backend.rsa_padding_supported(
+            padding.PSS(
+                mgf=padding.MGF1(hashes.SHA1()),
+                salt_length=padding.PSS.MAX_LENGTH
+            )
+        ),
+        skip_message="Does not support PSS."
+    )
+    @pytest.mark.supported(
+        only_if=lambda backend: backend.hash_supported(hashes.SHA512()),
+        skip_message="Does not support SHA512."
+    )
+    def test_pss_signing_digest_too_large_for_key_size(self, backend):
+        private_key = RSA_KEY_512.private_key(backend)
+        with pytest.raises(ValueError):
+            private_key.signer(
+                padding.PSS(
+                    mgf=padding.MGF1(hashes.SHA1()),
+                    salt_length=padding.PSS.MAX_LENGTH
+                ),
+                hashes.SHA512()
+            )
+
+    @pytest.mark.supported(
+        only_if=lambda backend: backend.rsa_padding_supported(
+            padding.PSS(
+                mgf=padding.MGF1(hashes.SHA1()),
+                salt_length=padding.PSS.MAX_LENGTH
+            )
+        ),
+        skip_message="Does not support PSS."
+    )
+    def test_pss_signing_salt_length_too_long(self, backend):
+        private_key = RSA_KEY_512.private_key(backend)
+        signer = private_key.signer(
+            padding.PSS(
+                mgf=padding.MGF1(hashes.SHA1()),
+                salt_length=1000000
+            ),
+            hashes.SHA1()
+        )
+        signer.update(b"failure coming")
+        with pytest.raises(ValueError):
+            signer.finalize()
+
+    @pytest.mark.supported(
+        only_if=lambda backend: backend.rsa_padding_supported(
+            padding.PKCS1v15()
+        ),
+        skip_message="Does not support PKCS1v1.5."
+    )
+    def test_use_after_finalize(self, backend):
+        private_key = RSA_KEY_512.private_key(backend)
+        signer = private_key.signer(padding.PKCS1v15(), hashes.SHA1())
+        signer.update(b"sign me")
+        signer.finalize()
+        with pytest.raises(AlreadyFinalized):
+            signer.finalize()
+        with pytest.raises(AlreadyFinalized):
+            signer.update(b"more data")
+
+    def test_unsupported_padding(self, backend):
+        private_key = RSA_KEY_512.private_key(backend)
+        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_PADDING):
+            private_key.signer(DummyPadding(), hashes.SHA1())
+
+    def test_padding_incorrect_type(self, backend):
+        private_key = RSA_KEY_512.private_key(backend)
+        with pytest.raises(TypeError):
+            private_key.signer("notpadding", hashes.SHA1())
+
+    @pytest.mark.supported(
+        only_if=lambda backend: backend.rsa_padding_supported(
+            padding.PSS(mgf=padding.MGF1(hashes.SHA1()), salt_length=0)
+        ),
+        skip_message="Does not support PSS."
+    )
+    def test_unsupported_pss_mgf(self, backend):
+        private_key = RSA_KEY_512.private_key(backend)
+        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_MGF):
+            private_key.signer(
+                padding.PSS(
+                    mgf=DummyMGF(),
+                    salt_length=padding.PSS.MAX_LENGTH
+                ),
+                hashes.SHA1()
+            )
+
+    @pytest.mark.supported(
+        only_if=lambda backend: backend.rsa_padding_supported(
+            padding.PKCS1v15()
+        ),
+        skip_message="Does not support PKCS1v1.5."
+    )
+    def test_pkcs1_digest_too_large_for_key_size(self, backend):
+        private_key = RSA_KEY_599.private_key(backend)
+        signer = private_key.signer(
+            padding.PKCS1v15(),
+            hashes.SHA512()
+        )
+        signer.update(b"failure coming")
+        with pytest.raises(ValueError):
+            signer.finalize()
+
+    @pytest.mark.supported(
+        only_if=lambda backend: backend.rsa_padding_supported(
+            padding.PKCS1v15()
+        ),
+        skip_message="Does not support PKCS1v1.5."
+    )
+    def test_pkcs1_minimum_key_size(self, backend):
+        private_key = RSA_KEY_745.private_key(backend)
+        signer = private_key.signer(
+            padding.PKCS1v15(),
+            hashes.SHA512()
+        )
+        signer.update(b"no failure")
+        signer.finalize()
+
+
+@pytest.mark.requires_backend_interface(interface=RSABackend)
+class TestRSAVerification(object):
+    @pytest.mark.supported(
+        only_if=lambda backend: backend.rsa_padding_supported(
+            padding.PKCS1v15()
+        ),
+        skip_message="Does not support PKCS1v1.5."
+    )
+    @pytest.mark.parametrize(
+        "pkcs1_example",
+        _flatten_pkcs1_examples(load_vectors_from_file(
+            os.path.join(
+                "asymmetric", "RSA", "pkcs1v15sign-vectors.txt"),
+            load_pkcs1_vectors
+        ))
+    )
+    def test_pkcs1v15_verification(self, pkcs1_example, backend):
+        private, public, example = pkcs1_example
+        public_key = rsa.RSAPublicNumbers(
+            e=public["public_exponent"],
+            n=public["modulus"]
+        ).public_key(backend)
+        verifier = public_key.verifier(
+            binascii.unhexlify(example["signature"]),
+            padding.PKCS1v15(),
+            hashes.SHA1()
+        )
+        verifier.update(binascii.unhexlify(example["message"]))
+        verifier.verify()
+
+    @pytest.mark.supported(
+        only_if=lambda backend: backend.rsa_padding_supported(
+            padding.PKCS1v15()
+        ),
+        skip_message="Does not support PKCS1v1.5."
+    )
+    def test_invalid_pkcs1v15_signature_wrong_data(self, backend):
+        private_key = RSA_KEY_512.private_key(backend)
+        public_key = private_key.public_key()
+        signer = private_key.signer(padding.PKCS1v15(), hashes.SHA1())
+        signer.update(b"sign me")
+        signature = signer.finalize()
+        verifier = public_key.verifier(
+            signature,
+            padding.PKCS1v15(),
+            hashes.SHA1()
+        )
+        verifier.update(b"incorrect data")
+        with pytest.raises(InvalidSignature):
+            verifier.verify()
+
+    @pytest.mark.supported(
+        only_if=lambda backend: backend.rsa_padding_supported(
+            padding.PKCS1v15()
+        ),
+        skip_message="Does not support PKCS1v1.5."
+    )
+    def test_invalid_pkcs1v15_signature_wrong_key(self, backend):
+        private_key = RSA_KEY_512.private_key(backend)
+        private_key2 = RSA_KEY_512_ALT.private_key(backend)
+        public_key = private_key2.public_key()
+        signer = private_key.signer(padding.PKCS1v15(), hashes.SHA1())
+        signer.update(b"sign me")
+        signature = signer.finalize()
+        verifier = public_key.verifier(
+            signature,
+            padding.PKCS1v15(),
+            hashes.SHA1()
+        )
+        verifier.update(b"sign me")
+        with pytest.raises(InvalidSignature):
+            verifier.verify()
+
+    @pytest.mark.supported(
+        only_if=lambda backend: backend.rsa_padding_supported(
+            padding.PSS(
+                mgf=padding.MGF1(hashes.SHA1()),
+                salt_length=20
+            )
+        ),
+        skip_message="Does not support PSS."
+    )
+    @pytest.mark.parametrize(
+        "pkcs1_example",
+        _flatten_pkcs1_examples(load_vectors_from_file(
+            os.path.join(
+                "asymmetric", "RSA", "pkcs-1v2-1d2-vec", "pss-vect.txt"),
+            load_pkcs1_vectors
+        ))
+    )
+    def test_pss_verification(self, pkcs1_example, backend):
+        private, public, example = pkcs1_example
+        public_key = rsa.RSAPublicNumbers(
+            e=public["public_exponent"],
+            n=public["modulus"]
+        ).public_key(backend)
+        verifier = public_key.verifier(
+            binascii.unhexlify(example["signature"]),
+            padding.PSS(
+                mgf=padding.MGF1(algorithm=hashes.SHA1()),
+                salt_length=20
+            ),
+            hashes.SHA1()
+        )
+        verifier.update(binascii.unhexlify(example["message"]))
+        verifier.verify()
+
+    @pytest.mark.supported(
+        only_if=lambda backend: backend.rsa_padding_supported(
+            padding.PSS(
+                mgf=padding.MGF1(hashes.SHA1()),
+                salt_length=padding.PSS.MAX_LENGTH
+            )
+        ),
+        skip_message="Does not support PSS."
+    )
+    def test_invalid_pss_signature_wrong_data(self, backend):
+        public_key = rsa.RSAPublicNumbers(
+            n=int(
+                b"dffc2137d5e810cde9e4b4612f5796447218bab913b3fa98bdf7982e4fa6"
+                b"ec4d6653ef2b29fb1642b095befcbea6decc178fb4bed243d3c3592c6854"
+                b"6af2d3f3", 16
+            ),
+            e=65537
+        ).public_key(backend)
+        signature = binascii.unhexlify(
+            b"0e68c3649df91c5bc3665f96e157efa75b71934aaa514d91e94ca8418d100f45"
+            b"6f05288e58525f99666bab052adcffdf7186eb40f583bd38d98c97d3d524808b"
+        )
+        verifier = public_key.verifier(
+            signature,
+            padding.PSS(
+                mgf=padding.MGF1(algorithm=hashes.SHA1()),
+                salt_length=padding.PSS.MAX_LENGTH
+            ),
+            hashes.SHA1()
+        )
+        verifier.update(b"incorrect data")
+        with pytest.raises(InvalidSignature):
+            verifier.verify()
+
+    @pytest.mark.supported(
+        only_if=lambda backend: backend.rsa_padding_supported(
+            padding.PSS(
+                mgf=padding.MGF1(hashes.SHA1()),
+                salt_length=padding.PSS.MAX_LENGTH
+            )
+        ),
+        skip_message="Does not support PSS."
+    )
+    def test_invalid_pss_signature_wrong_key(self, backend):
+        signature = binascii.unhexlify(
+            b"3a1880165014ba6eb53cc1449d13e5132ebcc0cfd9ade6d7a2494a0503bd0826"
+            b"f8a46c431e0d7be0ca3e453f8b2b009e2733764da7927cc6dbe7a021437a242e"
+        )
+        public_key = rsa.RSAPublicNumbers(
+            n=int(
+                b"381201f4905d67dfeb3dec131a0fbea773489227ec7a1448c3109189ac68"
+                b"5a95441be90866a14c4d2e139cd16db540ec6c7abab13ffff91443fd46a8"
+                b"960cbb7658ded26a5c95c86f6e40384e1c1239c63e541ba221191c4dd303"
+                b"231b42e33c6dbddf5ec9a746f09bf0c25d0f8d27f93ee0ae5c0d723348f4"
+                b"030d3581e13522e1", 16
+            ),
+            e=65537
+        ).public_key(backend)
+        verifier = public_key.verifier(
+            signature,
+            padding.PSS(
+                mgf=padding.MGF1(algorithm=hashes.SHA1()),
+                salt_length=padding.PSS.MAX_LENGTH
+            ),
+            hashes.SHA1()
+        )
+        verifier.update(b"sign me")
+        with pytest.raises(InvalidSignature):
+            verifier.verify()
+
+    @pytest.mark.supported(
+        only_if=lambda backend: backend.rsa_padding_supported(
+            padding.PSS(
+                mgf=padding.MGF1(hashes.SHA1()),
+                salt_length=padding.PSS.MAX_LENGTH
+            )
+        ),
+        skip_message="Does not support PSS."
+    )
+    def test_invalid_pss_signature_data_too_large_for_modulus(self, backend):
+        signature = binascii.unhexlify(
+            b"cb43bde4f7ab89eb4a79c6e8dd67e0d1af60715da64429d90c716a490b799c29"
+            b"194cf8046509c6ed851052367a74e2e92d9b38947ed74332acb115a03fcc0222"
+        )
+        public_key = rsa.RSAPublicNumbers(
+            n=int(
+                b"381201f4905d67dfeb3dec131a0fbea773489227ec7a1448c3109189ac68"
+                b"5a95441be90866a14c4d2e139cd16db540ec6c7abab13ffff91443fd46a8"
+                b"960cbb7658ded26a5c95c86f6e40384e1c1239c63e541ba221191c4dd303"
+                b"231b42e33c6dbddf5ec9a746f09bf0c25d0f8d27f93ee0ae5c0d723348f4"
+                b"030d3581e13522", 16
+            ),
+            e=65537
+        ).public_key(backend)
+        verifier = public_key.verifier(
+            signature,
+            padding.PSS(
+                mgf=padding.MGF1(algorithm=hashes.SHA1()),
+                salt_length=padding.PSS.MAX_LENGTH
+            ),
+            hashes.SHA1()
+        )
+        verifier.update(b"sign me")
+        with pytest.raises(InvalidSignature):
+            verifier.verify()
+
+    @pytest.mark.supported(
+        only_if=lambda backend: backend.rsa_padding_supported(
+            padding.PKCS1v15()
+        ),
+        skip_message="Does not support PKCS1v1.5."
+    )
+    def test_use_after_finalize(self, backend):
+        private_key = RSA_KEY_512.private_key(backend)
+        public_key = private_key.public_key()
+        signer = private_key.signer(padding.PKCS1v15(), hashes.SHA1())
+        signer.update(b"sign me")
+        signature = signer.finalize()
+
+        verifier = public_key.verifier(
+            signature,
+            padding.PKCS1v15(),
+            hashes.SHA1()
+        )
+        verifier.update(b"sign me")
+        verifier.verify()
+        with pytest.raises(AlreadyFinalized):
+            verifier.verify()
+        with pytest.raises(AlreadyFinalized):
+            verifier.update(b"more data")
+
+    def test_unsupported_padding(self, backend):
+        private_key = RSA_KEY_512.private_key(backend)
+        public_key = private_key.public_key()
+        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_PADDING):
+            public_key.verifier(b"sig", DummyPadding(), hashes.SHA1())
+
+    @pytest.mark.supported(
+        only_if=lambda backend: backend.rsa_padding_supported(
+            padding.PKCS1v15()
+        ),
+        skip_message="Does not support PKCS1v1.5."
+    )
+    def test_signature_not_bytes(self, backend):
+        public_key = RSA_KEY_512.public_numbers.public_key(backend)
+        signature = 1234
+
+        with pytest.raises(TypeError):
+            public_key.verifier(
+                signature,
+                padding.PKCS1v15(),
+                hashes.SHA1()
+            )
+
+    def test_padding_incorrect_type(self, backend):
+        private_key = RSA_KEY_512.private_key(backend)
+        public_key = private_key.public_key()
+        with pytest.raises(TypeError):
+            public_key.verifier(b"sig", "notpadding", hashes.SHA1())
+
+    @pytest.mark.supported(
+        only_if=lambda backend: backend.rsa_padding_supported(
+            padding.PSS(mgf=padding.MGF1(hashes.SHA1()), salt_length=0)
+        ),
+        skip_message="Does not support PSS."
+    )
+    def test_unsupported_pss_mgf(self, backend):
+        private_key = RSA_KEY_512.private_key(backend)
+        public_key = private_key.public_key()
+        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_MGF):
+            public_key.verifier(
+                b"sig",
+                padding.PSS(
+                    mgf=DummyMGF(),
+                    salt_length=padding.PSS.MAX_LENGTH
+                ),
+                hashes.SHA1()
+            )
+
+    @pytest.mark.supported(
+        only_if=lambda backend: backend.rsa_padding_supported(
+            padding.PSS(
+                mgf=padding.MGF1(hashes.SHA1()),
+                salt_length=padding.PSS.MAX_LENGTH
+            )
+        ),
+        skip_message="Does not support PSS."
+    )
+    @pytest.mark.supported(
+        only_if=lambda backend: backend.hash_supported(hashes.SHA512()),
+        skip_message="Does not support SHA512."
+    )
+    def test_pss_verify_digest_too_large_for_key_size(self, backend):
+        private_key = RSA_KEY_512.private_key(backend)
+        signature = binascii.unhexlify(
+            b"8b9a3ae9fb3b64158f3476dd8d8a1f1425444e98940e0926378baa9944d219d8"
+            b"534c050ef6b19b1bdc6eb4da422e89161106a6f5b5cc16135b11eb6439b646bd"
+        )
+        public_key = private_key.public_key()
+        with pytest.raises(ValueError):
+            public_key.verifier(
+                signature,
+                padding.PSS(
+                    mgf=padding.MGF1(algorithm=hashes.SHA1()),
+                    salt_length=padding.PSS.MAX_LENGTH
+                ),
+                hashes.SHA512()
+            )
+
+    @pytest.mark.supported(
+        only_if=lambda backend: backend.rsa_padding_supported(
+            padding.PSS(
+                mgf=padding.MGF1(hashes.SHA1()),
+                salt_length=padding.PSS.MAX_LENGTH
+            )
+        ),
+        skip_message="Does not support PSS."
+    )
+    def test_pss_verify_salt_length_too_long(self, backend):
+        signature = binascii.unhexlify(
+            b"8b9a3ae9fb3b64158f3476dd8d8a1f1425444e98940e0926378baa9944d219d8"
+            b"534c050ef6b19b1bdc6eb4da422e89161106a6f5b5cc16135b11eb6439b646bd"
+        )
+        public_key = rsa.RSAPublicNumbers(
+            n=int(
+                b"d309e4612809437548b747d7f9eb9cd3340f54fe42bb3f84a36933b0839c"
+                b"11b0c8b7f67e11f7252370161e31159c49c784d4bc41c42a78ce0f0b40a3"
+                b"ca8ffb91", 16
+            ),
+            e=65537
+        ).public_key(backend)
+        verifier = public_key.verifier(
+            signature,
+            padding.PSS(
+                mgf=padding.MGF1(
+                    algorithm=hashes.SHA1(),
+                ),
+                salt_length=1000000
+            ),
+            hashes.SHA1()
+        )
+        verifier.update(b"sign me")
+        with pytest.raises(InvalidSignature):
+            verifier.verify()
+
+
+@pytest.mark.requires_backend_interface(interface=RSABackend)
+class TestRSAPSSMGF1Verification(object):
+    test_rsa_pss_mgf1_sha1 = pytest.mark.supported(
+        only_if=lambda backend: backend.rsa_padding_supported(
+            padding.PSS(
+                mgf=padding.MGF1(hashes.SHA1()),
+                salt_length=padding.PSS.MAX_LENGTH
+            )
+        ),
+        skip_message="Does not support PSS using MGF1 with SHA1."
+    )(generate_rsa_verification_test(
+        load_rsa_nist_vectors,
+        os.path.join("asymmetric", "RSA", "FIPS_186-2"),
+        [
+            "SigGenPSS_186-2.rsp",
+            "SigGenPSS_186-3.rsp",
+            "SigVerPSS_186-3.rsp",
+        ],
+        hashes.SHA1(),
+        lambda params, hash_alg: padding.PSS(
+            mgf=padding.MGF1(
+                algorithm=hash_alg,
+            ),
+            salt_length=params["salt_length"]
+        )
+    ))
+
+    test_rsa_pss_mgf1_sha224 = pytest.mark.supported(
+        only_if=lambda backend: backend.rsa_padding_supported(
+            padding.PSS(
+                mgf=padding.MGF1(hashes.SHA224()),
+                salt_length=padding.PSS.MAX_LENGTH
+            )
+        ),
+        skip_message="Does not support PSS using MGF1 with SHA224."
+    )(generate_rsa_verification_test(
+        load_rsa_nist_vectors,
+        os.path.join("asymmetric", "RSA", "FIPS_186-2"),
+        [
+            "SigGenPSS_186-2.rsp",
+            "SigGenPSS_186-3.rsp",
+            "SigVerPSS_186-3.rsp",
+        ],
+        hashes.SHA224(),
+        lambda params, hash_alg: padding.PSS(
+            mgf=padding.MGF1(
+                algorithm=hash_alg,
+            ),
+            salt_length=params["salt_length"]
+        )
+    ))
+
+    test_rsa_pss_mgf1_sha256 = pytest.mark.supported(
+        only_if=lambda backend: backend.rsa_padding_supported(
+            padding.PSS(
+                mgf=padding.MGF1(hashes.SHA256()),
+                salt_length=padding.PSS.MAX_LENGTH
+            )
+        ),
+        skip_message="Does not support PSS using MGF1 with SHA256."
+    )(generate_rsa_verification_test(
+        load_rsa_nist_vectors,
+        os.path.join("asymmetric", "RSA", "FIPS_186-2"),
+        [
+            "SigGenPSS_186-2.rsp",
+            "SigGenPSS_186-3.rsp",
+            "SigVerPSS_186-3.rsp",
+        ],
+        hashes.SHA256(),
+        lambda params, hash_alg: padding.PSS(
+            mgf=padding.MGF1(
+                algorithm=hash_alg,
+            ),
+            salt_length=params["salt_length"]
+        )
+    ))
+
+    test_rsa_pss_mgf1_sha384 = pytest.mark.supported(
+        only_if=lambda backend: backend.rsa_padding_supported(
+            padding.PSS(
+                mgf=padding.MGF1(hashes.SHA384()),
+                salt_length=padding.PSS.MAX_LENGTH
+            )
+        ),
+        skip_message="Does not support PSS using MGF1 with SHA384."
+    )(generate_rsa_verification_test(
+        load_rsa_nist_vectors,
+        os.path.join("asymmetric", "RSA", "FIPS_186-2"),
+        [
+            "SigGenPSS_186-2.rsp",
+            "SigGenPSS_186-3.rsp",
+            "SigVerPSS_186-3.rsp",
+        ],
+        hashes.SHA384(),
+        lambda params, hash_alg: padding.PSS(
+            mgf=padding.MGF1(
+                algorithm=hash_alg,
+            ),
+            salt_length=params["salt_length"]
+        )
+    ))
+
+    test_rsa_pss_mgf1_sha512 = pytest.mark.supported(
+        only_if=lambda backend: backend.rsa_padding_supported(
+            padding.PSS(
+                mgf=padding.MGF1(hashes.SHA512()),
+                salt_length=padding.PSS.MAX_LENGTH
+            )
+        ),
+        skip_message="Does not support PSS using MGF1 with SHA512."
+    )(generate_rsa_verification_test(
+        load_rsa_nist_vectors,
+        os.path.join("asymmetric", "RSA", "FIPS_186-2"),
+        [
+            "SigGenPSS_186-2.rsp",
+            "SigGenPSS_186-3.rsp",
+            "SigVerPSS_186-3.rsp",
+        ],
+        hashes.SHA512(),
+        lambda params, hash_alg: padding.PSS(
+            mgf=padding.MGF1(
+                algorithm=hash_alg,
+            ),
+            salt_length=params["salt_length"]
+        )
+    ))
+
+
+@pytest.mark.requires_backend_interface(interface=RSABackend)
+class TestRSAPKCS1Verification(object):
+    test_rsa_pkcs1v15_verify_sha1 = pytest.mark.supported(
+        only_if=lambda backend: (
+            backend.hash_supported(hashes.SHA1()) and
+            backend.rsa_padding_supported(padding.PKCS1v15())
+        ),
+        skip_message="Does not support SHA1 and PKCS1v1.5."
+    )(generate_rsa_verification_test(
+        load_rsa_nist_vectors,
+        os.path.join("asymmetric", "RSA", "FIPS_186-2"),
+        [
+            "SigGen15_186-2.rsp",
+            "SigGen15_186-3.rsp",
+            "SigVer15_186-3.rsp",
+        ],
+        hashes.SHA1(),
+        lambda params, hash_alg: padding.PKCS1v15()
+    ))
+
+    test_rsa_pkcs1v15_verify_sha224 = pytest.mark.supported(
+        only_if=lambda backend: (
+            backend.hash_supported(hashes.SHA224()) and
+            backend.rsa_padding_supported(padding.PKCS1v15())
+        ),
+        skip_message="Does not support SHA224 and PKCS1v1.5."
+    )(generate_rsa_verification_test(
+        load_rsa_nist_vectors,
+        os.path.join("asymmetric", "RSA", "FIPS_186-2"),
+        [
+            "SigGen15_186-2.rsp",
+            "SigGen15_186-3.rsp",
+            "SigVer15_186-3.rsp",
+        ],
+        hashes.SHA224(),
+        lambda params, hash_alg: padding.PKCS1v15()
+    ))
+
+    test_rsa_pkcs1v15_verify_sha256 = pytest.mark.supported(
+        only_if=lambda backend: (
+            backend.hash_supported(hashes.SHA256()) and
+            backend.rsa_padding_supported(padding.PKCS1v15())
+        ),
+        skip_message="Does not support SHA256 and PKCS1v1.5."
+    )(generate_rsa_verification_test(
+        load_rsa_nist_vectors,
+        os.path.join("asymmetric", "RSA", "FIPS_186-2"),
+        [
+            "SigGen15_186-2.rsp",
+            "SigGen15_186-3.rsp",
+            "SigVer15_186-3.rsp",
+        ],
+        hashes.SHA256(),
+        lambda params, hash_alg: padding.PKCS1v15()
+    ))
+
+    test_rsa_pkcs1v15_verify_sha384 = pytest.mark.supported(
+        only_if=lambda backend: (
+            backend.hash_supported(hashes.SHA384()) and
+            backend.rsa_padding_supported(padding.PKCS1v15())
+        ),
+        skip_message="Does not support SHA384 and PKCS1v1.5."
+    )(generate_rsa_verification_test(
+        load_rsa_nist_vectors,
+        os.path.join("asymmetric", "RSA", "FIPS_186-2"),
+        [
+            "SigGen15_186-2.rsp",
+            "SigGen15_186-3.rsp",
+            "SigVer15_186-3.rsp",
+        ],
+        hashes.SHA384(),
+        lambda params, hash_alg: padding.PKCS1v15()
+    ))
+
+    test_rsa_pkcs1v15_verify_sha512 = pytest.mark.supported(
+        only_if=lambda backend: (
+            backend.hash_supported(hashes.SHA512()) and
+            backend.rsa_padding_supported(padding.PKCS1v15())
+        ),
+        skip_message="Does not support SHA512 and PKCS1v1.5."
+    )(generate_rsa_verification_test(
+        load_rsa_nist_vectors,
+        os.path.join("asymmetric", "RSA", "FIPS_186-2"),
+        [
+            "SigGen15_186-2.rsp",
+            "SigGen15_186-3.rsp",
+            "SigVer15_186-3.rsp",
+        ],
+        hashes.SHA512(),
+        lambda params, hash_alg: padding.PKCS1v15()
+    ))
+
+
+class TestPSS(object):
+    def test_invalid_salt_length_not_integer(self):
+        with pytest.raises(TypeError):
+            padding.PSS(
+                mgf=padding.MGF1(
+                    hashes.SHA1()
+                ),
+                salt_length=b"not_a_length"
+            )
+
+    def test_invalid_salt_length_negative_integer(self):
+        with pytest.raises(ValueError):
+            padding.PSS(
+                mgf=padding.MGF1(
+                    hashes.SHA1()
+                ),
+                salt_length=-1
+            )
+
+    def test_valid_pss_parameters(self):
+        algorithm = hashes.SHA1()
+        salt_length = algorithm.digest_size
+        mgf = padding.MGF1(algorithm)
+        pss = padding.PSS(mgf=mgf, salt_length=salt_length)
+        assert pss._mgf == mgf
+        assert pss._salt_length == salt_length
+
+    def test_valid_pss_parameters_maximum(self):
+        algorithm = hashes.SHA1()
+        mgf = padding.MGF1(algorithm)
+        pss = padding.PSS(mgf=mgf, salt_length=padding.PSS.MAX_LENGTH)
+        assert pss._mgf == mgf
+        assert pss._salt_length == padding.PSS.MAX_LENGTH
+
+
+class TestMGF1(object):
+    def test_invalid_hash_algorithm(self):
+        with pytest.raises(TypeError):
+            padding.MGF1(b"not_a_hash")
+
+    def test_valid_mgf1_parameters(self):
+        algorithm = hashes.SHA1()
+        mgf = padding.MGF1(algorithm)
+        assert mgf._algorithm == algorithm
+
+
+class TestOAEP(object):
+    def test_invalid_algorithm(self):
+        mgf = padding.MGF1(hashes.SHA1())
+        with pytest.raises(TypeError):
+            padding.OAEP(
+                mgf=mgf,
+                algorithm=b"",
+                label=None
+            )
+
+
+@pytest.mark.requires_backend_interface(interface=RSABackend)
+class TestRSADecryption(object):
+    @pytest.mark.supported(
+        only_if=lambda backend: backend.rsa_padding_supported(
+            padding.PKCS1v15()
+        ),
+        skip_message="Does not support PKCS1v1.5."
+    )
+    @pytest.mark.parametrize(
+        "vector",
+        _flatten_pkcs1_examples(load_vectors_from_file(
+            os.path.join(
+                "asymmetric", "RSA", "pkcs1v15crypt-vectors.txt"),
+            load_pkcs1_vectors
+        ))
+    )
+    def test_decrypt_pkcs1v15_vectors(self, vector, backend):
+        private, public, example = vector
+        skey = rsa.RSAPrivateNumbers(
+            p=private["p"],
+            q=private["q"],
+            d=private["private_exponent"],
+            dmp1=private["dmp1"],
+            dmq1=private["dmq1"],
+            iqmp=private["iqmp"],
+            public_numbers=rsa.RSAPublicNumbers(
+                e=private["public_exponent"],
+                n=private["modulus"]
+            )
+        ).private_key(backend)
+        ciphertext = binascii.unhexlify(example["encryption"])
+        assert len(ciphertext) == math.ceil(skey.key_size / 8.0)
+        message = skey.decrypt(ciphertext, padding.PKCS1v15())
+        assert message == binascii.unhexlify(example["message"])
+
+    def test_unsupported_padding(self, backend):
+        private_key = RSA_KEY_512.private_key(backend)
+        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_PADDING):
+            private_key.decrypt(b"0" * 64, DummyPadding())
+
+    @pytest.mark.supported(
+        only_if=lambda backend: backend.rsa_padding_supported(
+            padding.PKCS1v15()
+        ),
+        skip_message="Does not support PKCS1v1.5."
+    )
+    def test_decrypt_invalid_decrypt(self, backend):
+        private_key = RSA_KEY_512.private_key(backend)
+        with pytest.raises(ValueError):
+            private_key.decrypt(
+                b"\x00" * 64,
+                padding.PKCS1v15()
+            )
+
+    @pytest.mark.supported(
+        only_if=lambda backend: backend.rsa_padding_supported(
+            padding.PKCS1v15()
+        ),
+        skip_message="Does not support PKCS1v1.5."
+    )
+    def test_decrypt_ciphertext_too_large(self, backend):
+        private_key = RSA_KEY_512.private_key(backend)
+        with pytest.raises(ValueError):
+            private_key.decrypt(
+                b"\x00" * 65,
+                padding.PKCS1v15()
+            )
+
+    @pytest.mark.supported(
+        only_if=lambda backend: backend.rsa_padding_supported(
+            padding.PKCS1v15()
+        ),
+        skip_message="Does not support PKCS1v1.5."
+    )
+    def test_decrypt_ciphertext_too_small(self, backend):
+        private_key = RSA_KEY_512.private_key(backend)
+        ct = binascii.unhexlify(
+            b"50b4c14136bd198c2f3c3ed243fce036e168d56517984a263cd66492b80804f1"
+            b"69d210f2b9bdfb48b12f9ea05009c77da257cc600ccefe3a6283789d8ea0"
+        )
+        with pytest.raises(ValueError):
+            private_key.decrypt(
+                ct,
+                padding.PKCS1v15()
+            )
+
+    @pytest.mark.supported(
+        only_if=lambda backend: backend.rsa_padding_supported(
+            padding.OAEP(
+                mgf=padding.MGF1(algorithm=hashes.SHA1()),
+                algorithm=hashes.SHA1(),
+                label=None
+            )
+        ),
+        skip_message="Does not support OAEP."
+    )
+    @pytest.mark.parametrize(
+        "vector",
+        _flatten_pkcs1_examples(load_vectors_from_file(
+            os.path.join(
+                "asymmetric", "RSA", "pkcs-1v2-1d2-vec", "oaep-vect.txt"),
+            load_pkcs1_vectors
+        ))
+    )
+    def test_decrypt_oaep_vectors(self, vector, backend):
+        private, public, example = vector
+        skey = rsa.RSAPrivateNumbers(
+            p=private["p"],
+            q=private["q"],
+            d=private["private_exponent"],
+            dmp1=private["dmp1"],
+            dmq1=private["dmq1"],
+            iqmp=private["iqmp"],
+            public_numbers=rsa.RSAPublicNumbers(
+                e=private["public_exponent"],
+                n=private["modulus"]
+            )
+        ).private_key(backend)
+        message = skey.decrypt(
+            binascii.unhexlify(example["encryption"]),
+            padding.OAEP(
+                mgf=padding.MGF1(algorithm=hashes.SHA1()),
+                algorithm=hashes.SHA1(),
+                label=None
+            )
+        )
+        assert message == binascii.unhexlify(example["message"])
+
+    def test_unsupported_oaep_mgf(self, backend):
+        private_key = RSA_KEY_512.private_key(backend)
+        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_MGF):
+            private_key.decrypt(
+                b"0" * 64,
+                padding.OAEP(
+                    mgf=DummyMGF(),
+                    algorithm=hashes.SHA1(),
+                    label=None
+                )
+            )
+
+
+@pytest.mark.requires_backend_interface(interface=RSABackend)
+class TestRSAEncryption(object):
+    @pytest.mark.supported(
+        only_if=lambda backend: backend.rsa_padding_supported(
+            padding.OAEP(
+                mgf=padding.MGF1(algorithm=hashes.SHA1()),
+                algorithm=hashes.SHA1(),
+                label=None
+            )
+        ),
+        skip_message="Does not support OAEP."
+    )
+    @pytest.mark.parametrize(
+        ("key_data", "pad"),
+        itertools.product(
+            (RSA_KEY_1024, RSA_KEY_1025, RSA_KEY_1026, RSA_KEY_1027,
+             RSA_KEY_1028, RSA_KEY_1029, RSA_KEY_1030, RSA_KEY_1031,
+             RSA_KEY_1536, RSA_KEY_2048),
+            [
+                padding.OAEP(
+                    mgf=padding.MGF1(algorithm=hashes.SHA1()),
+                    algorithm=hashes.SHA1(),
+                    label=None
+                )
+            ]
+        )
+    )
+    def test_rsa_encrypt_oaep(self, key_data, pad, backend):
+        private_key = key_data.private_key(backend)
+        pt = b"encrypt me!"
+        public_key = private_key.public_key()
+        ct = public_key.encrypt(pt, pad)
+        assert ct != pt
+        assert len(ct) == math.ceil(public_key.key_size / 8.0)
+        recovered_pt = private_key.decrypt(ct, pad)
+        assert recovered_pt == pt
+
+    @pytest.mark.supported(
+        only_if=lambda backend: backend.rsa_padding_supported(
+            padding.PKCS1v15()
+        ),
+        skip_message="Does not support PKCS1v1.5."
+    )
+    @pytest.mark.parametrize(
+        ("key_data", "pad"),
+        itertools.product(
+            (RSA_KEY_1024, RSA_KEY_1025, RSA_KEY_1026, RSA_KEY_1027,
+             RSA_KEY_1028, RSA_KEY_1029, RSA_KEY_1030, RSA_KEY_1031,
+             RSA_KEY_1536, RSA_KEY_2048),
+            [padding.PKCS1v15()]
+        )
+    )
+    def test_rsa_encrypt_pkcs1v15(self, key_data, pad, backend):
+        private_key = key_data.private_key(backend)
+        pt = b"encrypt me!"
+        public_key = private_key.public_key()
+        ct = public_key.encrypt(pt, pad)
+        assert ct != pt
+        assert len(ct) == math.ceil(public_key.key_size / 8.0)
+        recovered_pt = private_key.decrypt(ct, pad)
+        assert recovered_pt == pt
+
+    @pytest.mark.parametrize(
+        ("key_data", "pad"),
+        itertools.product(
+            (RSA_KEY_1024, RSA_KEY_1025, RSA_KEY_1026, RSA_KEY_1027,
+             RSA_KEY_1028, RSA_KEY_1029, RSA_KEY_1030, RSA_KEY_1031,
+             RSA_KEY_1536, RSA_KEY_2048),
+            (
+                padding.OAEP(
+                    mgf=padding.MGF1(algorithm=hashes.SHA1()),
+                    algorithm=hashes.SHA1(),
+                    label=None
+                ),
+                padding.PKCS1v15()
+            )
+        )
+    )
+    def test_rsa_encrypt_key_too_small(self, key_data, pad, backend):
+        private_key = key_data.private_key(backend)
+        public_key = private_key.public_key()
+        # Slightly smaller than the key size but not enough for padding.
+        with pytest.raises(ValueError):
+            public_key.encrypt(
+                b"\x00" * (private_key.key_size // 8 - 1),
+                pad
+            )
+
+        # Larger than the key size.
+        with pytest.raises(ValueError):
+            public_key.encrypt(
+                b"\x00" * (private_key.key_size // 8 + 5),
+                pad
+            )
+
+    def test_unsupported_padding(self, backend):
+        private_key = RSA_KEY_512.private_key(backend)
+        public_key = private_key.public_key()
+
+        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_PADDING):
+            public_key.encrypt(b"somedata", DummyPadding())
+        with pytest.raises(TypeError):
+            public_key.encrypt(b"somedata", padding=object())
+
+    def test_unsupported_oaep_mgf(self, backend):
+        private_key = RSA_KEY_512.private_key(backend)
+        public_key = private_key.public_key()
+
+        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_MGF):
+            public_key.encrypt(
+                b"ciphertext",
+                padding.OAEP(
+                    mgf=DummyMGF(),
+                    algorithm=hashes.SHA1(),
+                    label=None
+                )
+            )
+
+
+@pytest.mark.requires_backend_interface(interface=RSABackend)
+class TestRSANumbers(object):
+    def test_rsa_public_numbers(self):
+        public_numbers = rsa.RSAPublicNumbers(e=1, n=15)
+        assert public_numbers.e == 1
+        assert public_numbers.n == 15
+
+    def test_rsa_private_numbers(self):
+        public_numbers = rsa.RSAPublicNumbers(e=1, n=15)
+        private_numbers = rsa.RSAPrivateNumbers(
+            p=3,
+            q=5,
+            d=1,
+            dmp1=1,
+            dmq1=1,
+            iqmp=2,
+            public_numbers=public_numbers
+        )
+
+        assert private_numbers.p == 3
+        assert private_numbers.q == 5
+        assert private_numbers.d == 1
+        assert private_numbers.dmp1 == 1
+        assert private_numbers.dmq1 == 1
+        assert private_numbers.iqmp == 2
+        assert private_numbers.public_numbers == public_numbers
+
+    def test_rsa_private_numbers_create_key(self, backend):
+        private_key = RSA_KEY_1024.private_key(backend)
+        assert private_key
+
+    def test_rsa_public_numbers_create_key(self, backend):
+        public_key = RSA_KEY_1024.public_numbers.public_key(backend)
+        assert public_key
+
+    def test_public_numbers_invalid_types(self):
+        with pytest.raises(TypeError):
+            rsa.RSAPublicNumbers(e=None, n=15)
+
+        with pytest.raises(TypeError):
+            rsa.RSAPublicNumbers(e=1, n=None)
+
+    def test_private_numbers_invalid_types(self):
+        public_numbers = rsa.RSAPublicNumbers(e=1, n=15)
+
+        with pytest.raises(TypeError):
+            rsa.RSAPrivateNumbers(
+                p=None,
+                q=5,
+                d=1,
+                dmp1=1,
+                dmq1=1,
+                iqmp=2,
+                public_numbers=public_numbers
+            )
+
+        with pytest.raises(TypeError):
+            rsa.RSAPrivateNumbers(
+                p=3,
+                q=None,
+                d=1,
+                dmp1=1,
+                dmq1=1,
+                iqmp=2,
+                public_numbers=public_numbers
+            )
+
+        with pytest.raises(TypeError):
+            rsa.RSAPrivateNumbers(
+                p=3,
+                q=5,
+                d=None,
+                dmp1=1,
+                dmq1=1,
+                iqmp=2,
+                public_numbers=public_numbers
+            )
+
+        with pytest.raises(TypeError):
+            rsa.RSAPrivateNumbers(
+                p=3,
+                q=5,
+                d=1,
+                dmp1=None,
+                dmq1=1,
+                iqmp=2,
+                public_numbers=public_numbers
+            )
+
+        with pytest.raises(TypeError):
+            rsa.RSAPrivateNumbers(
+                p=3,
+                q=5,
+                d=1,
+                dmp1=1,
+                dmq1=None,
+                iqmp=2,
+                public_numbers=public_numbers
+            )
+
+        with pytest.raises(TypeError):
+            rsa.RSAPrivateNumbers(
+                p=3,
+                q=5,
+                d=1,
+                dmp1=1,
+                dmq1=1,
+                iqmp=None,
+                public_numbers=public_numbers
+            )
+
+        with pytest.raises(TypeError):
+            rsa.RSAPrivateNumbers(
+                p=3,
+                q=5,
+                d=1,
+                dmp1=1,
+                dmq1=1,
+                iqmp=2,
+                public_numbers=None
+            )
+
+    def test_invalid_public_numbers_argument_values(self, backend):
+        # Start with public_exponent=7, modulus=15. Then change one value at a
+        # time to test the bounds.
+
+        # Test a modulus < 3.
+
+        with pytest.raises(ValueError):
+            rsa.RSAPublicNumbers(e=7, n=2).public_key(backend)
+
+        # Test a public_exponent < 3
+        with pytest.raises(ValueError):
+            rsa.RSAPublicNumbers(e=1, n=15).public_key(backend)
+
+        # Test a public_exponent > modulus
+        with pytest.raises(ValueError):
+            rsa.RSAPublicNumbers(e=17, n=15).public_key(backend)
+
+        # Test a public_exponent that is not odd.
+        with pytest.raises(ValueError):
+            rsa.RSAPublicNumbers(e=14, n=15).public_key(backend)
+
+    def test_invalid_private_numbers_argument_values(self, backend):
+        # Start with p=3, q=11, private_exponent=3, public_exponent=7,
+        # modulus=33, dmp1=1, dmq1=3, iqmp=2. Then change one value at
+        # a time to test the bounds.
+
+        # Test a modulus < 3.
+        with pytest.raises(ValueError):
+            rsa.RSAPrivateNumbers(
+                p=3,
+                q=11,
+                d=3,
+                dmp1=1,
+                dmq1=3,
+                iqmp=2,
+                public_numbers=rsa.RSAPublicNumbers(
+                    e=7,
+                    n=2
+                )
+            ).private_key(backend)
+
+        # Test a modulus != p * q.
+        with pytest.raises(ValueError):
+            rsa.RSAPrivateNumbers(
+                p=3,
+                q=11,
+                d=3,
+                dmp1=1,
+                dmq1=3,
+                iqmp=2,
+                public_numbers=rsa.RSAPublicNumbers(
+                    e=7,
+                    n=35
+                )
+            ).private_key(backend)
+
+        # Test a p > modulus.
+        with pytest.raises(ValueError):
+            rsa.RSAPrivateNumbers(
+                p=37,
+                q=11,
+                d=3,
+                dmp1=1,
+                dmq1=3,
+                iqmp=2,
+                public_numbers=rsa.RSAPublicNumbers(
+                    e=7,
+                    n=33
+                )
+            ).private_key(backend)
+
+        # Test a q > modulus.
+        with pytest.raises(ValueError):
+            rsa.RSAPrivateNumbers(
+                p=3,
+                q=37,
+                d=3,
+                dmp1=1,
+                dmq1=3,
+                iqmp=2,
+                public_numbers=rsa.RSAPublicNumbers(
+                    e=7,
+                    n=33
+                )
+            ).private_key(backend)
+
+        # Test a dmp1 > modulus.
+        with pytest.raises(ValueError):
+            rsa.RSAPrivateNumbers(
+                p=3,
+                q=11,
+                d=3,
+                dmp1=35,
+                dmq1=3,
+                iqmp=2,
+                public_numbers=rsa.RSAPublicNumbers(
+                    e=7,
+                    n=33
+                )
+            ).private_key(backend)
+
+        # Test a dmq1 > modulus.
+        with pytest.raises(ValueError):
+            rsa.RSAPrivateNumbers(
+                p=3,
+                q=11,
+                d=3,
+                dmp1=1,
+                dmq1=35,
+                iqmp=2,
+                public_numbers=rsa.RSAPublicNumbers(
+                    e=7,
+                    n=33
+                )
+            ).private_key(backend)
+
+        # Test an iqmp > modulus.
+        with pytest.raises(ValueError):
+            rsa.RSAPrivateNumbers(
+                p=3,
+                q=11,
+                d=3,
+                dmp1=1,
+                dmq1=3,
+                iqmp=35,
+                public_numbers=rsa.RSAPublicNumbers(
+                    e=7,
+                    n=33
+                )
+            ).private_key(backend)
+
+        # Test a private_exponent > modulus
+        with pytest.raises(ValueError):
+            rsa.RSAPrivateNumbers(
+                p=3,
+                q=11,
+                d=37,
+                dmp1=1,
+                dmq1=3,
+                iqmp=2,
+                public_numbers=rsa.RSAPublicNumbers(
+                    e=7,
+                    n=33
+                )
+            ).private_key(backend)
+
+        # Test a public_exponent < 3
+        with pytest.raises(ValueError):
+            rsa.RSAPrivateNumbers(
+                p=3,
+                q=11,
+                d=3,
+                dmp1=1,
+                dmq1=3,
+                iqmp=2,
+                public_numbers=rsa.RSAPublicNumbers(
+                    e=1,
+                    n=33
+                )
+            ).private_key(backend)
+
+        # Test a public_exponent > modulus
+        with pytest.raises(ValueError):
+            rsa.RSAPrivateNumbers(
+                p=3,
+                q=11,
+                d=3,
+                dmp1=1,
+                dmq1=3,
+                iqmp=35,
+                public_numbers=rsa.RSAPublicNumbers(
+                    e=65537,
+                    n=33
+                )
+            ).private_key(backend)
+
+        # Test a public_exponent that is not odd.
+        with pytest.raises(ValueError):
+            rsa.RSAPrivateNumbers(
+                p=3,
+                q=11,
+                d=3,
+                dmp1=1,
+                dmq1=3,
+                iqmp=2,
+                public_numbers=rsa.RSAPublicNumbers(
+                    e=6,
+                    n=33
+                )
+            ).private_key(backend)
+
+        # Test a dmp1 that is not odd.
+        with pytest.raises(ValueError):
+            rsa.RSAPrivateNumbers(
+                p=3,
+                q=11,
+                d=3,
+                dmp1=2,
+                dmq1=3,
+                iqmp=2,
+                public_numbers=rsa.RSAPublicNumbers(
+                    e=7,
+                    n=33
+                )
+            ).private_key(backend)
+
+        # Test a dmq1 that is not odd.
+        with pytest.raises(ValueError):
+            rsa.RSAPrivateNumbers(
+                p=3,
+                q=11,
+                d=3,
+                dmp1=1,
+                dmq1=4,
+                iqmp=2,
+                public_numbers=rsa.RSAPublicNumbers(
+                    e=7,
+                    n=33
+                )
+            ).private_key(backend)
+
+    def test_public_number_repr(self):
+        num = RSAPublicNumbers(1, 1)
+        assert repr(num) == "<RSAPublicNumbers(e=1, n=1)>"
+
+
+class TestRSANumbersEquality(object):
+    def test_public_numbers_eq(self):
+        num = RSAPublicNumbers(1, 2)
+        num2 = RSAPublicNumbers(1, 2)
+        assert num == num2
+
+    def test_public_numbers_ne(self):
+        num = RSAPublicNumbers(1, 2)
+        assert num != RSAPublicNumbers(2, 2)
+        assert num != RSAPublicNumbers(1, 3)
+        assert num != object()
+
+    def test_private_numbers_eq(self):
+        pub = RSAPublicNumbers(1, 2)
+        num = RSAPrivateNumbers(1, 2, 3, 4, 5, 6, pub)
+        pub2 = RSAPublicNumbers(1, 2)
+        num2 = RSAPrivateNumbers(1, 2, 3, 4, 5, 6, pub2)
+        assert num == num2
+
+    def test_private_numbers_ne(self):
+        pub = RSAPublicNumbers(1, 2)
+        num = RSAPrivateNumbers(1, 2, 3, 4, 5, 6, pub)
+        assert num != RSAPrivateNumbers(
+            1, 2, 3, 4, 5, 7, RSAPublicNumbers(1, 2)
+        )
+        assert num != RSAPrivateNumbers(
+            1, 2, 3, 4, 4, 6, RSAPublicNumbers(1, 2)
+        )
+        assert num != RSAPrivateNumbers(
+            1, 2, 3, 5, 5, 6, RSAPublicNumbers(1, 2)
+        )
+        assert num != RSAPrivateNumbers(
+            1, 2, 4, 4, 5, 6, RSAPublicNumbers(1, 2)
+        )
+        assert num != RSAPrivateNumbers(
+            1, 3, 3, 4, 5, 6, RSAPublicNumbers(1, 2)
+        )
+        assert num != RSAPrivateNumbers(
+            2, 2, 3, 4, 5, 6, RSAPublicNumbers(1, 2)
+        )
+        assert num != RSAPrivateNumbers(
+            1, 2, 3, 4, 5, 6, RSAPublicNumbers(2, 2)
+        )
+        assert num != RSAPrivateNumbers(
+            1, 2, 3, 4, 5, 6, RSAPublicNumbers(1, 3)
+        )
+        assert num != object()
+
+    def test_public_numbers_hash(self):
+        pub1 = RSAPublicNumbers(3, 17)
+        pub2 = RSAPublicNumbers(3, 17)
+        pub3 = RSAPublicNumbers(7, 21)
+
+        assert hash(pub1) == hash(pub2)
+        assert hash(pub1) != hash(pub3)
+
+    def test_private_numbers_hash(self):
+        priv1 = RSAPrivateNumbers(1, 2, 3, 4, 5, 6, RSAPublicNumbers(1, 2))
+        priv2 = RSAPrivateNumbers(1, 2, 3, 4, 5, 6, RSAPublicNumbers(1, 2))
+        priv3 = RSAPrivateNumbers(1, 2, 3, 4, 5, 6, RSAPublicNumbers(1, 3))
+
+        assert hash(priv1) == hash(priv2)
+        assert hash(priv1) != hash(priv3)
+
+
+class TestRSAPrimeFactorRecovery(object):
+    @pytest.mark.parametrize(
+        "vector",
+        _flatten_pkcs1_examples(load_vectors_from_file(
+            os.path.join(
+                "asymmetric", "RSA", "pkcs1v15crypt-vectors.txt"),
+            load_pkcs1_vectors
+        ))
+    )
+    def test_recover_prime_factors(self, vector):
+        private, public, example = vector
+        p, q = rsa.rsa_recover_prime_factors(
+            private["modulus"],
+            private["public_exponent"],
+            private["private_exponent"]
+        )
+        # Unfortunately there is no convention on which prime should be p
+        # and which one q. The function we use always makes p < q, but the
+        # NIST vectors are not so consistent. Accordingly we verify we've
+        # recovered the proper (p, q) by sorting them and asserting on that.
+        assert sorted([p, q]) == sorted([private["p"], private["q"]])
+
+    def test_invalid_recover_prime_factors(self):
+        with pytest.raises(ValueError):
+            rsa.rsa_recover_prime_factors(34, 3, 7)
+
+
+@pytest.mark.requires_backend_interface(interface=RSABackend)
+@pytest.mark.requires_backend_interface(interface=PEMSerializationBackend)
+class TestRSAPrivateKeySerialization(object):
+    @pytest.mark.parametrize(
+        ("fmt", "password"),
+        itertools.product(
+            [
+                serialization.PrivateFormat.TraditionalOpenSSL,
+                serialization.PrivateFormat.PKCS8
+            ],
+            [
+                b"s",
+                b"longerpassword",
+                b"!*$&(@#$*&($T@%_somesymbols",
+                b"\x01" * 1000,
+            ]
+        )
+    )
+    def test_private_bytes_encrypted_pem(self, backend, fmt, password):
+        key = RSA_KEY_2048.private_key(backend)
+        serialized = key.private_bytes(
+            serialization.Encoding.PEM,
+            fmt,
+            serialization.BestAvailableEncryption(password)
+        )
+        loaded_key = serialization.load_pem_private_key(
+            serialized, password, backend
+        )
+        loaded_priv_num = loaded_key.private_numbers()
+        priv_num = key.private_numbers()
+        assert loaded_priv_num == priv_num
+
+    @pytest.mark.parametrize(
+        ("fmt", "password"),
+        [
+            [serialization.PrivateFormat.PKCS8, b"s"],
+            [serialization.PrivateFormat.PKCS8, b"longerpassword"],
+            [serialization.PrivateFormat.PKCS8, b"!*$&(@#$*&($T@%_somesymbol"],
+            [serialization.PrivateFormat.PKCS8, b"\x01" * 1000]
+        ]
+    )
+    def test_private_bytes_encrypted_der(self, backend, fmt, password):
+        key = RSA_KEY_2048.private_key(backend)
+        serialized = key.private_bytes(
+            serialization.Encoding.DER,
+            fmt,
+            serialization.BestAvailableEncryption(password)
+        )
+        loaded_key = serialization.load_der_private_key(
+            serialized, password, backend
+        )
+        loaded_priv_num = loaded_key.private_numbers()
+        priv_num = key.private_numbers()
+        assert loaded_priv_num == priv_num
+
+    @pytest.mark.parametrize(
+        ("encoding", "fmt", "loader_func"),
+        [
+            [
+                serialization.Encoding.PEM,
+                serialization.PrivateFormat.TraditionalOpenSSL,
+                serialization.load_pem_private_key
+            ],
+            [
+                serialization.Encoding.DER,
+                serialization.PrivateFormat.TraditionalOpenSSL,
+                serialization.load_der_private_key
+            ],
+            [
+                serialization.Encoding.PEM,
+                serialization.PrivateFormat.PKCS8,
+                serialization.load_pem_private_key
+            ],
+            [
+                serialization.Encoding.DER,
+                serialization.PrivateFormat.PKCS8,
+                serialization.load_der_private_key
+            ],
+        ]
+    )
+    def test_private_bytes_unencrypted(self, backend, encoding, fmt,
+                                       loader_func):
+        key = RSA_KEY_2048.private_key(backend)
+        serialized = key.private_bytes(
+            encoding, fmt, serialization.NoEncryption()
+        )
+        loaded_key = loader_func(serialized, None, backend)
+        loaded_priv_num = loaded_key.private_numbers()
+        priv_num = key.private_numbers()
+        assert loaded_priv_num == priv_num
+
+    @pytest.mark.parametrize(
+        ("key_path", "encoding", "loader_func"),
+        [
+            [
+                os.path.join(
+                    "asymmetric",
+                    "Traditional_OpenSSL_Serialization",
+                    "testrsa.pem"
+                ),
+                serialization.Encoding.PEM,
+                serialization.load_pem_private_key
+            ],
+            [
+                os.path.join("asymmetric", "DER_Serialization", "testrsa.der"),
+                serialization.Encoding.DER,
+                serialization.load_der_private_key
+            ],
+        ]
+    )
+    def test_private_bytes_traditional_openssl_unencrypted(
+        self, backend, key_path, encoding, loader_func
+    ):
+        key_bytes = load_vectors_from_file(
+            key_path, lambda pemfile: pemfile.read(), mode="rb"
+        )
+        key = loader_func(key_bytes, None, backend)
+        serialized = key.private_bytes(
+            encoding,
+            serialization.PrivateFormat.TraditionalOpenSSL,
+            serialization.NoEncryption()
+        )
+        assert serialized == key_bytes
+
+    def test_private_bytes_traditional_der_encrypted_invalid(self, backend):
+        key = RSA_KEY_2048.private_key(backend)
+        with pytest.raises(ValueError):
+            key.private_bytes(
+                serialization.Encoding.DER,
+                serialization.PrivateFormat.TraditionalOpenSSL,
+                serialization.BestAvailableEncryption(b"password")
+            )
+
+    def test_private_bytes_invalid_encoding(self, backend):
+        key = RSA_KEY_2048.private_key(backend)
+        with pytest.raises(TypeError):
+            key.private_bytes(
+                "notencoding",
+                serialization.PrivateFormat.PKCS8,
+                serialization.NoEncryption()
+            )
+
+    def test_private_bytes_invalid_format(self, backend):
+        key = RSA_KEY_2048.private_key(backend)
+        with pytest.raises(TypeError):
+            key.private_bytes(
+                serialization.Encoding.PEM,
+                "invalidformat",
+                serialization.NoEncryption()
+            )
+
+    def test_private_bytes_invalid_encryption_algorithm(self, backend):
+        key = RSA_KEY_2048.private_key(backend)
+        with pytest.raises(TypeError):
+            key.private_bytes(
+                serialization.Encoding.PEM,
+                serialization.PrivateFormat.TraditionalOpenSSL,
+                "notanencalg"
+            )
+
+    def test_private_bytes_unsupported_encryption_type(self, backend):
+        key = RSA_KEY_2048.private_key(backend)
+        with pytest.raises(ValueError):
+            key.private_bytes(
+                serialization.Encoding.PEM,
+                serialization.PrivateFormat.TraditionalOpenSSL,
+                DummyKeyEncryption()
+            )
+
+
+@pytest.mark.requires_backend_interface(interface=RSABackend)
+@pytest.mark.requires_backend_interface(interface=PEMSerializationBackend)
+class TestRSAPEMPublicKeySerialization(object):
+    @pytest.mark.parametrize(
+        ("key_path", "loader_func", "encoding", "format"),
+        [
+            (
+                os.path.join("asymmetric", "public", "PKCS1", "rsa.pub.pem"),
+                serialization.load_pem_public_key,
+                serialization.Encoding.PEM,
+                serialization.PublicFormat.PKCS1,
+            ), (
+                os.path.join("asymmetric", "public", "PKCS1", "rsa.pub.der"),
+                serialization.load_der_public_key,
+                serialization.Encoding.DER,
+                serialization.PublicFormat.PKCS1,
+            ), (
+                os.path.join("asymmetric", "PKCS8", "unenc-rsa-pkcs8.pub.pem"),
+                serialization.load_pem_public_key,
+                serialization.Encoding.PEM,
+                serialization.PublicFormat.SubjectPublicKeyInfo,
+            ), (
+                os.path.join(
+                    "asymmetric",
+                    "DER_Serialization",
+                    "unenc-rsa-pkcs8.pub.der"
+                ),
+                serialization.load_der_public_key,
+                serialization.Encoding.DER,
+                serialization.PublicFormat.SubjectPublicKeyInfo,
+            )
+        ]
+    )
+    def test_public_bytes_match(self, key_path, loader_func, encoding, format,
+                                backend):
+        key_bytes = load_vectors_from_file(
+            key_path, lambda pemfile: pemfile.read(), mode="rb"
+        )
+        key = loader_func(key_bytes, backend)
+        serialized = key.public_bytes(encoding, format)
+        assert serialized == key_bytes
+
+    def test_public_bytes_invalid_encoding(self, backend):
+        key = RSA_KEY_2048.private_key(backend).public_key()
+        with pytest.raises(TypeError):
+            key.public_bytes("notencoding", serialization.PublicFormat.PKCS1)
+
+    def test_public_bytes_invalid_format(self, backend):
+        key = RSA_KEY_2048.private_key(backend).public_key()
+        with pytest.raises(TypeError):
+            key.public_bytes(serialization.Encoding.PEM, "invalidformat")
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_seed.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_seed.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_seed.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_seed.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,84 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import binascii
+import os
+
+import pytest
+
+from cryptography.hazmat.backends.interfaces import CipherBackend
+from cryptography.hazmat.primitives.ciphers import algorithms, modes
+
+from .utils import generate_encrypt_test
+from ...utils import load_nist_vectors
+
+
+@pytest.mark.supported(
+    only_if=lambda backend: backend.cipher_supported(
+        algorithms.SEED("\x00" * 16), modes.ECB()
+    ),
+    skip_message="Does not support SEED ECB",
+)
+@pytest.mark.requires_backend_interface(interface=CipherBackend)
+class TestSEEDModeECB(object):
+    test_ECB = generate_encrypt_test(
+        load_nist_vectors,
+        os.path.join("ciphers", "SEED"),
+        ["rfc-4269.txt"],
+        lambda key, **kwargs: algorithms.SEED(binascii.unhexlify((key))),
+        lambda **kwargs: modes.ECB(),
+    )
+
+
+@pytest.mark.supported(
+    only_if=lambda backend: backend.cipher_supported(
+        algorithms.SEED("\x00" * 16), modes.CBC("\x00" * 16)
+    ),
+    skip_message="Does not support SEED CBC",
+)
+@pytest.mark.requires_backend_interface(interface=CipherBackend)
+class TestSEEDModeCBC(object):
+    test_CBC = generate_encrypt_test(
+        load_nist_vectors,
+        os.path.join("ciphers", "SEED"),
+        ["rfc-4196.txt"],
+        lambda key, **kwargs: algorithms.SEED(binascii.unhexlify((key))),
+        lambda iv, **kwargs: modes.CBC(binascii.unhexlify(iv))
+    )
+
+
+@pytest.mark.supported(
+    only_if=lambda backend: backend.cipher_supported(
+        algorithms.SEED("\x00" * 16), modes.OFB("\x00" * 16)
+    ),
+    skip_message="Does not support SEED OFB",
+)
+@pytest.mark.requires_backend_interface(interface=CipherBackend)
+class TestSEEDModeOFB(object):
+    test_OFB = generate_encrypt_test(
+        load_nist_vectors,
+        os.path.join("ciphers", "SEED"),
+        ["seed-ofb.txt"],
+        lambda key, **kwargs: algorithms.SEED(binascii.unhexlify((key))),
+        lambda iv, **kwargs: modes.OFB(binascii.unhexlify(iv))
+    )
+
+
+@pytest.mark.supported(
+    only_if=lambda backend: backend.cipher_supported(
+        algorithms.SEED("\x00" * 16), modes.CFB("\x00" * 16)
+    ),
+    skip_message="Does not support SEED CFB",
+)
+@pytest.mark.requires_backend_interface(interface=CipherBackend)
+class TestSEEDModeCFB(object):
+    test_CFB = generate_encrypt_test(
+        load_nist_vectors,
+        os.path.join("ciphers", "SEED"),
+        ["seed-cfb.txt"],
+        lambda key, **kwargs: algorithms.SEED(binascii.unhexlify((key))),
+        lambda iv, **kwargs: modes.CFB(binascii.unhexlify(iv))
+    )
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_serialization.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_serialization.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_serialization.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_serialization.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,1170 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import base64
+import itertools
+import os
+import textwrap
+
+import pytest
+
+from cryptography.exceptions import UnsupportedAlgorithm, _Reasons
+from cryptography.hazmat.backends.interfaces import (
+    DERSerializationBackend, DSABackend, EllipticCurveBackend,
+    PEMSerializationBackend, RSABackend
+)
+from cryptography.hazmat.primitives.asymmetric import dsa, ec, rsa
+from cryptography.hazmat.primitives.serialization import (
+    BestAvailableEncryption, load_der_private_key, load_der_public_key,
+    load_pem_private_key, load_pem_public_key, load_ssh_public_key
+)
+
+
+from .test_ec import _skip_curve_unsupported
+from .utils import (
+    _check_dsa_private_numbers, _check_rsa_private_numbers,
+    load_vectors_from_file
+)
+from ...utils import raises_unsupported_algorithm
+
+
+@pytest.mark.requires_backend_interface(interface=DERSerializationBackend)
+class TestDERSerialization(object):
+    @pytest.mark.requires_backend_interface(interface=RSABackend)
+    @pytest.mark.parametrize(
+        ("key_path", "password"),
+        [
+            (["DER_Serialization", "enc-rsa-pkcs8.der"], b"foobar"),
+            (["DER_Serialization", "enc2-rsa-pkcs8.der"], b"baz"),
+            (["DER_Serialization", "unenc-rsa-pkcs8.der"], None),
+            (["DER_Serialization", "testrsa.der"], None),
+        ]
+    )
+    def test_load_der_rsa_private_key(self, key_path, password, backend):
+        key = load_vectors_from_file(
+            os.path.join("asymmetric", *key_path),
+            lambda derfile: load_der_private_key(
+                derfile.read(), password, backend
+            ),
+            mode="rb"
+        )
+        assert key
+        assert isinstance(key, rsa.RSAPrivateKey)
+        _check_rsa_private_numbers(key.private_numbers())
+
+    @pytest.mark.requires_backend_interface(interface=DSABackend)
+    @pytest.mark.parametrize(
+        ("key_path", "password"),
+        [
+            (["DER_Serialization", "unenc-dsa-pkcs8.der"], None),
+            (["DER_Serialization", "dsa.1024.der"], None),
+            (["DER_Serialization", "dsa.2048.der"], None),
+            (["DER_Serialization", "dsa.3072.der"], None),
+        ]
+    )
+    def test_load_der_dsa_private_key(self, key_path, password, backend):
+        key = load_vectors_from_file(
+            os.path.join("asymmetric", *key_path),
+            lambda derfile: load_der_private_key(
+                derfile.read(), password, backend
+            ),
+            mode="rb"
+        )
+        assert key
+        assert isinstance(key, dsa.DSAPrivateKey)
+        _check_dsa_private_numbers(key.private_numbers())
+
+    @pytest.mark.parametrize(
+        ("key_path", "password"),
+        [
+            (["DER_Serialization", "ec_private_key.der"], None),
+            (["DER_Serialization", "ec_private_key_encrypted.der"], b"123456"),
+        ]
+    )
+    @pytest.mark.requires_backend_interface(interface=EllipticCurveBackend)
+    def test_load_der_ec_private_key(self, key_path, password, backend):
+        _skip_curve_unsupported(backend, ec.SECP256R1())
+        key = load_vectors_from_file(
+            os.path.join("asymmetric", *key_path),
+            lambda derfile: load_der_private_key(
+                derfile.read(), password, backend
+            ),
+            mode="rb"
+        )
+
+        assert key
+        assert isinstance(key, ec.EllipticCurvePrivateKey)
+        assert key.curve.name == "secp256r1"
+        assert key.curve.key_size == 256
+
+    @pytest.mark.parametrize(
+        "key_path",
+        [
+            ["DER_Serialization", "enc-rsa-pkcs8.der"],
+        ]
+    )
+    @pytest.mark.requires_backend_interface(interface=RSABackend)
+    def test_wrong_password(self, key_path, backend):
+        key_file = os.path.join("asymmetric", *key_path)
+        password = b"this password is wrong"
+
+        with pytest.raises(ValueError):
+            load_vectors_from_file(
+                key_file,
+                lambda derfile: load_der_private_key(
+                    derfile.read(), password, backend
+                ),
+                mode="rb"
+            )
+
+    @pytest.mark.parametrize(
+        "key_path",
+        [
+            ["DER_Serialization", "unenc-rsa-pkcs8.der"]
+        ]
+    )
+    @pytest.mark.requires_backend_interface(interface=RSABackend)
+    def test_unused_password(self, key_path, backend):
+        key_file = os.path.join("asymmetric", *key_path)
+        password = b"this password will not be used"
+
+        with pytest.raises(TypeError):
+            load_vectors_from_file(
+                key_file,
+                lambda derfile: load_der_private_key(
+                    derfile.read(), password, backend
+                ),
+                mode="rb"
+            )
+
+    @pytest.mark.parametrize(
+        ("key_path", "password"),
+        itertools.product(
+            [
+                ["DER_Serialization", "enc-rsa-pkcs8.der"],
+            ],
+            [b"", None]
+        )
+    )
+    @pytest.mark.requires_backend_interface(interface=RSABackend)
+    def test_missing_password(self, key_path, password, backend):
+        key_file = os.path.join("asymmetric", *key_path)
+
+        with pytest.raises(TypeError):
+            load_vectors_from_file(
+                key_file,
+                lambda derfile: load_der_private_key(
+                    derfile.read(), password, backend
+                ),
+                mode="rb"
+            )
+
+    def test_wrong_format(self, backend):
+        key_data = b"---- NOT A KEY ----\n"
+
+        with pytest.raises(ValueError):
+            load_der_private_key(
+                key_data, None, backend
+            )
+
+        with pytest.raises(ValueError):
+            load_der_private_key(
+                key_data, b"this password will not be used", backend
+            )
+
+    def test_corrupt_der_pkcs8(self, backend):
+        # unenc-rsa-pkcs8 with a bunch of data missing.
+        key_data = textwrap.dedent("""\
+        MIICdQIBADALBgkqhkiG9w0BAQEEggJhMIICXQIBAAKBgQC7JHoJfg6yNzLMOWet
+        8Z49a4KD0dCspMAYvo2YAMB7/wdEycocujbhJ2n/seONi+5XqTqqFkM5VBl8rmkk
+        FPZk/7x0xmdsTPECSWnHK+HhoaNDFPR3j8jQhVo1laxiqcEhAHegi5cwtFosuJAv
+        FiRC0Cgz+frQPFQEBsAV9RuasyQxqzxrR0Ow0qncBeGBWbYE6WZhqtcLAI895b+i
+        +F4lbB4iD7T9QeIDMU/aIMXA81UO4cns1z4qDAHKeyLLrPQrJ/B4X7XC+egUWm5+
+        hr1qmyAMusyXIBECQQDJWZ8piluf4yrYfsJAn6hF5T4RjTztbqvO0GVG2McHY7Uj
+        NPSffhzHx/ll0fQEQji+OgydCCX8o3HZrgw5YfSJAkEA7e+rqdU5nO5ZG//PSEQb
+        tjLnRiTzBH/elQhtdZ5nF7pcpNTi4k13zutmKcWW4GK75azcRGJUhu1kDM7QYAOd
+        SQJAVNkYcifkvna7GmooL5VYEsQsqLbM4v0NF2TIGNfG3z1MGp75KrC5LhL97MNR
+        we2p/bd2k0HYyCKUGnf2nMPDiQJBAI75pwittSoE240EobUGIDTSz8CJsXIxuDmL
+        z+KOpdpPRR5TQmbEMEspjsFpFymMiuYPgmihQbO2cJl1qScY5OkCQQCJ6m5tcN8l
+        Xxg/SNpjEIv+qAyUD96XVlOJlOIeLHQ8kYE0C6ZA+MsqYIzgAreJk88Yn0lU/X0/
+        mu/UpE/BRZmR
+        """).encode()
+        bad_der = base64.b64decode(b"".join(key_data.splitlines()))
+
+        with pytest.raises(ValueError):
+            load_der_private_key(
+                bad_der, None, backend
+            )
+
+        with pytest.raises(ValueError):
+            load_der_private_key(
+                bad_der, b"this password will not be used", backend
+            )
+
+    def test_corrupt_traditional_format_der(self, backend):
+        # privkey with a bunch of data missing.
+        key_data = textwrap.dedent("""\
+        MIIBPAIBAAJBAKrbeqkuRk8VcRmWFmtP+LviMB3+6dizWW3DwaffznyHGAFwUJ/I
+        Tv0XtbsCyl3QoyKGhrOAy3RvPK5M38iuXT0CAwEAAQJAZ3cnzaHXM/bxGaR5CR1R
+        rD1qFBAVfoQFiOH9uPJgMaoAuoQEisPHVcZDKcOv4wEg6/TInAIXBnEigtqvRzuy
+        mvcpHZwQJdmdHHkGKAs37Dfxi67HbkUCIQCeZGliHXFa071Fp06ZeWlR2ADonTZz
+        rJBhdTe0v5pCeQIhAIZfkiGgGBX4cIuuckzEm43g9WMUjxP/0GlK39vIyihxAiEA
+        mymehFRT0MvqW5xAKAx7Pgkt8HVKwVhc2LwGKHE0DZM=
+        """).encode()
+        bad_der = base64.b64decode(b"".join(key_data.splitlines()))
+
+        with pytest.raises(ValueError):
+            load_pem_private_key(bad_der, None, backend)
+
+        with pytest.raises(ValueError):
+            load_pem_private_key(
+                bad_der, b"this password will not be used", backend
+            )
+
+    @pytest.mark.parametrize(
+        "key_file",
+        [
+            os.path.join(
+                "asymmetric", "DER_Serialization", "unenc-rsa-pkcs8.pub.der"),
+            os.path.join(
+                "asymmetric", "DER_Serialization", "rsa_public_key.der"),
+            os.path.join("asymmetric", "public", "PKCS1", "rsa.pub.der"),
+        ]
+    )
+    @pytest.mark.requires_backend_interface(interface=RSABackend)
+    def test_load_der_rsa_public_key(self, key_file, backend):
+        key = load_vectors_from_file(
+            key_file,
+            lambda derfile: load_der_public_key(
+                derfile.read(), backend
+            ),
+            mode="rb"
+        )
+        assert key
+        assert isinstance(key, rsa.RSAPublicKey)
+        numbers = key.public_numbers()
+        assert numbers.e == 65537
+
+    def test_load_der_invalid_public_key(self, backend):
+        with pytest.raises(ValueError):
+            load_der_public_key(b"invalid data", backend)
+
+    @pytest.mark.parametrize(
+        "key_file",
+        [
+            os.path.join(
+                "asymmetric", "DER_Serialization", "unenc-dsa-pkcs8.pub.der"),
+            os.path.join(
+                "asymmetric", "DER_Serialization", "dsa_public_key.der"),
+        ]
+    )
+    @pytest.mark.requires_backend_interface(interface=DSABackend)
+    def test_load_der_dsa_public_key(self, key_file, backend):
+        key = load_vectors_from_file(
+            key_file,
+            lambda derfile: load_der_public_key(
+                derfile.read(), backend
+            ),
+            mode="rb"
+        )
+        assert key
+        assert isinstance(key, dsa.DSAPublicKey)
+
+    @pytest.mark.requires_backend_interface(interface=EllipticCurveBackend)
+    def test_load_ec_public_key(self, backend):
+        _skip_curve_unsupported(backend, ec.SECP256R1())
+        key = load_vectors_from_file(
+            os.path.join(
+                "asymmetric", "DER_Serialization",
+                "ec_public_key.der"),
+            lambda derfile: load_der_public_key(
+                derfile.read(), backend
+            ),
+            mode="rb"
+        )
+        assert key
+        assert isinstance(key, ec.EllipticCurvePublicKey)
+        assert key.curve.name == "secp256r1"
+        assert key.curve.key_size == 256
+
+
+@pytest.mark.requires_backend_interface(interface=PEMSerializationBackend)
+class TestPEMSerialization(object):
+    @pytest.mark.parametrize(
+        ("key_file", "password"),
+        [
+            (["PEM_Serialization", "rsa_private_key.pem"], b"123456"),
+            (["PKCS8", "unenc-rsa-pkcs8.pem"], None),
+            (["PKCS8", "enc-rsa-pkcs8.pem"], b"foobar"),
+            (["PKCS8", "enc2-rsa-pkcs8.pem"], b"baz"),
+            (["PKCS8", "pkcs12_s2k_pem-X_9607.pem"], b"123456"),
+            (["PKCS8", "pkcs12_s2k_pem-X_9671.pem"], b"123456"),
+            (["PKCS8", "pkcs12_s2k_pem-X_9925.pem"], b"123456"),
+            (["PKCS8", "pkcs12_s2k_pem-X_9926.pem"], b"123456"),
+            (["PKCS8", "pkcs12_s2k_pem-X_9927.pem"], b"123456"),
+            (["PKCS8", "pkcs12_s2k_pem-X_9928.pem"], b"123456"),
+            (["PKCS8", "pkcs12_s2k_pem-X_9929.pem"], b"123456"),
+            (["PKCS8", "pkcs12_s2k_pem-X_9930.pem"], b"123456"),
+            (["PKCS8", "pkcs12_s2k_pem-X_9931.pem"], b"123456"),
+            (["PKCS8", "pkcs12_s2k_pem-X_9932.pem"], b"123456"),
+            (["Traditional_OpenSSL_Serialization", "key1.pem"], b"123456"),
+            (["Traditional_OpenSSL_Serialization", "key2.pem"], b"a123456"),
+            (["Traditional_OpenSSL_Serialization", "testrsa.pem"], None),
+            (["Traditional_OpenSSL_Serialization", "testrsa-encrypted.pem"],
+             b"password"),
+        ]
+    )
+    def test_load_pem_rsa_private_key(self, key_file, password, backend):
+        key = load_vectors_from_file(
+            os.path.join("asymmetric", *key_file),
+            lambda pemfile: load_pem_private_key(
+                pemfile.read().encode(), password, backend
+            )
+        )
+
+        assert key
+        assert isinstance(key, rsa.RSAPrivateKey)
+        _check_rsa_private_numbers(key.private_numbers())
+
+    @pytest.mark.parametrize(
+        ("key_path", "password"),
+        [
+            (["Traditional_OpenSSL_Serialization", "dsa.1024.pem"], None),
+            (["Traditional_OpenSSL_Serialization", "dsa.2048.pem"], None),
+            (["Traditional_OpenSSL_Serialization", "dsa.3072.pem"], None),
+            (["PKCS8", "unenc-dsa-pkcs8.pem"], None),
+            (["PEM_Serialization", "dsa_private_key.pem"], b"123456"),
+        ]
+    )
+    def test_load_dsa_private_key(self, key_path, password, backend):
+        key = load_vectors_from_file(
+            os.path.join("asymmetric", *key_path),
+            lambda pemfile: load_pem_private_key(
+                pemfile.read().encode(), password, backend
+            )
+        )
+        assert key
+        assert isinstance(key, dsa.DSAPrivateKey)
+        _check_dsa_private_numbers(key.private_numbers())
+
+    @pytest.mark.parametrize(
+        ("key_path", "password"),
+        [
+            (["PKCS8", "ec_private_key.pem"], None),
+            (["PKCS8", "ec_private_key_encrypted.pem"], b"123456"),
+            (["PEM_Serialization", "ec_private_key.pem"], None),
+            (["PEM_Serialization", "ec_private_key_encrypted.pem"], b"123456"),
+        ]
+    )
+    @pytest.mark.requires_backend_interface(interface=EllipticCurveBackend)
+    def test_load_pem_ec_private_key(self, key_path, password, backend):
+        _skip_curve_unsupported(backend, ec.SECP256R1())
+        key = load_vectors_from_file(
+            os.path.join("asymmetric", *key_path),
+            lambda pemfile: load_pem_private_key(
+                pemfile.read().encode(), password, backend
+            )
+        )
+
+        assert key
+        assert isinstance(key, ec.EllipticCurvePrivateKey)
+        assert key.curve.name == "secp256r1"
+        assert key.curve.key_size == 256
+
+    @pytest.mark.parametrize(
+        ("key_file"),
+        [
+            os.path.join("asymmetric", "PKCS8", "unenc-rsa-pkcs8.pub.pem"),
+            os.path.join(
+                "asymmetric", "PEM_Serialization", "rsa_public_key.pem"),
+            os.path.join("asymmetric", "public", "PKCS1", "rsa.pub.pem"),
+        ]
+    )
+    def test_load_pem_rsa_public_key(self, key_file, backend):
+        key = load_vectors_from_file(
+            key_file,
+            lambda pemfile: load_pem_public_key(
+                pemfile.read().encode(), backend
+            )
+        )
+        assert key
+        assert isinstance(key, rsa.RSAPublicKey)
+        numbers = key.public_numbers()
+        assert numbers.e == 65537
+
+    @pytest.mark.parametrize(
+        ("key_file"),
+        [
+            os.path.join("asymmetric", "PKCS8", "unenc-dsa-pkcs8.pub.pem"),
+            os.path.join(
+                "asymmetric", "PEM_Serialization",
+                "dsa_public_key.pem"),
+        ]
+    )
+    def test_load_pem_dsa_public_key(self, key_file, backend):
+        key = load_vectors_from_file(
+            key_file,
+            lambda pemfile: load_pem_public_key(
+                pemfile.read().encode(), backend
+            )
+        )
+        assert key
+        assert isinstance(key, dsa.DSAPublicKey)
+
+    @pytest.mark.requires_backend_interface(interface=EllipticCurveBackend)
+    def test_load_ec_public_key(self, backend):
+        _skip_curve_unsupported(backend, ec.SECP256R1())
+        key = load_vectors_from_file(
+            os.path.join(
+                "asymmetric", "PEM_Serialization",
+                "ec_public_key.pem"),
+            lambda pemfile: load_pem_public_key(
+                pemfile.read().encode(), backend
+            )
+        )
+        assert key
+        assert isinstance(key, ec.EllipticCurvePublicKey)
+        assert key.curve.name == "secp256r1"
+        assert key.curve.key_size == 256
+
+    def test_rsa_traditional_encrypted_values(self, backend):
+        pkey = load_vectors_from_file(
+            os.path.join(
+                "asymmetric", "Traditional_OpenSSL_Serialization", "key1.pem"),
+            lambda pemfile: load_pem_private_key(
+                pemfile.read().encode(), b"123456", backend
+            )
+        )
+        assert pkey
+
+        numbers = pkey.private_numbers()
+        assert numbers.p == int(
+            "fb7d316fc51531b36d93adaefaf52db6ad5beb793d37c4cf9dfc1ddd17cfbafb",
+            16
+        )
+        assert numbers.q == int(
+            "df98264e646de9a0fbeab094e31caad5bc7adceaaae3c800ca0275dd4bb307f5",
+            16
+        )
+        assert numbers.d == int(
+            "db4848c36f478dd5d38f35ae519643b6b810d404bcb76c00e44015e56ca1cab0"
+            "7bb7ae91f6b4b43fcfc82a47d7ed55b8c575152116994c2ce5325ec24313b911",
+            16
+        )
+        assert numbers.dmp1 == int(
+            "ce997f967192c2bcc3853186f1559fd355c190c58ddc15cbf5de9b6df954c727",
+            16
+        )
+        assert numbers.dmq1 == int(
+            "b018a57ab20ffaa3862435445d863369b852cf70a67c55058213e3fe10e3848d",
+            16
+        )
+        assert numbers.iqmp == int(
+            "6a8d830616924f5cf2d1bc1973f97fde6b63e052222ac7be06aa2532d10bac76",
+            16
+        )
+        assert numbers.public_numbers.e == 65537
+        assert numbers.public_numbers.n == int(
+            "dba786074f2f0350ce1d99f5aed5b520cfe0deb5429ec8f2a88563763f566e77"
+            "9814b7c310e5326edae31198eed439b845dd2db99eaa60f5c16a43f4be6bcf37",
+            16
+        )
+
+    @pytest.mark.parametrize(
+        "key_path",
+        [
+            ["Traditional_OpenSSL_Serialization", "testrsa.pem"],
+            ["PKCS8", "unenc-rsa-pkcs8.pem"]
+        ]
+    )
+    def test_unused_password(self, key_path, backend):
+        key_file = os.path.join("asymmetric", *key_path)
+        password = b"this password will not be used"
+
+        with pytest.raises(TypeError):
+            load_vectors_from_file(
+                key_file,
+                lambda pemfile: load_pem_private_key(
+                    pemfile.read().encode(), password, backend
+                )
+            )
+
+    @pytest.mark.parametrize(
+        "key_path",
+        [
+            ["Traditional_OpenSSL_Serialization", "testrsa-encrypted.pem"],
+            ["PKCS8", "enc-rsa-pkcs8.pem"]
+        ]
+    )
+    def test_wrong_password(self, key_path, backend):
+        key_file = os.path.join("asymmetric", *key_path)
+        password = b"this password is wrong"
+
+        with pytest.raises(ValueError):
+            load_vectors_from_file(
+                key_file,
+                lambda pemfile: load_pem_private_key(
+                    pemfile.read().encode(), password, backend
+                )
+            )
+
+    @pytest.mark.parametrize(
+        ("key_path", "password"),
+        itertools.product(
+            [
+                ["Traditional_OpenSSL_Serialization",
+                 "testrsa-encrypted.pem"],
+                ["PKCS8", "enc-rsa-pkcs8.pem"],
+            ],
+            [b"", None]
+        )
+    )
+    def test_missing_password(self, key_path, password, backend):
+        key_file = os.path.join("asymmetric", *key_path)
+
+        with pytest.raises(TypeError):
+            load_vectors_from_file(
+                key_file,
+                lambda pemfile: load_pem_private_key(
+                    pemfile.read().encode(), password, backend
+                )
+            )
+
+    def test_wrong_private_format(self, backend):
+        key_data = b"---- NOT A KEY ----\n"
+
+        with pytest.raises(ValueError):
+            load_pem_private_key(
+                key_data, None, backend
+            )
+
+        with pytest.raises(ValueError):
+            load_pem_private_key(
+                key_data, b"this password will not be used", backend
+            )
+
+    def test_wrong_public_format(self, backend):
+        key_data = b"---- NOT A KEY ----\n"
+
+        with pytest.raises(ValueError):
+            load_pem_public_key(key_data, backend)
+
+    def test_corrupt_traditional_format(self, backend):
+        # privkey.pem with a bunch of data missing.
+        key_data = textwrap.dedent("""\
+        -----BEGIN RSA PRIVATE KEY-----
+        MIIBPAIBAAJBAKrbeqkuRk8VcRmWFmtP+LviMB3+6dizWW3DwaffznyHGAFwUJ/I
+        Tv0XtbsCyl3QoyKGhrOAy3RvPK5M38iuXT0CAwEAAQJAZ3cnzaHXM/bxGaR5CR1R
+        rD1qFBAVfoQFiOH9uPJgMaoAuoQEisPHVcZDKcOv4wEg6/TInAIXBnEigtqvRzuy
+        mvcpHZwQJdmdHHkGKAs37Dfxi67HbkUCIQCeZGliHXFa071Fp06ZeWlR2ADonTZz
+        rJBhdTe0v5pCeQIhAIZfkiGgGBX4cIuuckzEm43g9WMUjxP/0GlK39vIyihxAiEA
+        mymehFRT0MvqW5xAKAx7Pgkt8HVKwVhc2LwGKHE0DZM=
+        -----END RSA PRIVATE KEY-----
+        """).encode()
+
+        with pytest.raises(ValueError):
+            load_pem_private_key(
+                key_data, None, backend
+            )
+
+        with pytest.raises(ValueError):
+            load_pem_private_key(
+                key_data, b"this password will not be used", backend
+            )
+
+    def test_traditional_encrypted_corrupt_format(self, backend):
+        # privkey.pem with a single bit flipped
+        key_data = textwrap.dedent("""\
+        -----BEGIN RSA PRIVATE KEY-----
+        Proc-Type: <,ENCRYPTED
+        DEK-Info: AES-128-CBC,5E22A2BD85A653FB7A3ED20DE84F54CD
+
+        hAqtb5ZkTMGcs4BBDQ1SKZzdQThWRDzEDxM3qBfjvYa35KxZ54aic013mW/lwj2I
+        v5bbpOjrHYHNAiZYZ7RNb+ztbF6F/g5PA5g7mFwEq+LFBY0InIplYBSv9QtE+lot
+        Dy4AlZa/+NzJwgdKDb+JVfk5SddyD4ywnyeORnMPy4xXKvjXwmW+iLibZVKsjIgw
+        H8hSxcD+FhWyJm9h9uLtmpuqhQo0jTUYpnTezZx2xeVPB53Ev7YCxR9Nsgj5GsVf
+        9Z/hqLB7IFgM3pa0z3PQeUIZF/cEf72fISWIOBwwkzVrPUkXWfbuWeJXQXSs3amE
+        5A295jD9BQp9CY0nNFSsy+qiXWToq2xT3y5zVNEStmN0SCGNaIlUnJzL9IHW+oMI
+        kPmXZMnAYBWeeCF1gf3J3aE5lZInegHNfEI0+J0LazC2aNU5Dg/BNqrmRqKWEIo/
+        -----END RSA PRIVATE KEY-----
+        """).encode()
+
+        password = b"this password is wrong"
+
+        with pytest.raises(ValueError):
+            load_pem_private_key(
+                key_data, None, backend
+            )
+
+        with pytest.raises(ValueError):
+            load_pem_private_key(
+                key_data, password, backend
+            )
+
+    def test_unsupported_key_encryption(self, backend):
+        key_data = textwrap.dedent("""\
+        -----BEGIN RSA PRIVATE KEY-----
+        Proc-Type: 4,ENCRYPTED
+        DEK-Info: FAKE-123,5E22A2BD85A653FB7A3ED20DE84F54CD
+
+        hAqtb5ZkTMGcs4BBDQ1SKZzdQThWRDzEDxM3qBfjvYa35KxZ54aic013mW/lwj2I
+        v5bbpOjrHYHNAiZYZ7RNb+ztbF6F/g5PA5g7mFwEq+LFBY0InIplYBSv9QtE+lot
+        Dy4AlZa/+NzJwgdKDb+JVfk5SddyD4ywnyeORnMPy4xXKvjXwmW+iLibZVKsjIgw
+        H8hSxcD+FhWyJm9h9uLtmpuqhQo0jTUYpnTezZx2xeVPB53Ev7YCxR9Nsgj5GsVf
+        9Z/hqLB7IFgM3pa0z3PQeUIZF/cEf72fISWIOBwwkzVrPUkXWfbuWeJXQXSs3amE
+        5A295jD9BQp9CY0nNFSsy+qiXWToq2xT3y5zVNEStmN0SCGNaIlUnJzL9IHW+oMI
+        kPmXZMnAYBWeeCF1gf3J3aE5lZInegHNfEI0+J0LazC2aNU5Dg/BNqrmRqKWEIo/
+        -----END RSA PRIVATE KEY-----
+        """).encode()
+
+        password = b"password"
+
+        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_CIPHER):
+            load_pem_private_key(
+                key_data, password, backend
+            )
+
+    def test_corrupt_pkcs8_format(self, backend):
+        # unenc-rsa-pkcs8.pem with a bunch of data missing.
+        key_data = textwrap.dedent("""\
+        -----BEGIN PRIVATE KEY-----
+        MIICdQIBADALBgkqhkiG9w0BAQEEggJhMIICXQIBAAKBgQC7JHoJfg6yNzLMOWet
+        8Z49a4KD0dCspMAYvo2YAMB7/wdEycocujbhJ2n/seONi+5XqTqqFkM5VBl8rmkk
+        FPZk/7x0xmdsTPECSWnHK+HhoaNDFPR3j8jQhVo1laxiqcEhAHegi5cwtFosuJAv
+        FiRC0Cgz+frQPFQEBsAV9RuasyQxqzxrR0Ow0qncBeGBWbYE6WZhqtcLAI895b+i
+        +F4lbB4iD7T9QeIDMU/aIMXA81UO4cns1z4qDAHKeyLLrPQrJ/B4X7XC+egUWm5+
+        hr1qmyAMusyXIBECQQDJWZ8piluf4yrYfsJAn6hF5T4RjTztbqvO0GVG2McHY7Uj
+        NPSffhzHx/ll0fQEQji+OgydCCX8o3HZrgw5YfSJAkEA7e+rqdU5nO5ZG//PSEQb
+        tjLnRiTzBH/elQhtdZ5nF7pcpNTi4k13zutmKcWW4GK75azcRGJUhu1kDM7QYAOd
+        SQJAVNkYcifkvna7GmooL5VYEsQsqLbM4v0NF2TIGNfG3z1MGp75KrC5LhL97MNR
+        we2p/bd2k0HYyCKUGnf2nMPDiQJBAI75pwittSoE240EobUGIDTSz8CJsXIxuDmL
+        z+KOpdpPRR5TQmbEMEspjsFpFymMiuYPgmihQbO2cJl1qScY5OkCQQCJ6m5tcN8l
+        Xxg/SNpjEIv+qAyUD96XVlOJlOIeLHQ8kYE0C6ZA+MsqYIzgAreJk88Yn0lU/X0/
+        mu/UpE/BRZmR
+        -----END PRIVATE KEY-----
+        """).encode()
+
+        with pytest.raises(ValueError):
+            load_pem_private_key(
+                key_data, None, backend
+            )
+
+        with pytest.raises(ValueError):
+            load_pem_private_key(
+                key_data, b"this password will not be used", backend
+            )
+
+    def test_pks8_encrypted_corrupt_format(self, backend):
+        # enc-rsa-pkcs8.pem with some bits flipped.
+        key_data = textwrap.dedent("""\
+        -----BEGIN ENCRYPTED PRIVATE KEY-----
+        MIICojAcBgoqhkiG9w0BDAEDMA4ECHK0M0+QuEL9AgIBIcSCAoDRq+KRY+0XP0tO
+        lwBTzViiXSXoyNnKAZKt5r5K/fGNntv22g/1s/ZNCetrqsJDC5eMUPPacz06jFq/
+        Ipsep4/OgjQ9UAOzXNrWEoNyrHnWDo7usgD3CW0mKyqER4+wG0adVMbt3N+CJHGB
+        85jzRmQTfkdx1rSWeSx+XyswHn8ER4+hQ+omKWMVm7AFkjjmP/KnhUnLT98J8rhU
+        ArQoFPHz/6HVkypFccNaPPNg6IA4aS2A+TU9vJYOaXSVfFB2yf99hfYYzC+ukmuU
+        5Lun0cysK5s/5uSwDueUmDQKspnaNyiaMGDxvw8hilJc7vg0fGObfnbIpizhxJwq
+        gKBfR7Zt0Hv8OYi1He4MehfMGdbHskztF+yQ40LplBGXQrvAqpU4zShga1BoQ98T
+        0ekbBmqj7hg47VFsppXR7DKhx7G7rpMmdKbFhAZVCjae7rRGpUtD52cpFdPhMyAX
+        huhMkoczwUW8B/rM4272lkHo6Br0yk/TQfTEGkvryflNVu6lniPTV151WV5U1M3o
+        3G3a44eDyt7Ln+WSOpWtbPQMTrpKhur6WXgJvrpa/m02oOGdvOlDsoOCgavgQMWg
+        7xKKL7620pHl7p7f/8tlE8q6vLXVvyNtAOgt/JAr2rgvrHaZSzDE0DwgCjBXEm+7
+        cVMVNkHod7bLQefVanVtWqPzbmr8f7gKeuGwWSG9oew/lN2hxcLEPJHAQlnLgx3P
+        0GdGjK9NvwA0EP2gYIeE4+UtSder7xQ7bVh25VB20R4TTIIs4aXXCVOoQPagnzaT
+        6JLgl8FrvdfjHwIvmSOO1YMNmILBq000Q8WDqyErBDs4hsvtO6VQ4LeqJj6gClX3
+        qeJNaJFu
+        -----END ENCRYPTED PRIVATE KEY-----
+        """).encode()
+
+        password = b"this password is wrong"
+
+        with pytest.raises(ValueError):
+            load_pem_private_key(
+                key_data, None, backend
+            )
+
+        with pytest.raises(ValueError):
+            load_pem_private_key(
+                key_data, password, backend
+            )
+
+    def test_rsa_pkcs8_encrypted_values(self, backend):
+        pkey = load_vectors_from_file(
+            os.path.join(
+                "asymmetric", "PKCS8", "enc-rsa-pkcs8.pem"),
+            lambda pemfile: load_pem_private_key(
+                pemfile.read().encode(), b"foobar", backend
+            )
+        )
+        assert pkey
+
+        numbers = pkey.private_numbers()
+
+        assert numbers.public_numbers.n == int(
+            "00beec64d6db5760ac2fd4c971145641b9bd7f5c56558ece608795c79807"
+            "376a7fe5b19f95b35ca358ea5c8abd7ae051d49cd2f1e45969a1ae945460"
+            "3c14b278664a0e414ebc8913acb6203626985525e17a600611b028542dd0"
+            "562aad787fb4f1650aa318cdcff751e1b187cbf6785fbe164e9809491b95"
+            "dd68480567c99b1a57", 16
+        )
+
+        assert numbers.public_numbers.e == 65537
+
+        assert numbers.d == int(
+            "0cfe316e9dc6b8817f4fcfd5ae38a0886f68f773b8a6db4c9e6d8703c599"
+            "f3d9785c3a2c09e4c8090909fb3721e19a3009ec21221523a729265707a5"
+            "8f13063671c42a4096cad378ef2510cb59e23071489d8893ac4934dd149f"
+            "34f2d094bea57f1c8027c3a77248ac9b91218737d0c3c3dfa7d7829e6977"
+            "cf7d995688c86c81", 16
+        )
+
+        assert numbers.p == int(
+            "00db122ac857b2c0437d7616daa98e597bb75ca9ad3a47a70bec10c10036"
+            "03328794b225c8e3eee6ffd3fd6d2253d28e071fe27d629ab072faa14377"
+            "ce6118cb67", 16
+        )
+
+        assert numbers.q == int(
+            "00df1b8aa8506fcbbbb9d00257f2975e38b33d2698fd0f37e82d7ef38c56"
+            "f21b6ced63c825383782a7115cfcc093300987dbd2853b518d1c8f26382a"
+            "2d2586d391", 16
+        )
+
+        assert numbers.dmp1 == int(
+            "00be18aca13e60712fdf5daa85421eb10d86d654b269e1255656194fb0c4"
+            "2dd01a1070ea12c19f5c39e09587af02f7b1a1030d016a9ffabf3b36d699"
+            "ceaf38d9bf", 16
+        )
+
+        assert numbers.dmq1 == int(
+            "71aa8978f90a0c050744b77cf1263725b203ac9f730606d8ae1d289dce4a"
+            "28b8d534e9ea347aeb808c73107e583eb80c546d2bddadcdb3c82693a4c1"
+            "3d863451", 16
+        )
+
+        assert numbers.iqmp == int(
+            "136b7b1afac6e6279f71b24217b7083485a5e827d156024609dae39d48a6"
+            "bdb55af2f062cc4a3b077434e6fffad5faa29a2b5dba2bed3e4621e478c0"
+            "97ccfe7f", 16
+        )
+
+    def test_load_pem_dsa_private_key(self, backend):
+        key = load_vectors_from_file(
+            os.path.join("asymmetric", "PKCS8", "unenc-dsa-pkcs8.pem"),
+            lambda pemfile: load_pem_private_key(
+                pemfile.read().encode(), None, backend
+            )
+        )
+        assert key
+        assert isinstance(key, dsa.DSAPrivateKey)
+
+        params = key.parameters()
+        assert isinstance(params, dsa.DSAParameters)
+
+        num = key.private_numbers()
+        pub = num.public_numbers
+        parameter_numbers = pub.parameter_numbers
+        assert num.x == int("00a535a8e1d0d91beafc8bee1d9b2a3a8de3311203",
+                            16)
+        assert pub.y == int(
+            "2b260ea97dc6a12ae932c640e7df3d8ff04a8a05a0324f8d5f1b23f15fa1"
+            "70ff3f42061124eff2586cb11b49a82dcdc1b90fc6a84fb10109cb67db5d"
+            "2da971aeaf17be5e37284563e4c64d9e5fc8480258b319f0de29d54d8350"
+            "70d9e287914d77df81491f4423b62da984eb3f45eb2a29fcea5dae525ac6"
+            "ab6bcce04bfdf5b6",
+            16
+        )
+
+        assert parameter_numbers.p == int(
+            "00aa0930cc145825221caffa28ac2894196a27833de5ec21270791689420"
+            "7774a2e7b238b0d36f1b2499a2c2585083eb01432924418d867faa212dd1"
+            "071d4dceb2782794ad393cc08a4d4ada7f68d6e839a5fcd34b4e402d82cb"
+            "8a8cb40fec31911bf9bd360b034caacb4c5e947992573c9e90099c1b0f05"
+            "940cabe5d2de49a167",
+            16
+        )
+
+        assert parameter_numbers.q == int(
+            "00adc0e869b36f0ac013a681fdf4d4899d69820451", 16)
+
+        assert parameter_numbers.g == int(
+            "008c6b4589afa53a4d1048bfc346d1f386ca75521ccf72ddaa251286880e"
+            "e13201ff48890bbfc33d79bacaec71e7a778507bd5f1a66422e39415be03"
+            "e71141ba324f5b93131929182c88a9fa4062836066cebe74b5c6690c7d10"
+            "1106c240ab7ebd54e4e3301fd086ce6adac922fb2713a2b0887cba13b9bc"
+            "68ce5cfff241cd3246",
+            16
+        )
+
+    @pytest.mark.parametrize(
+        ("key_file", "password"),
+        [
+            ("bad-oid-dsa-key.pem", None),
+        ]
+    )
+    def test_load_bad_oid_key(self, key_file, password, backend):
+        with raises_unsupported_algorithm(
+            _Reasons.UNSUPPORTED_PUBLIC_KEY_ALGORITHM
+        ):
+            load_vectors_from_file(
+                os.path.join(
+                    "asymmetric", "PKCS8", key_file),
+                lambda pemfile: load_pem_private_key(
+                    pemfile.read().encode(), password, backend
+                )
+            )
+
+    @pytest.mark.parametrize(
+        ("key_file", "password"),
+        [
+            ("bad-encryption-oid.pem", b"password"),
+        ]
+    )
+    def test_load_bad_encryption_oid_key(self, key_file, password, backend):
+        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_CIPHER):
+            load_vectors_from_file(
+                os.path.join(
+                    "asymmetric", "PKCS8", key_file),
+                lambda pemfile: load_pem_private_key(
+                    pemfile.read().encode(), password, backend
+                )
+            )
+
+
+@pytest.mark.requires_backend_interface(interface=RSABackend)
+class TestRSASSHSerialization(object):
+    def test_load_ssh_public_key_unsupported(self, backend):
+        ssh_key = b'ecdsa-sha2-junk AAAAE2VjZHNhLXNoYTItbmlzdHAyNTY='
+
+        with pytest.raises(UnsupportedAlgorithm):
+            load_ssh_public_key(ssh_key, backend)
+
+    def test_load_ssh_public_key_bad_format(self, backend):
+        ssh_key = b'ssh-rsa not-a-real-key'
+
+        with pytest.raises(ValueError):
+            load_ssh_public_key(ssh_key, backend)
+
+    def test_load_ssh_public_key_rsa_too_short(self, backend):
+        ssh_key = b'ssh-rsa'
+
+        with pytest.raises(ValueError):
+            load_ssh_public_key(ssh_key, backend)
+
+    def test_load_ssh_public_key_rsa_comment_with_spaces(self, backend):
+        ssh_key = (
+            b"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDDu/XRP1kyK6Cgt36gts9XAk"
+            b"FiiuJLW6RU0j3KKVZSs1I7Z3UmU9/9aVh/rZV43WQG8jaR6kkcP4stOR0DEtll"
+            b"PDA7ZRBnrfiHpSQYQ874AZaAoIjgkv7DBfsE6gcDQLub0PFjWyrYQUJhtOLQEK"
+            b"vY/G0vt2iRL3juawWmCFdTK3W3XvwAdgGk71i6lHt+deOPNEPN2H58E4odrZ2f"
+            b"sxn/adpDqfb2sM0kPwQs0aWvrrKGvUaustkivQE4XWiSFnB0oJB/lKK/CKVKuy"
+            b"///ImSCGHQRvhwariN2tvZ6CBNSLh3iQgeB0AkyJlng7MXB2qYq/Ci2FUOryCX"
+            # Extra section appended
+            b"2MzHvnbv testkey@localhost extra"
+        )
+
+        load_ssh_public_key(ssh_key, backend)
+
+    def test_load_ssh_public_key_rsa_extra_data_after_modulo(self, backend):
+        ssh_key = (
+            b"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDDu/XRP1kyK6Cgt36gts9XAk"
+            b"FiiuJLW6RU0j3KKVZSs1I7Z3UmU9/9aVh/rZV43WQG8jaR6kkcP4stOR0DEtll"
+            b"PDA7ZRBnrfiHpSQYQ874AZaAoIjgkv7DBfsE6gcDQLub0PFjWyrYQUJhtOLQEK"
+            b"vY/G0vt2iRL3juawWmCFdTK3W3XvwAdgGk71i6lHt+deOPNEPN2H58E4odrZ2f"
+            b"sxn/adpDqfb2sM0kPwQs0aWvrrKGvUaustkivQE4XWiSFnB0oJB/lKK/CKVKuy"
+            b"///ImSCGHQRvhwariN2tvZ6CBNSLh3iQgeB0AkyJlng7MXB2qYq/Ci2FUOryCX"
+            b"2MzHvnbvAQ== testkey@localhost"
+        )
+
+        with pytest.raises(ValueError):
+            load_ssh_public_key(ssh_key, backend)
+
+    def test_load_ssh_public_key_rsa_different_string(self, backend):
+        ssh_key = (
+            # "AAAAB3NzA" the final A is capitalized here to cause the string
+            # ssh-rsa inside the base64 encoded blob to be incorrect. It should
+            # be a lower case 'a'.
+            b"ssh-rsa AAAAB3NzAC1yc2EAAAADAQABAAABAQDDu/XRP1kyK6Cgt36gts9XAk"
+            b"FiiuJLW6RU0j3KKVZSs1I7Z3UmU9/9aVh/rZV43WQG8jaR6kkcP4stOR0DEtll"
+            b"PDA7ZRBnrfiHpSQYQ874AZaAoIjgkv7DBfsE6gcDQLub0PFjWyrYQUJhtOLQEK"
+            b"vY/G0vt2iRL3juawWmCFdTK3W3XvwAdgGk71i6lHt+deOPNEPN2H58E4odrZ2f"
+            b"sxn/adpDqfb2sM0kPwQs0aWvrrKGvUaustkivQE4XWiSFnB0oJB/lKK/CKVKuy"
+            b"///ImSCGHQRvhwariN2tvZ6CBNSLh3iQgeB0AkyJlng7MXB2qYq/Ci2FUOryCX"
+            b"2MzHvnbvAQ== testkey@localhost"
+        )
+        with pytest.raises(ValueError):
+            load_ssh_public_key(ssh_key, backend)
+
+    def test_load_ssh_public_key_rsa(self, backend):
+        ssh_key = (
+            b"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDDu/XRP1kyK6Cgt36gts9XAk"
+            b"FiiuJLW6RU0j3KKVZSs1I7Z3UmU9/9aVh/rZV43WQG8jaR6kkcP4stOR0DEtll"
+            b"PDA7ZRBnrfiHpSQYQ874AZaAoIjgkv7DBfsE6gcDQLub0PFjWyrYQUJhtOLQEK"
+            b"vY/G0vt2iRL3juawWmCFdTK3W3XvwAdgGk71i6lHt+deOPNEPN2H58E4odrZ2f"
+            b"sxn/adpDqfb2sM0kPwQs0aWvrrKGvUaustkivQE4XWiSFnB0oJB/lKK/CKVKuy"
+            b"///ImSCGHQRvhwariN2tvZ6CBNSLh3iQgeB0AkyJlng7MXB2qYq/Ci2FUOryCX"
+            b"2MzHvnbv testkey@localhost"
+        )
+
+        key = load_ssh_public_key(ssh_key, backend)
+
+        assert key is not None
+        assert isinstance(key, rsa.RSAPublicKey)
+
+        numbers = key.public_numbers()
+
+        expected_e = 0x10001
+        expected_n = int(
+            '00C3BBF5D13F59322BA0A0B77EA0B6CF570241628AE24B5BA454D'
+            '23DCA295652B3523B67752653DFFD69587FAD9578DD6406F23691'
+            'EA491C3F8B2D391D0312D9653C303B651067ADF887A5241843CEF'
+            '8019680A088E092FEC305FB04EA070340BB9BD0F1635B2AD84142'
+            '61B4E2D010ABD8FC6D2FB768912F78EE6B05A60857532B75B75EF'
+            'C007601A4EF58BA947B7E75E38F3443CDD87E7C138A1DAD9D9FB3'
+            '19FF69DA43A9F6F6B0CD243F042CD1A5AFAEB286BD46AEB2D922B'
+            'D01385D6892167074A0907F94A2BF08A54ABB2FFFFC89920861D0'
+            '46F8706AB88DDADBD9E8204D48B87789081E074024C8996783B31'
+            '7076A98ABF0A2D8550EAF2097D8CCC7BE76EF', 16)
+
+        expected = rsa.RSAPublicNumbers(expected_e, expected_n)
+
+        assert numbers == expected
+
+
+@pytest.mark.requires_backend_interface(interface=DSABackend)
+class TestDSSSSHSerialization(object):
+    def test_load_ssh_public_key_dss_too_short(self, backend):
+        ssh_key = b'ssh-dss'
+
+        with pytest.raises(ValueError):
+            load_ssh_public_key(ssh_key, backend)
+
+    def test_load_ssh_public_key_dss_comment_with_spaces(self, backend):
+        ssh_key = (
+            b"ssh-dss AAAAB3NzaC1kc3MAAACBALmwUtfwdjAUjU2Dixd5DvT0NDcjjr69UD"
+            b"LqSD/Xt5Al7D3GXr1WOrWGpjO0NE9qzRCvMTU7zykRH6XjuNXB6Hvv48Zfm4vm"
+            b"nHQHFmmMg2bI75JbnOwdzWnnPZJrVU4rS23dFFPqs5ug+EbhVVrcwzxahjcSjJ"
+            b"7WEQSkVQWnSPbbAAAAFQDXmpD3DIkGvLSBf1GdUF4PHKtUrQAAAIB/bJFwss+2"
+            b"fngmfG/Li5OyL7A9iVoGdkUaFaxEUROTp7wkm2z49fXFAir+/U31v50Tu98YLf"
+            b"WvKlxdHcdgQYV9Ww5LIrhWwwD4UKOwC6w5S3KHVbi3pWUi7vxJFXOWfeu1mC/J"
+            b"TWqMKR91j+rmOtdppWIZRyIVIqLcMdGO3m+2VgAAAIANFDz5KQH5NvoljpoRQi"
+            b"RgyPjxWXiE7vjLElKj4v8KrpanAywBzdhIW1y/tzpGuwRwj5ihi8iNTHgSsoTa"
+            b"j5AG5HPomJf5vJElxpu/2O9pHA52wcNObIQ7j+JA5uWusxNIbl+pF6sSiP8abr"
+            b"z53N7tPF/IhHTjBHb1Ol7IFu9p9A== testkey@localhost extra"
+        )
+
+        load_ssh_public_key(ssh_key, backend)
+
+    def test_load_ssh_public_key_dss_extra_data_after_modulo(self, backend):
+        ssh_key = (
+            b"ssh-dss AAAAB3NzaC1kc3MAAACBALmwUtfwdjAUjU2Dixd5DvT0NDcjjr69UD"
+            b"LqSD/Xt5Al7D3GXr1WOrWGpjO0NE9qzRCvMTU7zykRH6XjuNXB6Hvv48Zfm4vm"
+            b"nHQHFmmMg2bI75JbnOwdzWnnPZJrVU4rS23dFFPqs5ug+EbhVVrcwzxahjcSjJ"
+            b"7WEQSkVQWnSPbbAAAAFQDXmpD3DIkGvLSBf1GdUF4PHKtUrQAAAIB/bJFwss+2"
+            b"fngmfG/Li5OyL7A9iVoGdkUaFaxEUROTp7wkm2z49fXFAir+/U31v50Tu98YLf"
+            b"WvKlxdHcdgQYV9Ww5LIrhWwwD4UKOwC6w5S3KHVbi3pWUi7vxJFXOWfeu1mC/J"
+            b"TWqMKR91j+rmOtdppWIZRyIVIqLcMdGO3m+2VgAAAIANFDz5KQH5NvoljpoRQi"
+            b"RgyPjxWXiE7vjLElKj4v8KrpanAywBzdhIW1y/tzpGuwRwj5ihi8iNTHgSsoTa"
+            b"j5AG5HPomJf5vJElxpu/2O9pHA52wcNObIQ7j+JA5uWusxNIbl+pF6sSiP8abr"
+            b"z53N7tPF/IhHTjBHb1Ol7IFu9p9AAwMD== testkey@localhost"
+        )
+
+        with pytest.raises(ValueError):
+            load_ssh_public_key(ssh_key, backend)
+
+    def test_load_ssh_public_key_dss_different_string(self, backend):
+        ssh_key = (
+            # "AAAAB3NzA" the final A is capitalized here to cause the string
+            # ssh-dss inside the base64 encoded blob to be incorrect. It should
+            # be a lower case 'a'.
+            b"ssh-dss AAAAB3NzAC1kc3MAAACBALmwUtfwdjAUjU2Dixd5DvT0NDcjjr69UD"
+            b"LqSD/Xt5Al7D3GXr1WOrWGpjO0NE9qzRCvMTU7zykRH6XjuNXB6Hvv48Zfm4vm"
+            b"nHQHFmmMg2bI75JbnOwdzWnnPZJrVU4rS23dFFPqs5ug+EbhVVrcwzxahjcSjJ"
+            b"7WEQSkVQWnSPbbAAAAFQDXmpD3DIkGvLSBf1GdUF4PHKtUrQAAAIB/bJFwss+2"
+            b"fngmfG/Li5OyL7A9iVoGdkUaFaxEUROTp7wkm2z49fXFAir+/U31v50Tu98YLf"
+            b"WvKlxdHcdgQYV9Ww5LIrhWwwD4UKOwC6w5S3KHVbi3pWUi7vxJFXOWfeu1mC/J"
+            b"TWqMKR91j+rmOtdppWIZRyIVIqLcMdGO3m+2VgAAAIANFDz5KQH5NvoljpoRQi"
+            b"RgyPjxWXiE7vjLElKj4v8KrpanAywBzdhIW1y/tzpGuwRwj5ihi8iNTHgSsoTa"
+            b"j5AG5HPomJf5vJElxpu/2O9pHA52wcNObIQ7j+JA5uWusxNIbl+pF6sSiP8abr"
+            b"z53N7tPF/IhHTjBHb1Ol7IFu9p9A== testkey@localhost"
+        )
+        with pytest.raises(ValueError):
+            load_ssh_public_key(ssh_key, backend)
+
+    def test_load_ssh_public_key_dss(self, backend):
+        ssh_key = (
+            b"ssh-dss AAAAB3NzaC1kc3MAAACBALmwUtfwdjAUjU2Dixd5DvT0NDcjjr69UD"
+            b"LqSD/Xt5Al7D3GXr1WOrWGpjO0NE9qzRCvMTU7zykRH6XjuNXB6Hvv48Zfm4vm"
+            b"nHQHFmmMg2bI75JbnOwdzWnnPZJrVU4rS23dFFPqs5ug+EbhVVrcwzxahjcSjJ"
+            b"7WEQSkVQWnSPbbAAAAFQDXmpD3DIkGvLSBf1GdUF4PHKtUrQAAAIB/bJFwss+2"
+            b"fngmfG/Li5OyL7A9iVoGdkUaFaxEUROTp7wkm2z49fXFAir+/U31v50Tu98YLf"
+            b"WvKlxdHcdgQYV9Ww5LIrhWwwD4UKOwC6w5S3KHVbi3pWUi7vxJFXOWfeu1mC/J"
+            b"TWqMKR91j+rmOtdppWIZRyIVIqLcMdGO3m+2VgAAAIANFDz5KQH5NvoljpoRQi"
+            b"RgyPjxWXiE7vjLElKj4v8KrpanAywBzdhIW1y/tzpGuwRwj5ihi8iNTHgSsoTa"
+            b"j5AG5HPomJf5vJElxpu/2O9pHA52wcNObIQ7j+JA5uWusxNIbl+pF6sSiP8abr"
+            b"z53N7tPF/IhHTjBHb1Ol7IFu9p9A== testkey@localhost"
+        )
+
+        key = load_ssh_public_key(ssh_key, backend)
+
+        assert key is not None
+        assert isinstance(key, dsa.DSAPublicKey)
+
+        numbers = key.public_numbers()
+
+        expected_y = int(
+            "d143cf92901f936fa258e9a11422460c8f8f1597884eef8cb1252a3e2ff0aae"
+            "96a7032c01cdd8485b5cbfb73a46bb04708f98a18bc88d4c7812b284da8f900"
+            "6e473e89897f9bc9125c69bbfd8ef691c0e76c1c34e6c843b8fe240e6e5aeb3"
+            "13486e5fa917ab1288ff1a6ebcf9dcdeed3c5fc88474e30476f53a5ec816ef6"
+            "9f4", 16
+        )
+        expected_p = int(
+            "b9b052d7f07630148d4d838b17790ef4f43437238ebebd5032ea483fd7b7902"
+            "5ec3dc65ebd563ab586a633b4344f6acd10af31353bcf29111fa5e3b8d5c1e8"
+            "7befe3c65f9b8be69c740716698c8366c8ef925b9cec1dcd69e73d926b554e2"
+            "b4b6ddd1453eab39ba0f846e1555adcc33c5a8637128c9ed61104a45505a748"
+            "f6db", 16
+        )
+        expected_q = 1230879958723280233885494314531920096931919647917
+        expected_g = int(
+            "7f6c9170b2cfb67e78267c6fcb8b93b22fb03d895a0676451a15ac44511393a"
+            "7bc249b6cf8f5f5c5022afefd4df5bf9d13bbdf182df5af2a5c5d1dc7604185"
+            "7d5b0e4b22b856c300f850a3b00bac394b728755b8b7a56522eefc491573967"
+            "debb5982fc94d6a8c291f758feae63ad769a5621947221522a2dc31d18ede6f"
+            "b656", 16
+        )
+        expected = dsa.DSAPublicNumbers(
+            expected_y,
+            dsa.DSAParameterNumbers(expected_p, expected_q, expected_g)
+        )
+
+        assert numbers == expected
+
+
+@pytest.mark.requires_backend_interface(interface=EllipticCurveBackend)
+class TestECDSASSHSerialization(object):
+    def test_load_ssh_public_key_ecdsa_nist_p256(self, backend):
+        _skip_curve_unsupported(backend, ec.SECP256R1())
+
+        ssh_key = (
+            b"ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAy"
+            b"NTYAAABBBGG2MfkHXp0UkxUyllDzWNBAImsvt5t7pFtTXegZK2WbGxml8zMrgWi5"
+            b"teIg1TO03/FD9hbpBFgBeix3NrCFPls= root@cloud-server-01"
+        )
+        key = load_ssh_public_key(ssh_key, backend)
+        assert isinstance(key, ec.EllipticCurvePublicKey)
+
+        expected_x = int(
+            "44196257377740326295529888716212621920056478823906609851236662550"
+            "785814128027", 10
+        )
+        expected_y = int(
+            "12257763433170736656417248739355923610241609728032203358057767672"
+            "925775019611", 10
+        )
+
+        assert key.public_numbers() == ec.EllipticCurvePublicNumbers(
+            expected_x, expected_y, ec.SECP256R1()
+        )
+
+    def test_load_ssh_public_key_ecdsa_nist_p384(self, backend):
+        _skip_curve_unsupported(backend, ec.SECP384R1())
+        ssh_key = (
+            b"ecdsa-sha2-nistp384 AAAAE2VjZHNhLXNoYTItbmlzdHAzODQAAAAIbmlzdHAz"
+            b"ODQAAABhBMzucOm9wbwg4iMr5QL0ya0XNQGXpw4wM5f12E3tWhdcrzyGHyel71t1"
+            b"4bvF9JZ2/WIuSxUr33XDl8jYo+lMQ5N7Vanc7f7i3AR1YydatL3wQfZStQ1I3rBa"
+            b"qQtRSEU8Tg== root@cloud-server-01"
+        )
+        key = load_ssh_public_key(ssh_key, backend)
+
+        expected_x = int(
+            "31541830871345183397582554827482786756220448716666815789487537666"
+            "592636882822352575507883817901562613492450642523901", 10
+        )
+        expected_y = int(
+            "15111413269431823234030344298767984698884955023183354737123929430"
+            "995703524272335782455051101616329050844273733614670", 10
+        )
+
+        assert key.public_numbers() == ec.EllipticCurvePublicNumbers(
+            expected_x, expected_y, ec.SECP384R1()
+        )
+
+    def test_load_ssh_public_key_ecdsa_nist_p521(self, backend):
+        _skip_curve_unsupported(backend, ec.SECP521R1())
+        ssh_key = (
+            b"ecdsa-sha2-nistp521 AAAAE2VjZHNhLXNoYTItbmlzdHA1MjEAAAAIbmlzdHA1"
+            b"MjEAAACFBAGTrRhMSEgF6Ni+PXNz+5fjS4lw3ypUILVVQ0Av+0hQxOx+MyozELon"
+            b"I8NKbrbBjijEs1GuImsmkTmWsMXS1j2A7wB4Kseh7W9KA9IZJ1+TMrzWUEwvOOXi"
+            b"wT23pbaWWXG4NaM7vssWfZBnvz3S174TCXnJ+DSccvWBFnKP0KchzLKxbg== "
+            b"root@cloud-server-01"
+        )
+        key = load_ssh_public_key(ssh_key, backend)
+
+        expected_x = int(
+            "54124123120178189598842622575230904027376313369742467279346415219"
+            "77809037378785192537810367028427387173980786968395921877911964629"
+            "142163122798974160187785455", 10
+        )
+        expected_y = int(
+            "16111775122845033200938694062381820957441843014849125660011303579"
+            "15284560361402515564433711416776946492019498546572162801954089916"
+            "006665939539407104638103918", 10
+        )
+
+        assert key.public_numbers() == ec.EllipticCurvePublicNumbers(
+            expected_x, expected_y, ec.SECP521R1()
+        )
+
+    def test_load_ssh_public_key_ecdsa_nist_p256_trailing_data(self, backend):
+        ssh_key = (
+            b"ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAy"
+            b"NTYAAABBBGG2MfkHXp0UkxUyllDzWNBAImsvt5t7pFtTXegZK2WbGxml8zMrgWi5"
+            b"teIg1TO03/FD9hbpBFgBeix3NrCFPltB= root@cloud-server-01"
+        )
+        with pytest.raises(ValueError):
+            load_ssh_public_key(ssh_key, backend)
+
+    def test_load_ssh_public_key_ecdsa_nist_p256_missing_data(self, backend):
+        ssh_key = (
+            b"ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAy"
+            b"NTYAAABBBGG2MfkHXp0UkxUyllDzWNBAImsvt5t7pFtTXegZK2WbGxml8zMrgWi5"
+            b"teIg1TO03/FD9hbpBFgBeix3NrCF= root@cloud-server-01"
+        )
+        with pytest.raises(ValueError):
+            load_ssh_public_key(ssh_key, backend)
+
+    def test_load_ssh_public_key_ecdsa_nist_p256_compressed(self, backend):
+        # If we ever implement compressed points, note that this is not a valid
+        # one, it just has the compressed marker in the right place.
+        ssh_key = (
+            b"ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAy"
+            b"NTYAAABBAWG2MfkHXp0UkxUyllDzWNBAImsvt5t7pFtTXegZK2WbGxml8zMrgWi5"
+            b"teIg1TO03/FD9hbpBFgBeix3NrCFPls= root@cloud-server-01"
+        )
+        with pytest.raises(NotImplementedError):
+            load_ssh_public_key(ssh_key, backend)
+
+    def test_load_ssh_public_key_ecdsa_nist_p256_bad_curve_name(self, backend):
+        ssh_key = (
+            # The curve name in here is changed to be "nistp255".
+            b"ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAy"
+            b"NTUAAABBBGG2MfkHXp0UkxUyllDzWNBAImsvt5t7pFtTXegZK2WbGxml8zMrgWi5"
+            b"teIg1TO03/FD9hbpBFgBeix3NrCFPls= root@cloud-server-01"
+        )
+        with pytest.raises(ValueError):
+            load_ssh_public_key(ssh_key, backend)
+
+
+class TestKeySerializationEncryptionTypes(object):
+    def test_non_bytes_password(self):
+        with pytest.raises(ValueError):
+            BestAvailableEncryption(object())
+
+    def test_encryption_with_zero_length_password(self):
+        with pytest.raises(ValueError):
+            BestAvailableEncryption(b"")
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_x963kdf.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_x963kdf.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_x963kdf.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_x963kdf.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,120 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import binascii
+
+import pytest
+
+from cryptography.exceptions import (
+    AlreadyFinalized, InvalidKey, _Reasons
+)
+from cryptography.hazmat.backends.interfaces import HashBackend
+from cryptography.hazmat.primitives import hashes
+from cryptography.hazmat.primitives.kdf.x963kdf import X963KDF
+
+from ...utils import raises_unsupported_algorithm
+
+
+@pytest.mark.requires_backend_interface(interface=HashBackend)
+class TestX963KDF(object):
+    def test_length_limit(self, backend):
+        big_length = hashes.SHA256().digest_size * (2 ** 32 - 1) + 1
+
+        with pytest.raises(ValueError):
+            X963KDF(hashes.SHA256(), big_length, None, backend)
+
+    def test_already_finalized(self, backend):
+        xkdf = X963KDF(hashes.SHA256(), 16, None, backend)
+
+        xkdf.derive(b"\x01" * 16)
+
+        with pytest.raises(AlreadyFinalized):
+            xkdf.derive(b"\x02" * 16)
+
+    def test_derive(self, backend):
+        key = binascii.unhexlify(
+            b"96c05619d56c328ab95fe84b18264b08725b85e33fd34f08"
+        )
+
+        derivedkey = binascii.unhexlify(b"443024c3dae66b95e6f5670601558f71")
+
+        xkdf = X963KDF(hashes.SHA256(), 16, None, backend)
+
+        assert xkdf.derive(key) == derivedkey
+
+    def test_verify(self, backend):
+        key = binascii.unhexlify(
+            b"22518b10e70f2a3f243810ae3254139efbee04aa57c7af7d"
+        )
+
+        sharedinfo = binascii.unhexlify(b"75eef81aa3041e33b80971203d2c0c52")
+
+        derivedkey = binascii.unhexlify(
+            b"c498af77161cc59f2962b9a713e2b215152d139766ce34a776df11866a69bf2e"
+            b"52a13d9c7c6fc878c50c5ea0bc7b00e0da2447cfd874f6cf92f30d0097111485"
+            b"500c90c3af8b487872d04685d14c8d1dc8d7fa08beb0ce0ababc11f0bd496269"
+            b"142d43525a78e5bc79a17f59676a5706dc54d54d4d1f0bd7e386128ec26afc21"
+        )
+
+        xkdf = X963KDF(hashes.SHA256(), 128, sharedinfo, backend)
+
+        assert xkdf.verify(key, derivedkey) is None
+
+    def test_invalid_verify(self, backend):
+        key = binascii.unhexlify(
+            b"96c05619d56c328ab95fe84b18264b08725b85e33fd34f08"
+        )
+
+        xkdf = X963KDF(hashes.SHA256(), 16, None, backend)
+
+        with pytest.raises(InvalidKey):
+            xkdf.verify(key, b"wrong derived key")
+
+    def test_unicode_typeerror(self, backend):
+        with pytest.raises(TypeError):
+            X963KDF(
+                hashes.SHA256(),
+                16,
+                sharedinfo=u"foo",
+                backend=backend
+            )
+
+        with pytest.raises(TypeError):
+            xkdf = X963KDF(
+                hashes.SHA256(),
+                16,
+                sharedinfo=None,
+                backend=backend
+            )
+
+            xkdf.derive(u"foo")
+
+        with pytest.raises(TypeError):
+            xkdf = X963KDF(
+                hashes.SHA256(),
+                16,
+                sharedinfo=None,
+                backend=backend
+            )
+
+            xkdf.verify(u"foo", b"bar")
+
+        with pytest.raises(TypeError):
+            xkdf = X963KDF(
+                hashes.SHA256(),
+                16,
+                sharedinfo=None,
+                backend=backend
+            )
+
+            xkdf.verify(b"foo", u"bar")
+
+
+def test_invalid_backend():
+    pretend_backend = object()
+
+    with raises_unsupported_algorithm(_Reasons.BACKEND_MISSING_INTERFACE):
+        X963KDF(hashes.SHA256(), 16, None, pretend_backend)
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_x963_vectors.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_x963_vectors.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_x963_vectors.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/test_x963_vectors.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,72 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import binascii
+import os
+
+import pytest
+
+from cryptography import utils
+from cryptography.hazmat.backends import default_backend
+from cryptography.hazmat.backends.interfaces import HashBackend
+from cryptography.hazmat.primitives import hashes
+from cryptography.hazmat.primitives.kdf.x963kdf import X963KDF
+
+from ...utils import load_vectors_from_file, load_x963_vectors
+
+
+@utils.register_interface(hashes.HashAlgorithm)
+class UnsupportedDummyHash(object):
+    name = "unsupported-dummy-hash"
+    block_size = None
+    digest_size = None
+
+
+def _skip_hashfn_unsupported(backend, hashfn):
+    if not backend.hash_supported(hashfn):
+        pytest.skip(
+            "Hash {0} is not supported by this backend {1}".format(
+                hashfn.name, backend
+            )
+        )
+
+
+@pytest.mark.requires_backend_interface(interface=HashBackend)
+class TestX963(object):
+    _algorithms_dict = {
+        'SHA-1': hashes.SHA1,
+        'SHA-224': hashes.SHA224,
+        'SHA-256': hashes.SHA256,
+        'SHA-384': hashes.SHA384,
+        'SHA-512': hashes.SHA512
+    }
+
+    @pytest.mark.parametrize(
+        ("vector"),
+        load_vectors_from_file(
+            os.path.join("KDF", "ansx963_2001.txt"),
+            load_x963_vectors
+        )
+    )
+    def test_x963(self, backend, vector):
+        hashfn = self._algorithms_dict[vector["hash"]]
+        _skip_hashfn_unsupported(backend, hashfn())
+
+        key = binascii.unhexlify(vector["Z"])
+        sharedinfo = None
+        if vector["sharedinfo_length"] != 0:
+            sharedinfo = binascii.unhexlify(vector["sharedinfo"])
+        key_data_len = vector["key_data_length"] // 8
+        key_data = binascii.unhexlify(vector["key_data"])
+
+        xkdf = X963KDF(algorithm=hashfn(),
+                       length=key_data_len,
+                       sharedinfo=sharedinfo,
+                       backend=default_backend())
+        xkdf.verify(key, key_data)
+
+    def test_unsupported_hash(self, backend):
+        _skip_hashfn_unsupported(backend, UnsupportedDummyHash())
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/twofactor/__init__.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/twofactor/__init__.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/twofactor/__init__.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/twofactor/__init__.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,5 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/twofactor/test_hotp.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/twofactor/test_hotp.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/twofactor/test_hotp.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/twofactor/test_hotp.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,115 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import os
+
+import pytest
+
+from cryptography.exceptions import _Reasons
+from cryptography.hazmat.backends.interfaces import HMACBackend
+from cryptography.hazmat.primitives import hashes
+from cryptography.hazmat.primitives.hashes import MD5, SHA1
+from cryptography.hazmat.primitives.twofactor import InvalidToken
+from cryptography.hazmat.primitives.twofactor.hotp import HOTP
+
+from ....utils import (
+    load_nist_vectors, load_vectors_from_file, raises_unsupported_algorithm
+)
+
+vectors = load_vectors_from_file(
+    "twofactor/rfc-4226.txt", load_nist_vectors)
+
+
+@pytest.mark.supported(
+    only_if=lambda backend: backend.hmac_supported(hashes.SHA1()),
+    skip_message="Does not support HMAC-SHA1."
+)
+@pytest.mark.requires_backend_interface(interface=HMACBackend)
+class TestHOTP(object):
+    def test_invalid_key_length(self, backend):
+        secret = os.urandom(10)
+
+        with pytest.raises(ValueError):
+            HOTP(secret, 6, SHA1(), backend)
+
+    def test_invalid_hotp_length(self, backend):
+        secret = os.urandom(16)
+
+        with pytest.raises(ValueError):
+            HOTP(secret, 4, SHA1(), backend)
+
+    def test_invalid_algorithm(self, backend):
+        secret = os.urandom(16)
+
+        with pytest.raises(TypeError):
+            HOTP(secret, 6, MD5(), backend)
+
+    @pytest.mark.parametrize("params", vectors)
+    def test_truncate(self, backend, params):
+        secret = params["secret"]
+        counter = int(params["counter"])
+        truncated = params["truncated"]
+
+        hotp = HOTP(secret, 6, SHA1(), backend)
+
+        assert hotp._dynamic_truncate(counter) == int(truncated.decode(), 16)
+
+    @pytest.mark.parametrize("params", vectors)
+    def test_generate(self, backend, params):
+        secret = params["secret"]
+        counter = int(params["counter"])
+        hotp_value = params["hotp"]
+
+        hotp = HOTP(secret, 6, SHA1(), backend)
+
+        assert hotp.generate(counter) == hotp_value
+
+    @pytest.mark.parametrize("params", vectors)
+    def test_verify(self, backend, params):
+        secret = params["secret"]
+        counter = int(params["counter"])
+        hotp_value = params["hotp"]
+
+        hotp = HOTP(secret, 6, SHA1(), backend)
+
+        assert hotp.verify(hotp_value, counter) is None
+
+    def test_invalid_verify(self, backend):
+        secret = b"12345678901234567890"
+        counter = 0
+
+        hotp = HOTP(secret, 6, SHA1(), backend)
+
+        with pytest.raises(InvalidToken):
+            hotp.verify(b"123456", counter)
+
+    def test_length_not_int(self, backend):
+        secret = b"12345678901234567890"
+
+        with pytest.raises(TypeError):
+            HOTP(secret, b"foo", SHA1(), backend)
+
+    def test_get_provisioning_uri(self, backend):
+        secret = b"12345678901234567890"
+        hotp = HOTP(secret, 6, SHA1(), backend)
+
+        assert hotp.get_provisioning_uri("Alice Smith", 1, None) == (
+            "otpauth://hotp/Alice%20Smith?digits=6&secret=GEZDGNBV"
+            "GY3TQOJQGEZDGNBVGY3TQOJQ&algorithm=SHA1&counter=1")
+
+        assert hotp.get_provisioning_uri("Alice Smith", 1, 'Foo') == (
+            "otpauth://hotp/Foo:Alice%20Smith?digits=6&secret=GEZD"
+            "GNBVGY3TQOJQGEZDGNBVGY3TQOJQ&algorithm=SHA1&issuer=Foo"
+            "&counter=1")
+
+
+def test_invalid_backend():
+    secret = b"12345678901234567890"
+
+    pretend_backend = object()
+
+    with raises_unsupported_algorithm(_Reasons.BACKEND_MISSING_INTERFACE):
+        HOTP(secret, 8, hashes.SHA1(), pretend_backend)
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/twofactor/test_totp.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/twofactor/test_totp.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/twofactor/test_totp.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/twofactor/test_totp.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,149 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import pytest
+
+from cryptography.exceptions import _Reasons
+from cryptography.hazmat.backends.interfaces import HMACBackend
+from cryptography.hazmat.primitives import hashes
+from cryptography.hazmat.primitives.twofactor import InvalidToken
+from cryptography.hazmat.primitives.twofactor.totp import TOTP
+
+from ....utils import (
+    load_nist_vectors, load_vectors_from_file, raises_unsupported_algorithm
+)
+
+vectors = load_vectors_from_file(
+    "twofactor/rfc-6238.txt", load_nist_vectors)
+
+
+@pytest.mark.requires_backend_interface(interface=HMACBackend)
+class TestTOTP(object):
+    @pytest.mark.supported(
+        only_if=lambda backend: backend.hmac_supported(hashes.SHA1()),
+        skip_message="Does not support HMAC-SHA1."
+    )
+    @pytest.mark.parametrize(
+        "params", [i for i in vectors if i["mode"] == b"SHA1"])
+    def test_generate_sha1(self, backend, params):
+        secret = params["secret"]
+        time = int(params["time"])
+        totp_value = params["totp"]
+
+        totp = TOTP(secret, 8, hashes.SHA1(), 30, backend)
+        assert totp.generate(time) == totp_value
+
+    @pytest.mark.supported(
+        only_if=lambda backend: backend.hmac_supported(hashes.SHA256()),
+        skip_message="Does not support HMAC-SHA256."
+    )
+    @pytest.mark.parametrize(
+        "params", [i for i in vectors if i["mode"] == b"SHA256"])
+    def test_generate_sha256(self, backend, params):
+        secret = params["secret"]
+        time = int(params["time"])
+        totp_value = params["totp"]
+
+        totp = TOTP(secret, 8, hashes.SHA256(), 30, backend)
+        assert totp.generate(time) == totp_value
+
+    @pytest.mark.supported(
+        only_if=lambda backend: backend.hmac_supported(hashes.SHA512()),
+        skip_message="Does not support HMAC-SHA512."
+    )
+    @pytest.mark.parametrize(
+        "params", [i for i in vectors if i["mode"] == b"SHA512"])
+    def test_generate_sha512(self, backend, params):
+        secret = params["secret"]
+        time = int(params["time"])
+        totp_value = params["totp"]
+
+        totp = TOTP(secret, 8, hashes.SHA512(), 30, backend)
+        assert totp.generate(time) == totp_value
+
+    @pytest.mark.supported(
+        only_if=lambda backend: backend.hmac_supported(hashes.SHA1()),
+        skip_message="Does not support HMAC-SHA1."
+    )
+    @pytest.mark.parametrize(
+        "params", [i for i in vectors if i["mode"] == b"SHA1"])
+    def test_verify_sha1(self, backend, params):
+        secret = params["secret"]
+        time = int(params["time"])
+        totp_value = params["totp"]
+
+        totp = TOTP(secret, 8, hashes.SHA1(), 30, backend)
+
+        assert totp.verify(totp_value, time) is None
+
+    @pytest.mark.supported(
+        only_if=lambda backend: backend.hmac_supported(hashes.SHA256()),
+        skip_message="Does not support HMAC-SHA256."
+    )
+    @pytest.mark.parametrize(
+        "params", [i for i in vectors if i["mode"] == b"SHA256"])
+    def test_verify_sha256(self, backend, params):
+        secret = params["secret"]
+        time = int(params["time"])
+        totp_value = params["totp"]
+
+        totp = TOTP(secret, 8, hashes.SHA256(), 30, backend)
+
+        assert totp.verify(totp_value, time) is None
+
+    @pytest.mark.supported(
+        only_if=lambda backend: backend.hmac_supported(hashes.SHA512()),
+        skip_message="Does not support HMAC-SHA512."
+    )
+    @pytest.mark.parametrize(
+        "params", [i for i in vectors if i["mode"] == b"SHA512"])
+    def test_verify_sha512(self, backend, params):
+        secret = params["secret"]
+        time = int(params["time"])
+        totp_value = params["totp"]
+
+        totp = TOTP(secret, 8, hashes.SHA512(), 30, backend)
+
+        assert totp.verify(totp_value, time) is None
+
+    def test_invalid_verify(self, backend):
+        secret = b"12345678901234567890"
+        time = 59
+
+        totp = TOTP(secret, 8, hashes.SHA1(), 30, backend)
+
+        with pytest.raises(InvalidToken):
+            totp.verify(b"12345678", time)
+
+    def test_floating_point_time_generate(self, backend):
+        secret = b"12345678901234567890"
+        time = 59.1
+
+        totp = TOTP(secret, 8, hashes.SHA1(), 30, backend)
+
+        assert totp.generate(time) == b"94287082"
+
+    def test_get_provisioning_uri(self, backend):
+        secret = b"12345678901234567890"
+        totp = TOTP(secret, 6, hashes.SHA1(), 30, backend=backend)
+
+        assert totp.get_provisioning_uri("Alice Smith", None) == (
+            "otpauth://totp/Alice%20Smith?digits=6&secret=GEZDGNBVG"
+            "Y3TQOJQGEZDGNBVGY3TQOJQ&algorithm=SHA1&period=30")
+
+        assert totp.get_provisioning_uri("Alice Smith", 'World') == (
+            "otpauth://totp/World:Alice%20Smith?digits=6&secret=GEZ"
+            "DGNBVGY3TQOJQGEZDGNBVGY3TQOJQ&algorithm=SHA1&issuer=World"
+            "&period=30")
+
+
+def test_invalid_backend():
+    secret = b"12345678901234567890"
+
+    pretend_backend = object()
+
+    with raises_unsupported_algorithm(_Reasons.BACKEND_MISSING_INTERFACE):
+        TOTP(secret, 8, hashes.SHA1(), 30, pretend_backend)
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/utils.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/utils.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/utils.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hazmat/primitives/utils.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,423 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import binascii
+import itertools
+import os
+
+import pytest
+
+from cryptography.exceptions import (
+    AlreadyFinalized, AlreadyUpdated, InvalidSignature, InvalidTag,
+    NotYetFinalized
+)
+from cryptography.hazmat.primitives import hashes, hmac
+from cryptography.hazmat.primitives.asymmetric import rsa
+from cryptography.hazmat.primitives.ciphers import Cipher
+from cryptography.hazmat.primitives.kdf.hkdf import HKDF, HKDFExpand
+from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
+
+from ...utils import load_vectors_from_file
+
+
+def _load_all_params(path, file_names, param_loader):
+    all_params = []
+    for file_name in file_names:
+        all_params.extend(
+            load_vectors_from_file(os.path.join(path, file_name), param_loader)
+        )
+    return all_params
+
+
+def generate_encrypt_test(param_loader, path, file_names, cipher_factory,
+                          mode_factory):
+    all_params = _load_all_params(path, file_names, param_loader)
+
+    @pytest.mark.parametrize("params", all_params)
+    def test_encryption(self, backend, params):
+        encrypt_test(backend, cipher_factory, mode_factory, params)
+
+    return test_encryption
+
+
+def encrypt_test(backend, cipher_factory, mode_factory, params):
+    plaintext = params["plaintext"]
+    ciphertext = params["ciphertext"]
+    cipher = Cipher(
+        cipher_factory(**params),
+        mode_factory(**params),
+        backend=backend
+    )
+    encryptor = cipher.encryptor()
+    actual_ciphertext = encryptor.update(binascii.unhexlify(plaintext))
+    actual_ciphertext += encryptor.finalize()
+    assert actual_ciphertext == binascii.unhexlify(ciphertext)
+    decryptor = cipher.decryptor()
+    actual_plaintext = decryptor.update(binascii.unhexlify(ciphertext))
+    actual_plaintext += decryptor.finalize()
+    assert actual_plaintext == binascii.unhexlify(plaintext)
+
+
+def generate_aead_test(param_loader, path, file_names, cipher_factory,
+                       mode_factory):
+    all_params = _load_all_params(path, file_names, param_loader)
+
+    @pytest.mark.parametrize("params", all_params)
+    def test_aead(self, backend, params):
+        aead_test(backend, cipher_factory, mode_factory, params)
+
+    return test_aead
+
+
+def aead_test(backend, cipher_factory, mode_factory, params):
+    if params.get("pt") is not None:
+        plaintext = params["pt"]
+    ciphertext = params["ct"]
+    aad = params["aad"]
+    if params.get("fail") is True:
+        cipher = Cipher(
+            cipher_factory(binascii.unhexlify(params["key"])),
+            mode_factory(binascii.unhexlify(params["iv"]),
+                         binascii.unhexlify(params["tag"]),
+                         len(binascii.unhexlify(params["tag"]))),
+            backend
+        )
+        decryptor = cipher.decryptor()
+        decryptor.authenticate_additional_data(binascii.unhexlify(aad))
+        actual_plaintext = decryptor.update(binascii.unhexlify(ciphertext))
+        with pytest.raises(InvalidTag):
+            decryptor.finalize()
+    else:
+        cipher = Cipher(
+            cipher_factory(binascii.unhexlify(params["key"])),
+            mode_factory(binascii.unhexlify(params["iv"]), None),
+            backend
+        )
+        encryptor = cipher.encryptor()
+        encryptor.authenticate_additional_data(binascii.unhexlify(aad))
+        actual_ciphertext = encryptor.update(binascii.unhexlify(plaintext))
+        actual_ciphertext += encryptor.finalize()
+        tag_len = len(binascii.unhexlify(params["tag"]))
+        assert binascii.hexlify(encryptor.tag[:tag_len]) == params["tag"]
+        cipher = Cipher(
+            cipher_factory(binascii.unhexlify(params["key"])),
+            mode_factory(binascii.unhexlify(params["iv"]),
+                         binascii.unhexlify(params["tag"]),
+                         min_tag_length=tag_len),
+            backend
+        )
+        decryptor = cipher.decryptor()
+        decryptor.authenticate_additional_data(binascii.unhexlify(aad))
+        actual_plaintext = decryptor.update(binascii.unhexlify(ciphertext))
+        actual_plaintext += decryptor.finalize()
+        assert actual_plaintext == binascii.unhexlify(plaintext)
+
+
+def generate_stream_encryption_test(param_loader, path, file_names,
+                                    cipher_factory):
+    all_params = _load_all_params(path, file_names, param_loader)
+
+    @pytest.mark.parametrize("params", all_params)
+    def test_stream_encryption(self, backend, params):
+        stream_encryption_test(backend, cipher_factory, params)
+    return test_stream_encryption
+
+
+def stream_encryption_test(backend, cipher_factory, params):
+    plaintext = params["plaintext"]
+    ciphertext = params["ciphertext"]
+    offset = params["offset"]
+    cipher = Cipher(cipher_factory(**params), None, backend=backend)
+    encryptor = cipher.encryptor()
+    # throw away offset bytes
+    encryptor.update(b"\x00" * int(offset))
+    actual_ciphertext = encryptor.update(binascii.unhexlify(plaintext))
+    actual_ciphertext += encryptor.finalize()
+    assert actual_ciphertext == binascii.unhexlify(ciphertext)
+    decryptor = cipher.decryptor()
+    decryptor.update(b"\x00" * int(offset))
+    actual_plaintext = decryptor.update(binascii.unhexlify(ciphertext))
+    actual_plaintext += decryptor.finalize()
+    assert actual_plaintext == binascii.unhexlify(plaintext)
+
+
+def generate_hash_test(param_loader, path, file_names, hash_cls):
+    all_params = _load_all_params(path, file_names, param_loader)
+
+    @pytest.mark.parametrize("params", all_params)
+    def test_hash(self, backend, params):
+        hash_test(backend, hash_cls, params)
+    return test_hash
+
+
+def hash_test(backend, algorithm, params):
+    msg, md = params
+    m = hashes.Hash(algorithm, backend=backend)
+    m.update(binascii.unhexlify(msg))
+    expected_md = md.replace(" ", "").lower().encode("ascii")
+    assert m.finalize() == binascii.unhexlify(expected_md)
+
+
+def generate_base_hash_test(algorithm, digest_size, block_size):
+    def test_base_hash(self, backend):
+        base_hash_test(backend, algorithm, digest_size, block_size)
+    return test_base_hash
+
+
+def base_hash_test(backend, algorithm, digest_size, block_size):
+    m = hashes.Hash(algorithm, backend=backend)
+    assert m.algorithm.digest_size == digest_size
+    assert m.algorithm.block_size == block_size
+    m_copy = m.copy()
+    assert m != m_copy
+    assert m._ctx != m_copy._ctx
+
+    m.update(b"abc")
+    copy = m.copy()
+    copy.update(b"123")
+    m.update(b"123")
+    assert copy.finalize() == m.finalize()
+
+
+def generate_long_string_hash_test(hash_factory, md):
+    def test_long_string_hash(self, backend):
+        long_string_hash_test(backend, hash_factory, md)
+    return test_long_string_hash
+
+
+def long_string_hash_test(backend, algorithm, md):
+    m = hashes.Hash(algorithm, backend=backend)
+    m.update(b"a" * 1000000)
+    assert m.finalize() == binascii.unhexlify(md.lower().encode("ascii"))
+
+
+def generate_base_hmac_test(hash_cls):
+    def test_base_hmac(self, backend):
+        base_hmac_test(backend, hash_cls)
+    return test_base_hmac
+
+
+def base_hmac_test(backend, algorithm):
+    key = b"ab"
+    h = hmac.HMAC(binascii.unhexlify(key), algorithm, backend=backend)
+    h_copy = h.copy()
+    assert h != h_copy
+    assert h._ctx != h_copy._ctx
+
+
+def generate_hmac_test(param_loader, path, file_names, algorithm):
+    all_params = _load_all_params(path, file_names, param_loader)
+
+    @pytest.mark.parametrize("params", all_params)
+    def test_hmac(self, backend, params):
+        hmac_test(backend, algorithm, params)
+    return test_hmac
+
+
+def hmac_test(backend, algorithm, params):
+    msg, md, key = params
+    h = hmac.HMAC(binascii.unhexlify(key), algorithm, backend=backend)
+    h.update(binascii.unhexlify(msg))
+    assert h.finalize() == binascii.unhexlify(md.encode("ascii"))
+
+
+def generate_pbkdf2_test(param_loader, path, file_names, algorithm):
+    all_params = _load_all_params(path, file_names, param_loader)
+
+    @pytest.mark.parametrize("params", all_params)
+    def test_pbkdf2(self, backend, params):
+        pbkdf2_test(backend, algorithm, params)
+    return test_pbkdf2
+
+
+def pbkdf2_test(backend, algorithm, params):
+    # Password and salt can contain \0, which should be loaded as a null char.
+    # The NIST loader loads them as literal strings so we replace with the
+    # proper value.
+    kdf = PBKDF2HMAC(
+        algorithm,
+        int(params["length"]),
+        params["salt"],
+        int(params["iterations"]),
+        backend
+    )
+    derived_key = kdf.derive(params["password"])
+    assert binascii.hexlify(derived_key) == params["derived_key"]
+
+
+def generate_aead_exception_test(cipher_factory, mode_factory):
+    def test_aead_exception(self, backend):
+        aead_exception_test(backend, cipher_factory, mode_factory)
+    return test_aead_exception
+
+
+def aead_exception_test(backend, cipher_factory, mode_factory):
+    cipher = Cipher(
+        cipher_factory(binascii.unhexlify(b"0" * 32)),
+        mode_factory(binascii.unhexlify(b"0" * 24)),
+        backend
+    )
+    encryptor = cipher.encryptor()
+    encryptor.update(b"a" * 16)
+    with pytest.raises(NotYetFinalized):
+        encryptor.tag
+    with pytest.raises(AlreadyUpdated):
+        encryptor.authenticate_additional_data(b"b" * 16)
+    encryptor.finalize()
+    with pytest.raises(AlreadyFinalized):
+        encryptor.authenticate_additional_data(b"b" * 16)
+    with pytest.raises(AlreadyFinalized):
+        encryptor.update(b"b" * 16)
+    with pytest.raises(AlreadyFinalized):
+        encryptor.finalize()
+    cipher = Cipher(
+        cipher_factory(binascii.unhexlify(b"0" * 32)),
+        mode_factory(binascii.unhexlify(b"0" * 24), b"0" * 16),
+        backend
+    )
+    decryptor = cipher.decryptor()
+    decryptor.update(b"a" * 16)
+    with pytest.raises(AttributeError):
+        decryptor.tag
+
+
+def generate_aead_tag_exception_test(cipher_factory, mode_factory):
+    def test_aead_tag_exception(self, backend):
+        aead_tag_exception_test(backend, cipher_factory, mode_factory)
+    return test_aead_tag_exception
+
+
+def aead_tag_exception_test(backend, cipher_factory, mode_factory):
+    cipher = Cipher(
+        cipher_factory(binascii.unhexlify(b"0" * 32)),
+        mode_factory(binascii.unhexlify(b"0" * 24)),
+        backend
+    )
+    with pytest.raises(ValueError):
+        cipher.decryptor()
+
+    with pytest.raises(ValueError):
+        mode_factory(binascii.unhexlify(b"0" * 24), b"000")
+
+    with pytest.raises(ValueError):
+        mode_factory(binascii.unhexlify(b"0" * 24), b"000000", 2)
+
+    cipher = Cipher(
+        cipher_factory(binascii.unhexlify(b"0" * 32)),
+        mode_factory(binascii.unhexlify(b"0" * 24), b"0" * 16),
+        backend
+    )
+    with pytest.raises(ValueError):
+        cipher.encryptor()
+
+
+def hkdf_derive_test(backend, algorithm, params):
+    hkdf = HKDF(
+        algorithm,
+        int(params["l"]),
+        salt=binascii.unhexlify(params["salt"]) or None,
+        info=binascii.unhexlify(params["info"]) or None,
+        backend=backend
+    )
+
+    okm = hkdf.derive(binascii.unhexlify(params["ikm"]))
+
+    assert okm == binascii.unhexlify(params["okm"])
+
+
+def hkdf_extract_test(backend, algorithm, params):
+    hkdf = HKDF(
+        algorithm,
+        int(params["l"]),
+        salt=binascii.unhexlify(params["salt"]) or None,
+        info=binascii.unhexlify(params["info"]) or None,
+        backend=backend
+    )
+
+    prk = hkdf._extract(binascii.unhexlify(params["ikm"]))
+
+    assert prk == binascii.unhexlify(params["prk"])
+
+
+def hkdf_expand_test(backend, algorithm, params):
+    hkdf = HKDFExpand(
+        algorithm,
+        int(params["l"]),
+        info=binascii.unhexlify(params["info"]) or None,
+        backend=backend
+    )
+
+    okm = hkdf.derive(binascii.unhexlify(params["prk"]))
+
+    assert okm == binascii.unhexlify(params["okm"])
+
+
+def generate_hkdf_test(param_loader, path, file_names, algorithm):
+    all_params = _load_all_params(path, file_names, param_loader)
+
+    all_tests = [hkdf_extract_test, hkdf_expand_test, hkdf_derive_test]
+
+    @pytest.mark.parametrize(
+        ("params", "hkdf_test"),
+        itertools.product(all_params, all_tests)
+    )
+    def test_hkdf(self, backend, params, hkdf_test):
+        hkdf_test(backend, algorithm, params)
+
+    return test_hkdf
+
+
+def generate_rsa_verification_test(param_loader, path, file_names, hash_alg,
+                                   pad_factory):
+    all_params = _load_all_params(path, file_names, param_loader)
+    all_params = [i for i in all_params
+                  if i["algorithm"] == hash_alg.name.upper()]
+
+    @pytest.mark.parametrize("params", all_params)
+    def test_rsa_verification(self, backend, params):
+        rsa_verification_test(backend, params, hash_alg, pad_factory)
+
+    return test_rsa_verification
+
+
+def rsa_verification_test(backend, params, hash_alg, pad_factory):
+    public_numbers = rsa.RSAPublicNumbers(
+        e=params["public_exponent"],
+        n=params["modulus"]
+    )
+    public_key = public_numbers.public_key(backend)
+    pad = pad_factory(params, hash_alg)
+    verifier = public_key.verifier(
+        binascii.unhexlify(params["s"]),
+        pad,
+        hash_alg
+    )
+    verifier.update(binascii.unhexlify(params["msg"]))
+    if params["fail"]:
+        with pytest.raises(InvalidSignature):
+            verifier.verify()
+    else:
+        verifier.verify()
+
+
+def _check_rsa_private_numbers(skey):
+    assert skey
+    pkey = skey.public_numbers
+    assert pkey
+    assert pkey.e
+    assert pkey.n
+    assert skey.d
+    assert skey.p * skey.q == pkey.n
+    assert skey.dmp1 == rsa.rsa_crt_dmp1(skey.d, skey.p)
+    assert skey.dmq1 == rsa.rsa_crt_dmq1(skey.d, skey.q)
+    assert skey.iqmp == rsa.rsa_crt_iqmp(skey.p, skey.q)
+
+
+def _check_dsa_private_numbers(skey):
+    assert skey
+    pkey = skey.public_numbers
+    params = pkey.parameter_numbers
+    assert pow(params.g, skey.x, params.p) == pkey.y
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hypothesis/__init__.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hypothesis/__init__.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hypothesis/__init__.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hypothesis/__init__.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,5 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hypothesis/test_fernet.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hypothesis/test_fernet.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/hypothesis/test_fernet.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/hypothesis/test_fernet.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,15 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from hypothesis import given
+from hypothesis.strategies import binary
+
+from cryptography.fernet import Fernet
+
+
+@given(binary())
+def test_fernet(data):
+    f = Fernet(Fernet.generate_key())
+    ct = f.encrypt(data)
+    assert f.decrypt(ct) == data
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/__init__.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/__init__.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/__init__.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/__init__.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,5 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/test_fernet.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/test_fernet.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/test_fernet.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/test_fernet.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,149 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import base64
+import calendar
+import json
+import os
+import time
+
+import iso8601
+
+import pytest
+
+import six
+
+from cryptography.fernet import Fernet, InvalidToken, MultiFernet
+from cryptography.hazmat.backends import default_backend
+from cryptography.hazmat.backends.interfaces import CipherBackend, HMACBackend
+from cryptography.hazmat.primitives.ciphers import algorithms, modes
+
+import cryptography_vectors
+
+
+def json_parametrize(keys, filename):
+    vector_file = cryptography_vectors.open_vector_file(
+        os.path.join('fernet', filename), "r"
+    )
+    with vector_file:
+        data = json.load(vector_file)
+        return pytest.mark.parametrize(keys, [
+            tuple([entry[k] for k in keys])
+            for entry in data
+        ])
+
+
+def test_default_backend():
+    f = Fernet(Fernet.generate_key())
+    assert f._backend is default_backend()
+
+
+@pytest.mark.requires_backend_interface(interface=CipherBackend)
+@pytest.mark.requires_backend_interface(interface=HMACBackend)
+@pytest.mark.supported(
+    only_if=lambda backend: backend.cipher_supported(
+        algorithms.AES("\x00" * 32), modes.CBC("\x00" * 16)
+    ),
+    skip_message="Does not support AES CBC",
+)
+class TestFernet(object):
+    @json_parametrize(
+        ("secret", "now", "iv", "src", "token"), "generate.json",
+    )
+    def test_generate(self, secret, now, iv, src, token, backend):
+        f = Fernet(secret.encode("ascii"), backend=backend)
+        actual_token = f._encrypt_from_parts(
+            src.encode("ascii"),
+            calendar.timegm(iso8601.parse_date(now).utctimetuple()),
+            b"".join(map(six.int2byte, iv))
+        )
+        assert actual_token == token.encode("ascii")
+
+    @json_parametrize(
+        ("secret", "now", "src", "ttl_sec", "token"), "verify.json",
+    )
+    def test_verify(self, secret, now, src, ttl_sec, token, backend,
+                    monkeypatch):
+        f = Fernet(secret.encode("ascii"), backend=backend)
+        current_time = calendar.timegm(iso8601.parse_date(now).utctimetuple())
+        monkeypatch.setattr(time, "time", lambda: current_time)
+        payload = f.decrypt(token.encode("ascii"), ttl=ttl_sec)
+        assert payload == src.encode("ascii")
+
+    @json_parametrize(("secret", "token", "now", "ttl_sec"), "invalid.json")
+    def test_invalid(self, secret, token, now, ttl_sec, backend, monkeypatch):
+        f = Fernet(secret.encode("ascii"), backend=backend)
+        current_time = calendar.timegm(iso8601.parse_date(now).utctimetuple())
+        monkeypatch.setattr(time, "time", lambda: current_time)
+        with pytest.raises(InvalidToken):
+            f.decrypt(token.encode("ascii"), ttl=ttl_sec)
+
+    def test_invalid_start_byte(self, backend):
+        f = Fernet(base64.urlsafe_b64encode(b"\x00" * 32), backend=backend)
+        with pytest.raises(InvalidToken):
+            f.decrypt(base64.urlsafe_b64encode(b"\x81"))
+
+    def test_timestamp_too_short(self, backend):
+        f = Fernet(base64.urlsafe_b64encode(b"\x00" * 32), backend=backend)
+        with pytest.raises(InvalidToken):
+            f.decrypt(base64.urlsafe_b64encode(b"\x80abc"))
+
+    def test_non_base64_token(self, backend):
+        f = Fernet(base64.urlsafe_b64encode(b"\x00" * 32), backend=backend)
+        with pytest.raises(InvalidToken):
+            f.decrypt(b"\x00")
+
+    def test_unicode(self, backend):
+        f = Fernet(base64.urlsafe_b64encode(b"\x00" * 32), backend=backend)
+        with pytest.raises(TypeError):
+            f.encrypt(u"")
+        with pytest.raises(TypeError):
+            f.decrypt(u"")
+
+    @pytest.mark.parametrize("message", [b"", b"Abc!", b"\x00\xFF\x00\x80"])
+    def test_roundtrips(self, message, backend):
+        f = Fernet(Fernet.generate_key(), backend=backend)
+        assert f.decrypt(f.encrypt(message)) == message
+
+    def test_bad_key(self, backend):
+        with pytest.raises(ValueError):
+            Fernet(base64.urlsafe_b64encode(b"abc"), backend=backend)
+
+
+@pytest.mark.requires_backend_interface(interface=CipherBackend)
+@pytest.mark.requires_backend_interface(interface=HMACBackend)
+@pytest.mark.supported(
+    only_if=lambda backend: backend.cipher_supported(
+        algorithms.AES("\x00" * 32), modes.CBC("\x00" * 16)
+    ),
+    skip_message="Does not support AES CBC",
+)
+class TestMultiFernet(object):
+    def test_encrypt(self, backend):
+        f1 = Fernet(base64.urlsafe_b64encode(b"\x00" * 32), backend=backend)
+        f2 = Fernet(base64.urlsafe_b64encode(b"\x01" * 32), backend=backend)
+        f = MultiFernet([f1, f2])
+
+        assert f1.decrypt(f.encrypt(b"abc")) == b"abc"
+
+    def test_decrypt(self, backend):
+        f1 = Fernet(base64.urlsafe_b64encode(b"\x00" * 32), backend=backend)
+        f2 = Fernet(base64.urlsafe_b64encode(b"\x01" * 32), backend=backend)
+        f = MultiFernet([f1, f2])
+
+        assert f.decrypt(f1.encrypt(b"abc")) == b"abc"
+        assert f.decrypt(f2.encrypt(b"abc")) == b"abc"
+
+        with pytest.raises(InvalidToken):
+            f.decrypt(b"\x00" * 16)
+
+    def test_no_fernets(self, backend):
+        with pytest.raises(ValueError):
+            MultiFernet([])
+
+    def test_non_iterable_argument(self, backend):
+        with pytest.raises(TypeError):
+            MultiFernet(None)
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/test_interfaces.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/test_interfaces.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/test_interfaces.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/test_interfaces.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,58 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+import abc
+
+import pytest
+
+import six
+
+from cryptography.utils import InterfaceNotImplemented, verify_interface
+
+
+class TestVerifyInterface(object):
+    def test_verify_missing_method(self):
+        @six.add_metaclass(abc.ABCMeta)
+        class SimpleInterface(object):
+            @abc.abstractmethod
+            def method(self):
+                """A simple method"""
+
+        class NonImplementer(object):
+            pass
+
+        with pytest.raises(InterfaceNotImplemented):
+            verify_interface(SimpleInterface, NonImplementer)
+
+    def test_different_arguments(self):
+        @six.add_metaclass(abc.ABCMeta)
+        class SimpleInterface(object):
+            @abc.abstractmethod
+            def method(self, a):
+                """Method with one argument"""
+
+        class NonImplementer(object):
+            def method(self):
+                """Method with no arguments"""
+
+        # Invoke this to ensure the line is covered
+        NonImplementer().method()
+        with pytest.raises(InterfaceNotImplemented):
+            verify_interface(SimpleInterface, NonImplementer)
+
+    def test_handles_abstract_property(self):
+        @six.add_metaclass(abc.ABCMeta)
+        class SimpleInterface(object):
+            @abc.abstractproperty
+            def property(self):
+                """An abstract property"""
+
+        class NonImplementer(object):
+            @property
+            def property(self):
+                """A concrete property"""
+
+        # Invoke this to ensure the line is covered
+        NonImplementer().property
+        verify_interface(SimpleInterface, NonImplementer)
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/test_utils.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/test_utils.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/test_utils.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/test_utils.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,3532 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import binascii
+import os
+import textwrap
+
+import pretend
+
+import pytest
+
+import cryptography
+from cryptography.exceptions import UnsupportedAlgorithm, _Reasons
+
+import cryptography_vectors
+
+from .utils import (
+    check_backend_support, load_cryptrec_vectors,
+    load_fips_dsa_key_pair_vectors, load_fips_dsa_sig_vectors,
+    load_fips_ecdsa_key_pair_vectors, load_fips_ecdsa_signing_vectors,
+    load_hash_vectors, load_kasvs_dh_vectors,
+    load_kasvs_ecdh_vectors, load_nist_vectors,
+    load_pkcs1_vectors, load_rsa_nist_vectors, load_vectors_from_file,
+    load_x963_vectors,
+    raises_unsupported_algorithm, select_backends, skip_if_empty
+)
+
+
+class FakeInterface(object):
+    pass
+
+
+def test_select_one_backend():
+    b1 = pretend.stub(name="b1")
+    b2 = pretend.stub(name="b2")
+    b3 = pretend.stub(name="b3")
+    backends = [b1, b2, b3]
+    name = "b2"
+    selected_backends = select_backends(name, backends)
+    assert len(selected_backends) == 1
+    assert selected_backends[0] == b2
+
+
+def test_select_no_backend():
+    b1 = pretend.stub(name="b1")
+    b2 = pretend.stub(name="b2")
+    b3 = pretend.stub(name="b3")
+    backends = [b1, b2, b3]
+    name = "back!"
+    with pytest.raises(ValueError):
+        select_backends(name, backends)
+
+
+def test_select_backends_none():
+    b1 = pretend.stub(name="b1")
+    b2 = pretend.stub(name="b2")
+    b3 = pretend.stub(name="b3")
+    backends = [b1, b2, b3]
+    name = None
+    selected_backends = select_backends(name, backends)
+    assert len(selected_backends) == 3
+
+
+def test_select_two_backends():
+    b1 = pretend.stub(name="b1")
+    b2 = pretend.stub(name="b2")
+    b3 = pretend.stub(name="b3")
+    backends = [b1, b2, b3]
+    name = "b2 ,b1 "
+    selected_backends = select_backends(name, backends)
+    assert len(selected_backends) == 2
+    assert selected_backends == [b1, b2]
+
+
+def test_skip_if_empty():
+    with pytest.raises(pytest.skip.Exception):
+        skip_if_empty([], [FakeInterface])
+
+    skip_if_empty(["notempty"], [FakeInterface])
+
+
+def test_check_backend_support_skip():
+    supported = pretend.stub(
+        kwargs={"only_if": lambda backend: False, "skip_message": "Nope"}
+    )
+    item = pretend.stub(keywords={"supported": [supported]},
+                        funcargs={"backend": True})
+    with pytest.raises(pytest.skip.Exception) as exc_info:
+        check_backend_support(item)
+    assert exc_info.value.args[0] == "Nope (True)"
+
+
+def test_check_backend_support_no_skip():
+    supported = pretend.stub(
+        kwargs={"only_if": lambda backend: True, "skip_message": "Nope"}
+    )
+    item = pretend.stub(keywords={"supported": [supported]},
+                        funcargs={"backend": True})
+    assert check_backend_support(item) is None
+
+
+def test_check_backend_support_no_backend():
+    supported = pretend.stub(
+        kwargs={"only_if": "notalambda", "skip_message": "Nope"}
+    )
+    item = pretend.stub(keywords={"supported": supported},
+                        funcargs={})
+    with pytest.raises(ValueError):
+        check_backend_support(item)
+
+
+def test_load_nist_vectors():
+    vector_data = textwrap.dedent("""
+    # CAVS 11.1
+    # Config info for aes_values
+    # AESVS GFSbox test data for CBC
+    # State : Encrypt and Decrypt
+    # Key Length : 128
+    # Generated on Fri Apr 22 15:11:33 2011
+
+    [ENCRYPT]
+
+    COUNT = 0
+    KEY = 00000000000000000000000000000000
+    IV = 00000000000000000000000000000000
+    PLAINTEXT = f34481ec3cc627bacd5dc3fb08f273e6
+    CIPHERTEXT = 0336763e966d92595a567cc9ce537f5e
+
+    COUNT = 1
+    KEY = 00000000000000000000000000000000
+    IV = 00000000000000000000000000000000
+    PLAINTEXT = 9798c4640bad75c7c3227db910174e72
+    CIPHERTEXT = a9a1631bf4996954ebc093957b234589
+
+    [DECRYPT]
+
+    COUNT = 0
+    KEY = 00000000000000000000000000000000
+    IV = 00000000000000000000000000000000
+    CIPHERTEXT = 0336763e966d92595a567cc9ce537f5e
+    PLAINTEXT = f34481ec3cc627bacd5dc3fb08f273e6
+
+    COUNT = 1
+    KEY = 00000000000000000000000000000000
+    IV = 00000000000000000000000000000000
+    CIPHERTEXT = a9a1631bf4996954ebc093957b234589
+    PLAINTEXT = 9798c4640bad75c7c3227db910174e72
+    """).splitlines()
+
+    assert load_nist_vectors(vector_data) == [
+        {
+            "key": b"00000000000000000000000000000000",
+            "iv": b"00000000000000000000000000000000",
+            "plaintext": b"f34481ec3cc627bacd5dc3fb08f273e6",
+            "ciphertext": b"0336763e966d92595a567cc9ce537f5e",
+        },
+        {
+            "key": b"00000000000000000000000000000000",
+            "iv": b"00000000000000000000000000000000",
+            "plaintext": b"9798c4640bad75c7c3227db910174e72",
+            "ciphertext": b"a9a1631bf4996954ebc093957b234589",
+        },
+        {
+            "key": b"00000000000000000000000000000000",
+            "iv": b"00000000000000000000000000000000",
+            "plaintext": b"f34481ec3cc627bacd5dc3fb08f273e6",
+            "ciphertext": b"0336763e966d92595a567cc9ce537f5e",
+        },
+        {
+            "key": b"00000000000000000000000000000000",
+            "iv": b"00000000000000000000000000000000",
+            "plaintext": b"9798c4640bad75c7c3227db910174e72",
+            "ciphertext": b"a9a1631bf4996954ebc093957b234589",
+        },
+    ]
+
+
+def test_load_nist_vectors_with_null_chars():
+    vector_data = textwrap.dedent("""
+    COUNT = 0
+    KEY = thing\\0withnulls
+
+    COUNT = 1
+    KEY = 00000000000000000000000000000000
+    """).splitlines()
+
+    assert load_nist_vectors(vector_data) == [
+        {
+            "key": b"thing\x00withnulls",
+        },
+        {
+            "key": b"00000000000000000000000000000000",
+        },
+    ]
+
+
+def test_load_cryptrec_vectors():
+    vector_data = textwrap.dedent("""
+    # Vectors taken from http://info.isl.ntt.co.jp/crypt/eng/camellia/
+    # Download is t_camelia.txt
+
+    # Camellia with 128-bit key
+
+    K No.001 : 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+
+    P No.001 : 80 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+    C No.001 : 07 92 3A 39 EB 0A 81 7D 1C 4D 87 BD B8 2D 1F 1C
+
+    P No.002 : 40 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+    C No.002 : 48 CD 64 19 80 96 72 D2 34 92 60 D8 9A 08 D3 D3
+
+    K No.002 : 10 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+
+    P No.001 : 80 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+    C No.001 : 07 92 3A 39 EB 0A 81 7D 1C 4D 87 BD B8 2D 1F 1C
+    """).splitlines()
+
+    assert load_cryptrec_vectors(vector_data) == [
+        {
+            "key": b"00000000000000000000000000000000",
+            "plaintext": b"80000000000000000000000000000000",
+            "ciphertext": b"07923A39EB0A817D1C4D87BDB82D1F1C",
+        },
+        {
+            "key": b"00000000000000000000000000000000",
+            "plaintext": b"40000000000000000000000000000000",
+            "ciphertext": b"48CD6419809672D2349260D89A08D3D3",
+        },
+        {
+            "key": b"10000000000000000000000000000000",
+            "plaintext": b"80000000000000000000000000000000",
+            "ciphertext": b"07923A39EB0A817D1C4D87BDB82D1F1C",
+        },
+    ]
+
+
+def test_load_cryptrec_vectors_invalid():
+    vector_data = textwrap.dedent("""
+    # Vectors taken from http://info.isl.ntt.co.jp/crypt/eng/camellia/
+    # Download is t_camelia.txt
+
+    # Camellia with 128-bit key
+
+    E No.001 : 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+    """).splitlines()
+
+    with pytest.raises(ValueError):
+        load_cryptrec_vectors(vector_data)
+
+
+def test_load_hash_vectors():
+    vector_data = textwrap.dedent("""
+
+        # http://tools.ietf.org/html/rfc1321
+        [irrelevant]
+
+        Len = 0
+        Msg = 00
+        MD = d41d8cd98f00b204e9800998ecf8427e
+
+        Len = 8
+        Msg = 61
+        MD = 0cc175b9c0f1b6a831c399e269772661
+
+        Len = 24
+        Msg = 616263
+        MD = 900150983cd24fb0d6963f7d28e17f72
+
+        Len = 112
+        Msg = 6d65737361676520646967657374
+        MD = f96b697d7cb7938d525a2f31aaf161d0
+    """).splitlines()
+    assert load_hash_vectors(vector_data) == [
+        (b"", "d41d8cd98f00b204e9800998ecf8427e"),
+        (b"61", "0cc175b9c0f1b6a831c399e269772661"),
+        (b"616263", "900150983cd24fb0d6963f7d28e17f72"),
+        (b"6d65737361676520646967657374", "f96b697d7cb7938d525a2f31aaf161d0"),
+    ]
+
+
+def test_load_hmac_vectors():
+    vector_data = textwrap.dedent("""
+Len = 224
+# "Jefe"
+Key = 4a656665
+# "what do ya want for nothing?"
+Msg = 7768617420646f2079612077616e7420666f72206e6f7468696e673f
+MD = 750c783e6ab0b503eaa86e310a5db738
+    """).splitlines()
+    assert load_hash_vectors(vector_data) == [
+        (b"7768617420646f2079612077616e7420666f72206e6f7468696e673f",
+         "750c783e6ab0b503eaa86e310a5db738",
+         b"4a656665"),
+    ]
+
+
+def test_load_hash_vectors_bad_data():
+    vector_data = textwrap.dedent("""
+        # http://tools.ietf.org/html/rfc1321
+
+        Len = 0
+        Msg = 00
+        UNKNOWN=Hello World
+    """).splitlines()
+    with pytest.raises(ValueError):
+        load_hash_vectors(vector_data)
+
+
+def test_load_vectors_from_file():
+    vectors = load_vectors_from_file(
+        os.path.join("ciphers", "Blowfish", "bf-cfb.txt"),
+        load_nist_vectors,
+    )
+    assert vectors == [
+        {
+            "key": b"0123456789ABCDEFF0E1D2C3B4A59687",
+            "iv": b"FEDCBA9876543210",
+            "plaintext": (
+                b"37363534333231204E6F77206973207468652074696D6520666F722000"
+            ),
+            "ciphertext": (
+                b"E73214A2822139CAF26ECF6D2EB9E76E3DA3DE04D1517200519D57A6C3"
+            ),
+        }
+    ]
+
+
+def test_load_nist_gcm_vectors():
+    vector_data = textwrap.dedent("""
+        [Keylen = 128]
+        [IVlen = 96]
+        [PTlen = 0]
+        [AADlen = 0]
+        [Taglen = 128]
+
+        Count = 0
+        Key = 11754cd72aec309bf52f7687212e8957
+        IV = 3c819d9a9bed087615030b65
+        PT =
+        AAD =
+        CT =
+        Tag = 250327c674aaf477aef2675748cf6971
+
+        Count = 1
+        Key = 272f16edb81a7abbea887357a58c1917
+        IV = 794ec588176c703d3d2a7a07
+        PT =
+        AAD =
+        CT =
+        Tag = b6e6f197168f5049aeda32dafbdaeb
+
+        Count = 2
+        Key = a49a5e26a2f8cb63d05546c2a62f5343
+        IV = 907763b19b9b4ab6bd4f0281
+        CT =
+        AAD =
+        Tag = a2be08210d8c470a8df6e8fbd79ec5cf
+        FAIL
+
+        Count = 3
+        Key = 5c1155084cc0ede76b3bc22e9f7574ef
+        IV = 9549e4ba69a61cad7856efc1
+        PT = d1448fa852b84408e2dad8381f363de7
+        AAD = e98e9d9c618e46fef32660976f854ee3
+        CT = f78b60ca125218493bea1c50a2e12ef4
+        Tag = d72da7f5c6cf0bca7242c71835809449
+
+        [Keylen = 128]
+        [IVlen = 96]
+        [PTlen = 0]
+        [AADlen = 0]
+        [Taglen = 120]
+
+        Count = 0
+        Key = eac258e99c55e6ae8ef1da26640613d7
+        IV = 4e8df20faaf2c8eebe922902
+        CT =
+        AAD =
+        Tag = e39aeaebe86aa309a4d062d6274339
+        PT =
+
+        Count = 1
+        Key = 3726cf02fcc6b8639a5497652c94350d
+        IV = 55fef82cde693ce76efcc193
+        CT =
+        AAD =
+        Tag = 3d68111a81ed22d2ef5bccac4fc27f
+        FAIL
+
+        Count = 2
+        Key = f202299d5fd74f03b12d2119a6c4c038
+        IV = eec51e7958c3f20a1bb71815
+        CT =
+        AAD =
+        Tag = a81886b3fb26e51fca87b267e1e157
+        FAIL
+
+        Count = 3
+        Key = fd52925f39546b4c55ffb6b20c59898c
+        IV = f5cf3227444afd905a5f6dba
+        CT =
+        AAD =
+        Tag = 1665b0f1a0b456e1664cfd3de08ccd
+        PT =
+
+        [Keylen = 128]
+        [IVlen = 8]
+        [PTlen = 104]
+        [AADlen = 0]
+        [Taglen = 128]
+
+        Count = 0
+        Key = 58fab7632bcf10d2bcee58520bf37414
+        IV = 3c
+        CT = 15c4db4cbb451211179d57017f
+        AAD =
+        Tag = eae841d4355feeb3f786bc86625f1e5b
+        FAIL
+    """).splitlines()
+    assert load_nist_vectors(vector_data) == [
+        {'aad': b'',
+         'pt': b'',
+         'iv': b'3c819d9a9bed087615030b65',
+         'tag': b'250327c674aaf477aef2675748cf6971',
+         'key': b'11754cd72aec309bf52f7687212e8957',
+         'ct': b''},
+        {'aad': b'',
+         'pt': b'',
+         'iv': b'794ec588176c703d3d2a7a07',
+         'tag': b'b6e6f197168f5049aeda32dafbdaeb',
+         'key': b'272f16edb81a7abbea887357a58c1917',
+         'ct': b''},
+        {'aad': b'',
+         'iv': b'907763b19b9b4ab6bd4f0281',
+         'tag': b'a2be08210d8c470a8df6e8fbd79ec5cf',
+         'key': b'a49a5e26a2f8cb63d05546c2a62f5343',
+         'ct': b'',
+         'fail': True},
+        {'aad': b'e98e9d9c618e46fef32660976f854ee3',
+         'pt': b'd1448fa852b84408e2dad8381f363de7',
+         'iv': b'9549e4ba69a61cad7856efc1',
+         'tag': b'd72da7f5c6cf0bca7242c71835809449',
+         'key': b'5c1155084cc0ede76b3bc22e9f7574ef',
+         'ct': b'f78b60ca125218493bea1c50a2e12ef4'},
+        {'aad': b'',
+         'pt': b'',
+         'iv': b'4e8df20faaf2c8eebe922902',
+         'tag': b'e39aeaebe86aa309a4d062d6274339',
+         'key': b'eac258e99c55e6ae8ef1da26640613d7',
+         'ct': b''},
+        {'aad': b'',
+         'iv': b'55fef82cde693ce76efcc193',
+         'tag': b'3d68111a81ed22d2ef5bccac4fc27f',
+         'key': b'3726cf02fcc6b8639a5497652c94350d',
+         'ct': b'',
+         'fail': True},
+        {'aad': b'',
+         'iv': b'eec51e7958c3f20a1bb71815',
+         'tag': b'a81886b3fb26e51fca87b267e1e157',
+         'key': b'f202299d5fd74f03b12d2119a6c4c038',
+         'ct': b'',
+         'fail': True},
+        {'aad': b'',
+         'pt': b'',
+         'iv': b'f5cf3227444afd905a5f6dba',
+         'tag': b'1665b0f1a0b456e1664cfd3de08ccd',
+         'key': b'fd52925f39546b4c55ffb6b20c59898c',
+         'ct': b''},
+        {'aad': b'',
+         'iv': b'3c',
+         'tag': b'eae841d4355feeb3f786bc86625f1e5b',
+         'key': b'58fab7632bcf10d2bcee58520bf37414',
+         'ct': b'15c4db4cbb451211179d57017f',
+         'fail': True},
+    ]
+
+
+def test_load_pkcs1_vectors():
+    vector_data = textwrap.dedent("""
+    Test vectors for RSA-PSS
+    ========================
+
+    This file contains an extract of the original pss-vect.txt
+
+    Key lengths:
+
+    Key  8: 1031 bits
+    Key  9: 1536 bits
+    ===========================================================================
+
+    <snip>
+
+    # Example 8: A 1031-bit RSA key pair
+    # -----------------------------------
+
+
+    # Public key
+    # ----------
+
+    # Modulus:
+    49 53 70 a1 fb 18 54 3c 16 d3 63 1e 31 63 25 5d
+    f6 2b e6 ee e8 90 d5 f2 55 09 e4 f7 78 a8 ea 6f
+    bb bc df 85 df f6 4e 0d 97 20 03 ab 36 81 fb ba
+    6d d4 1f d5 41 82 9b 2e 58 2d e9 f2 a4 a4 e0 a2
+    d0 90 0b ef 47 53 db 3c ee 0e e0 6c 7d fa e8 b1
+    d5 3b 59 53 21 8f 9c ce ea 69 5b 08 66 8e de aa
+    dc ed 94 63 b1 d7 90 d5 eb f2 7e 91 15 b4 6c ad
+    4d 9a 2b 8e fa b0 56 1b 08 10 34 47 39 ad a0 73
+    3f
+
+    # Exponent:
+    01 00 01
+
+    # Private key
+    # -----------
+
+    # Modulus:
+    49 53 70 a1 fb 18 54 3c 16 d3 63 1e 31 63 25 5d
+    f6 2b e6 ee e8 90 d5 f2 55 09 e4 f7 78 a8 ea 6f
+    bb bc df 85 df f6 4e 0d 97 20 03 ab 36 81 fb ba
+    6d d4 1f d5 41 82 9b 2e 58 2d e9 f2 a4 a4 e0 a2
+    d0 90 0b ef 47 53 db 3c ee 0e e0 6c 7d fa e8 b1
+    d5 3b 59 53 21 8f 9c ce ea 69 5b 08 66 8e de aa
+    dc ed 94 63 b1 d7 90 d5 eb f2 7e 91 15 b4 6c ad
+    4d 9a 2b 8e fa b0 56 1b 08 10 34 47 39 ad a0 73
+    3f
+
+    # Public exponent:
+    01 00 01
+
+    # Exponent:
+    6c 66 ff e9 89 80 c3 8f cd ea b5 15 98 98 83 61
+    65 f4 b4 b8 17 c4 f6 a8 d4 86 ee 4e a9 13 0f e9
+    b9 09 2b d1 36 d1 84 f9 5f 50 4a 60 7e ac 56 58
+    46 d2 fd d6 59 7a 89 67 c7 39 6e f9 5a 6e ee bb
+    45 78 a6 43 96 6d ca 4d 8e e3 de 84 2d e6 32 79
+    c6 18 15 9c 1a b5 4a 89 43 7b 6a 61 20 e4 93 0a
+    fb 52 a4 ba 6c ed 8a 49 47 ac 64 b3 0a 34 97 cb
+    e7 01 c2 d6 26 6d 51 72 19 ad 0e c6 d3 47 db e9
+
+    # Prime 1:
+    08 da d7 f1 13 63 fa a6 23 d5 d6 d5 e8 a3 19 32
+    8d 82 19 0d 71 27 d2 84 6c 43 9b 0a b7 26 19 b0
+    a4 3a 95 32 0e 4e c3 4f c3 a9 ce a8 76 42 23 05
+    bd 76 c5 ba 7b e9 e2 f4 10 c8 06 06 45 a1 d2 9e
+    db
+
+    # Prime 2:
+    08 47 e7 32 37 6f c7 90 0f 89 8e a8 2e b2 b0 fc
+    41 85 65 fd ae 62 f7 d9 ec 4c e2 21 7b 97 99 0d
+    d2 72 db 15 7f 99 f6 3c 0d cb b9 fb ac db d4 c4
+    da db 6d f6 77 56 35 8c a4 17 48 25 b4 8f 49 70
+    6d
+
+    # Prime exponent 1:
+    05 c2 a8 3c 12 4b 36 21 a2 aa 57 ea 2c 3e fe 03
+    5e ff 45 60 f3 3d de bb 7a da b8 1f ce 69 a0 c8
+    c2 ed c1 65 20 dd a8 3d 59 a2 3b e8 67 96 3a c6
+    5f 2c c7 10 bb cf b9 6e e1 03 de b7 71 d1 05 fd
+    85
+
+    # Prime exponent 2:
+    04 ca e8 aa 0d 9f aa 16 5c 87 b6 82 ec 14 0b 8e
+    d3 b5 0b 24 59 4b 7a 3b 2c 22 0b 36 69 bb 81 9f
+    98 4f 55 31 0a 1a e7 82 36 51 d4 a0 2e 99 44 79
+    72 59 51 39 36 34 34 e5 e3 0a 7e 7d 24 15 51 e1
+    b9
+
+    # Coefficient:
+    07 d3 e4 7b f6 86 60 0b 11 ac 28 3c e8 8d bb 3f
+    60 51 e8 ef d0 46 80 e4 4c 17 1e f5 31 b8 0b 2b
+    7c 39 fc 76 63 20 e2 cf 15 d8 d9 98 20 e9 6f f3
+    0d c6 96 91 83 9c 4b 40 d7 b0 6e 45 30 7d c9 1f
+    3f
+
+    # RSA-PSS signing of 6 random messages with random salts
+    # -------------------------------------------------------
+    # PSS Example 8.1
+
+    # -----------------
+
+    # Message to be signed:
+    81 33 2f 4b e6 29 48 41 5e a1 d8 99 79 2e ea cf
+    6c 6e 1d b1 da 8b e1 3b 5c ea 41 db 2f ed 46 70
+    92 e1 ff 39 89 14 c7 14 25 97 75 f5 95 f8 54 7f
+    73 56 92 a5 75 e6 92 3a f7 8f 22 c6 99 7d db 90
+    fb 6f 72 d7 bb 0d d5 74 4a 31 de cd 3d c3 68 58
+    49 83 6e d3 4a ec 59 63 04 ad 11 84 3c 4f 88 48
+    9f 20 97 35 f5 fb 7f da f7 ce c8 ad dc 58 18 16
+    8f 88 0a cb f4 90 d5 10 05 b7 a8 e8 4e 43 e5 42
+    87 97 75 71 dd 99 ee a4 b1 61 eb 2d f1 f5 10 8f
+    12 a4 14 2a 83 32 2e db 05 a7 54 87 a3 43 5c 9a
+    78 ce 53 ed 93 bc 55 08 57 d7 a9 fb
+
+    # Salt:
+    1d 65 49 1d 79 c8 64 b3 73 00 9b e6 f6 f2 46 7b
+    ac 4c 78 fa
+
+    # Signature:
+    02 62 ac 25 4b fa 77 f3 c1 ac a2 2c 51 79 f8 f0
+    40 42 2b 3c 5b af d4 0a 8f 21 cf 0f a5 a6 67 cc
+    d5 99 3d 42 db af b4 09 c5 20 e2 5f ce 2b 1e e1
+    e7 16 57 7f 1e fa 17 f3 da 28 05 2f 40 f0 41 9b
+    23 10 6d 78 45 aa f0 11 25 b6 98 e7 a4 df e9 2d
+    39 67 bb 00 c4 d0 d3 5b a3 55 2a b9 a8 b3 ee f0
+    7c 7f ec db c5 42 4a c4 db 1e 20 cb 37 d0 b2 74
+    47 69 94 0e a9 07 e1 7f bb ca 67 3b 20 52 23 80
+    c5
+
+    # PSS Example 8.2
+
+    # -----------------
+
+    # Message to be signed:
+    e2 f9 6e af 0e 05 e7 ba 32 6e cc a0 ba 7f d2 f7
+    c0 23 56 f3 ce de 9d 0f aa bf 4f cc 8e 60 a9 73
+    e5 59 5f d9 ea 08
+
+    # Salt:
+    43 5c 09 8a a9 90 9e b2 37 7f 12 48 b0 91 b6 89
+    87 ff 18 38
+
+    # Signature:
+    27 07 b9 ad 51 15 c5 8c 94 e9 32 e8 ec 0a 28 0f
+    56 33 9e 44 a1 b5 8d 4d dc ff 2f 31 2e 5f 34 dc
+    fe 39 e8 9c 6a 94 dc ee 86 db bd ae 5b 79 ba 4e
+    08 19 a9 e7 bf d9 d9 82 e7 ee 6c 86 ee 68 39 6e
+    8b 3a 14 c9 c8 f3 4b 17 8e b7 41 f9 d3 f1 21 10
+    9b f5 c8 17 2f ad a2 e7 68 f9 ea 14 33 03 2c 00
+    4a 8a a0 7e b9 90 00 0a 48 dc 94 c8 ba c8 aa be
+    2b 09 b1 aa 46 c0 a2 aa 0e 12 f6 3f bb a7 75 ba
+    7e
+
+    # <snip>
+
+    # =============================================
+
+    # Example 9: A 1536-bit RSA key pair
+    # -----------------------------------
+
+
+    # Public key
+    # ----------
+
+    # Modulus:
+    e6 bd 69 2a c9 66 45 79 04 03 fd d0 f5 be b8 b9
+    bf 92 ed 10 00 7f c3 65 04 64 19 dd 06 c0 5c 5b
+    5b 2f 48 ec f9 89 e4 ce 26 91 09 97 9c bb 40 b4
+    a0 ad 24 d2 24 83 d1 ee 31 5a d4 cc b1 53 42 68
+    35 26 91 c5 24 f6 dd 8e 6c 29 d2 24 cf 24 69 73
+    ae c8 6c 5b f6 b1 40 1a 85 0d 1b 9a d1 bb 8c bc
+    ec 47 b0 6f 0f 8c 7f 45 d3 fc 8f 31 92 99 c5 43
+    3d db c2 b3 05 3b 47 de d2 ec d4 a4 ca ef d6 14
+    83 3d c8 bb 62 2f 31 7e d0 76 b8 05 7f e8 de 3f
+    84 48 0a d5 e8 3e 4a 61 90 4a 4f 24 8f b3 97 02
+    73 57 e1 d3 0e 46 31 39 81 5c 6f d4 fd 5a c5 b8
+    17 2a 45 23 0e cb 63 18 a0 4f 14 55 d8 4e 5a 8b
+
+    # Exponent:
+    01 00 01
+
+    # Private key
+    # -----------
+
+    # Modulus:
+    e6 bd 69 2a c9 66 45 79 04 03 fd d0 f5 be b8 b9
+    bf 92 ed 10 00 7f c3 65 04 64 19 dd 06 c0 5c 5b
+    5b 2f 48 ec f9 89 e4 ce 26 91 09 97 9c bb 40 b4
+    a0 ad 24 d2 24 83 d1 ee 31 5a d4 cc b1 53 42 68
+    35 26 91 c5 24 f6 dd 8e 6c 29 d2 24 cf 24 69 73
+    ae c8 6c 5b f6 b1 40 1a 85 0d 1b 9a d1 bb 8c bc
+    ec 47 b0 6f 0f 8c 7f 45 d3 fc 8f 31 92 99 c5 43
+    3d db c2 b3 05 3b 47 de d2 ec d4 a4 ca ef d6 14
+    83 3d c8 bb 62 2f 31 7e d0 76 b8 05 7f e8 de 3f
+    84 48 0a d5 e8 3e 4a 61 90 4a 4f 24 8f b3 97 02
+    73 57 e1 d3 0e 46 31 39 81 5c 6f d4 fd 5a c5 b8
+    17 2a 45 23 0e cb 63 18 a0 4f 14 55 d8 4e 5a 8b
+
+    # Public exponent:
+    01 00 01
+
+    # Exponent:
+    6a 7f d8 4f b8 5f ad 07 3b 34 40 6d b7 4f 8d 61
+    a6 ab c1 21 96 a9 61 dd 79 56 5e 9d a6 e5 18 7b
+    ce 2d 98 02 50 f7 35 95 75 35 92 70 d9 15 90 bb
+    0e 42 7c 71 46 0b 55 d5 14 10 b1 91 bc f3 09 fe
+    a1 31 a9 2c 8e 70 27 38 fa 71 9f 1e 00 41 f5 2e
+    40 e9 1f 22 9f 4d 96 a1 e6 f1 72 e1 55 96 b4 51
+    0a 6d ae c2 61 05 f2 be bc 53 31 6b 87 bd f2 13
+    11 66 60 70 e8 df ee 69 d5 2c 71 a9 76 ca ae 79
+    c7 2b 68 d2 85 80 dc 68 6d 9f 51 29 d2 25 f8 2b
+    3d 61 55 13 a8 82 b3 db 91 41 6b 48 ce 08 88 82
+    13 e3 7e eb 9a f8 00 d8 1c ab 32 8c e4 20 68 99
+    03 c0 0c 7b 5f d3 1b 75 50 3a 6d 41 96 84 d6 29
+
+    # Prime 1:
+    f8 eb 97 e9 8d f1 26 64 ee fd b7 61 59 6a 69 dd
+    cd 0e 76 da ec e6 ed 4b f5 a1 b5 0a c0 86 f7 92
+    8a 4d 2f 87 26 a7 7e 51 5b 74 da 41 98 8f 22 0b
+    1c c8 7a a1 fc 81 0c e9 9a 82 f2 d1 ce 82 1e dc
+    ed 79 4c 69 41 f4 2c 7a 1a 0b 8c 4d 28 c7 5e c6
+    0b 65 22 79 f6 15 4a 76 2a ed 16 5d 47 de e3 67
+
+    # Prime 2:
+    ed 4d 71 d0 a6 e2 4b 93 c2 e5 f6 b4 bb e0 5f 5f
+    b0 af a0 42 d2 04 fe 33 78 d3 65 c2 f2 88 b6 a8
+    da d7 ef e4 5d 15 3e ef 40 ca cc 7b 81 ff 93 40
+    02 d1 08 99 4b 94 a5 e4 72 8c d9 c9 63 37 5a e4
+    99 65 bd a5 5c bf 0e fe d8 d6 55 3b 40 27 f2 d8
+    62 08 a6 e6 b4 89 c1 76 12 80 92 d6 29 e4 9d 3d
+
+    # Prime exponent 1:
+    2b b6 8b dd fb 0c 4f 56 c8 55 8b ff af 89 2d 80
+    43 03 78 41 e7 fa 81 cf a6 1a 38 c5 e3 9b 90 1c
+    8e e7 11 22 a5 da 22 27 bd 6c de eb 48 14 52 c1
+    2a d3 d6 1d 5e 4f 77 6a 0a b5 56 59 1b ef e3 e5
+    9e 5a 7f dd b8 34 5e 1f 2f 35 b9 f4 ce e5 7c 32
+    41 4c 08 6a ec 99 3e 93 53 e4 80 d9 ee c6 28 9f
+
+    # Prime exponent 2:
+    4f f8 97 70 9f ad 07 97 46 49 45 78 e7 0f d8 54
+    61 30 ee ab 56 27 c4 9b 08 0f 05 ee 4a d9 f3 e4
+    b7 cb a9 d6 a5 df f1 13 a4 1c 34 09 33 68 33 f1
+    90 81 6d 8a 6b c4 2e 9b ec 56 b7 56 7d 0f 3c 9c
+    69 6d b6 19 b2 45 d9 01 dd 85 6d b7 c8 09 2e 77
+    e9 a1 cc cd 56 ee 4d ba 42 c5 fd b6 1a ec 26 69
+
+    # Coefficient:
+    77 b9 d1 13 7b 50 40 4a 98 27 29 31 6e fa fc 7d
+    fe 66 d3 4e 5a 18 26 00 d5 f3 0a 0a 85 12 05 1c
+    56 0d 08 1d 4d 0a 18 35 ec 3d 25 a6 0f 4e 4d 6a
+    a9 48 b2 bf 3d bb 5b 12 4c bb c3 48 92 55 a3 a9
+    48 37 2f 69 78 49 67 45 f9 43 e1 db 4f 18 38 2c
+    ea a5 05 df c6 57 57 bb 3f 85 7a 58 dc e5 21 56
+
+    # PKCS#1 v1.5 Signature Example 2.17
+
+    # -----------------
+
+    # Message to be signed:
+    06 ad d7 5a b6 89 de 06 77 44 e6 9a 2e bd 4b 90
+    fa 93 83 00 3c d0 5f f5 36 cb f2 94 cd 21 5f 09
+    23 b7 fc 90 04 f0 aa 18 52 71 a1 d0 06 1f d0 e9
+    77 7a d1 ec 0c 71 59 1f 57 8b f7 b8 e5 a1
+
+    # Signature:
+    45 14 21 0e 54 1d 5b ad 7d d6 0a e5 49 b9 43 ac
+    c4 4f 21 39 0d f5 b6 13 18 45 5a 17 61 0d f5 b7
+    4d 84 ae d2 32 f1 7e 59 d9 1d d2 65 99 22 f8 12
+    db d4 96 81 69 03 84 b9 54 e9 ad fb 9b 1a 96 8c
+    0c bf f7 63 ec ee d6 27 50 c5 91 64 b5 e0 80 a8
+    fe f3 d5 5b fe 2a cf ad 27 52 a6 a8 45 9f a1 fa
+    b4 9a d3 78 c6 96 4b 23 ee 97 fd 10 34 61 0c 5c
+    c1 4c 61 e0 eb fb 17 11 f8 ad e9 6f e6 55 7b 38
+
+    # <snip>
+
+    # =============================================
+
+    # <snip>
+    """).splitlines()
+
+    vectors = tuple(load_pkcs1_vectors(vector_data))
+    expected = (
+        (
+            {
+                'modulus': int(
+                    '495370a1fb18543c16d3631e3163255df62be6eee890d5f25509e4f77'
+                    '8a8ea6fbbbcdf85dff64e0d972003ab3681fbba6dd41fd541829b2e58'
+                    '2de9f2a4a4e0a2d0900bef4753db3cee0ee06c7dfae8b1d53b5953218'
+                    'f9cceea695b08668edeaadced9463b1d790d5ebf27e9115b46cad4d9a'
+                    '2b8efab0561b0810344739ada0733f', 16),
+                'public_exponent': int('10001', 16),
+                'private_exponent': int(
+                    '6c66ffe98980c38fcdeab5159898836165f4b4b817c4f6a8d486ee4ea'
+                    '9130fe9b9092bd136d184f95f504a607eac565846d2fdd6597a8967c7'
+                    '396ef95a6eeebb4578a643966dca4d8ee3de842de63279c618159c1ab'
+                    '54a89437b6a6120e4930afb52a4ba6ced8a4947ac64b30a3497cbe701'
+                    'c2d6266d517219ad0ec6d347dbe9', 16),
+                'p': int(
+                    '8dad7f11363faa623d5d6d5e8a319328d82190d7127d2846c439b0ab7'
+                    '2619b0a43a95320e4ec34fc3a9cea876422305bd76c5ba7be9e2f410c'
+                    '8060645a1d29edb', 16),
+                'q': int(
+                    '847e732376fc7900f898ea82eb2b0fc418565fdae62f7d9ec4ce2217b'
+                    '97990dd272db157f99f63c0dcbb9fbacdbd4c4dadb6df67756358ca41'
+                    '74825b48f49706d', 16),
+                'dmp1': int(
+                    '05c2a83c124b3621a2aa57ea2c3efe035eff4560f33ddebb7adab81fc'
+                    'e69a0c8c2edc16520dda83d59a23be867963ac65f2cc710bbcfb96ee1'
+                    '03deb771d105fd85', 16),
+                'dmq1': int(
+                    '04cae8aa0d9faa165c87b682ec140b8ed3b50b24594b7a3b2c220b366'
+                    '9bb819f984f55310a1ae7823651d4a02e99447972595139363434e5e3'
+                    '0a7e7d241551e1b9', 16),
+                'iqmp': int(
+                    '07d3e47bf686600b11ac283ce88dbb3f6051e8efd04680e44c171ef53'
+                    '1b80b2b7c39fc766320e2cf15d8d99820e96ff30dc69691839c4b40d7'
+                    'b06e45307dc91f3f', 16),
+                'examples': [
+                    {
+                        'message': b'81332f4be62948415ea1d899792eeacf6c6e1db1d'
+                                   b'a8be13b5cea41db2fed467092e1ff398914c71425'
+                                   b'9775f595f8547f735692a575e6923af78f22c6997'
+                                   b'ddb90fb6f72d7bb0dd5744a31decd3dc368584983'
+                                   b'6ed34aec596304ad11843c4f88489f209735f5fb7'
+                                   b'fdaf7cec8addc5818168f880acbf490d51005b7a8'
+                                   b'e84e43e54287977571dd99eea4b161eb2df1f5108'
+                                   b'f12a4142a83322edb05a75487a3435c9a78ce53ed'
+                                   b'93bc550857d7a9fb',
+                        'salt': b'1d65491d79c864b373009be6f6f2467bac4c78fa',
+                        'signature': b'0262ac254bfa77f3c1aca22c5179f8f040422b3'
+                                     b'c5bafd40a8f21cf0fa5a667ccd5993d42dbafb4'
+                                     b'09c520e25fce2b1ee1e716577f1efa17f3da280'
+                                     b'52f40f0419b23106d7845aaf01125b698e7a4df'
+                                     b'e92d3967bb00c4d0d35ba3552ab9a8b3eef07c7'
+                                     b'fecdbc5424ac4db1e20cb37d0b2744769940ea9'
+                                     b'07e17fbbca673b20522380c5'
+                    }, {
+                        'message': b'e2f96eaf0e05e7ba326ecca0ba7fd2f7c02356f3c'
+                                   b'ede9d0faabf4fcc8e60a973e5595fd9ea08',
+                        'salt': b'435c098aa9909eb2377f1248b091b68987ff1838',
+                        'signature': b'2707b9ad5115c58c94e932e8ec0a280f56339e4'
+                                     b'4a1b58d4ddcff2f312e5f34dcfe39e89c6a94dc'
+                                     b'ee86dbbdae5b79ba4e0819a9e7bfd9d982e7ee6'
+                                     b'c86ee68396e8b3a14c9c8f34b178eb741f9d3f1'
+                                     b'21109bf5c8172fada2e768f9ea1433032c004a8'
+                                     b'aa07eb990000a48dc94c8bac8aabe2b09b1aa46'
+                                     b'c0a2aa0e12f63fbba775ba7e'
+                    }
+                ]
+            },
+
+            {
+                'modulus': int(
+                    '495370a1fb18543c16d3631e3163255df62be6eee890d5f25509e4f77'
+                    '8a8ea6fbbbcdf85dff64e0d972003ab3681fbba6dd41fd541829b2e58'
+                    '2de9f2a4a4e0a2d0900bef4753db3cee0ee06c7dfae8b1d53b5953218'
+                    'f9cceea695b08668edeaadced9463b1d790d5ebf27e9115b46cad4d9a'
+                    '2b8efab0561b0810344739ada0733f', 16),
+                'public_exponent': int('10001', 16)
+            }
+        ),
+        (
+            {
+                'modulus': int(
+                    'e6bd692ac96645790403fdd0f5beb8b9bf92ed10007fc365046419dd0'
+                    '6c05c5b5b2f48ecf989e4ce269109979cbb40b4a0ad24d22483d1ee31'
+                    '5ad4ccb1534268352691c524f6dd8e6c29d224cf246973aec86c5bf6b'
+                    '1401a850d1b9ad1bb8cbcec47b06f0f8c7f45d3fc8f319299c5433ddb'
+                    'c2b3053b47ded2ecd4a4caefd614833dc8bb622f317ed076b8057fe8d'
+                    'e3f84480ad5e83e4a61904a4f248fb397027357e1d30e463139815c6f'
+                    'd4fd5ac5b8172a45230ecb6318a04f1455d84e5a8b', 16),
+                'public_exponent': int('10001', 16),
+                'private_exponent': int(
+                    '6a7fd84fb85fad073b34406db74f8d61a6abc12196a961dd79565e9da'
+                    '6e5187bce2d980250f7359575359270d91590bb0e427c71460b55d514'
+                    '10b191bcf309fea131a92c8e702738fa719f1e0041f52e40e91f229f4'
+                    'd96a1e6f172e15596b4510a6daec26105f2bebc53316b87bdf2131166'
+                    '6070e8dfee69d52c71a976caae79c72b68d28580dc686d9f5129d225f'
+                    '82b3d615513a882b3db91416b48ce08888213e37eeb9af800d81cab32'
+                    '8ce420689903c00c7b5fd31b75503a6d419684d629', 16),
+                'p': int(
+                    'f8eb97e98df12664eefdb761596a69ddcd0e76daece6ed4bf5a1b50ac'
+                    '086f7928a4d2f8726a77e515b74da41988f220b1cc87aa1fc810ce99a'
+                    '82f2d1ce821edced794c6941f42c7a1a0b8c4d28c75ec60b652279f61'
+                    '54a762aed165d47dee367', 16),
+                'q': int(
+                    'ed4d71d0a6e24b93c2e5f6b4bbe05f5fb0afa042d204fe3378d365c2f'
+                    '288b6a8dad7efe45d153eef40cacc7b81ff934002d108994b94a5e472'
+                    '8cd9c963375ae49965bda55cbf0efed8d6553b4027f2d86208a6e6b48'
+                    '9c176128092d629e49d3d', 16),
+                'dmp1': int(
+                    '2bb68bddfb0c4f56c8558bffaf892d8043037841e7fa81cfa61a38c5e'
+                    '39b901c8ee71122a5da2227bd6cdeeb481452c12ad3d61d5e4f776a0a'
+                    'b556591befe3e59e5a7fddb8345e1f2f35b9f4cee57c32414c086aec9'
+                    '93e9353e480d9eec6289f', 16),
+                'dmq1': int(
+                    '4ff897709fad079746494578e70fd8546130eeab5627c49b080f05ee4'
+                    'ad9f3e4b7cba9d6a5dff113a41c3409336833f190816d8a6bc42e9bec'
+                    '56b7567d0f3c9c696db619b245d901dd856db7c8092e77e9a1cccd56e'
+                    'e4dba42c5fdb61aec2669', 16),
+                'iqmp': int(
+                    '77b9d1137b50404a982729316efafc7dfe66d34e5a182600d5f30a0a8'
+                    '512051c560d081d4d0a1835ec3d25a60f4e4d6aa948b2bf3dbb5b124c'
+                    'bbc3489255a3a948372f6978496745f943e1db4f18382ceaa505dfc65'
+                    '757bb3f857a58dce52156', 16),
+                'examples': [
+                    {
+                        'message': b'06add75ab689de067744e69a2ebd4b90fa9383003'
+                                   b'cd05ff536cbf294cd215f0923b7fc9004f0aa1852'
+                                   b'71a1d0061fd0e9777ad1ec0c71591f578bf7b8e5a'
+                                   b'1',
+                        'signature': b'4514210e541d5bad7dd60ae549b943acc44f213'
+                                     b'90df5b61318455a17610df5b74d84aed232f17e'
+                                     b'59d91dd2659922f812dbd49681690384b954e9a'
+                                     b'dfb9b1a968c0cbff763eceed62750c59164b5e0'
+                                     b'80a8fef3d55bfe2acfad2752a6a8459fa1fab49'
+                                     b'ad378c6964b23ee97fd1034610c5cc14c61e0eb'
+                                     b'fb1711f8ade96fe6557b38'
+                    }
+                ]
+            },
+
+            {
+                'modulus': int(
+                    'e6bd692ac96645790403fdd0f5beb8b9bf92ed10007fc365046419dd0'
+                    '6c05c5b5b2f48ecf989e4ce269109979cbb40b4a0ad24d22483d1ee31'
+                    '5ad4ccb1534268352691c524f6dd8e6c29d224cf246973aec86c5bf6b'
+                    '1401a850d1b9ad1bb8cbcec47b06f0f8c7f45d3fc8f319299c5433ddb'
+                    'c2b3053b47ded2ecd4a4caefd614833dc8bb622f317ed076b8057fe8d'
+                    'e3f84480ad5e83e4a61904a4f248fb397027357e1d30e463139815c6f'
+                    'd4fd5ac5b8172a45230ecb6318a04f1455d84e5a8b', 16),
+                'public_exponent': int('10001', 16)
+            }
+        )
+    )
+    assert vectors == expected
+
+
+def test_load_pkcs1_oaep_vectors():
+    vector_data = textwrap.dedent("""
+    Test vectors for RSA-OAEP
+    =========================
+
+    This file contains test vectors for the RSA-OAEP encryption
+
+    Key lengths:
+
+    Key  1: 1024 bits
+    # <snip>
+    ===========================================================================
+    # Example 1: A 1024-bit RSA key pair
+    # -----------------------------------
+
+
+    # Public key
+    # ----------
+
+    # Modulus:
+    a8 b3 b2 84 af 8e b5 0b 38 70 34 a8 60 f1 46 c4
+    91 9f 31 87 63 cd 6c 55 98 c8 ae 48 11 a1 e0 ab
+    c4 c7 e0 b0 82 d6 93 a5 e7 fc ed 67 5c f4 66 85
+    12 77 2c 0c bc 64 a7 42 c6 c6 30 f5 33 c8 cc 72
+    f6 2a e8 33 c4 0b f2 58 42 e9 84 bb 78 bd bf 97
+    c0 10 7d 55 bd b6 62 f5 c4 e0 fa b9 84 5c b5 14
+    8e f7 39 2d d3 aa ff 93 ae 1e 6b 66 7b b3 d4 24
+    76 16 d4 f5 ba 10 d4 cf d2 26 de 88 d3 9f 16 fb
+
+    # Exponent:
+    01 00 01
+
+    # Private key
+    # -----------
+
+    # Modulus:
+    a8 b3 b2 84 af 8e b5 0b 38 70 34 a8 60 f1 46 c4
+    91 9f 31 87 63 cd 6c 55 98 c8 ae 48 11 a1 e0 ab
+    c4 c7 e0 b0 82 d6 93 a5 e7 fc ed 67 5c f4 66 85
+    12 77 2c 0c bc 64 a7 42 c6 c6 30 f5 33 c8 cc 72
+    f6 2a e8 33 c4 0b f2 58 42 e9 84 bb 78 bd bf 97
+    c0 10 7d 55 bd b6 62 f5 c4 e0 fa b9 84 5c b5 14
+    8e f7 39 2d d3 aa ff 93 ae 1e 6b 66 7b b3 d4 24
+    76 16 d4 f5 ba 10 d4 cf d2 26 de 88 d3 9f 16 fb
+
+    # Public exponent:
+    01 00 01
+
+    # Exponent:
+    53 33 9c fd b7 9f c8 46 6a 65 5c 73 16 ac a8 5c
+    55 fd 8f 6d d8 98 fd af 11 95 17 ef 4f 52 e8 fd
+    8e 25 8d f9 3f ee 18 0f a0 e4 ab 29 69 3c d8 3b
+    15 2a 55 3d 4a c4 d1 81 2b 8b 9f a5 af 0e 7f 55
+    fe 73 04 df 41 57 09 26 f3 31 1f 15 c4 d6 5a 73
+    2c 48 31 16 ee 3d 3d 2d 0a f3 54 9a d9 bf 7c bf
+    b7 8a d8 84 f8 4d 5b eb 04 72 4d c7 36 9b 31 de
+    f3 7d 0c f5 39 e9 cf cd d3 de 65 37 29 ea d5 d1
+
+    # Prime 1:
+    d3 27 37 e7 26 7f fe 13 41 b2 d5 c0 d1 50 a8 1b
+    58 6f b3 13 2b ed 2f 8d 52 62 86 4a 9c b9 f3 0a
+    f3 8b e4 48 59 8d 41 3a 17 2e fb 80 2c 21 ac f1
+    c1 1c 52 0c 2f 26 a4 71 dc ad 21 2e ac 7c a3 9d
+
+    # Prime 2:
+    cc 88 53 d1 d5 4d a6 30 fa c0 04 f4 71 f2 81 c7
+    b8 98 2d 82 24 a4 90 ed be b3 3d 3e 3d 5c c9 3c
+    47 65 70 3d 1d d7 91 64 2f 1f 11 6a 0d d8 52 be
+    24 19 b2 af 72 bf e9 a0 30 e8 60 b0 28 8b 5d 77
+
+    # Prime exponent 1:
+    0e 12 bf 17 18 e9 ce f5 59 9b a1 c3 88 2f e8 04
+    6a 90 87 4e ef ce 8f 2c cc 20 e4 f2 74 1f b0 a3
+    3a 38 48 ae c9 c9 30 5f be cb d2 d7 68 19 96 7d
+    46 71 ac c6 43 1e 40 37 96 8d b3 78 78 e6 95 c1
+
+    # Prime exponent 2:
+    95 29 7b 0f 95 a2 fa 67 d0 07 07 d6 09 df d4 fc
+    05 c8 9d af c2 ef 6d 6e a5 5b ec 77 1e a3 33 73
+    4d 92 51 e7 90 82 ec da 86 6e fe f1 3c 45 9e 1a
+    63 13 86 b7 e3 54 c8 99 f5 f1 12 ca 85 d7 15 83
+
+    # Coefficient:
+    4f 45 6c 50 24 93 bd c0 ed 2a b7 56 a3 a6 ed 4d
+    67 35 2a 69 7d 42 16 e9 32 12 b1 27 a6 3d 54 11
+    ce 6f a9 8d 5d be fd 73 26 3e 37 28 14 27 43 81
+    81 66 ed 7d d6 36 87 dd 2a 8c a1 d2 f4 fb d8 e1
+
+    # RSA-OAEP encryption of 6 random messages with random seeds
+    # -----------------------------------------------------------
+
+    # OAEP Example 1.1
+    # ------------------
+
+    # Message:
+    66 28 19 4e 12 07 3d b0 3b a9 4c da 9e f9 53 23
+    97 d5 0d ba 79 b9 87 00 4a fe fe 34
+
+    # Seed:
+    18 b7 76 ea 21 06 9d 69 77 6a 33 e9 6b ad 48 e1
+    dd a0 a5 ef
+
+    # Encryption:
+    35 4f e6 7b 4a 12 6d 5d 35 fe 36 c7 77 79 1a 3f
+    7b a1 3d ef 48 4e 2d 39 08 af f7 22 fa d4 68 fb
+    21 69 6d e9 5d 0b e9 11 c2 d3 17 4f 8a fc c2 01
+    03 5f 7b 6d 8e 69 40 2d e5 45 16 18 c2 1a 53 5f
+    a9 d7 bf c5 b8 dd 9f c2 43 f8 cf 92 7d b3 13 22
+    d6 e8 81 ea a9 1a 99 61 70 e6 57 a0 5a 26 64 26
+    d9 8c 88 00 3f 84 77 c1 22 70 94 a0 d9 fa 1e 8c
+    40 24 30 9c e1 ec cc b5 21 00 35 d4 7a c7 2e 8a
+
+    # OAEP Example 1.2
+    # ------------------
+
+    # Message:
+    75 0c 40 47 f5 47 e8 e4 14 11 85 65 23 29 8a c9
+    ba e2 45 ef af 13 97 fb e5 6f 9d d5
+
+    # Seed:
+    0c c7 42 ce 4a 9b 7f 32 f9 51 bc b2 51 ef d9 25
+    fe 4f e3 5f
+
+    # Encryption:
+    64 0d b1 ac c5 8e 05 68 fe 54 07 e5 f9 b7 01 df
+    f8 c3 c9 1e 71 6c 53 6f c7 fc ec 6c b5 b7 1c 11
+    65 98 8d 4a 27 9e 15 77 d7 30 fc 7a 29 93 2e 3f
+    00 c8 15 15 23 6d 8d 8e 31 01 7a 7a 09 df 43 52
+    d9 04 cd eb 79 aa 58 3a dc c3 1e a6 98 a4 c0 52
+    83 da ba 90 89 be 54 91 f6 7c 1a 4e e4 8d c7 4b
+    bb e6 64 3a ef 84 66 79 b4 cb 39 5a 35 2d 5e d1
+    15 91 2d f6 96 ff e0 70 29 32 94 6d 71 49 2b 44
+
+    # =============================================
+    """).splitlines()
+
+    vectors = load_pkcs1_vectors(vector_data)
+    expected = [
+        (
+            {
+                'modulus': int(
+                    'a8b3b284af8eb50b387034a860f146c4919f318763cd6c5598c8ae481'
+                    '1a1e0abc4c7e0b082d693a5e7fced675cf4668512772c0cbc64a742c6'
+                    'c630f533c8cc72f62ae833c40bf25842e984bb78bdbf97c0107d55bdb'
+                    '662f5c4e0fab9845cb5148ef7392dd3aaff93ae1e6b667bb3d4247616'
+                    'd4f5ba10d4cfd226de88d39f16fb', 16),
+                'public_exponent': int('10001', 16),
+                'private_exponent': int(
+                    '53339cfdb79fc8466a655c7316aca85c55fd8f6dd898fdaf119517ef4'
+                    'f52e8fd8e258df93fee180fa0e4ab29693cd83b152a553d4ac4d1812b'
+                    '8b9fa5af0e7f55fe7304df41570926f3311f15c4d65a732c483116ee3'
+                    'd3d2d0af3549ad9bf7cbfb78ad884f84d5beb04724dc7369b31def37d'
+                    '0cf539e9cfcdd3de653729ead5d1', 16),
+                'p': int(
+                    'd32737e7267ffe1341b2d5c0d150a81b586fb3132bed2f8d5262864a9'
+                    'cb9f30af38be448598d413a172efb802c21acf1c11c520c2f26a471dc'
+                    'ad212eac7ca39d', 16),
+                'q': int(
+                    'cc8853d1d54da630fac004f471f281c7b8982d8224a490edbeb33d3e3'
+                    'd5cc93c4765703d1dd791642f1f116a0dd852be2419b2af72bfe9a030'
+                    'e860b0288b5d77', 16),
+                'dmp1': int(
+                    '0e12bf1718e9cef5599ba1c3882fe8046a90874eefce8f2ccc20e4f27'
+                    '41fb0a33a3848aec9c9305fbecbd2d76819967d4671acc6431e403796'
+                    '8db37878e695c1', 16),
+                'dmq1': int(
+                    '95297b0f95a2fa67d00707d609dfd4fc05c89dafc2ef6d6ea55bec771'
+                    'ea333734d9251e79082ecda866efef13c459e1a631386b7e354c899f5'
+                    'f112ca85d71583', 16),
+                'iqmp': int(
+                    '4f456c502493bdc0ed2ab756a3a6ed4d67352a697d4216e93212b127a'
+                    '63d5411ce6fa98d5dbefd73263e3728142743818166ed7dd63687dd2a'
+                    '8ca1d2f4fbd8e1', 16),
+                'examples': [
+                    {
+                        'message': b'6628194e12073db03ba94cda9ef9532397d50dba7'
+                                   b'9b987004afefe34',
+                        'seed': b'18b776ea21069d69776a33e96bad48e1dda0a5ef',
+                        'encryption': b'354fe67b4a126d5d35fe36c777791a3f7ba13d'
+                                      b'ef484e2d3908aff722fad468fb21696de95d0b'
+                                      b'e911c2d3174f8afcc201035f7b6d8e69402de5'
+                                      b'451618c21a535fa9d7bfc5b8dd9fc243f8cf92'
+                                      b'7db31322d6e881eaa91a996170e657a05a2664'
+                                      b'26d98c88003f8477c1227094a0d9fa1e8c4024'
+                                      b'309ce1ecccb5210035d47ac72e8a'
+                    }, {
+                        'message': b'750c4047f547e8e41411856523298ac9bae245efa'
+                                   b'f1397fbe56f9dd5',
+                        'seed': b'0cc742ce4a9b7f32f951bcb251efd925fe4fe35f',
+                        'encryption': b'640db1acc58e0568fe5407e5f9b701dff8c3c9'
+                                      b'1e716c536fc7fcec6cb5b71c1165988d4a279e'
+                                      b'1577d730fc7a29932e3f00c81515236d8d8e31'
+                                      b'017a7a09df4352d904cdeb79aa583adcc31ea6'
+                                      b'98a4c05283daba9089be5491f67c1a4ee48dc7'
+                                      b'4bbbe6643aef846679b4cb395a352d5ed11591'
+                                      b'2df696ffe0702932946d71492b44'
+                    }
+                ]
+            },
+
+            {
+                'modulus': int(
+                    'a8b3b284af8eb50b387034a860f146c4919f318763cd6c5598c8ae481'
+                    '1a1e0abc4c7e0b082d693a5e7fced675cf4668512772c0cbc64a742c6'
+                    'c630f533c8cc72f62ae833c40bf25842e984bb78bdbf97c0107d55bdb'
+                    '662f5c4e0fab9845cb5148ef7392dd3aaff93ae1e6b667bb3d4247616'
+                    'd4f5ba10d4cfd226de88d39f16fb', 16),
+                'public_exponent': int('10001', 16),
+            }
+        )
+    ]
+    assert vectors == expected
+
+
+def test_load_hotp_vectors():
+    vector_data = textwrap.dedent("""
+    # HOTP Test Vectors
+    # RFC 4226 Appendix D
+
+    COUNT = 0
+    COUNTER = 0
+    INTERMEDIATE = cc93cf18508d94934c64b65d8ba7667fb7cde4b0
+    TRUNCATED = 4c93cf18
+    HOTP = 755224
+    SECRET = 12345678901234567890
+
+    COUNT = 1
+    COUNTER = 1
+    INTERMEDIATE = 75a48a19d4cbe100644e8ac1397eea747a2d33ab
+    TRUNCATED = 41397eea
+    HOTP = 287082
+    SECRET = 12345678901234567890
+
+
+    COUNT = 2
+    COUNTER = 2
+    INTERMEDIATE = 0bacb7fa082fef30782211938bc1c5e70416ff44
+    TRUNCATED = 82fef30
+    HOTP = 359152
+    SECRET = 12345678901234567890
+
+
+    COUNT = 3
+    COUNTER = 3
+    INTERMEDIATE = 66c28227d03a2d5529262ff016a1e6ef76557ece
+    TRUNCATED = 66ef7655
+    HOTP = 969429
+    SECRET = 12345678901234567890
+    """).splitlines()
+
+    assert load_nist_vectors(vector_data) == [
+        {
+            "counter": b"0",
+            "intermediate": b"cc93cf18508d94934c64b65d8ba7667fb7cde4b0",
+            "truncated": b"4c93cf18",
+            "hotp": b"755224",
+            "secret": b"12345678901234567890",
+        },
+        {
+            "counter": b"1",
+            "intermediate": b"75a48a19d4cbe100644e8ac1397eea747a2d33ab",
+            "truncated": b"41397eea",
+            "hotp": b"287082",
+            "secret": b"12345678901234567890",
+        },
+        {
+            "counter": b"2",
+            "intermediate": b"0bacb7fa082fef30782211938bc1c5e70416ff44",
+            "truncated": b"82fef30",
+            "hotp": b"359152",
+            "secret": b"12345678901234567890",
+        },
+        {
+            "counter": b"3",
+            "intermediate": b"66c28227d03a2d5529262ff016a1e6ef76557ece",
+            "truncated": b"66ef7655",
+            "hotp": b"969429",
+            "secret": b"12345678901234567890",
+        },
+    ]
+
+
+def test_load_totp_vectors():
+    vector_data = textwrap.dedent("""
+    # TOTP Test Vectors
+    # RFC 6238 Appendix B
+
+    COUNT = 0
+    TIME = 59
+    TOTP = 94287082
+    MODE = SHA1
+    SECRET = 12345678901234567890
+
+    COUNT = 1
+    TIME = 59
+    TOTP = 46119246
+    MODE = SHA256
+    SECRET = 12345678901234567890
+
+    COUNT = 2
+    TIME = 59
+    TOTP = 90693936
+    MODE = SHA512
+    SECRET = 12345678901234567890
+    """).splitlines()
+
+    assert load_nist_vectors(vector_data) == [
+        {
+            "time": b"59",
+            "totp": b"94287082",
+            "mode": b"SHA1",
+            "secret": b"12345678901234567890",
+        },
+        {
+            "time": b"59",
+            "totp": b"46119246",
+            "mode": b"SHA256",
+            "secret": b"12345678901234567890",
+        },
+        {
+            "time": b"59",
+            "totp": b"90693936",
+            "mode": b"SHA512",
+            "secret": b"12345678901234567890",
+        },
+    ]
+
+
+def test_load_rsa_nist_vectors():
+    vector_data = textwrap.dedent("""
+    # CAVS 11.4
+    # "SigGen PKCS#1 RSASSA-PSS" information
+    # Mod sizes selected: 1024 1536 2048 3072 4096
+    # SHA Algorithm selected:SHA1 SHA224 SHA256 SHA384 SHA512
+    # Salt len: 20
+
+    [mod = 1024]
+
+    n = bcb47b2e0dafcba81ff2a2b5cb115ca7e757184c9d72bcdcda707a146b3b4e29989d
+
+    e = 00000000000000000000000000000000000000000000000000000000000000000010001
+    SHAAlg = SHA1
+    Msg = 1248f62a4389f42f7b4bb131053d6c88a994db2075b912ccbe3ea7dc611714f14e
+    S = 682cf53c1145d22a50caa9eb1a9ba70670c5915e0fdfde6457a765de2a8fe12de97
+
+    SHAAlg = SHA384
+    Msg = e511903c2f1bfba245467295ac95413ac4746c984c3750a728c388aa628b0ebf
+    S = 9c748702bbcc1f9468864cd360c8c39d007b2d8aaee833606c70f7593cf0d1519
+
+    [mod = 1024]
+
+    n = 1234567890
+
+    e = 0010001
+
+    SHAAlg = SHA512
+    Msg = 3456781293fab829
+    S = deadbeef0000
+    """).splitlines()
+
+    vectors = load_rsa_nist_vectors(vector_data)
+    assert vectors == [
+        {
+            "modulus": int("bcb47b2e0dafcba81ff2a2b5cb115ca7e757184c9d72bcdcda"
+                           "707a146b3b4e29989d", 16),
+            "public_exponent": 65537,
+            "algorithm": "SHA1",
+            "salt_length": 20,
+            "msg": b"1248f62a4389f42f7b4bb131053d6c88a994db2075b912ccbe3ea7dc6"
+                   b"11714f14e",
+            "s": b"682cf53c1145d22a50caa9eb1a9ba70670c5915e0fdfde6457a765de2a8"
+                 b"fe12de97",
+            "fail": False
+        },
+        {
+            "modulus": int("bcb47b2e0dafcba81ff2a2b5cb115ca7e757184c9d72bcdcda"
+                           "707a146b3b4e29989d", 16),
+            "public_exponent": 65537,
+            "algorithm": "SHA384",
+            "salt_length": 20,
+            "msg": b"e511903c2f1bfba245467295ac95413ac4746c984c3750a728c388aa6"
+                   b"28b0ebf",
+            "s": b"9c748702bbcc1f9468864cd360c8c39d007b2d8aaee833606c70f7593cf"
+                 b"0d1519",
+            "fail": False
+        },
+        {
+            "modulus": 78187493520,
+            "public_exponent": 65537,
+            "algorithm": "SHA512",
+            "salt_length": 20,
+            "msg": b"3456781293fab829",
+            "s": b"deadbeef0000",
+            "fail": False
+        },
+    ]
+
+
+def test_load_rsa_nist_pkcs1v15_verification_vectors():
+    vector_data = textwrap.dedent("""
+    # CAVS 11.0
+    # "SigVer PKCS#1 Ver 1.5" information
+    # Mod sizes selected: 1024 1536 2048 3072 4096
+    # SHA Algorithm selected:SHA1 SHA224 SHA256 SHA384 SHA512
+    # Generated on Wed Mar 02 00:13:02 2011
+
+    [mod = 1024]
+
+    n = be499b5e7f06c83fa0293e31465c8eb6b58af920bae52a7b5b9bfeb7aa72db126411
+
+    p = e7a80c5d211c06acb900939495f26d365fc2b4825b75e356f89003eaa5931e6be5c3
+    q = d248aa248000f720258742da67b711940c8f76e1ecd52b67a6ffe1e49354d66ff84f
+
+    SHAAlg = SHA1
+    e = 00000000000000000000000000000000000000000000000000000000000000000011
+    d = 0d0f17362bdad181db4e1fe03e8de1a3208989914e14bf269558826bfa20faf4b68d
+    Msg = 6b9cfac0ba1c7890b13e381ce752195cc1375237db2afcf6a9dcd1f95ec733a80c
+    S = 562d87b5781c01d166fef3972669a0495c145b898a17df4743fbefb0a1582bd6ba9d
+    SaltVal = 11223344555432167890
+    Result = F (3 - Signature changed )
+
+    SHAAlg = SHA1
+    e = 0000000000003
+    d = bfa20faf4b68d
+    Msg = 2a67c70ff14f9b34ddb42e6f89d5971057a0da980fc9ae70c81a84da0c0ac42737
+    S = 2b91c6ae2b3c46ff18d5b7abe239634cb752d0acb53eea0ccd8ea8483036a50e8faf
+    SaltVal = 11223344555432167890
+    Result = P
+    """).splitlines()
+
+    vectors = load_rsa_nist_vectors(vector_data)
+    assert vectors == [
+        {
+            "modulus": int("be499b5e7f06c83fa0293e31465c8eb6b58af920bae52a7b5b"
+                           "9bfeb7aa72db126411", 16),
+            "p": int("e7a80c5d211c06acb900939495f26d365fc2b4825b75e356f89003ea"
+                     "a5931e6be5c3", 16),
+            "q": int("d248aa248000f720258742da67b711940c8f76e1ecd52b67a6ffe1e4"
+                     "9354d66ff84f", 16),
+            "public_exponent": 17,
+            "algorithm": "SHA1",
+            "private_exponent": int("0d0f17362bdad181db4e1fe03e8de1a3208989914"
+                                    "e14bf269558826bfa20faf4b68d", 16),
+            "msg": b"6b9cfac0ba1c7890b13e381ce752195cc1375237db2afcf6a9dcd1f95"
+                   b"ec733a80c",
+            "s": b"562d87b5781c01d166fef3972669a0495c145b898a17df4743fbefb0a15"
+                 b"82bd6ba9d",
+            "saltval": b"11223344555432167890",
+            "fail": True
+        },
+        {
+            "modulus": int("be499b5e7f06c83fa0293e31465c8eb6b58af920bae52a7b5b"
+                           "9bfeb7aa72db126411", 16),
+            "p": int("e7a80c5d211c06acb900939495f26d365fc2b4825b75e356f89003ea"
+                     "a5931e6be5c3", 16),
+            "q": int("d248aa248000f720258742da67b711940c8f76e1ecd52b67a6ffe1e4"
+                     "9354d66ff84f", 16),
+            "public_exponent": 3,
+            "algorithm": "SHA1",
+            "private_exponent": int("bfa20faf4b68d", 16),
+            "msg": b"2a67c70ff14f9b34ddb42e6f89d5971057a0da980fc9ae70c81a84da0"
+                   b"c0ac42737",
+            "s": b"2b91c6ae2b3c46ff18d5b7abe239634cb752d0acb53eea0ccd8ea848303"
+                 b"6a50e8faf",
+            "saltval": b"11223344555432167890",
+            "fail": False
+        },
+    ]
+
+
+def test_load_rsa_nist_pss_verification_vectors():
+    vector_data = textwrap.dedent("""
+    # CAVS 11.0
+    # "SigVer PKCS#1 RSASSA-PSS" information
+    # Mod sizes selected: 1024 1536 2048 3072 4096
+    # SHA Algorithm selected:SHA1 SHA224 SHA256 SHA384 SHA512
+    # Salt len: 10
+    # Generated on Wed Mar 02 00:25:22 2011
+
+    [mod = 1024]
+
+    n = be499b5e7f06c83fa0293e31465c8eb6b5
+
+    p = e7a80c5d211c06acb900939495f26d365f
+    q = d248aa248000f720258742da67b711940c
+
+    SHAAlg = SHA1
+    e = 00000000000000011
+    d = c8e26a88239672cf49b3422a07c4d834ba
+    Msg = 6b9cfac0ba1c7890b13e381ce752195c
+    S = 562d87b5781c01d166fef3972669a0495c
+    SaltVal = 11223344555432167890
+    Result = F (3 - Signature changed )
+
+    SHAAlg = SHA384
+    e = 000003
+    d = 0d0f17362bdad181db4e1fe03e8de1a320
+    Msg = 2a67c70ff14f9b34ddb42e6f89d59710
+    S = 2b91c6ae2b3c46ff18d5b7abe239634cb7
+    SaltVal = 11223344555432167890
+    Result = P
+    """).splitlines()
+
+    vectors = load_rsa_nist_vectors(vector_data)
+    assert vectors == [
+        {
+            "modulus": int("be499b5e7f06c83fa0293e31465c8eb6b5", 16),
+            "p": int("e7a80c5d211c06acb900939495f26d365f", 16),
+            "q": int("d248aa248000f720258742da67b711940c", 16),
+            "public_exponent": 17,
+            "algorithm": "SHA1",
+            "private_exponent": int("c8e26a88239672cf49b3422a07c4d834ba", 16),
+            "msg": b"6b9cfac0ba1c7890b13e381ce752195c",
+            "s": b"562d87b5781c01d166fef3972669a0495c",
+            "saltval": b"11223344555432167890",
+            "salt_length": 10,
+            "fail": True
+        },
+        {
+            "modulus": int("be499b5e7f06c83fa0293e31465c8eb6b5", 16),
+            "p": int("e7a80c5d211c06acb900939495f26d365f", 16),
+            "q": int("d248aa248000f720258742da67b711940c", 16),
+            "public_exponent": 3,
+            "algorithm": "SHA384",
+            "private_exponent": int("0d0f17362bdad181db4e1fe03e8de1a320", 16),
+            "msg": b"2a67c70ff14f9b34ddb42e6f89d59710",
+            "s": b"2b91c6ae2b3c46ff18d5b7abe239634cb7",
+            "saltval": b"11223344555432167890",
+            "salt_length": 10,
+            "fail": False
+        },
+    ]
+
+
+def test_load_fips_dsa_key_pair_vectors():
+    vector_data = textwrap.dedent("""
+    #  CAVS 11.1
+    #  "KeyPair" information
+    #  Mod sizes selected: L=1024, N=160:: L=2048, N=224 :: L=2048, N=256 :: L
+=3072, N=256
+    # Generated on Wed May 04 08:50:52 2011
+
+
+    [mod = L=1024, N=160]
+
+    P = d38311e2cd388c3ed698e82fdf88eb92b5a9a483dc88005d4b725ef341eabb47cf8a7a\
+8a41e792a156b7ce97206c4f9c5ce6fc5ae7912102b6b502e59050b5b21ce263dddb2044b65223\
+6f4d42ab4b5d6aa73189cef1ace778d7845a5c1c1c7147123188f8dc551054ee162b634d60f097\
+f719076640e20980a0093113a8bd73
+    Q = 96c5390a8b612c0e422bb2b0ea194a3ec935a281
+    G = 06b7861abbd35cc89e79c52f68d20875389b127361ca66822138ce4991d2b862259d6b\
+4548a6495b195aa0e0b6137ca37eb23b94074d3c3d300042bdf15762812b6333ef7b07ceba7860\
+7610fcc9ee68491dbc1e34cd12615474e52b18bc934fb00c61d39e7da8902291c4434a4e2224c3\
+f4fd9f93cd6f4f17fc076341a7e7d9
+
+    X = 8185fee9cc7c0e91fd85503274f1cd5a3fd15a49
+    Y = 6f26d98d41de7d871b6381851c9d91fa03942092ab6097e76422070edb71db44ff5682\
+80fdb1709f8fc3feab39f1f824adaeb2a298088156ac31af1aa04bf54f475bdcfdcf2f8a2dd973\
+e922d83e76f016558617603129b21c70bf7d0e5dc9e68fe332e295b65876eb9a12fe6fca9f1a1c\
+e80204646bf99b5771d249a6fea627
+
+    X = 85322d6ea73083064376099ca2f65f56e8522d9b
+    Y = 21f8690f717c9f4dcb8f4b6971de2f15b9231fcf41b7eeb997d781f240bfdddfd2090d\
+22083c26cca39bf37c9caf1ec89518ea64845a50d747b49131ffff6a2fd11ea7bacbb93c7d0513\
+7383a06365af82225dd3713ca5a45006316f53bd12b0e260d5f79795e5a4c9f353f12867a1d320\
+2394673ada8563b71555e53f415254
+
+    [mod = L=2048, N=224]
+
+    P = 904ef8e31e14721910fa0969e77c99b79f190071a86026e37a887a6053960dbfb74390\
+a6641319fe0af32c4e982934b0f1f4c5bc57534e8e56d77c36f0a99080c0d5bc9022fa34f58922\
+81d7b1009571cb5b35699303f912b276d86b1b0722fc0b1500f0ffb2e4d90867a3bdca181a9734\
+617a8a9f991aa7c14dec1cf45ceba00600f8425440ed0c3b52c82e3aa831932a98b477da220867\
+eb2d5e0ca34580b33b1b65e558411ed09c369f4717bf03b551787e13d9e47c267c91c697225265\
+da157945cd8b32e84fc45b80533265239aa00a2dd3d05f5cb231b7daf724b7ecdce170360a8397\
+2e5be94626273d449f441be300a7345db387bebadad67d8060a7
+    Q = d7d0a83e84d13032b830ed74a6a88592ec9a4cf42bf37080c6600aad
+    G = 2050b18d3c9f39fac396c009310d6616f9309b67b59aef9aee813d6b4f12ee29ba8a6b\
+350b11d4336d44b4641230002d870f1e6b1d8728bdd40262df0d2440999185ae077f7034c61679\
+f4360fbb5d181569e7cb8acb04371c11ba55f1bbd777b74304b99b66d4405303e7120dc8bc4785\
+f56e9533e65b63a0c77cce7bba0d5d6069df5edffa927c5a255a09405a008258ed93506a843366\
+2154f6f67e922d7c9788f04d4ec09581063950d9cde8e373ea59a58b2a6df6ba8663345574fabb\
+a9ca981696d83aeac1f34f14f1a813ba900b3f0341dea23f7d3297f919a97e1ae00ac0728c93fe\
+0a88b66591baf4eb0bc6900f39ba5feb41cbbeea7eb7919aa4d3
+
+    X = 3f19424da3b4f0cafca3fc5019fcd225dd7e496ffdf6b77e364f45be
+    Y = 7681ed0ac257ab7ff17c52de4638c0614749792707a0c0d23883697e34963df15c806f\
+a6206f7fafb3269018e7703bd1e6f518d13544331a017713dbbe0cee8da6c095271fbf24edb74a\
+44e18b1d3b835622f68d31921c67c83e8479d1972ed0cb106c68188fe22c044254251ebf880b90\
+49dc3b7958ef61e1e67d2f677d2a7d2ab6b7c42b70cc5dedc3e5de7459a2dbc70c69008553d7ff\
+b6bf81c012c8bd67bdddeaab9a4a4373027912a7c7d9cd9cfc6c81dffe0cc7a6d40c3b2065aee7\
+be80e3c35497d64c8045bc511edaf7314c84c56bd9f0fecf62262ea5b45b49a0cffb223713bdbd\
+3ad03a25a0bb2211eba41ffcd08ab0e1ad485c29a3fc25ee8359
+
+    X = 241396352dd26efe0e2e184da52fe2b61d9d51b91b5009674c447854
+    Y = 2f07a3aa9884c65288e5fef56c7b7f4445632273290bae6fcaab87c90058b2bef81ad3\
+34958657cf649ffb976d618b34ce69ef6d68c0d8bfe275cf097a301e8dd5595958e0c668c15f67\
+b5c0b0d01983057ce61593635aab5e0564ed720b0336f055a86755c76be22df3b8487f16e2ba0b\
+5136fd30d7e3b1d30c3bd298d3acc0a1988a11756c94e9a53184d0d3edfbb649caf03eace3083d\
+e9933921e627f4b2e011d1c79e45d8ea1eb7e4e59a1cbd8382b3238474eb949749c985200fbb25\
+41e2dce080aa881945d4d935076e48a0846dc5513bb4da8563b946af54f546455931e79c065ce7\
+ca223a98f8fde40091d38eb2c3eb8e3b81d88374f3146b0afc42
+
+    [mod = L=2048, N=256]
+
+    P = ea1fb1af22881558ef93be8a5f8653c5a559434c49c8c2c12ace5e9c41434c9cf0a8e9\
+498acb0f4663c08b4484eace845f6fb17dac62c98e706af0fc74e4da1c6c2b3fbf5a1d58ff82fc\
+1a66f3e8b12252c40278fff9dd7f102eed2cb5b7323ebf1908c234d935414dded7f8d244e54561\
+b0dca39b301de8c49da9fb23df33c6182e3f983208c560fb5119fbf78ebe3e6564ee235c6a15cb\
+b9ac247baba5a423bc6582a1a9d8a2b4f0e9e3d9dbac122f750dd754325135257488b1f6ecabf2\
+1bff2947fe0d3b2cb7ffe67f4e7fcdf1214f6053e72a5bb0dd20a0e9fe6db2df0a908c36e95e60\
+bf49ca4368b8b892b9c79f61ef91c47567c40e1f80ac5aa66ef7
+    Q = 8ec73f3761caf5fdfe6e4e82098bf10f898740dcb808204bf6b18f507192c19d
+    G = e4c4eca88415b23ecf811c96e48cd24200fe916631a68a684e6ccb6b1913413d344d1d\
+8d84a333839d88eee431521f6e357c16e6a93be111a98076739cd401bab3b9d565bf4fb99e9d18\
+5b1e14d61c93700133f908bae03e28764d107dcd2ea7674217622074bb19efff482f5f5c1a86d5\
+551b2fc68d1c6e9d8011958ef4b9c2a3a55d0d3c882e6ad7f9f0f3c61568f78d0706b10a26f23b\
+4f197c322b825002284a0aca91807bba98ece912b80e10cdf180cf99a35f210c1655fbfdd74f13\
+b1b5046591f8403873d12239834dd6c4eceb42bf7482e1794a1601357b629ddfa971f2ed273b14\
+6ec1ca06d0adf55dd91d65c37297bda78c6d210c0bc26e558302
+
+    X = 405772da6e90d809e77d5de796562a2dd4dfd10ef00a83a3aba6bd818a0348a1
+    Y = 6b32e31ab9031dc4dd0b5039a78d07826687ab087ae6de4736f5b0434e1253092e8a0b\
+231f9c87f3fc8a4cb5634eb194bf1b638b7a7889620ce6711567e36aa36cda4604cfaa601a4591\
+8371d4ccf68d8b10a50a0460eb1dc0fff62ef5e6ee4d473e18ea4a66c196fb7e677a49b48241a0\
+b4a97128eff30fa437050501a584f8771e7280d26d5af30784039159c11ebfea10b692fd0a5821\
+5eeb18bff117e13f08db792ed4151a218e4bed8dddfb0793225bd1e9773505166f4bd8cedbb286\
+ea28232972da7bae836ba97329ba6b0a36508e50a52a7675e476d4d4137eae13f22a9d2fefde70\
+8ba8f34bf336c6e76331761e4b0617633fe7ec3f23672fb19d27
+
+    X = 0e0b95e31fda3f888059c46c3002ef8f2d6be112d0209aeb9e9545da67aeea80
+    Y = 778082b77ddba6f56597cc74c3a612abf2ddbd85cc81430c99ab843c1f630b9db01399\
+65f563978164f9bf3a8397256be714625cd41cd7fa0067d94ea66d7e073f7125af692ad01371d4\
+a17f4550590378f2b074030c20e36911598a1018772f61be3b24de4be5a388ccc09e15a92819c3\
+1dec50de9fde105b49eaa097b9d13d9219eeb33b628facfd1c78a7159c8430d0647c506e7e3de7\
+4763cb351eada72c00bef3c9641881e6254870c1e6599f8ca2f1bbb74f39a905e3a34e4544168e\
+6e50c9e3305fd09cab6ed4aff6fda6e0d5bf375c81ac9054406d9193b003c89272f1bd83d48250\
+134b65c77c2b6332d38d34d9016f0e8975536ad6c348a1faedb0
+
+    [mod = L=3072, N=256]
+
+    P = f335666dd1339165af8b9a5e3835adfe15c158e4c3c7bd53132e7d5828c352f593a9a7\
+87760ce34b789879941f2f01f02319f6ae0b756f1a842ba54c85612ed632ee2d79ef17f06b77c6\
+41b7b080aff52a03fc2462e80abc64d223723c236deeb7d201078ec01ca1fbc1763139e25099a8\
+4ec389159c409792080736bd7caa816b92edf23f2c351f90074aa5ea2651b372f8b58a0a65554d\
+b2561d706a63685000ac576b7e4562e262a14285a9c6370b290e4eb7757527d80b6c0fd5df831d\
+36f3d1d35f12ab060548de1605fd15f7c7aafed688b146a02c945156e284f5b71282045aba9844\
+d48b5df2e9e7a5887121eae7d7b01db7cdf6ff917cd8eb50c6bf1d54f90cce1a491a9c74fea88f\
+7e7230b047d16b5a6027881d6f154818f06e513faf40c8814630e4e254f17a47bfe9cb519b9828\
+9935bf17673ae4c8033504a20a898d0032ee402b72d5986322f3bdfb27400561f7476cd715eaab\
+b7338b854e51fc2fa026a5a579b6dcea1b1c0559c13d3c1136f303f4b4d25ad5b692229957
+    Q = d3eba6521240694015ef94412e08bf3cf8d635a455a398d6f210f6169041653b
+    G = ce84b30ddf290a9f787a7c2f1ce92c1cbf4ef400e3cd7ce4978db2104d7394b493c183\
+32c64cec906a71c3778bd93341165dee8e6cd4ca6f13afff531191194ada55ecf01ff94d6cf7c4\
+768b82dd29cd131aaf202aefd40e564375285c01f3220af4d70b96f1395420d778228f1461f5d0\
+b8e47357e87b1fe3286223b553e3fc9928f16ae3067ded6721bedf1d1a01bfd22b9ae85fce7782\
+0d88cdf50a6bde20668ad77a707d1c60fcc5d51c9de488610d0285eb8ff721ff141f93a9fb23c1\
+d1f7654c07c46e58836d1652828f71057b8aff0b0778ef2ca934ea9d0f37daddade2d823a4d8e3\
+62721082e279d003b575ee59fd050d105dfd71cd63154efe431a0869178d9811f4f231dc5dcf3b\
+0ec0f2b0f9896c32ec6c7ee7d60aa97109e09224907328d4e6acd10117e45774406c4c947da802\
+0649c3168f690e0bd6e91ac67074d1d436b58ae374523deaf6c93c1e6920db4a080b744804bb07\
+3cecfe83fa9398cf150afa286dc7eb7949750cf5001ce104e9187f7e16859afa8fd0d775ae
+
+    X = b2764c46113983777d3e7e97589f1303806d14ad9f2f1ef033097de954b17706
+    Y = 814824e435e1e6f38daa239aad6dad21033afce6a3ebd35c1359348a0f2418871968c2\
+babfc2baf47742148828f8612183178f126504da73566b6bab33ba1f124c15aa461555c2451d86\
+c94ee21c3e3fc24c55527e01b1f03adcdd8ec5cb08082803a7b6a829c3e99eeb332a2cf5c035b0\
+ce0078d3d414d31fa47e9726be2989b8d06da2e6cd363f5a7d1515e3f4925e0b32adeae3025cc5\
+a996f6fd27494ea408763de48f3bb39f6a06514b019899b312ec570851637b8865cff3a52bf5d5\
+4ad5a19e6e400a2d33251055d0a440b50d53f4791391dc754ad02b9eab74c46b4903f9d76f8243\
+39914db108057af7cde657d41766a99991ac8787694f4185d6f91d7627048f827b405ec67bf2fe\
+56141c4c581d8c317333624e073e5879a82437cb0c7b435c0ce434e15965db1315d64895991e6b\
+be7dac040c42052408bbc53423fd31098248a58f8a67da3a39895cd0cc927515d044c1e3cb6a32\
+59c3d0da354cce89ea3552c59609db10ee989986527436af21d9485ddf25f90f7dff6d2bae
+
+    X = 52e3e040efb30e1befd909a0bdbcfd140d005b1bff094af97186080262f1904d
+    Y = a5ae6e8f9b7a68ab0516dad4d7b7d002126f811d5a52e3d35c6d387fcb43fd19bf7792\
+362f9c98f8348aa058bb62376685f3d0c366c520d697fcd8416947151d4bbb6f32b53528a01647\
+9e99d2cd48d1fc679027c15f0042f207984efe05c1796bca8eba678dfdd00b80418e3ea840557e\
+73b09e003882f9a68edba3431d351d1ca07a8150b018fdbdf6c2f1ab475792a3ccaa6594472a45\
+f8dc777b60bf67de3e0f65c20d11b7d59faedf83fbce52617f500d9e514947c455274c6e900464\
+767fb56599b81344cf6d12c25cb2b7d038d7b166b6cf30534811c15d0e8ab880a2ac06786ae2dd\
+de61329a78d526f65245380ce877e979c5b50de66c9c30d66382c8f254653d25a1eb1d3a4897d7\
+623399b473ce712a2184cf2da1861706c41466806aefe41b497db82aca6c31c8f4aa68c17d1d9e\
+380b57998917655783ec96e5234a131f7299398d36f1f5f84297a55ff292f1f060958c358fed34\
+6db2de45127ca728a9417b2c54203e33e53b9a061d924395b09afab8daf3e8dd7eedcec3ac
+    """).splitlines()
+
+    expected = [
+        {'g': int('06b7861abbd35cc89e79c52f68d20875389b127361ca66822138ce499'
+                  '1d2b862259d6b4548a6495b195aa0e0b6137ca37eb23b94074d3c3d3000'
+                  '42bdf15762812b6333ef7b07ceba78607610fcc9ee68491dbc1e34cd12'
+                  '615474e52b18bc934fb00c61d39e7da8902291c4434a4e2224c3f'
+                  '4fd9f93cd6f4f17fc076341a7e7d9', 16),
+         'p': int('d38311e2cd388c3ed698e82fdf88eb92b5a9a483dc88005d4b725e'
+                  'f341eabb47cf8a7a8a41e792a156b7ce97206c4f9c5ce6fc5ae791210'
+                  '2b6b502e59050b5b21ce263dddb2044b652236f4d42ab4b5d6aa73189c'
+                  'ef1ace778d7845a5c1c1c7147123188f8dc551054ee162b634d60f097f7'
+                  '19076640e20980a0093113a8bd73', 16),
+         'q': int('96c5390a8b612c0e422bb2b0ea194a3ec935a281', 16),
+         'x': int('8185fee9cc7c0e91fd85503274f1cd5a3fd15a49', 16),
+         'y': int('6f26d98d41de7d871b6381851c9d91fa03942092ab6097e76422'
+                  '070edb71db44ff568280fdb1709f8fc3feab39f1f824adaeb2a29808815'
+                  '6ac31af1aa04bf54f475bdcfdcf2f8a2dd973e922d83e76f01655861760'
+                  '3129b21c70bf7d0e5dc9e68fe332e295b65876eb9a12fe6fca9f1a1ce80'
+                  '204646bf99b5771d249a6fea627', 16)},
+        {'g': int('06b7861abbd35cc89e79c52f68d20875389b127361ca66822138ce4991d'
+                  '2b862259d6b4548a6495b195aa0e0b6137ca37eb23b94074d3c3d30004'
+                  '2bdf15762812b6333ef7b07ceba78607610fcc9ee68491dbc1e34cd126'
+                  '15474e52b18bc934fb00c61d39e7da8902291c4434a4e2224c3f4fd9'
+                  'f93cd6f4f17fc076341a7e7d9', 16),
+         'p': int('d38311e2cd388c3ed698e82fdf88eb92b5a9a483dc88005d4b725ef341e'
+                  'abb47cf8a7a8a41e792a156b7ce97206c4f9c5ce6fc5ae7912102b6b50'
+                  '2e59050b5b21ce263dddb2044b652236f4d42ab4b5d6aa73189cef1a'
+                  'ce778d7845a5c1c1c7147123188f8dc551054ee162b634d6'
+                  '0f097f719076640e20980a0093113a8bd73', 16),
+         'q': int('96c5390a8b612c0e422bb2b0ea194a3ec935a281', 16),
+         'x': int('85322d6ea73083064376099ca2f65f56e8522d9b', 16),
+         'y': int('21f8690f717c9f4dcb8f4b6971de2f15b9231fcf41b7eeb997d781f240'
+                  'bfdddfd2090d22083c26cca39bf37c9caf1ec89518ea64845a50d747b49'
+                  '131ffff6a2fd11ea7bacbb93c7d05137383a06365af82225dd3713c'
+                  'a5a45006316f53bd12b0e260d5f79795e5a4c9f353f12867a1d3'
+                  '202394673ada8563b71555e53f415254', 16)},
+
+        {'g': int('e4c4eca88415b23ecf811c96e48cd24200fe916631a68a684e6ccb6b191'
+                  '3413d344d1d8d84a333839d88eee431521f6e357c16e6a93be111a9807'
+                  '6739cd401bab3b9d565bf4fb99e9d185b1e14d61c93700133f908bae0'
+                  '3e28764d107dcd2ea7674217622074bb19efff482f5f5c1a86d5551b2'
+                  'fc68d1c6e9d8011958ef4b9c2a3a55d0d3c882e6ad7f9f0f3c61568f78'
+                  'd0706b10a26f23b4f197c322b825002284a0aca91807bba98ece912'
+                  'b80e10cdf180cf99a35f210c1655fbfdd74f13b1b5046591f8403873d'
+                  '12239834dd6c4eceb42bf7482e1794a1601357b629ddfa971f2ed273b1'
+                  '46ec1ca06d0adf55dd91d65c37297bda78c6d210c0bc26e558302', 16),
+         'p': int('ea1fb1af22881558ef93be8a5f8653c5a559434c49c8c2c12ace'
+                  '5e9c41434c9cf0a8e9498acb0f4663c08b4484eace845f6fb17d'
+                  'ac62c98e706af0fc74e4da1c6c2b3fbf5a1d58ff82fc1a66f3e8b122'
+                  '52c40278fff9dd7f102eed2cb5b7323ebf1908c234d935414dded7f8d2'
+                  '44e54561b0dca39b301de8c49da9fb23df33c6182e3f983208c560fb5'
+                  '119fbf78ebe3e6564ee235c6a15cbb9ac247baba5a423bc6582a1a9d8a'
+                  '2b4f0e9e3d9dbac122f750dd754325135257488b1f6ecabf21bff2947'
+                  'fe0d3b2cb7ffe67f4e7fcdf1214f6053e72a5bb0dd20a0e9fe6db2df0a'
+                  '908c36e95e60bf49ca4368b8b892b9c79f61ef91c47567c40e1f80ac'
+                  '5aa66ef7', 16),
+         'q': int('8ec73f3761caf5fdfe6e4e82098bf10f898740dcb808204bf6b1'
+                  '8f507192c19d', 16),
+         'x': int('405772da6e90d809e77d5de796562a2dd4dfd10ef00a83a3aba6'
+                  'bd818a0348a1', 16),
+         'y': int('6b32e31ab9031dc4dd0b5039a78d07826687ab087ae6de4736f5'
+                  'b0434e1253092e8a0b231f9c87f3fc8a4cb5634eb194bf1b638'
+                  'b7a7889620ce6711567e36aa36cda4604cfaa601a45918371d'
+                  '4ccf68d8b10a50a0460eb1dc0fff62ef5e6ee4d473e18ea4a6'
+                  '6c196fb7e677a49b48241a0b4a97128eff30fa437050501a584'
+                  'f8771e7280d26d5af30784039159c11ebfea10b692fd0a58215ee'
+                  'b18bff117e13f08db792ed4151a218e4bed8dddfb0793225bd1e97'
+                  '73505166f4bd8cedbb286ea28232972da7bae836ba97329ba6b0a36508'
+                  'e50a52a7675e476d4d4137eae13f22a9d2fefde708ba8f34bf336c6e7'
+                  '6331761e4b0617633fe7ec3f23672fb19d27', 16)},
+        {'g': int('e4c4eca88415b23ecf811c96e48cd24200fe916631a68a684e6ccb6b191'
+                  '3413d344d1d8d84a333839d88eee431521f6e357c16e6a93be111a9807'
+                  '6739cd401bab3b9d565bf4fb99e9d185b1e14d61c93700133f908bae0'
+                  '3e28764d107dcd2ea7674217622074bb19efff482f5f5c1a86d5551b2'
+                  'fc68d1c6e9d8011958ef4b9c2a3a55d0d3c882e6ad7f9f0f3c61568f78'
+                  'd0706b10a26f23b4f197c322b825002284a0aca91807bba98ece912'
+                  'b80e10cdf180cf99a35f210c1655fbfdd74f13b1b5046591f8403873d'
+                  '12239834dd6c4eceb42bf7482e1794a1601357b629ddfa971f2ed273b1'
+                  '46ec1ca06d0adf55dd91d65c37297bda78c6d210c0bc26e558302', 16),
+         'p': int('ea1fb1af22881558ef93be8a5f8653c5a559434c49c8c2c12ace'
+                  '5e9c41434c9cf0a8e9498acb0f4663c08b4484eace845f6fb17d'
+                  'ac62c98e706af0fc74e4da1c6c2b3fbf5a1d58ff82fc1a66f3e8b122'
+                  '52c40278fff9dd7f102eed2cb5b7323ebf1908c234d935414dded7f8d2'
+                  '44e54561b0dca39b301de8c49da9fb23df33c6182e3f983208c560fb5'
+                  '119fbf78ebe3e6564ee235c6a15cbb9ac247baba5a423bc6582a1a9d8a'
+                  '2b4f0e9e3d9dbac122f750dd754325135257488b1f6ecabf21bff2947'
+                  'fe0d3b2cb7ffe67f4e7fcdf1214f6053e72a5bb0dd20a0e9fe6db2df0a'
+                  '908c36e95e60bf49ca4368b8b892b9c79f61ef91c47567c40e1f80ac'
+                  '5aa66ef7', 16),
+         'q': int('8ec73f3761caf5fdfe6e4e82098bf10f898740dcb808204bf6b1'
+                  '8f507192c19d', 16),
+         'x': int('0e0b95e31fda3f888059c46c3002ef8f2d6be112d0209aeb9e95'
+                  '45da67aeea80', 16),
+         'y': int('778082b77ddba6f56597cc74c3a612abf2ddbd85cc81430c99ab'
+                  '843c1f630b9db0139965f563978164f9bf3a8397256be714625'
+                  'cd41cd7fa0067d94ea66d7e073f7125af692ad01371d4a17f45'
+                  '50590378f2b074030c20e36911598a1018772f61be3b24de4be'
+                  '5a388ccc09e15a92819c31dec50de9fde105b49eaa097b9d13d'
+                  '9219eeb33b628facfd1c78a7159c8430d0647c506e7e3de74763c'
+                  'b351eada72c00bef3c9641881e6254870c1e6599f8ca2f1bbb74f'
+                  '39a905e3a34e4544168e6e50c9e3305fd09cab6ed4aff6fda6e0d'
+                  '5bf375c81ac9054406d9193b003c89272f1bd83d48250134b65c77'
+                  'c2b6332d38d34d9016f0e8975536ad6c348a1faedb0', 16)},
+
+        {'g': int('ce84b30ddf290a9f787a7c2f1ce92c1cbf4ef400e3cd7ce4978d'
+                  'b2104d7394b493c18332c64cec906a71c3778bd93341165dee8'
+                  'e6cd4ca6f13afff531191194ada55ecf01ff94d6cf7c4768b82'
+                  'dd29cd131aaf202aefd40e564375285c01f3220af4d70b96f1'
+                  '395420d778228f1461f5d0b8e47357e87b1fe3286223b553e3'
+                  'fc9928f16ae3067ded6721bedf1d1a01bfd22b9ae85fce77820d88cdf'
+                  '50a6bde20668ad77a707d1c60fcc5d51c9de488610d0285eb8ff721f'
+                  'f141f93a9fb23c1d1f7654c07c46e58836d1652828f71057b8aff0b077'
+                  '8ef2ca934ea9d0f37daddade2d823a4d8e362721082e279d003b575ee'
+                  '59fd050d105dfd71cd63154efe431a0869178d9811f4f231dc5dcf3b'
+                  '0ec0f2b0f9896c32ec6c7ee7d60aa97109e09224907328d4e6acd1011'
+                  '7e45774406c4c947da8020649c3168f690e0bd6e91ac67074d1d436b'
+                  '58ae374523deaf6c93c1e6920db4a080b744804bb073cecfe83fa939'
+                  '8cf150afa286dc7eb7949750cf5001ce104e9187f7e16859afa8fd0d'
+                  '775ae', 16),
+         'p': int('f335666dd1339165af8b9a5e3835adfe15c158e4c3c7bd53132e7d5828'
+                  'c352f593a9a787760ce34b789879941f2f01f02319f6ae0b756f1a842'
+                  'ba54c85612ed632ee2d79ef17f06b77c641b7b080aff52a03fc2462e8'
+                  '0abc64d223723c236deeb7d201078ec01ca1fbc1763139e25099a84ec'
+                  '389159c409792080736bd7caa816b92edf23f2c351f90074aa5ea2651'
+                  'b372f8b58a0a65554db2561d706a63685000ac576b7e4562e262a1428'
+                  '5a9c6370b290e4eb7757527d80b6c0fd5df831d36f3d1d35f12ab0605'
+                  '48de1605fd15f7c7aafed688b146a02c945156e284f5b71282045aba9'
+                  '844d48b5df2e9e7a5887121eae7d7b01db7cdf6ff917cd8eb50c6bf1d'
+                  '54f90cce1a491a9c74fea88f7e7230b047d16b5a6027881d6f154818f'
+                  '06e513faf40c8814630e4e254f17a47bfe9cb519b98289935bf17673a'
+                  'e4c8033504a20a898d0032ee402b72d5986322f3bdfb27400561f7476'
+                  'cd715eaabb7338b854e51fc2fa026a5a579b6dcea1b1c0559c13d3c11'
+                  '36f303f4b4d25ad5b692229957', 16),
+         'q': int('d3eba6521240694015ef94412e08bf3cf8d635a455a398d6f210'
+                  'f6169041653b', 16),
+         'x': int('b2764c46113983777d3e7e97589f1303806d14ad9f2f1ef03309'
+                  '7de954b17706', 16),
+         'y': int('814824e435e1e6f38daa239aad6dad21033afce6a3ebd35c1359348a0f2'
+                  '418871968c2babfc2baf47742148828f8612183178f126504da73566b6'
+                  'bab33ba1f124c15aa461555c2451d86c94ee21c3e3fc24c55527e'
+                  '01b1f03adcdd8ec5cb08082803a7b6a829c3e99eeb332a2cf5c035b0c'
+                  'e0078d3d414d31fa47e9726be2989b8d06da2e6cd363f5a7d1515e3f4'
+                  '925e0b32adeae3025cc5a996f6fd27494ea408763de48f3bb39f6a06'
+                  '514b019899b312ec570851637b8865cff3a52bf5d54ad5a19e6e400'
+                  'a2d33251055d0a440b50d53f4791391dc754ad02b9eab74c46b4903'
+                  'f9d76f824339914db108057af7cde657d41766a99991ac8787694f'
+                  '4185d6f91d7627048f827b405ec67bf2fe56141c4c581d8c317333'
+                  '624e073e5879a82437cb0c7b435c0ce434e15965db1315d648959'
+                  '91e6bbe7dac040c42052408bbc53423fd31098248a58f8a67da3a'
+                  '39895cd0cc927515d044c1e3cb6a3259c3d0da354cce89ea3552c'
+                  '59609db10ee989986527436af21d9485ddf25f90f7dff6d2bae', 16)},
+        {'g': int('ce84b30ddf290a9f787a7c2f1ce92c1cbf4ef400e3cd7ce4978d'
+                  'b2104d7394b493c18332c64cec906a71c3778bd93341165dee8'
+                  'e6cd4ca6f13afff531191194ada55ecf01ff94d6cf7c4768b82'
+                  'dd29cd131aaf202aefd40e564375285c01f3220af4d70b96f1'
+                  '395420d778228f1461f5d0b8e47357e87b1fe3286223b553e3'
+                  'fc9928f16ae3067ded6721bedf1d1a01bfd22b9ae85fce77820d88cdf'
+                  '50a6bde20668ad77a707d1c60fcc5d51c9de488610d0285eb8ff721f'
+                  'f141f93a9fb23c1d1f7654c07c46e58836d1652828f71057b8aff0b077'
+                  '8ef2ca934ea9d0f37daddade2d823a4d8e362721082e279d003b575ee'
+                  '59fd050d105dfd71cd63154efe431a0869178d9811f4f231dc5dcf3b'
+                  '0ec0f2b0f9896c32ec6c7ee7d60aa97109e09224907328d4e6acd1011'
+                  '7e45774406c4c947da8020649c3168f690e0bd6e91ac67074d1d436b'
+                  '58ae374523deaf6c93c1e6920db4a080b744804bb073cecfe83fa939'
+                  '8cf150afa286dc7eb7949750cf5001ce104e9187f7e16859afa8fd0d'
+                  '775ae', 16),
+         'p': int('f335666dd1339165af8b9a5e3835adfe15c158e4c3c7bd53132e7d5828'
+                  'c352f593a9a787760ce34b789879941f2f01f02319f6ae0b756f1a842'
+                  'ba54c85612ed632ee2d79ef17f06b77c641b7b080aff52a03fc2462e8'
+                  '0abc64d223723c236deeb7d201078ec01ca1fbc1763139e25099a84ec'
+                  '389159c409792080736bd7caa816b92edf23f2c351f90074aa5ea2651'
+                  'b372f8b58a0a65554db2561d706a63685000ac576b7e4562e262a1428'
+                  '5a9c6370b290e4eb7757527d80b6c0fd5df831d36f3d1d35f12ab0605'
+                  '48de1605fd15f7c7aafed688b146a02c945156e284f5b71282045aba9'
+                  '844d48b5df2e9e7a5887121eae7d7b01db7cdf6ff917cd8eb50c6bf1d'
+                  '54f90cce1a491a9c74fea88f7e7230b047d16b5a6027881d6f154818f'
+                  '06e513faf40c8814630e4e254f17a47bfe9cb519b98289935bf17673a'
+                  'e4c8033504a20a898d0032ee402b72d5986322f3bdfb27400561f7476'
+                  'cd715eaabb7338b854e51fc2fa026a5a579b6dcea1b1c0559c13d3c11'
+                  '36f303f4b4d25ad5b692229957', 16),
+         'q': int('d3eba6521240694015ef94412e08bf3cf8d635a455a398d6f210'
+                  'f6169041653b', 16),
+         'x': int('52e3e040efb30e1befd909a0bdbcfd140d005b1bff094af97186'
+                  '080262f1904d', 16),
+         'y': int('a5ae6e8f9b7a68ab0516dad4d7b7d002126f811d5a52e3d35c6d'
+                  '387fcb43fd19bf7792362f9c98f8348aa058bb62376685f3d0c3'
+                  '66c520d697fcd8416947151d4bbb6f32b53528a016479e99d2cd'
+                  '48d1fc679027c15f0042f207984efe05c1796bca8eba678dfdd0'
+                  '0b80418e3ea840557e73b09e003882f9a68edba3431d351d1ca0'
+                  '7a8150b018fdbdf6c2f1ab475792a3ccaa6594472a45f8dc777b'
+                  '60bf67de3e0f65c20d11b7d59faedf83fbce52617f500d9e5149'
+                  '47c455274c6e900464767fb56599b81344cf6d12c25cb2b7d038'
+                  'd7b166b6cf30534811c15d0e8ab880a2ac06786ae2ddde61329a'
+                  '78d526f65245380ce877e979c5b50de66c9c30d66382c8f25465'
+                  '3d25a1eb1d3a4897d7623399b473ce712a2184cf2da1861706c4'
+                  '1466806aefe41b497db82aca6c31c8f4aa68c17d1d9e380b5799'
+                  '8917655783ec96e5234a131f7299398d36f1f5f84297a55ff292'
+                  'f1f060958c358fed346db2de45127ca728a9417b2c54203e33e5'
+                  '3b9a061d924395b09afab8daf3e8dd7eedcec3ac', 16)}
+    ]
+
+    assert expected == load_fips_dsa_key_pair_vectors(vector_data)
+
+
+def test_load_fips_dsa_sig_ver_vectors():
+    vector_data = textwrap.dedent("""
+    # CAVS 11.0
+    # "SigVer" information
+    # Mod sizes selected: SHA-1 L=1024, N=160,SHA-384 L=2048, N=256
+    # Generated on Fri Apr 01 08:37:15 2011
+
+    [mod = L=1024, N=160, SHA-1]
+
+    P = dc5bf3a88b2d99e4c95cdd7a0501cc38630d425cf5c390af3429cff1f35147b795cae\
+a923f0d3577158f8a0c89dabd1962c2c453306b5d70cacfb01430aceb54e5a5fa6f93\
+40d3bd2da612fceeb76b0ec1ebfae635a56ab141b108e00dc76eefe2edd0c514c21c4\
+57457c39065dba9d0ecb7569c247172d8438ad2827b60435b
+    Q = e956602b83d195dbe945b3ac702fc61f81571f1d
+    G = d7eb9ca20a3c7a079606bafc4c9261ccaba303a5dc9fe9953f197dfe548c234895baa\
+77f441ee6a2d97b909cbbd26ff7b869d24cae51b5c6edb127a4b5d75cd8b46608bfa1\
+48249dffdb59807c5d7dde3fe3080ca3a2d28312142becb1fa8e24003e21c72871081\
+74b95d5bc711e1c8d9b1076784f5dc37a964a5e51390da713
+
+    Msg = 0fe1bfee500bdb76026099b1d37553f6bdfe48c82094ef98cb309dd777330bedfaa\
+2f94c823ef74ef4074b50d8706041ac0e371c7c22dcf70263b8d60e17a86c7c379c\
+fda8f22469e0df9d49d59439fc99891873628fff25dda5fac5ac794e948babdde96\
+8143ba05f1128f34fdad5875edc4cd71c6c24ba2060ffbd439ce2b3
+    X = 1d93010c29ecfc432188942f46f19f44f0e1bb5d
+    Y = 6240ea0647117c38fe705106d56db578f3e10130928452d4f3587881b8a2bc6873a8b\
+efc3237f20914e2a91c7f07a928ee22adeed23d74ab7f82ea11f70497e578f7a9b4cb\
+d6f10226222b0b4da2ea1e49813d6bb9882fbf675c0846bb80cc891857b89b0ef1beb\
+6cce3378a9aab5d66ad4cb9277cf447dfe1e64434749432fb
+    R = b5af307867fb8b54390013cc67020ddf1f2c0b81
+    S = 620d3b22ab5031440c3e35eab6f481298f9e9f08
+    Result = P
+
+    Msg = 97d50898025d2f9ba633866e968ca75e969d394edba6517204cb3dd537c2ba38778\
+a2dc9dbc685a915e5676fcd43bc3726bc59ce3d7a9fae35565082a069c139fa37c9\
+0d922b126933db3fa6c5ef6b1edf00d174a51887bb76909c6a94fe994ecc7b7fc8f\
+26113b17f30f9d01693df99a125b4f17e184331c6b6e8ca00f54f3a
+    X = 350e13534692a7e0c4b7d58836046c436fbb2322
+    Y = 69974de550fe6bd3099150faea1623ad3fb6d9bf23a07215093f319725ad0877accff\
+d291b6da18eb0cbe51676ceb0977504eb97c27c0b191883f72fb2710a9fbd8bcf13be\
+0bf854410b32f42b33ec89d3cc1cf892bcd536c4195ca9ada302ad600c3408739935d\
+77dc247529ca47f844cc86f5016a2fe962c6e20ca7c4d4e8f
+    R = b5d05faa7005764e8dae0327c5bf1972ff7681b9
+    S = 18ea15bd9f00475b25204cbc23f8c23e01588015
+    Result = F (3 - R changed )
+
+    [mod = L=2048, N=224, SHA-1]
+
+    # unsupported so we ignore this
+
+    Msg = f9d01693df99a125b4f17e184331c6b6e8ca00f54f3a
+    X = e0c4b7d58836046c436fbb2322
+    Y = fb6d9bf23a07215093f319725ad0877accff
+    R = 5764e8dae0327c5bf1972ff7681b9
+    S = 475b25204cbc23f8c23e01588015
+    Result = F (3 - R changed )
+
+    [mod = L=2048, N=256, SHA-384]
+
+    P = e7c1c86125db9ef417da1ced7ea0861bdad629216a3f3c745df42a46b989e59f4d984\
+25ee3c932fa3c2b6f637bdb6545bec526faa037e11f5578a4363b9fca5eba60d6a9cb\
+aa2befd04141d989c7356285132c2eaf74f2d868521cdc0a17ae9a2546ef863027d3f\
+8cc7949631fd0e2971417a912c8b8c5c989730db6ea6e8baee0e667850429038093c8\
+51ccb6fb173bb081e0efe0bd7450e0946888f89f75e443ab93ef2da293a01622cf43c\
+6dd79625d41ba8f9ef7e3086ab39134283d8e96c89249488120fd061e4a87d34af410\
+69c0b4fd3934c31b589cbe85b68b912718d5dab859fda7082511fad1d152044905005\
+546e19b14aa96585a55269bf2b831
+    Q = 8e056ec9d4b7acb580087a6ed9ba3478711bb025d5b8d9c731ef9b38bd43db2f
+    G = dc2bfb9776786ad310c8b0cdcbba3062402613c67e6959a8d8d1b05aab636528b7b1f\
+e9cd33765f853d6dbe13d09f2681f8c7b1ed7886aaed70c7bd76dbe858ffb8bd86235\
+ddf759244678f428c6519af593dc94eeadbd9852ba2b3d61664e8d58c29d2039af3c3\
+d6d16f90988f6a8c824569f3d48050e30896a9e17cd0232ef01ab8790008f6973b84c\
+763a72f4ae8b485abfb7e8efeb86808fa2b281d3e5d65d28f5992a34c077c5aa8026c\
+b2fbc34a45f7e9bd216b10e6f12ecb172e9a6eb8f2e91316905b6add1fd22e83bc2f0\
+89f1d5e6a6e6707c18ff55ddcb7954e8bceaf0efc4e8314910c03b0e51175f344faaf\
+ee476a373ac95743cec712b72cf2e
+
+    Msg = 6cd6ccfd66bcd832189c5f0c77994210e3bf2c43416f0fe77c4e92f31c5369538dc\
+2c003f146c5ac79df43194ccf3c44d470d9f1083bd15b99b5bcf88c32d8a9021f09\
+ea2288d7b3bf345a12aef3949c1e121b9fb371a67c2d1377364206ac839dd784835\
+61426bda0303f285aa12e9c45d3cdfc6beae3549703b187deeb3296
+    X = 56c897b5938ad5b3d437d7e4826da586a6b3be15e893fa1aaa946f20a028b6b3
+    Y = 38ad44489e1a5778b9689f4dcf40e2acf23840fb954e987d6e8cb629106328ac64e1f\
+3c3eba48b21176ad4afe3b733bead382ee1597e1b83e4b43424f2daaba04e5bd79e14\
+36693ac2bddb79a298f026e57e200a252efd1e848a4a2e90be6e78f5242b468b9c0c6\
+d2615047a5a40b9ae7e57a519114db55bf3bed65e580f894b094630ca9c217f6accd0\
+91e72d2f22da620044ff372d7273f9445017fad492959e59600b7494dbe766a03e401\
+25d4e6747c76f68a5b0cdc0e7d7cee12d08c6fb7d0fb049e420a33405075ed4463296\
+345ca695fb7feab7c1b5333ae519fcd4bb6a043f4555378969114743d4face96cad31\
+c0e0089da4e3f61b6d7dabc088ab7
+    R = 3b85b17be240ed658beb3652c9d93e8e9eea160d35ee2459614305802963374e
+    S = 726800a5174a53b56dce86064109c0273cd11fcfa3c92c5cd6aa910260c0e3c7
+    Result = F (1 - Message changed)
+
+    Msg = 3ad6b0884f358dea09c31a9abc40c45a6000611fc2b907b30eac00413fd2819de70\
+15488a411609d46c499b8f7afa1b78b352ac7f8535bd805b8ff2a5eae557098c668\
+f7ccd73af886d6823a6d456c29931ee864ed46d767382785728c2a83fcff5271007\
+d2a67d06fa205fd7b9d1a42ea5d6dc76e5e18a9eb148cd1e8b262ae
+    X = 2faf566a9f057960f1b50c69508f483d9966d6e35743591f3a677a9dc40e1555
+    Y = 926425d617babe87c442b03903e32ba5bbf0cd9d602b59c4df791a4d64a6d4333ca0c\
+0d370552539197d327dcd1bbf8c454f24b03fc7805f862db34c7b066ddfddbb11dbd0\
+10b27123062d028fe041cb56a2e77488348ae0ab6705d87aac4d4e9e6600e9e706326\
+d9979982cffa839beb9eacc3963bcca455a507e80c1c37ad4e765b2c9c0477a075e9b\
+c584feacdf3a35a9391d4711f14e197c54022282bfed9a191213d64127f17a9c5affe\
+c26e0c71f15d3a5b16098fec118c45bf8bb2f3b1560df0949254c1c0aeb0a16d5a95a\
+40fab8521fbe8ea77c51169b587cc3360e5733e6a23b9fded8c40724ea1f9e93614b3\
+a6c9b4f8dbbe915b794497227ba62
+    R = 343ea0a9e66277380f604d5880fca686bffab69ca97bfba015a102a7e23dce0e
+    S = 6258488c770e0f5ad7b9da8bade5023fc0d17c6ec517bd08d53e6dc01ac5c2b3
+    Result = P
+    """).splitlines()
+
+    expected = [
+        {
+            'p': int('dc5bf3a88b2d99e4c95cdd7a0501cc38630d425cf5c390af3429cff1'
+                     'f35147b795caea923f0d3577158f8a0c89dabd1962c2c453306b5d70'
+                     'cacfb01430aceb54e5a5fa6f9340d3bd2da612fceeb76b0ec1ebfae6'
+                     '35a56ab141b108e00dc76eefe2edd0c514c21c457457c39065dba9d0'
+                     'ecb7569c247172d8438ad2827b60435b', 16),
+            'q': int('e956602b83d195dbe945b3ac702fc61f81571f1d', 16),
+            'g': int('d7eb9ca20a3c7a079606bafc4c9261ccaba303a5dc9fe9953f197dfe'
+                     '548c234895baa77f441ee6a2d97b909cbbd26ff7b869d24cae51b5c6'
+                     'edb127a4b5d75cd8b46608bfa148249dffdb59807c5d7dde3fe3080c'
+                     'a3a2d28312142becb1fa8e24003e21c7287108174b95d5bc711e1c8d'
+                     '9b1076784f5dc37a964a5e51390da713', 16),
+            'digest_algorithm': 'SHA-1',
+            'msg': binascii.unhexlify(
+                b'0fe1bfee500bdb76026099b1d37553f6bdfe48c82094ef98cb309dd77733'
+                b'0bedfaa2f94c823ef74ef4074b50d8706041ac0e371c7c22dcf70263b8d6'
+                b'0e17a86c7c379cfda8f22469e0df9d49d59439fc99891873628fff25dda5'
+                b'fac5ac794e948babdde968143ba05f1128f34fdad5875edc4cd71c6c24ba'
+                b'2060ffbd439ce2b3'),
+            'x': int('1d93010c29ecfc432188942f46f19f44f0e1bb5d', 16),
+            'y': int('6240ea0647117c38fe705106d56db578f3e10130928452d4f3587881'
+                     'b8a2bc6873a8befc3237f20914e2a91c7f07a928ee22adeed23d74ab'
+                     '7f82ea11f70497e578f7a9b4cbd6f10226222b0b4da2ea1e49813d6b'
+                     'b9882fbf675c0846bb80cc891857b89b0ef1beb6cce3378a9aab5d66'
+                     'ad4cb9277cf447dfe1e64434749432fb', 16),
+            'r': int('b5af307867fb8b54390013cc67020ddf1f2c0b81', 16),
+            's': int('620d3b22ab5031440c3e35eab6f481298f9e9f08', 16),
+            'result': 'P'},
+        {
+            'p': int('dc5bf3a88b2d99e4c95cdd7a0501cc38630d425cf5c390af3429cff1'
+                     'f35147b795caea923f0d3577158f8a0c89dabd1962c2c453306b5d70'
+                     'cacfb01430aceb54e5a5fa6f9340d3bd2da612fceeb76b0ec1ebfae6'
+                     '35a56ab141b108e00dc76eefe2edd0c514c21c457457c39065dba9d0'
+                     'ecb7569c247172d8438ad2827b60435b', 16),
+            'q': int('e956602b83d195dbe945b3ac702fc61f81571f1d', 16),
+            'g': int('d7eb9ca20a3c7a079606bafc4c9261ccaba303a5dc9fe9953f197dfe'
+                     '548c234895baa77f441ee6a2d97b909cbbd26ff7b869d24cae51b5c6'
+                     'edb127a4b5d75cd8b46608bfa148249dffdb59807c5d7dde3fe3080c'
+                     'a3a2d28312142becb1fa8e24003e21c7287108174b95d5bc711e1c8d'
+                     '9b1076784f5dc37a964a5e51390da713', 16),
+            'digest_algorithm': 'SHA-1',
+            'msg': binascii.unhexlify(
+                b'97d50898025d2f9ba633866e968ca75e969d394edba6517204cb3dd537c2'
+                b'ba38778a2dc9dbc685a915e5676fcd43bc3726bc59ce3d7a9fae35565082'
+                b'a069c139fa37c90d922b126933db3fa6c5ef6b1edf00d174a51887bb7690'
+                b'9c6a94fe994ecc7b7fc8f26113b17f30f9d01693df99a125b4f17e184331'
+                b'c6b6e8ca00f54f3a'),
+            'x': int('350e13534692a7e0c4b7d58836046c436fbb2322', 16),
+            'y': int('69974de550fe6bd3099150faea1623ad3fb6d9bf23a07215093f3197'
+                     '25ad0877accffd291b6da18eb0cbe51676ceb0977504eb97c27c0b19'
+                     '1883f72fb2710a9fbd8bcf13be0bf854410b32f42b33ec89d3cc1cf8'
+                     '92bcd536c4195ca9ada302ad600c3408739935d77dc247529ca47f84'
+                     '4cc86f5016a2fe962c6e20ca7c4d4e8f', 16),
+            'r': int('b5d05faa7005764e8dae0327c5bf1972ff7681b9', 16),
+            's': int('18ea15bd9f00475b25204cbc23f8c23e01588015', 16),
+            'result': 'F'},
+        {
+            'p': int('e7c1c86125db9ef417da1ced7ea0861bdad629216a3f3c745df42a4'
+                     '6b989e59f4d98425ee3c932fa3c2b6f637bdb6545bec526faa037e1'
+                     '1f5578a4363b9fca5eba60d6a9cbaa2befd04141d989c7356285132'
+                     'c2eaf74f2d868521cdc0a17ae9a2546ef863027d3f8cc7949631fd0'
+                     'e2971417a912c8b8c5c989730db6ea6e8baee0e667850429038093c'
+                     '851ccb6fb173bb081e0efe0bd7450e0946888f89f75e443ab93ef2d'
+                     'a293a01622cf43c6dd79625d41ba8f9ef7e3086ab39134283d8e96c'
+                     '89249488120fd061e4a87d34af41069c0b4fd3934c31b589cbe85b6'
+                     '8b912718d5dab859fda7082511fad1d152044905005546e19b14aa9'
+                     '6585a55269bf2b831', 16),
+            'q': int('8e056ec9d4b7acb580087a6ed9ba3478711bb025d5b8d9c731ef9b3'
+                     '8bd43db2f', 16),
+            'g': int('dc2bfb9776786ad310c8b0cdcbba3062402613c67e6959a8d8d1b05'
+                     'aab636528b7b1fe9cd33765f853d6dbe13d09f2681f8c7b1ed7886a'
+                     'aed70c7bd76dbe858ffb8bd86235ddf759244678f428c6519af593d'
+                     'c94eeadbd9852ba2b3d61664e8d58c29d2039af3c3d6d16f90988f6'
+                     'a8c824569f3d48050e30896a9e17cd0232ef01ab8790008f6973b84'
+                     'c763a72f4ae8b485abfb7e8efeb86808fa2b281d3e5d65d28f5992a'
+                     '34c077c5aa8026cb2fbc34a45f7e9bd216b10e6f12ecb172e9a6eb8'
+                     'f2e91316905b6add1fd22e83bc2f089f1d5e6a6e6707c18ff55ddcb'
+                     '7954e8bceaf0efc4e8314910c03b0e51175f344faafee476a373ac9'
+                     '5743cec712b72cf2e', 16),
+            'digest_algorithm': 'SHA-384',
+            'msg': binascii.unhexlify(
+                b'6cd6ccfd66bcd832189c5f0c77994210e3bf2c43416f0fe77c4e92f31c5'
+                b'369538dc2c003f146c5ac79df43194ccf3c44d470d9f1083bd15b99b5bc'
+                b'f88c32d8a9021f09ea2288d7b3bf345a12aef3949c1e121b9fb371a67c2'
+                b'd1377364206ac839dd78483561426bda0303f285aa12e9c45d3cdfc6bea'
+                b'e3549703b187deeb3296'),
+            'x': int('56c897b5938ad5b3d437d7e4826da586a6b3be15e893fa1aaa946f2'
+                     '0a028b6b3', 16),
+            'y': int('38ad44489e1a5778b9689f4dcf40e2acf23840fb954e987d6e8cb62'
+                     '9106328ac64e1f3c3eba48b21176ad4afe3b733bead382ee1597e1b'
+                     '83e4b43424f2daaba04e5bd79e1436693ac2bddb79a298f026e57e2'
+                     '00a252efd1e848a4a2e90be6e78f5242b468b9c0c6d2615047a5a40'
+                     'b9ae7e57a519114db55bf3bed65e580f894b094630ca9c217f6accd'
+                     '091e72d2f22da620044ff372d7273f9445017fad492959e59600b74'
+                     '94dbe766a03e40125d4e6747c76f68a5b0cdc0e7d7cee12d08c6fb7'
+                     'd0fb049e420a33405075ed4463296345ca695fb7feab7c1b5333ae5'
+                     '19fcd4bb6a043f4555378969114743d4face96cad31c0e0089da4e3'
+                     'f61b6d7dabc088ab7', 16),
+            'r': int('3b85b17be240ed658beb3652c9d93e8e9eea160d35ee24596143058'
+                     '02963374e', 16),
+            's': int('726800a5174a53b56dce86064109c0273cd11fcfa3c92c5cd6aa910'
+                     '260c0e3c7', 16),
+            'result': 'F'},
+        {
+            'p': int('e7c1c86125db9ef417da1ced7ea0861bdad629216a3f3c745df42a4'
+                     '6b989e59f4d98425ee3c932fa3c2b6f637bdb6545bec526faa037e1'
+                     '1f5578a4363b9fca5eba60d6a9cbaa2befd04141d989c7356285132'
+                     'c2eaf74f2d868521cdc0a17ae9a2546ef863027d3f8cc7949631fd0'
+                     'e2971417a912c8b8c5c989730db6ea6e8baee0e667850429038093c'
+                     '851ccb6fb173bb081e0efe0bd7450e0946888f89f75e443ab93ef2d'
+                     'a293a01622cf43c6dd79625d41ba8f9ef7e3086ab39134283d8e96c'
+                     '89249488120fd061e4a87d34af41069c0b4fd3934c31b589cbe85b6'
+                     '8b912718d5dab859fda7082511fad1d152044905005546e19b14aa9'
+                     '6585a55269bf2b831', 16),
+            'q': int('8e056ec9d4b7acb580087a6ed9ba3478711bb025d5b8d9c731ef9b3'
+                     '8bd43db2f', 16),
+            'g': int('dc2bfb9776786ad310c8b0cdcbba3062402613c67e6959a8d8d1b05'
+                     'aab636528b7b1fe9cd33765f853d6dbe13d09f2681f8c7b1ed7886a'
+                     'aed70c7bd76dbe858ffb8bd86235ddf759244678f428c6519af593d'
+                     'c94eeadbd9852ba2b3d61664e8d58c29d2039af3c3d6d16f90988f6'
+                     'a8c824569f3d48050e30896a9e17cd0232ef01ab8790008f6973b84'
+                     'c763a72f4ae8b485abfb7e8efeb86808fa2b281d3e5d65d28f5992a'
+                     '34c077c5aa8026cb2fbc34a45f7e9bd216b10e6f12ecb172e9a6eb8'
+                     'f2e91316905b6add1fd22e83bc2f089f1d5e6a6e6707c18ff55ddcb'
+                     '7954e8bceaf0efc4e8314910c03b0e51175f344faafee476a373ac9'
+                     '5743cec712b72cf2e', 16),
+            'digest_algorithm': 'SHA-384',
+            'msg': binascii.unhexlify(
+                b'3ad6b0884f358dea09c31a9abc40c45a6000611fc2b907b30eac00413fd'
+                b'2819de7015488a411609d46c499b8f7afa1b78b352ac7f8535bd805b8ff'
+                b'2a5eae557098c668f7ccd73af886d6823a6d456c29931ee864ed46d7673'
+                b'82785728c2a83fcff5271007d2a67d06fa205fd7b9d1a42ea5d6dc76e5e'
+                b'18a9eb148cd1e8b262ae'),
+            'x': int('2faf566a9f057960f1b50c69508f483d9966d6e35743591f3a677a9'
+                     'dc40e1555', 16),
+            'y': int('926425d617babe87c442b03903e32ba5bbf0cd9d602b59c4df791a4d'
+                     '64a6d4333ca0c0d370552539197d327dcd1bbf8c454f24b03fc7805f'
+                     '862db34c7b066ddfddbb11dbd010b27123062d028fe041cb56a2e774'
+                     '88348ae0ab6705d87aac4d4e9e6600e9e706326d9979982cffa839be'
+                     'b9eacc3963bcca455a507e80c1c37ad4e765b2c9c0477a075e9bc584'
+                     'feacdf3a35a9391d4711f14e197c54022282bfed9a191213d64127f1'
+                     '7a9c5affec26e0c71f15d3a5b16098fec118c45bf8bb2f3b1560df09'
+                     '49254c1c0aeb0a16d5a95a40fab8521fbe8ea77c51169b587cc3360e'
+                     '5733e6a23b9fded8c40724ea1f9e93614b3a6c9b4f8dbbe915b79449'
+                     '7227ba62', 16),
+            'r': int('343ea0a9e66277380f604d5880fca686bffab69ca97bfba015a102a'
+                     '7e23dce0e', 16),
+            's': int('6258488c770e0f5ad7b9da8bade5023fc0d17c6ec517bd08d53e6dc'
+                     '01ac5c2b3', 16),
+            'result': 'P'}
+    ]
+
+    assert expected == load_fips_dsa_sig_vectors(vector_data)
+
+
+def test_load_fips_dsa_sig_gen_vectors():
+    vector_data = textwrap.dedent("""
+    # CAVS 11.2
+    # "SigGen" information for "dsa2_values"
+    # Mod sizes selected: SHA-1 L=1024, N=160, SHA-256 L=2048, N=256
+
+    [mod = L=1024, N=160, SHA-1]
+
+    P = a8f9cd201e5e35d892f85f80e4db2599a5676a3b1d4f190330ed3256b26d0e80a0e49\
+a8fffaaad2a24f472d2573241d4d6d6c7480c80b4c67bb4479c15ada7ea8424d2502fa01472e7\
+60241713dab025ae1b02e1703a1435f62ddf4ee4c1b664066eb22f2e3bf28bb70a2a76e4fd5eb\
+e2d1229681b5b06439ac9c7e9d8bde283
+    Q = f85f0f83ac4df7ea0cdf8f469bfeeaea14156495
+    G = 2b3152ff6c62f14622b8f48e59f8af46883b38e79b8c74deeae9df131f8b856e3ad6c\
+8455dab87cc0da8ac973417ce4f7878557d6cdf40b35b4a0ca3eb310c6a95d68ce284ad4e25ea\
+28591611ee08b8444bd64b25f3f7c572410ddfb39cc728b9c936f85f419129869929cdb909a6a\
+3a99bbe089216368171bd0ba81de4fe33
+
+    Msg = 3b46736d559bd4e0c2c1b2553a33ad3c6cf23cac998d3d0c0e8fa4b19bca06f2f38\
+6db2dcff9dca4f40ad8f561ffc308b46c5f31a7735b5fa7e0f9e6cb512e63d7eea05538d66a75\
+cd0d4234b5ccf6c1715ccaaf9cdc0a2228135f716ee9bdee7fc13ec27a03a6d11c5c5b3685f51\
+900b1337153bc6c4e8f52920c33fa37f4e7
+    Y = 313fd9ebca91574e1c2eebe1517c57e0c21b0209872140c5328761bbb2450b33f1b18\
+b409ce9ab7c4cd8fda3391e8e34868357c199e16a6b2eba06d6749def791d79e95d3a4d09b24c\
+392ad89dbf100995ae19c01062056bb14bce005e8731efde175f95b975089bdcdaea562b32786\
+d96f5a31aedf75364008ad4fffebb970b
+    R = 50ed0e810e3f1c7cb6ac62332058448bd8b284c0
+    S = c6aded17216b46b7e4b6f2a97c1ad7cc3da83fde
+
+    Msg = d2bcb53b044b3e2e4b61ba2f91c0995fb83a6a97525e66441a3b489d9594238bc74\
+0bdeea0f718a769c977e2de003877b5d7dc25b182ae533db33e78f2c3ff0645f2137abc137d4e\
+7d93ccf24f60b18a820bc07c7b4b5fe08b4f9e7d21b256c18f3b9d49acc4f93e2ce6f3754c780\
+7757d2e1176042612cb32fc3f4f70700e25
+    Y = 29bdd759aaa62d4bf16b4861c81cf42eac2e1637b9ecba512bdbc13ac12a80ae8de25\
+26b899ae5e4a231aef884197c944c732693a634d7659abc6975a773f8d3cd5a361fe2492386a3\
+c09aaef12e4a7e73ad7dfc3637f7b093f2c40d6223a195c136adf2ea3fbf8704a675aa7817aa7\
+ec7f9adfb2854d4e05c3ce7f76560313b
+    R = a26c00b5750a2d27fe7435b93476b35438b4d8ab
+    S = 61c9bfcb2938755afa7dad1d1e07c6288617bf70
+
+    [mod = L=2048, N=256, SHA-256]
+
+    P = a8adb6c0b4cf9588012e5deff1a871d383e0e2a85b5e8e03d814fe13a059705e66323\
+0a377bf7323a8fa117100200bfd5adf857393b0bbd67906c081e585410e38480ead51684dac3a\
+38f7b64c9eb109f19739a4517cd7d5d6291e8af20a3fbf17336c7bf80ee718ee087e322ee4104\
+7dabefbcc34d10b66b644ddb3160a28c0639563d71993a26543eadb7718f317bf5d9577a61565\
+61b082a10029cd44012b18de6844509fe058ba87980792285f2750969fe89c2cd6498db354563\
+8d5379d125dccf64e06c1af33a6190841d223da1513333a7c9d78462abaab31b9f96d5f34445c\
+eb6309f2f6d2c8dde06441e87980d303ef9a1ff007e8be2f0be06cc15f
+    Q = e71f8567447f42e75f5ef85ca20fe557ab0343d37ed09edc3f6e68604d6b9dfb
+    G = 5ba24de9607b8998e66ce6c4f812a314c6935842f7ab54cd82b19fa104abfb5d84579\
+a623b2574b37d22ccae9b3e415e48f5c0f9bcbdff8071d63b9bb956e547af3a8df99e5d306197\
+9652ff96b765cb3ee493643544c75dbe5bb39834531952a0fb4b0378b3fcbb4c8b5800a533039\
+2a2a04e700bb6ed7e0b85795ea38b1b962741b3f33b9dde2f4ec1354f09e2eb78e95f037a5804\
+b6171659f88715ce1a9b0cc90c27f35ef2f10ff0c7c7a2bb0154d9b8ebe76a3d764aa879af372\
+f4240de8347937e5a90cec9f41ff2f26b8da9a94a225d1a913717d73f10397d2183f1ba3b7b45\
+a68f1ff1893caf69a827802f7b6a48d51da6fbefb64fd9a6c5b75c4561
+
+    Msg = 4e3a28bcf90d1d2e75f075d9fbe55b36c5529b17bc3a9ccaba6935c9e20548255b3\
+dfae0f91db030c12f2c344b3a29c4151c5b209f5e319fdf1c23b190f64f1fe5b330cb7c8fa952\
+f9d90f13aff1cb11d63181da9efc6f7e15bfed4862d1a62c7dcf3ba8bf1ff304b102b1ec3f149\
+7dddf09712cf323f5610a9d10c3d9132659
+    Y = 5a55dceddd1134ee5f11ed85deb4d634a3643f5f36dc3a70689256469a0b651ad2288\
+0f14ab85719434f9c0e407e60ea420e2a0cd29422c4899c416359dbb1e592456f2b3cce233259\
+c117542fd05f31ea25b015d9121c890b90e0bad033be1368d229985aac7226d1c8c2eab325ef3\
+b2cd59d3b9f7de7dbc94af1a9339eb430ca36c26c46ecfa6c5481711496f624e188ad7540ef5d\
+f26f8efacb820bd17a1f618acb50c9bc197d4cb7ccac45d824a3bf795c234b556b06aeb929173\
+453252084003f69fe98045fe74002ba658f93475622f76791d9b2623d1b5fff2cc16844746efd\
+2d30a6a8134bfc4c8cc80a46107901fb973c28fc553130f3286c1489da
+    R = 633055e055f237c38999d81c397848c38cce80a55b649d9e7905c298e2a51447
+    S = 2bbf68317660ec1e4b154915027b0bc00ee19cfc0bf75d01930504f2ce10a8b0
+
+    Msg = a733b3f588d5ac9b9d4fe2f804df8c256403a9f8eef6f191fc48e1267fb5b4d546b\
+a11e77b667844e489bf0d5f72990aeb061d01ccd7949a23def74a803b7d92d51abfadeb4885ff\
+d8ffd58ab87548a15c087a39b8993b2fa64c9d31a594eeb7512da16955834336a234435c5a9d0\
+dd9b15a94e116154dea63fdc8dd7a512181
+    Y = 356ed47537fbf02cb30a8cee0537f300dff1d0c467399ce70b87a8758d5ec9dd25624\
+6fccaeb9dfe109f2a984f2ddaa87aad54ce0d31f907e504521baf4207d7073b0a4a9fc67d8ddd\
+a99f87aed6e0367cec27f9c608af743bf1ee6e11d55a182d43b024ace534029b866f6422828bb\
+81a39aae9601ee81c7f81dd358e69f4e2edfa4654d8a65bc64311dc86aac4abc1fc7a3f651596\
+61a0d8e288eb8d665cb0adf5ac3d6ba8e9453facf7542393ae24fd50451d3828086558f7ec528\
+e284935a53f67a1aa8e25d8ad5c4ad55d83aef883a4d9eeb6297e6a53f65049ba9e2c6b7953a7\
+60bc1dc46f78ceaaa2c02f5375dd82e708744aa40b15799eb81d7e5b1a
+    R = bcd490568c0a89ba311bef88ea4f4b03d273e793722722327095a378dd6f3522
+    S = 74498fc43091fcdd2d1ef0775f8286945a01cd72b805256b0451f9cbd943cf82
+    """).splitlines()
+
+    expected = [
+        {
+            'p': int('a8f9cd201e5e35d892f85f80e4db2599a5676a3b1d4f190330ed325'
+                     '6b26d0e80a0e49a8fffaaad2a24f472d2573241d4d6d6c7480c80b4'
+                     'c67bb4479c15ada7ea8424d2502fa01472e760241713dab025ae1b0'
+                     '2e1703a1435f62ddf4ee4c1b664066eb22f2e3bf28bb70a2a76e4fd'
+                     '5ebe2d1229681b5b06439ac9c7e9d8bde283', 16),
+            'q': int('f85f0f83ac4df7ea0cdf8f469bfeeaea14156495', 16),
+            'g': int('2b3152ff6c62f14622b8f48e59f8af46883b38e79b8c74deeae9df1'
+                     '31f8b856e3ad6c8455dab87cc0da8ac973417ce4f7878557d6cdf40'
+                     'b35b4a0ca3eb310c6a95d68ce284ad4e25ea28591611ee08b8444bd'
+                     '64b25f3f7c572410ddfb39cc728b9c936f85f419129869929cdb909'
+                     'a6a3a99bbe089216368171bd0ba81de4fe33', 16),
+            'digest_algorithm': 'SHA-1',
+            'msg': binascii.unhexlify(
+                b'3b46736d559bd4e0c2c1b2553a33ad3c6cf23cac998d3d0c0e8fa4b19bc'
+                b'a06f2f386db2dcff9dca4f40ad8f561ffc308b46c5f31a7735b5fa7e0f9'
+                b'e6cb512e63d7eea05538d66a75cd0d4234b5ccf6c1715ccaaf9cdc0a222'
+                b'8135f716ee9bdee7fc13ec27a03a6d11c5c5b3685f51900b1337153bc6c'
+                b'4e8f52920c33fa37f4e7'),
+            'y': int('313fd9ebca91574e1c2eebe1517c57e0c21b0209872140c5328761b'
+                     'bb2450b33f1b18b409ce9ab7c4cd8fda3391e8e34868357c199e16a'
+                     '6b2eba06d6749def791d79e95d3a4d09b24c392ad89dbf100995ae1'
+                     '9c01062056bb14bce005e8731efde175f95b975089bdcdaea562b32'
+                     '786d96f5a31aedf75364008ad4fffebb970b', 16),
+            'r': int('50ed0e810e3f1c7cb6ac62332058448bd8b284c0', 16),
+            's': int('c6aded17216b46b7e4b6f2a97c1ad7cc3da83fde', 16)},
+        {
+            'p': int('a8f9cd201e5e35d892f85f80e4db2599a5676a3b1d4f190330ed325'
+                     '6b26d0e80a0e49a8fffaaad2a24f472d2573241d4d6d6c7480c80b4'
+                     'c67bb4479c15ada7ea8424d2502fa01472e760241713dab025ae1b0'
+                     '2e1703a1435f62ddf4ee4c1b664066eb22f2e3bf28bb70a2a76e4fd'
+                     '5ebe2d1229681b5b06439ac9c7e9d8bde283', 16),
+            'q': int('f85f0f83ac4df7ea0cdf8f469bfeeaea14156495', 16),
+            'g': int('2b3152ff6c62f14622b8f48e59f8af46883b38e79b8c74deeae9df1'
+                     '31f8b856e3ad6c8455dab87cc0da8ac973417ce4f7878557d6cdf40'
+                     'b35b4a0ca3eb310c6a95d68ce284ad4e25ea28591611ee08b8444bd'
+                     '64b25f3f7c572410ddfb39cc728b9c936f85f419129869929cdb909'
+                     'a6a3a99bbe089216368171bd0ba81de4fe33', 16),
+            'digest_algorithm': 'SHA-1',
+            'msg': binascii.unhexlify(
+                b'd2bcb53b044b3e2e4b61ba2f91c0995fb83a6a97525e66441a3b489d959'
+                b'4238bc740bdeea0f718a769c977e2de003877b5d7dc25b182ae533db33e'
+                b'78f2c3ff0645f2137abc137d4e7d93ccf24f60b18a820bc07c7b4b5fe08'
+                b'b4f9e7d21b256c18f3b9d49acc4f93e2ce6f3754c7807757d2e11760426'
+                b'12cb32fc3f4f70700e25'),
+            'y': int('29bdd759aaa62d4bf16b4861c81cf42eac2e1637b9ecba512bdbc13'
+                     'ac12a80ae8de2526b899ae5e4a231aef884197c944c732693a634d7'
+                     '659abc6975a773f8d3cd5a361fe2492386a3c09aaef12e4a7e73ad7'
+                     'dfc3637f7b093f2c40d6223a195c136adf2ea3fbf8704a675aa7817'
+                     'aa7ec7f9adfb2854d4e05c3ce7f76560313b', 16),
+            'r': int('a26c00b5750a2d27fe7435b93476b35438b4d8ab', 16),
+            's': int('61c9bfcb2938755afa7dad1d1e07c6288617bf70', 16)},
+        {
+            'p': int('a8adb6c0b4cf9588012e5deff1a871d383e0e2a85b5e8e03d814fe1'
+                     '3a059705e663230a377bf7323a8fa117100200bfd5adf857393b0bb'
+                     'd67906c081e585410e38480ead51684dac3a38f7b64c9eb109f1973'
+                     '9a4517cd7d5d6291e8af20a3fbf17336c7bf80ee718ee087e322ee4'
+                     '1047dabefbcc34d10b66b644ddb3160a28c0639563d71993a26543e'
+                     'adb7718f317bf5d9577a6156561b082a10029cd44012b18de684450'
+                     '9fe058ba87980792285f2750969fe89c2cd6498db3545638d5379d1'
+                     '25dccf64e06c1af33a6190841d223da1513333a7c9d78462abaab31'
+                     'b9f96d5f34445ceb6309f2f6d2c8dde06441e87980d303ef9a1ff00'
+                     '7e8be2f0be06cc15f', 16),
+            'q': int('e71f8567447f42e75f5ef85ca20fe557ab0343d37ed09edc3f6e686'
+                     '04d6b9dfb', 16),
+            'g': int('5ba24de9607b8998e66ce6c4f812a314c6935842f7ab54cd82b19fa'
+                     '104abfb5d84579a623b2574b37d22ccae9b3e415e48f5c0f9bcbdff'
+                     '8071d63b9bb956e547af3a8df99e5d3061979652ff96b765cb3ee49'
+                     '3643544c75dbe5bb39834531952a0fb4b0378b3fcbb4c8b5800a533'
+                     '0392a2a04e700bb6ed7e0b85795ea38b1b962741b3f33b9dde2f4ec'
+                     '1354f09e2eb78e95f037a5804b6171659f88715ce1a9b0cc90c27f3'
+                     '5ef2f10ff0c7c7a2bb0154d9b8ebe76a3d764aa879af372f4240de8'
+                     '347937e5a90cec9f41ff2f26b8da9a94a225d1a913717d73f10397d'
+                     '2183f1ba3b7b45a68f1ff1893caf69a827802f7b6a48d51da6fbefb'
+                     '64fd9a6c5b75c4561', 16),
+            'digest_algorithm': 'SHA-256',
+            'msg': binascii.unhexlify(
+                b'4e3a28bcf90d1d2e75f075d9fbe55b36c5529b17bc3a9ccaba6935c9e20'
+                b'548255b3dfae0f91db030c12f2c344b3a29c4151c5b209f5e319fdf1c23'
+                b'b190f64f1fe5b330cb7c8fa952f9d90f13aff1cb11d63181da9efc6f7e1'
+                b'5bfed4862d1a62c7dcf3ba8bf1ff304b102b1ec3f1497dddf09712cf323'
+                b'f5610a9d10c3d9132659'),
+            'y': int('5a55dceddd1134ee5f11ed85deb4d634a3643f5f36dc3a706892564'
+                     '69a0b651ad22880f14ab85719434f9c0e407e60ea420e2a0cd29422'
+                     'c4899c416359dbb1e592456f2b3cce233259c117542fd05f31ea25b'
+                     '015d9121c890b90e0bad033be1368d229985aac7226d1c8c2eab325'
+                     'ef3b2cd59d3b9f7de7dbc94af1a9339eb430ca36c26c46ecfa6c548'
+                     '1711496f624e188ad7540ef5df26f8efacb820bd17a1f618acb50c9'
+                     'bc197d4cb7ccac45d824a3bf795c234b556b06aeb92917345325208'
+                     '4003f69fe98045fe74002ba658f93475622f76791d9b2623d1b5fff'
+                     '2cc16844746efd2d30a6a8134bfc4c8cc80a46107901fb973c28fc5'
+                     '53130f3286c1489da', 16),
+            'r': int('633055e055f237c38999d81c397848c38cce80a55b649d9e7905c29'
+                     '8e2a51447', 16),
+            's': int('2bbf68317660ec1e4b154915027b0bc00ee19cfc0bf75d01930504f'
+                     '2ce10a8b0', 16)},
+        {
+            'p': int('a8adb6c0b4cf9588012e5deff1a871d383e0e2a85b5e8e03d814fe1'
+                     '3a059705e663230a377bf7323a8fa117100200bfd5adf857393b0bb'
+                     'd67906c081e585410e38480ead51684dac3a38f7b64c9eb109f1973'
+                     '9a4517cd7d5d6291e8af20a3fbf17336c7bf80ee718ee087e322ee4'
+                     '1047dabefbcc34d10b66b644ddb3160a28c0639563d71993a26543e'
+                     'adb7718f317bf5d9577a6156561b082a10029cd44012b18de684450'
+                     '9fe058ba87980792285f2750969fe89c2cd6498db3545638d5379d1'
+                     '25dccf64e06c1af33a6190841d223da1513333a7c9d78462abaab31'
+                     'b9f96d5f34445ceb6309f2f6d2c8dde06441e87980d303ef9a1ff00'
+                     '7e8be2f0be06cc15f', 16),
+            'q': int('e71f8567447f42e75f5ef85ca20fe557ab0343d37ed09edc3f6e686'
+                     '04d6b9dfb', 16),
+            'g': int('5ba24de9607b8998e66ce6c4f812a314c6935842f7ab54cd82b19fa'
+                     '104abfb5d84579a623b2574b37d22ccae9b3e415e48f5c0f9bcbdff'
+                     '8071d63b9bb956e547af3a8df99e5d3061979652ff96b765cb3ee49'
+                     '3643544c75dbe5bb39834531952a0fb4b0378b3fcbb4c8b5800a533'
+                     '0392a2a04e700bb6ed7e0b85795ea38b1b962741b3f33b9dde2f4ec'
+                     '1354f09e2eb78e95f037a5804b6171659f88715ce1a9b0cc90c27f3'
+                     '5ef2f10ff0c7c7a2bb0154d9b8ebe76a3d764aa879af372f4240de8'
+                     '347937e5a90cec9f41ff2f26b8da9a94a225d1a913717d73f10397d'
+                     '2183f1ba3b7b45a68f1ff1893caf69a827802f7b6a48d51da6fbefb'
+                     '64fd9a6c5b75c4561', 16),
+            'digest_algorithm': 'SHA-256',
+            'msg': binascii.unhexlify(
+                b'a733b3f588d5ac9b9d4fe2f804df8c256403a9f8eef6f191fc48e1267fb'
+                b'5b4d546ba11e77b667844e489bf0d5f72990aeb061d01ccd7949a23def7'
+                b'4a803b7d92d51abfadeb4885ffd8ffd58ab87548a15c087a39b8993b2fa'
+                b'64c9d31a594eeb7512da16955834336a234435c5a9d0dd9b15a94e11615'
+                b'4dea63fdc8dd7a512181'),
+            'y': int('356ed47537fbf02cb30a8cee0537f300dff1d0c467399ce70b87a87'
+                     '58d5ec9dd256246fccaeb9dfe109f2a984f2ddaa87aad54ce0d31f9'
+                     '07e504521baf4207d7073b0a4a9fc67d8ddda99f87aed6e0367cec2'
+                     '7f9c608af743bf1ee6e11d55a182d43b024ace534029b866f642282'
+                     '8bb81a39aae9601ee81c7f81dd358e69f4e2edfa4654d8a65bc6431'
+                     '1dc86aac4abc1fc7a3f65159661a0d8e288eb8d665cb0adf5ac3d6b'
+                     'a8e9453facf7542393ae24fd50451d3828086558f7ec528e284935a'
+                     '53f67a1aa8e25d8ad5c4ad55d83aef883a4d9eeb6297e6a53f65049'
+                     'ba9e2c6b7953a760bc1dc46f78ceaaa2c02f5375dd82e708744aa40'
+                     'b15799eb81d7e5b1a', 16),
+            'r': int('bcd490568c0a89ba311bef88ea4f4b03d273e793722722327095a37'
+                     '8dd6f3522', 16),
+            's': int('74498fc43091fcdd2d1ef0775f8286945a01cd72b805256b0451f9c'
+                     'bd943cf82', 16)}
+    ]
+    assert expected == load_fips_dsa_sig_vectors(vector_data)
+
+
+def test_load_fips_ecdsa_key_pair_vectors():
+    vector_data = textwrap.dedent("""
+    #  CAVS 11.0
+    #  "Key Pair" information
+    #  Curves selected: P-192 K-233 B-571
+    #  Generated on Wed Mar 16 16:16:42 2011
+
+
+    [P-192]
+
+    [B.4.2 Key Pair Generation by Testing Candidates]
+    N = 2
+
+    d = e5ce89a34adddf25ff3bf1ffe6803f57d0220de3118798ea
+    Qx = 8abf7b3ceb2b02438af19543d3e5b1d573fa9ac60085840f
+    Qy = a87f80182dcd56a6a061f81f7da393e7cffd5e0738c6b245
+
+    d = 7d14435714ad13ff23341cb567cc91198ff8617cc39751b2
+    Qx = 39dc723b19527daa1e80425209c56463481b9b47c51f8cbd
+    Qy = 432a3e84f2a16418834fabaf6b7d2341669512951f1672ad
+
+
+    [K-233]
+
+    [B.4.2 Key Pair Generation by Testing Candidates]
+    N = 2
+
+    d = 01da7422b50e3ff051f2aaaed10acea6cbf6110c517da2f4eaca8b5b87
+    Qx = 01c7475da9a161e4b3f7d6b086494063543a979e34b8d7ac44204d47bf9f
+    Qy = 0131cbd433f112871cc175943991b6a1350bf0cdd57ed8c831a2a7710c92
+
+    d = 530951158f7b1586978c196603c12d25607d2cb0557efadb23cd0ce8
+    Qx = d37500a0391d98d3070d493e2b392a2c79dc736c097ed24b7dd5ddec44
+    Qy = 01d996cc79f37d8dba143d4a8ad9a8a60ed7ea760aae1ddba34d883f65d9
+
+
+    [B-571]
+
+    [B.4.2 Key Pair Generation by Testing Candidates]
+    N = 2
+
+    d = 01443e93c7ef6802655f641ecbe95e75f1f15b02d2e172f49a32e22047d5c00ebe1b3f\
+f0456374461360667dbf07bc67f7d6135ee0d1d46a226a530fefe8ebf3b926e9fbad8d57a6
+    Qx = 053e3710d8e7d4138db0a369c97e5332c1be38a20a4a84c36f5e55ea9fd6f34545b86\
+4ea64f319e74b5ee9e4e1fa1b7c5b2db0e52467518f8c45b658824871d5d4025a6320ca06f8
+    Qy = 03a22cfd370c4a449b936ae97ab97aab11c57686cca99d14ef184f9417fad8bedae4d\
+f8357e3710bcda1833b30e297d4bf637938b995d231e557d13f062e81e830af5ab052208ead
+
+    d = 03d2bd44ca9eeee8c860a4873ed55a54bdfdf5dab4060df7292877960b85d1fd496aa3\
+3c587347213d7f6bf208a6ab4b430546e7b6ffbc3135bd12f44a28517867ca3c83a821d6f8
+    Qx = 07a7af10f6617090bade18b2e092d0dfdc87cd616db7f2db133477a82bfe3ea421ebb\
+7d6289980819292a719eb247195529ea60ad62862de0a26c72bfc49ecc81c2f9ed704e3168f
+    Qy = 0721496cf16f988b1aabef3368450441df8439a0ca794170f270ead56203d675b57f5\
+a4090a3a2f602a77ff3bac1417f7e25a683f667b3b91f105016a47afad46a0367b18e2bdf0c
+    """).splitlines()
+
+    expected = [
+        {
+            "curve": "secp192r1",
+            "d": int("e5ce89a34adddf25ff3bf1ffe6803f57d0220de3118798ea", 16),
+            "x": int("8abf7b3ceb2b02438af19543d3e5b1d573fa9ac60085840f", 16),
+            "y": int("a87f80182dcd56a6a061f81f7da393e7cffd5e0738c6b245", 16)
+        },
+
+        {
+            "curve": "secp192r1",
+            "d": int("7d14435714ad13ff23341cb567cc91198ff8617cc39751b2", 16),
+            "x": int("39dc723b19527daa1e80425209c56463481b9b47c51f8cbd", 16),
+            "y": int("432a3e84f2a16418834fabaf6b7d2341669512951f1672ad", 16),
+        },
+
+        {
+            "curve": "sect233k1",
+            "d": int("1da7422b50e3ff051f2aaaed10acea6cbf6110c517da2f4e"
+                     "aca8b5b87", 16),
+            "x": int("1c7475da9a161e4b3f7d6b086494063543a979e34b8d7ac4"
+                     "4204d47bf9f", 16),
+            "y": int("131cbd433f112871cc175943991b6a1350bf0cdd57ed8c83"
+                     "1a2a7710c92", 16),
+        },
+
+        {
+            "curve": "sect233k1",
+            "d": int("530951158f7b1586978c196603c12d25607d2cb0557efadb"
+                     "23cd0ce8", 16),
+            "x": int("d37500a0391d98d3070d493e2b392a2c79dc736c097ed24b"
+                     "7dd5ddec44", 16),
+            "y": int("1d996cc79f37d8dba143d4a8ad9a8a60ed7ea760aae1ddba"
+                     "34d883f65d9", 16),
+        },
+
+        {
+            "curve": "sect571r1",
+            "d": int("1443e93c7ef6802655f641ecbe95e75f1f15b02d2e172f49"
+                     "a32e22047d5c00ebe1b3ff0456374461360667dbf07bc67f"
+                     "7d6135ee0d1d46a226a530fefe8ebf3b926e9fbad8d57a6", 16),
+            "x": int("53e3710d8e7d4138db0a369c97e5332c1be38a20a4a84c36"
+                     "f5e55ea9fd6f34545b864ea64f319e74b5ee9e4e1fa1b7c5"
+                     "b2db0e52467518f8c45b658824871d5d4025a6320ca06f8", 16),
+            "y": int("3a22cfd370c4a449b936ae97ab97aab11c57686cca99d14e"
+                     "f184f9417fad8bedae4df8357e3710bcda1833b30e297d4b"
+                     "f637938b995d231e557d13f062e81e830af5ab052208ead", 16),
+        },
+
+        {
+            "curve": "sect571r1",
+            "d": int("3d2bd44ca9eeee8c860a4873ed55a54bdfdf5dab4060df72"
+                     "92877960b85d1fd496aa33c587347213d7f6bf208a6ab4b4"
+                     "30546e7b6ffbc3135bd12f44a28517867ca3c83a821d6f8", 16),
+            "x": int("7a7af10f6617090bade18b2e092d0dfdc87cd616db7f2db1"
+                     "33477a82bfe3ea421ebb7d6289980819292a719eb2471955"
+                     "29ea60ad62862de0a26c72bfc49ecc81c2f9ed704e3168f", 16),
+            "y": int("721496cf16f988b1aabef3368450441df8439a0ca794170f"
+                     "270ead56203d675b57f5a4090a3a2f602a77ff3bac1417f7"
+                     "e25a683f667b3b91f105016a47afad46a0367b18e2bdf0c", 16),
+        },
+    ]
+
+    assert expected == load_fips_ecdsa_key_pair_vectors(vector_data)
+
+
+def test_load_fips_ecdsa_signing_vectors():
+    vector_data = textwrap.dedent("""
+    #  CAVS 11.2
+    #  "SigVer" information for "ecdsa_values"
+    #  Curves/SHAs selected: P-192, B-571,SHA-512
+    #  Generated on Tue Aug 16 15:27:42 2011
+
+    [P-192,SHA-1]
+
+    Msg = ebf748d748ebbca7d29fb473698a6e6b4fb10c865d4af024cc39ae3df3464ba4f1d6\
+d40f32bf9618a91bb5986fa1a2af048a0e14dc51e5267eb05e127d689d0ac6f1a7f156ce066316\
+b971cc7a11d0fd7a2093e27cf2d08727a4e6748cc32fd59c7810c5b9019df21cdcc0bca432c0a3\
+eed0785387508877114359cee4a071cf
+    d = e14f37b3d1374ff8b03f41b9b3fdd2f0ebccf275d660d7f3
+    Qx = 07008ea40b08dbe76432096e80a2494c94982d2d5bcf98e6
+    Qy = 76fab681d00b414ea636ba215de26d98c41bd7f2e4d65477
+    k = cb0abc7043a10783684556fb12c4154d57bc31a289685f25
+    R = 6994d962bdd0d793ffddf855ec5bf2f91a9698b46258a63e
+    S = 02ba6465a234903744ab02bc8521405b73cf5fc00e1a9f41
+    Result = F (3 - S changed)
+
+    Msg = 0dcb3e96d77ee64e9d0a350d31563d525755fc675f0c833504e83fc69c030181b42f\
+e80c378e86274a93922c570d54a7a358c05755ec3ae91928e02236e81b43e596e4ccbf6a910488\
+9c388072bec4e1faeae11fe4eb24fa4f9573560dcf2e3abc703c526d46d502c7a7222583431cc8\
+178354ae7dbb84e3479917707bce0968
+    d = 7a0235bea3d70445f14d56f9b7fb80ec8ff4eb2f76865244
+    Qx = 0ea3c1fa1f124f26530cbfddeb831eecc67df31e08889d1d
+    Qy = 7215a0cce0501b47903bd8fe1179c2dfe07bd076f89f5225
+    k = 3c646b0f03f5575e5fd463d4319817ce8bd3022eaf551cef
+    R = a3ba51c39c43991d87dff0f34d0bec7c883299e04f60f95e
+    S = 8a7f9c59c6d65ad390e4c19636ba92b53be5d0f848b4e1f7
+
+    [B-571,SHA-512]
+
+    Msg = 10d2e00ae57176c79cdfc746c0c887abe799ee445b151b008e3d9f81eb69be40298d\
+df37b5c45a9b6e5ff83785d8c140cf11e6a4c3879a2845796872363da24b10f1f8d9cc48f8af20\
+681dceb60dd62095d6d3b1779a4a805de3d74e38983b24c0748618e2f92ef7cac257ff4bd1f411\
+13f2891eb13c47930e69ddbe91f270fb
+    d = 03e1b03ffca4399d5b439fac8f87a5cb06930f00d304193d7daf83d5947d0c1e293f74\
+aef8e56849f16147133c37a6b3d1b1883e5d61d6b871ea036c5291d9a74541f28878cb986
+    Qx = 3b236fc135d849d50140fdaae1045e6ae35ef61091e98f5059b30eb16acdd0deb2bc0\
+d3544bc3a666e0014e50030134fe5466a9e4d3911ed580e28851f3747c0010888e819d3d1f
+    Qy = 3a8b6627a587d289032bd76374d16771188d7ff281c39542c8977f6872fa932e5daa1\
+4e13792dea9ffe8e9f68d6b525ec99b81a5a60cfb0590cc6f297cfff8d7ba1a8bb81fe2e16
+    k = 2e56a94cfbbcd293e242f0c2a2e9df289a9480e6ba52e0f00fa19bcf2a7769bd155e6b\
+79ddbd6a8646b0e69c8baea27f8034a18796e8eb4fe6e0e2358c383521d9375d2b6b437f9
+    R = 2eb1c5c1fc93cf3c8babed12c031cf1504e094174fd335104cbe4a2abd210b5a14b1c3\
+a455579f1ed0517c31822340e4dd3c1f967e1b4b9d071a1072afc1a199f8c548cd449a634
+    S = 22f97bb48641235826cf4e597fa8de849402d6bd6114ad2d7fbcf53a08247e5ee921f1\
+bd5994dffee36eedff5592bb93b8bb148214da3b7baebffbd96b4f86c55b3f6bbac142442
+    Result = P (0 )
+
+    Msg = b61a0849a28672cb536fcf61ea2eb389d02ff7a09aa391744cae6597bd56703c40c5\
+0ca2dee5f7ee796acfd47322f03d8dbe4d99dc8eec588b4e5467f123075b2d74b2a0b0bbfd3ac5\
+487a905fad6d6ac1421c2e564c0cf15e1f0f10bc31c249b7b46edd2462a55f85560d99bde9d5b0\
+6b97817d1dbe0a67c701d6e6e7878272
+    d = 2e09ffd8b434bb7f67d1d3ccf482164f1653c6e4ec64dec2517aa21b7a93b2b21ea1ee\
+bb54734882f29303e489f02e3b741a87287e2dcdf3858eb6d2ec668f8b5b26f442ce513a2
+    Qx = 36f1be8738dd7dae4486b86a08fe90424f3673e76b10e739442e15f3bfafaf841842a\
+c98e490521b7e7bb94c127529f6ec6a42cc6f06fc80606f1210fe020ff508148f93301c9d3
+    Qy = 4d39666ebe99fe214336ad440d776c88eb916f2f4a3433548b87d2aebed840b424d15\
+c8341b4a0a657bf6a234d4fe78631c8e07ac1f4dc7474cd6b4545d536b7b17c160db4562d9
+    k = 378e7801566d7b77db7a474717ab2195b02957cc264a9449d4126a7cc574728ed5a476\
+9abd5dde987ca66cfe3d45b5fc52ffd266acb8a8bb3fcb4b60f7febbf48aebe33bd3efbdd
+    R = 3d8105f87fe3166046c08e80a28acc98a80b8b7a729623053c2a9e80afd06756edfe09\
+bdcf3035f6829ede041b745955d219dc5d30ddd8b37f6ba0f6d2857504cdc68a1ed812a10
+    S = 34db9998dc53527114518a7ce3783d674ca8cced823fa05e2942e7a0a20b3cc583dcd9\
+30c43f9b93079c5ee18a1f5a66e7c3527c18610f9b47a4da7e245ef803e0662e4d2ad721c
+    """).splitlines()
+
+    expected = [
+        {
+            "curve": "secp192r1",
+            "digest_algorithm": "SHA-1",
+            "message": binascii.unhexlify(
+                b"ebf748d748ebbca7d29fb473698a6e6b4fb10c865d4af024cc39ae3df346"
+                b"4ba4f1d6d40f32bf9618a91bb5986fa1a2af048a0e14dc51e5267eb05e12"
+                b"7d689d0ac6f1a7f156ce066316b971cc7a11d0fd7a2093e27cf2d08727a4"
+                b"e6748cc32fd59c7810c5b9019df21cdcc0bca432c0a3eed0785387508877"
+                b"114359cee4a071cf"
+            ),
+            "d": int("e14f37b3d1374ff8b03f41b9b3fdd2f0ebccf275d660d7f3", 16),
+            "x": int("7008ea40b08dbe76432096e80a2494c94982d2d5bcf98e6", 16),
+            "y": int("76fab681d00b414ea636ba215de26d98c41bd7f2e4d65477", 16),
+            "r": int("6994d962bdd0d793ffddf855ec5bf2f91a9698b46258a63e", 16),
+            "s": int("02ba6465a234903744ab02bc8521405b73cf5fc00e1a9f41", 16),
+            "fail": True
+        },
+        {
+            "curve": "secp192r1",
+            "digest_algorithm": "SHA-1",
+            "message": binascii.unhexlify(
+                b"0dcb3e96d77ee64e9d0a350d31563d525755fc675f0c833504e83fc69c03"
+                b"0181b42fe80c378e86274a93922c570d54a7a358c05755ec3ae91928e022"
+                b"36e81b43e596e4ccbf6a9104889c388072bec4e1faeae11fe4eb24fa4f95"
+                b"73560dcf2e3abc703c526d46d502c7a7222583431cc8178354ae7dbb84e3"
+                b"479917707bce0968"
+            ),
+            "d": int("7a0235bea3d70445f14d56f9b7fb80ec8ff4eb2f76865244", 16),
+            "x": int("ea3c1fa1f124f26530cbfddeb831eecc67df31e08889d1d", 16),
+            "y": int("7215a0cce0501b47903bd8fe1179c2dfe07bd076f89f5225", 16),
+            "r": int("a3ba51c39c43991d87dff0f34d0bec7c883299e04f60f95e", 16),
+            "s": int("8a7f9c59c6d65ad390e4c19636ba92b53be5d0f848b4e1f7", 16),
+        },
+        {
+            "curve": "sect571r1",
+            "digest_algorithm": "SHA-512",
+            "message": binascii.unhexlify(
+                b"10d2e00ae57176c79cdfc746c0c887abe799ee445b151b008e3d9f81eb69"
+                b"be40298ddf37b5c45a9b6e5ff83785d8c140cf11e6a4c3879a2845796872"
+                b"363da24b10f1f8d9cc48f8af20681dceb60dd62095d6d3b1779a4a805de3"
+                b"d74e38983b24c0748618e2f92ef7cac257ff4bd1f41113f2891eb13c4793"
+                b"0e69ddbe91f270fb"
+            ),
+            "d": int("3e1b03ffca4399d5b439fac8f87a5cb06930f00d304193d7daf83d59"
+                     "47d0c1e293f74aef8e56849f16147133c37a6b3d1b1883e5d61d6b87"
+                     "1ea036c5291d9a74541f28878cb986", 16),
+            "x": int("3b236fc135d849d50140fdaae1045e6ae35ef61091e98f5059b30eb1"
+                     "6acdd0deb2bc0d3544bc3a666e0014e50030134fe5466a9e4d3911ed"
+                     "580e28851f3747c0010888e819d3d1f", 16),
+            "y": int("3a8b6627a587d289032bd76374d16771188d7ff281c39542c8977f68"
+                     "72fa932e5daa14e13792dea9ffe8e9f68d6b525ec99b81a5a60cfb05"
+                     "90cc6f297cfff8d7ba1a8bb81fe2e16", 16),
+            "r": int("2eb1c5c1fc93cf3c8babed12c031cf1504e094174fd335104cbe4a2a"
+                     "bd210b5a14b1c3a455579f1ed0517c31822340e4dd3c1f967e1b4b9d"
+                     "071a1072afc1a199f8c548cd449a634", 16),
+            "s": int("22f97bb48641235826cf4e597fa8de849402d6bd6114ad2d7fbcf53a"
+                     "08247e5ee921f1bd5994dffee36eedff5592bb93b8bb148214da3b7b"
+                     "aebffbd96b4f86c55b3f6bbac142442", 16),
+            "fail": False
+        },
+        {
+            "curve": "sect571r1",
+            "digest_algorithm": "SHA-512",
+            "message": binascii.unhexlify(
+                b"b61a0849a28672cb536fcf61ea2eb389d02ff7a09aa391744cae6597bd56"
+                b"703c40c50ca2dee5f7ee796acfd47322f03d8dbe4d99dc8eec588b4e5467"
+                b"f123075b2d74b2a0b0bbfd3ac5487a905fad6d6ac1421c2e564c0cf15e1f"
+                b"0f10bc31c249b7b46edd2462a55f85560d99bde9d5b06b97817d1dbe0a67"
+                b"c701d6e6e7878272"
+            ),
+            "d": int("2e09ffd8b434bb7f67d1d3ccf482164f1653c6e4ec64dec2517aa21b"
+                     "7a93b2b21ea1eebb54734882f29303e489f02e3b741a87287e2dcdf3"
+                     "858eb6d2ec668f8b5b26f442ce513a2", 16),
+            "x": int("36f1be8738dd7dae4486b86a08fe90424f3673e76b10e739442e15f3"
+                     "bfafaf841842ac98e490521b7e7bb94c127529f6ec6a42cc6f06fc80"
+                     "606f1210fe020ff508148f93301c9d3", 16),
+            "y": int("4d39666ebe99fe214336ad440d776c88eb916f2f4a3433548b87d2ae"
+                     "bed840b424d15c8341b4a0a657bf6a234d4fe78631c8e07ac1f4dc74"
+                     "74cd6b4545d536b7b17c160db4562d9", 16),
+            "r": int("3d8105f87fe3166046c08e80a28acc98a80b8b7a729623053c2a9e80"
+                     "afd06756edfe09bdcf3035f6829ede041b745955d219dc5d30ddd8b3"
+                     "7f6ba0f6d2857504cdc68a1ed812a10", 16),
+            "s": int("34db9998dc53527114518a7ce3783d674ca8cced823fa05e2942e7a0"
+                     "a20b3cc583dcd930c43f9b93079c5ee18a1f5a66e7c3527c18610f9b"
+                     "47a4da7e245ef803e0662e4d2ad721c", 16)
+        }
+    ]
+    assert expected == load_fips_ecdsa_signing_vectors(vector_data)
+
+
+def test_load_kasvs_dh_vectors():
+    vector_data = textwrap.dedent("""
+    [SHA(s) supported (Used for hashing Z): SHA256 ]
+    #  Generated on Thu Mar 17 20:44:26 2011
+
+
+
+    [FA - SHA1]
+    P = da3a8085d372437805de95b88b675122f575df976610c6a844de99f1df82a06848bf7a\
+42f18895c97402e81118e01a00d0855d51922f434c022350861d58ddf60d65bc6941fc6064b147\
+071a4c30426d82fc90d888f94990267c64beef8c304a4b2b26fb93724d6a9472fa16bc50c5b9b8\
+b59afb62cfe9ea3ba042c73a6ade35
+    Q = f2ca7621eb250aa5f22cef1907011295defc50a7
+    G = a51883e9ac0539859df3d25c716437008bb4bd8ec4786eb4bc643299daef5e3e5af586\
+3a6ac40a597b83a27583f6a658d408825105b16d31b6ed088fc623f648fd6d95e9cefcb0745763\
+cddf564c87bcf4ba7928e74fd6a3080481f588d535e4c026b58a21e1e5ec412ff241b436043e29\
+173f1dc6cb943c09742de989547288
+
+
+
+    COUNT = 0
+    XstatCAVS = 42c6ee70beb7465928a1efe692d2281b8f7b53d6
+    YstatCAVS = 5a7890f6d20ee9c7162cd84222cb0c7cb5b4f29244a58fc95327fc41045f47\
+6fb3da42fca76a1dd59222a7a7c3872d5af7d8dc254e003eccdb38f291619c51911df2b6ed67d0\
+b459f4bc25819c0078777b9a1a24c72e7c037a3720a1edad5863ef5ac75ce816869c820859558d\
+5721089ddbe331f55bef741396a3bbf85c6c1a
+    XstatIUT = 54081a8fef2127a1f22ed90440b1b09c331d0614
+    YstatIUT = 0b92af0468b841ea5de4ca91d895b5e922245421de57ed7a88d2de41610b208\
+e8e233705f17b2e9eb91914bad2fa87f0a58519a7da2980bc06e7411c925a6050526bd86e62150\
+5e6f610b63fdcd9afcfaa96bd087afca44d9197cc35b559f731357a5b979250c0f3a254bb8165f\
+5072156e3fd6f9a6e69bcf4b4578f78b3bde7
+    Z = 8d8f4175e16e15a42eb9099b11528af88741cc206a088971d3064bb291eda608d1600b\
+ff829624db258fd15e95d96d3e74c6be3232afe5c855b9c59681ce13b7aea9ff2b16707e4c02f0\
+e82bf6dadf2149ac62630f6c62dea0e505e3279404da5ffd5a088e8474ae0c8726b8189cb3d2f0\
+4baffe700be849df9f91567fc2ebb8
+    CAVSHashZZ = eb99e77ac2272c7a2ee70c59375ac4d167312c20
+    Result = P (0 - Correct)
+
+
+
+    COUNT = 2
+    XstatCAVS = 32e642683d745a23dccf4f12f989d8dfd1fd9894c422930950cb4c71
+    YstatCAVS = 8cd371363b32fcc2e936e345f2278b77001f2efdf78512c3ee75c12f88507e\
+2d5c0e5cdded3bb78435506c8028a3f4d6f028c0f49a0d61f1285795197e56deac80279e723f2b\
+3746e213ac8ec60f1cefc2308ff17a7e9e2efab537e17406d2829fd85e0c54dda2d9f0b4fcda3d\
+2776110e096a817588e19588b77be8b41bafdd41ad91b0edf629333bd6ac1e461208ead124c31b\
+8a7935c723e1c450c5798dc05f8265ad9e35095ff112af9e889f00315fa337a76a450670866eca\
+12cc6ad0778576962eb9cdc12721d3c15e4d87b67488a145d400240670eb26695a42879cd3940a\
+55087f6527667277e1212a202dbe455c45c64b9be4a38153557bbb8fd755
+    XstatIUT = 7d8ae93df3bc09d399a4157ec562126acf51092c3269ab27f60a3a2b
+    YstatIUT = 22127e9728e906ea4b1512c8b1e80474b58446210c23ccfc800f83c2c15da81\
+59940e494b235266f6a9d5f80529067794f1a9edd566755d23d0a3060fe074c5a10122df3e4729\
+73bba39ea3a988e8387f5f0491e590b6b5edc299b4598ab1e79b72681a0be8cd8735a5adb85fa3\
+1310f29ec407c9654f1bb83bcdf7f771b68d176817f662e8d798b53ebb4e5dd407b7b1d8fdb62e\
+a9e1b60d6c3d75d9bcf83f4b8d1ed39408bd8d973b4ea81e8e832eac361dcd530713388a60971e\
+a9f8b1e69c1e99df1cca12bdaf293dacfa1419c5692ceffa91988aef3321ac8cbc2efae6c4337c\
+8808310fb5a240395a98e6004fe613c39e84f4177341746d9e388dcb2e8
+    Z = 0efeaa399a182e0a603baf0dd95aa0fae5289ebd47d5f0f60c86bc936839c31c9f7f37\
+bf04f76ab02f4094a8ab10ed907ec7291585cc085c3e8981df2bd46a01c19ec9a2f66709df1d4f\
+efbeb48c8263554e46890f59eb642bf95ff7f0de70138621c22c4cc32be6c3d5c82c0c9a76a9f5\
+a65bffe0c096a350f96a9da945d7e5095b15b566ce3cb8b0377cd9375b6c046afa9ea0bc084677\
+3445f16566b2c84cae4f6d212e89ee539a1ce7ea325273fd228053efce2a585eb9e8f308b48cf4\
+e29593b6f7a02e8625e1e8bff1ea1405f8c8c34b8339a9a99c7c9de4eb9895df7719ccda9394f5\
+3080eff1226f6b9c7ae0a38941e18b1a137aabbb62308eb35ba2
+    CAVSHashZZ = 76dedc997d5113573bbeeaf991f62b257511b7d9aa83270dfc4fec40
+    Result = P (10 - Z value should have leading 0 nibble )
+
+
+
+    COUNT = 3
+    XstatCAVS = 66502429aba271e2f2ee2197a2b336e5f0467f192aa28b60dcbf1194
+    YstatCAVS = dfb001294215423d7146a2453cdb8598ccef01e1d931a913c3e4ed4a3cf38a\
+912066c28e4eaf77dd80ff07183a6160bd95932f513402f864dcf7a70cbedc9b60bbfbc67f72a8\
+3d5f6463a2b5a4fc906d3e921f5e1069126113265b440e15ccf2d7164bad7131f1613fec35df7f\
+470d45888e0c91be091f3f9552d670b8b7f479853193cb3c39f35fc7bd547ccb1bc579a67302b4\
+ba948e6db51043d351bb74a952e6a694e6e7456f714c47d7c8eeeb4fd83ad93c86b78445f9393f\
+dfd65c7dbd7fd6eba9794ddf183901b1d213321fd0ab3f7588ab0f6b3692f365a87131eda0e062\
+505861988f6ce63150207545ecf9678e0971330253dfb7cfd546c5346fec
+    XstatIUT = 106b358be4f068348ac240ecbb454e5c39ca80b078cb0fafd856e9c5
+    YstatIUT = 715d0781975b7b03162f4401c1eda343fd9bf1140006034573b31828a618c35\
+6163554cd27da956f7179a69e860fb6efeaa2e2aa9f1261506a8344c4929953621381b13d6426e\
+152c0f2f94bfcd2b758eca24923596d427ed8f957e8bc9b1c7d21a87ef02222a1477cf3bfaadc6\
+8106456ab9706026006eccd290b21543de6bb97d5b8cf4ccee1c081a6d1dd27aaef060fa93888a\
+47a4a416ad5c5bd490ea600e04379232fb1077fbf394f4579accdbe352714e25b88916dca8d8f7\
+e0c4ed9594f7693f656a235a2e88ebda48b0d557e32da9f12d2a4c3180f05b16b4fba9bec79278\
+a3971b77f9223b5ab78b857e0376c5008211592c8c72d521373ee3b22b8
+    Z = cf879ebd107bb877457809c3fc410218b7acba3c5967495a8f1c3370d57f038a48dd69\
+f9f69b9f4dd855e7c58a1e4ec32646a978266eb314db468ea1dfcee8a85a1644a5732498c4fbcd\
+f85098c6ed0ce12e431e99142fd2335369b3f56620ada21aa69d883e82a0b5e35484dde32d17c2\
+dc873f2cc5518eb7fc19695dff9fc94c9d9432bb4b09d8180323cfc561ebc2d6eff8dd5f8496f2\
+b22377700a22bbfe61a6969c198129397454843e4fc3540026986039665095490056287e4fc49e\
+6cb3181cb2bf06444fd0040150271c9ce1f61c13ecd5dd022194a2dbf3e1c7fbc6bd19497c7b88\
+8b4da613d28fa6f378a43369cb8795a1c823f7d6cf4d84bba578
+    CAVSHashZZ = ebac4fb70699224f85d9e3c799b1f3a56dab268b882aba49525df02d
+    Result = F (5 - Z changed )
+
+
+
+    [FB - SHA224]
+    P = f3722b9b911c6aede9eaeeaa406283de66a097f39a7225df6c3c916e57920d356e5047\
+8d307dbfd146bfb91b6f68ecbbcf54b3d19c33a4b17293fea3e3d6bff8ac4cca93a805386f062a\
+8a27ae906ef5da94d279fd7b3d7289e00956f76bae9c0d2b8d11742ca5809630632aae58f9c6dc\
+e00c7380581deffde2187b022f83c6ceaeaadb0844a17fcbb04039ca6843c91f0c9058b22434b2\
+63c3dfda8de8429e087c5be97fc5c9db9526031ad3a218bd9916fb4a3c27966d208b1e360014c0\
+1e95530c148fb3cd27e6a7250d3c3b81dcd220ca14548dbccf99ebb9e334db6bcd14e632c98dd3\
+f9860af7ae450f1b7809b45f0ec10e6f27672beebc9963befc73
+    Q = a9a17de95a29091bf8e07dab53ea1aba9403be3c61027c6c8f48bac5
+    G = 035513ec441402b78353ab1bba550b21c76c89973885a627170262ef52497d5d137b89\
+27a212aaab2f051198c90bb81dffd9eb10b36b7ca3b63565b4c1025aea3b5e9c4a348c9cfa17f3\
+907a1e4469701c0dedb8a4b9e96c5965b1fb8c229b0c34baac774bf9dda4fc5ee8764358b3c848\
+12878aab7464bc09e97aecab7d7e3fbb4870e2a3b89667a4158bf1ed1a90dfaf47019fbb52b1b9\
+6365bb4e1e9474993fe382fd23480dc875861be152997a621fdb7aef977ea5b4d3d74486b162dc\
+28f95a64cf65587a919a57eef92934fc9410df7f09fa82f975328ed82ff29cc3e15a971f56f4ac\
+2dcb289252575e02a6cdb7fcc6cddd7b0dca9c422e63eb2b8f05
+
+
+
+    COUNT = 0
+    XstatCAVS = 1610eaa4e0ccc8857e2b53149e008492b1fbd9025a6e8d95aaee9c0f
+    YstatCAVS = 51ee21cd9f97015180f258fad5c94ff5a458806b1412087236bf77fe87aae1\
+a36735816ed6e2160a731159814b6ae1f3f52c478dd9207094adfb62f7667d5c366327e66d2309\
+6395e938504db330953a708015f861fe9d9487611093b9fe7327518a7cc15994ab573313e15411\
+7c1a3ae88b8bdd1e316748249e4a9cbd1947f159836d13613d1f9449fc3442171d1970bc28958c\
+1cafa2776a6f14ccdb29db02f64911bd83bfdcdfc843dd14a4cab9acb0bda8b293d2f5f7050768\
+e57533cbc415a29e6f31cc365e107f91ae3722484e2c7329a85af69055a5a104da37e810878896\
+d1b247b02b75234ecff82b1958f42d7b031622e9394c98b5229112f7f620
+    XstatIUT = 0c4c83d75b27864b052cadc556e500e25aabf0c9d1bc01f0e1fe3862
+    YstatIUT = 467a857337a82472a1307a64dccc8e9994c5c63ec4312936885d17be419051a\
+5f037fbb052d7010ebe01634d9e8b8b522d9ab4749fdc274f465369b89e360df8f70b7865a3c71\
+d2dbcd2df19e9293dab1153d3d63fcb7deb559b684dde6c6eed63214444807041c9a0ce3f52ca4\
+39ec16dd231995b5dc6f18e6801b6bd6454babccf9abbfacffb49c71e6494a4779cbfa550c5d71\
+44114e6fc193f460dcd0be7e6e06e546da7653770dc5859df87029e722dbe81361030569148d16\
+36988926bf0dcfe47c9d8a54698c08b3b5c70afe86b5c6f643463f8f34889d27d6cfd2d478c2d7\
+b3d008a985c7380f0b43f10024b59c3543880883c42d0e7e0a07326ba3a
+    Z = 10a30bacab82e652415376baffdbc008c7eb2e5a3aa68bc10ce486ca84983fd89b1b02\
+7bb40e75333406361005f5e756526a95fe01202df9217d81b1713d5187c368fdd4c9c2433d9e6c\
+18844769479b725c4140c92a304ee1bc5726d8f5321b5b1c54a1a6b67c527e6817c0ed613a0d4e\
+60db55de898788b7e8d4aa9a81ab5ed7f6282962c433d246ed640555bdd76d29c2874551264d74\
+c76373f8a88871b41b041c98041b16f94f983ddf00f5bc7d2416d19168c90178974a0602436cd1\
+86748bcc63a629edc3a0db59415cccd37a65130ea477c89da92d41371f5972891cf41f9c7f0e75\
+ccbff9893225384db30daa5e310f08e3e0fad98bcdf8ecf35fe5
+    CAVSHashZZ = 014f5daea733d0e9e100f852e74d64a319f741cfbdb47975ab9dd3d0
+    Result = F (3 - IUT's Static public key fails PKV 5.6.2.4)
+
+
+    COUNT = 1
+    XstatCAVS = 9ee22ac51664e40e0a24dbb94142dba40605e2b6eeaaa0268a0f6847
+    YstatCAVS = c2630c9d38ed5c825d1c6a3eba7143f3fc8a049c8bcd1efc212d2af64eca99\
+4308208691d330aa8f27fc4a1e55de4e512113996d21375a667f8c26d76dee2f6809b15432a33f\
+b735aca5c2263940f58712bded08f55443dee300b9489589e0462bd6bce19deaec4adc12fa61a6\
+94c8c5c999b28211d7835bac0ffd2b316850823e2dc1d1f58e05cbf75c673036d116b3f03b9687\
+c89f9c2a0d43c4ffc9a605addbdcce0cb3790c6db846156bb857a7b3df40dc6ed04d19cc9eaebb\
+6bbc034e77c3d882a1a62317cce25b6130f0803e3bc49b5e36768260073a617034872be0b50bed\
+32740224beaf582d67fbcfef3b3ecc18f9c71c782e9a68495ef31dc7986e
+    XstatIUT = 438093a468236658821bf64eb08456139963d4fb27121c3ed6c55876
+    YstatIUT = e192da8e1244e27221c1765344a5bb379dce741d427a734b4bdb6c4d16b2490\
+bd37564d745008e63ae46ef332331d79887ac63298ce143e125f8b320c0f859b7f5f2c1e0053e4\
+a7a16997e6143ff702300c9863ae7caef5c1dfca0ecf5197c557745b793f0790a4fe678aeb93fd\
+b52490d4f273a5553944dda3ac8b9b792c9b67f8d7b9496398e432a423ae87ebeba688be3ed67e\
+ddd7575fa56431cd48579bf53c903bbe066dd78b23c0996ef3a880f0d91315104366a82f01abde\
+cce96fd371f94e8420f8bc5b896c801df573554f749b03d0d28b1e1a990bc61c7e9659342ac7e2\
+68e9c0b7c40fdaab394f29cf0a54f780022f9a03b0bd28eb7db8b0b1b47
+    Z = 56f8f40fa4b8f3580f9014b30d60a42933a53a62182a690142f458dc275c3b2f0e721b\
+c5ee6e890b14516419110f5252ff1cceea8e274b2987aa78e3bae90c1935b276b7a1f1c944f79d\
+4774b7a85b3355bdf25cb02bddfbda4ee7918bc93a5c9ca6d7e8fdedbda8e6c8a6ca794bad055a\
+52b19c148958227344cbddd70271d4610316cfea1e559b0bc3a12d15023b30d9f2db602053a056\
+9c3bd2ce1faf59280ecd339f845dbcaaf2e883c5cc6263996f866b18b75d049d4c82097af8a5ce\
+353e14416b3eeb31ba9bc4f6f3dbd846c5299fb5c0043a1b95b9149b39d14df9e6a69547abf8a4\
+d518475576730ed528779366568e46b7dd4ed787cb72d0733c93
+    CAVSHashZZ = 17dbbaa7a20c1390cd8cb3d31ee947bf9dde87739e067b9861ffeea9
+    Result = P (0 - Correct)
+    """).splitlines()
+
+    expected = [
+        {
+            'fail_agree': False,
+            'fail_z': False,
+            'g': int(
+                "a51883e9ac0539859df3d25c716437008bb4bd8ec4786eb4bc643299daef5"
+                "e3e5af5863a6ac40a597b83a27583f6a658d408825105b16d31b6ed088fc6"
+                "23f648fd6d95e9cefcb0745763cddf564c87bcf4ba7928e74fd6a3080481f"
+                "588d535e4c026b58a21e1e5ec412ff241b436043e29173f1dc6cb943c0974"
+                "2de989547288", 16),
+            'p': int(
+                "da3a8085d372437805de95b88b675122f575df976610c6a844de99f1df82a"
+                "06848bf7a42f18895c97402e81118e01a00d0855d51922f434c022350861d"
+                "58ddf60d65bc6941fc6064b147071a4c30426d82fc90d888f94990267c64b"
+                "eef8c304a4b2b26fb93724d6a9472fa16bc50c5b9b8b59afb62cfe9ea3ba0"
+                "42c73a6ade35", 16),
+            'q': 1386090807861091316803998193774751098153687863463,
+            'x1': 381229709512864262422021151581620734547375903702,
+            'x2': 479735944608461101114916716909067001453470352916,
+            'y1': int(
+                "5a7890f6d20ee9c7162cd84222cb0c7cb5b4f29244a58fc95327fc41045f4"
+                "76fb3da42fca76a1dd59222a7a7c3872d5af7d8dc254e003eccdb38f29161"
+                "9c51911df2b6ed67d0b459f4bc25819c0078777b9a1a24c72e7c037a3720a"
+                "1edad5863ef5ac75ce816869c820859558d5721089ddbe331f55bef741396"
+                "a3bbf85c6c1a", 16),
+            'y2': int(
+                "b92af0468b841ea5de4ca91d895b5e922245421de57ed7a88d2de41610b20"
+                "8e8e233705f17b2e9eb91914bad2fa87f0a58519a7da2980bc06e7411c925"
+                "a6050526bd86e621505e6f610b63fdcd9afcfaa96bd087afca44d9197cc35"
+                "b559f731357a5b979250c0f3a254bb8165f5072156e3fd6f9a6e69bcf4b45"
+                "78f78b3bde7", 16),
+            'z': binascii.unhexlify(
+                b"8d8f4175e16e15a42eb9099b11528af88741cc206a088971d3064bb291ed"
+                b"a608d1600bff829624db258fd15e95d96d3e74c6be3232afe5c855b9c596"
+                b"81ce13b7aea9ff2b16707e4c02f0e82bf6dadf2149ac62630f6c62dea0e5"
+                b"05e3279404da5ffd5a088e8474ae0c8726b8189cb3d2f04baffe700be849"
+                b"df9f91567fc2ebb8"
+            )
+        },
+        {
+            'fail_agree': False,
+            'fail_z': False,
+            'g': int(
+                "a51883e9ac0539859df3d25c716437008bb4bd8ec4786eb4bc643299daef5"
+                "e3e5af5863a6ac40a597b83a27583f6a658d408825105b16d31b6ed088fc6"
+                "23f648fd6d95e9cefcb0745763cddf564c87bcf4ba7928e74fd6a3080481f"
+                "588d535e4c026b58a21e1e5ec412ff241b436043e29173f1dc6cb943c0974"
+                "2de989547288", 16),
+            'p': int(
+                "da3a8085d372437805de95b88b675122f575df976610c6a844de99f1df82a"
+                "06848bf7a42f18895c97402e81118e01a00d0855d51922f434c022350861d"
+                "58ddf60d65bc6941fc6064b147071a4c30426d82fc90d888f94990267c64b"
+                "eef8c304a4b2b26fb93724d6a9472fa16bc50c5b9b8b59afb62cfe9ea3ba0"
+                "42c73a6ade35", 16),
+            'q': 1386090807861091316803998193774751098153687863463,
+            'x1': int(
+                "32e642683d745a23dccf4f12f989d8dfd1fd9894c422930950cb4c71",
+                16),
+            'x2': int(
+                "7d8ae93df3bc09d399a4157ec562126acf51092c3269ab27f60a3a2b",
+                16),
+            'y1': int(
+                "8cd371363b32fcc2e936e345f2278b77001f2efdf78512c3ee75c12f88507"
+                "e2d5c0e5cdded3bb78435506c8028a3f4d6f028c0f49a0d61f1285795197e"
+                "56deac80279e723f2b3746e213ac8ec60f1cefc2308ff17a7e9e2efab537e"
+                "17406d2829fd85e0c54dda2d9f0b4fcda3d2776110e096a817588e19588b7"
+                "7be8b41bafdd41ad91b0edf629333bd6ac1e461208ead124c31b8a7935c72"
+                "3e1c450c5798dc05f8265ad9e35095ff112af9e889f00315fa337a76a4506"
+                "70866eca12cc6ad0778576962eb9cdc12721d3c15e4d87b67488a145d4002"
+                "40670eb26695a42879cd3940a55087f6527667277e1212a202dbe455c45c6"
+                "4b9be4a38153557bbb8fd755", 16),
+            'y2': int(
+                "22127e9728e906ea4b1512c8b1e80474b58446210c23ccfc800f83c2c15da"
+                "8159940e494b235266f6a9d5f80529067794f1a9edd566755d23d0a3060fe"
+                "074c5a10122df3e472973bba39ea3a988e8387f5f0491e590b6b5edc299b4"
+                "598ab1e79b72681a0be8cd8735a5adb85fa31310f29ec407c9654f1bb83bc"
+                "df7f771b68d176817f662e8d798b53ebb4e5dd407b7b1d8fdb62ea9e1b60d"
+                "6c3d75d9bcf83f4b8d1ed39408bd8d973b4ea81e8e832eac361dcd5307133"
+                "88a60971ea9f8b1e69c1e99df1cca12bdaf293dacfa1419c5692ceffa9198"
+                "8aef3321ac8cbc2efae6c4337c8808310fb5a240395a98e6004fe613c39e8"
+                "4f4177341746d9e388dcb2e8", 16),
+            'z': binascii.unhexlify(
+                b"0efeaa399a182e0a603baf0dd95aa0fae5289ebd47d5f0f60c86bc936839"
+                b"c31c9f7f37bf04f76ab02f4094a8ab10ed907ec7291585cc085c3e8981df"
+                b"2bd46a01c19ec9a2f66709df1d4fefbeb48c8263554e46890f59eb642bf9"
+                b"5ff7f0de70138621c22c4cc32be6c3d5c82c0c9a76a9f5a65bffe0c096a3"
+                b"50f96a9da945d7e5095b15b566ce3cb8b0377cd9375b6c046afa9ea0bc08"
+                b"46773445f16566b2c84cae4f6d212e89ee539a1ce7ea325273fd228053ef"
+                b"ce2a585eb9e8f308b48cf4e29593b6f7a02e8625e1e8bff1ea1405f8c8c3"
+                b"4b8339a9a99c7c9de4eb9895df7719ccda9394f53080eff1226f6b9c7ae0"
+                b"a38941e18b1a137aabbb62308eb35ba2"
+            )
+        },
+        {
+            'fail_agree': False,
+            'fail_z': True,
+            'g': int(
+                "a51883e9ac0539859df3d25c716437008bb4bd8ec4786eb4bc643299daef5"
+                "e3e5af5863a6ac40a597b83a27583f6a658d408825105b16d31b6ed088fc6"
+                "23f648fd6d95e9cefcb0745763cddf564c87bcf4ba7928e74fd6a3080481f"
+                "588d535e4c026b58a21e1e5ec412ff241b436043e29173f1dc6cb943c0974"
+                "2de989547288", 16),
+            'p': int(
+                "da3a8085d372437805de95b88b675122f575df976610c6a844de99f1df82a"
+                "06848bf7a42f18895c97402e81118e01a00d0855d51922f434c022350861d"
+                "58ddf60d65bc6941fc6064b147071a4c30426d82fc90d888f94990267c64b"
+                "eef8c304a4b2b26fb93724d6a9472fa16bc50c5b9b8b59afb62cfe9ea3ba0"
+                "42c73a6ade35", 16),
+            'q': 1386090807861091316803998193774751098153687863463,
+            'x1': int(
+                "66502429aba271e2f2ee2197a2b336e5f0467f192aa28b60dcbf1194",
+                16),
+            'x2': int(
+                "106b358be4f068348ac240ecbb454e5c39ca80b078cb0fafd856e9c5",
+                16),
+            'y1': int(
+                "dfb001294215423d7146a2453cdb8598ccef01e1d931a913c3e4ed4a3cf38"
+                "a912066c28e4eaf77dd80ff07183a6160bd95932f513402f864dcf7a70cbe"
+                "dc9b60bbfbc67f72a83d5f6463a2b5a4fc906d3e921f5e1069126113265b4"
+                "40e15ccf2d7164bad7131f1613fec35df7f470d45888e0c91be091f3f9552"
+                "d670b8b7f479853193cb3c39f35fc7bd547ccb1bc579a67302b4ba948e6db"
+                "51043d351bb74a952e6a694e6e7456f714c47d7c8eeeb4fd83ad93c86b784"
+                "45f9393fdfd65c7dbd7fd6eba9794ddf183901b1d213321fd0ab3f7588ab0"
+                "f6b3692f365a87131eda0e062505861988f6ce63150207545ecf9678e0971"
+                "330253dfb7cfd546c5346fec", 16),
+            'y2': int(
+                "715d0781975b7b03162f4401c1eda343fd9bf1140006034573b31828a618c"
+                "356163554cd27da956f7179a69e860fb6efeaa2e2aa9f1261506a8344c492"
+                "9953621381b13d6426e152c0f2f94bfcd2b758eca24923596d427ed8f957e"
+                "8bc9b1c7d21a87ef02222a1477cf3bfaadc68106456ab9706026006eccd29"
+                "0b21543de6bb97d5b8cf4ccee1c081a6d1dd27aaef060fa93888a47a4a416"
+                "ad5c5bd490ea600e04379232fb1077fbf394f4579accdbe352714e25b8891"
+                "6dca8d8f7e0c4ed9594f7693f656a235a2e88ebda48b0d557e32da9f12d2a"
+                "4c3180f05b16b4fba9bec79278a3971b77f9223b5ab78b857e0376c500821"
+                "1592c8c72d521373ee3b22b8", 16),
+            'z': binascii.unhexlify(
+                b"cf879ebd107bb877457809c3fc410218b7acba3c5967495a8f1c3370d57f"
+                b"038a48dd69f9f69b9f4dd855e7c58a1e4ec32646a978266eb314db468ea1"
+                b"dfcee8a85a1644a5732498c4fbcdf85098c6ed0ce12e431e99142fd23353"
+                b"69b3f56620ada21aa69d883e82a0b5e35484dde32d17c2dc873f2cc5518e"
+                b"b7fc19695dff9fc94c9d9432bb4b09d8180323cfc561ebc2d6eff8dd5f84"
+                b"96f2b22377700a22bbfe61a6969c198129397454843e4fc3540026986039"
+                b"665095490056287e4fc49e6cb3181cb2bf06444fd0040150271c9ce1f61c"
+                b"13ecd5dd022194a2dbf3e1c7fbc6bd19497c7b888b4da613d28fa6f378a4"
+                b"3369cb8795a1c823f7d6cf4d84bba578"
+            )
+        },
+        {
+            'fail_agree': True,
+            'fail_z': False,
+            'g': int(
+                "35513ec441402b78353ab1bba550b21c76c89973885a627170262ef52497d"
+                "5d137b8927a212aaab2f051198c90bb81dffd9eb10b36b7ca3b63565b4c10"
+                "25aea3b5e9c4a348c9cfa17f3907a1e4469701c0dedb8a4b9e96c5965b1fb"
+                "8c229b0c34baac774bf9dda4fc5ee8764358b3c84812878aab7464bc09e97"
+                "aecab7d7e3fbb4870e2a3b89667a4158bf1ed1a90dfaf47019fbb52b1b963"
+                "65bb4e1e9474993fe382fd23480dc875861be152997a621fdb7aef977ea5b"
+                "4d3d74486b162dc28f95a64cf65587a919a57eef92934fc9410df7f09fa82"
+                "f975328ed82ff29cc3e15a971f56f4ac2dcb289252575e02a6cdb7fcc6cdd"
+                "d7b0dca9c422e63eb2b8f05", 16),
+            'p': int(
+                "f3722b9b911c6aede9eaeeaa406283de66a097f39a7225df6c3c916e57920"
+                "d356e50478d307dbfd146bfb91b6f68ecbbcf54b3d19c33a4b17293fea3e3"
+                "d6bff8ac4cca93a805386f062a8a27ae906ef5da94d279fd7b3d7289e0095"
+                "6f76bae9c0d2b8d11742ca5809630632aae58f9c6dce00c7380581deffde2"
+                "187b022f83c6ceaeaadb0844a17fcbb04039ca6843c91f0c9058b22434b26"
+                "3c3dfda8de8429e087c5be97fc5c9db9526031ad3a218bd9916fb4a3c2796"
+                "6d208b1e360014c01e95530c148fb3cd27e6a7250d3c3b81dcd220ca14548"
+                "dbccf99ebb9e334db6bcd14e632c98dd3f9860af7ae450f1b7809b45f0ec1"
+                "0e6f27672beebc9963befc73", 16),
+            'q': int(
+                "a9a17de95a29091bf8e07dab53ea1aba9403be3c61027c6c8f48bac5",
+                16),
+            'x1': int(
+                "1610eaa4e0ccc8857e2b53149e008492b1fbd9025a6e8d95aaee9c0f",
+                16),
+            'x2': int(
+                "c4c83d75b27864b052cadc556e500e25aabf0c9d1bc01f0e1fe3862",
+                16),
+            'y1': int(
+                "51ee21cd9f97015180f258fad5c94ff5a458806b1412087236bf77fe87aae"
+                "1a36735816ed6e2160a731159814b6ae1f3f52c478dd9207094adfb62f766"
+                "7d5c366327e66d23096395e938504db330953a708015f861fe9d948761109"
+                "3b9fe7327518a7cc15994ab573313e154117c1a3ae88b8bdd1e316748249e"
+                "4a9cbd1947f159836d13613d1f9449fc3442171d1970bc28958c1cafa2776"
+                "a6f14ccdb29db02f64911bd83bfdcdfc843dd14a4cab9acb0bda8b293d2f5"
+                "f7050768e57533cbc415a29e6f31cc365e107f91ae3722484e2c7329a85af"
+                "69055a5a104da37e810878896d1b247b02b75234ecff82b1958f42d7b0316"
+                "22e9394c98b5229112f7f620", 16),
+            'y2': int(
+                "467a857337a82472a1307a64dccc8e9994c5c63ec4312936885d17be41905"
+                "1a5f037fbb052d7010ebe01634d9e8b8b522d9ab4749fdc274f465369b89e"
+                "360df8f70b7865a3c71d2dbcd2df19e9293dab1153d3d63fcb7deb559b684"
+                "dde6c6eed63214444807041c9a0ce3f52ca439ec16dd231995b5dc6f18e68"
+                "01b6bd6454babccf9abbfacffb49c71e6494a4779cbfa550c5d7144114e6f"
+                "c193f460dcd0be7e6e06e546da7653770dc5859df87029e722dbe81361030"
+                "569148d1636988926bf0dcfe47c9d8a54698c08b3b5c70afe86b5c6f64346"
+                "3f8f34889d27d6cfd2d478c2d7b3d008a985c7380f0b43f10024b59c35438"
+                "80883c42d0e7e0a07326ba3a", 16),
+            'z': binascii.unhexlify(
+                b"10a30bacab82e652415376baffdbc008c7eb2e5a3aa68bc10ce486ca8498"
+                b"3fd89b1b027bb40e75333406361005f5e756526a95fe01202df9217d81b1"
+                b"713d5187c368fdd4c9c2433d9e6c18844769479b725c4140c92a304ee1bc"
+                b"5726d8f5321b5b1c54a1a6b67c527e6817c0ed613a0d4e60db55de898788"
+                b"b7e8d4aa9a81ab5ed7f6282962c433d246ed640555bdd76d29c287455126"
+                b"4d74c76373f8a88871b41b041c98041b16f94f983ddf00f5bc7d2416d191"
+                b"68c90178974a0602436cd186748bcc63a629edc3a0db59415cccd37a6513"
+                b"0ea477c89da92d41371f5972891cf41f9c7f0e75ccbff9893225384db30d"
+                b"aa5e310f08e3e0fad98bcdf8ecf35fe5"
+            )
+        },
+        {
+            'fail_agree': False,
+            'fail_z': False,
+            'g': int("35513ec441402b78353ab1bba550b21c76c89973885a627170262ef5"
+                     "2497d5d137b8927a212aaab2f051198c90bb81dffd9eb10b36b7ca3b"
+                     "63565b4c1025aea3b5e9c4a348c9cfa17f3907a1e4469701c0dedb8a"
+                     "4b9e96c5965b1fb8c229b0c34baac774bf9dda4fc5ee8764358b3c84"
+                     "812878aab7464bc09e97aecab7d7e3fbb4870e2a3b89667a4158bf1e"
+                     "d1a90dfaf47019fbb52b1b96365bb4e1e9474993fe382fd23480dc87"
+                     "5861be152997a621fdb7aef977ea5b4d3d74486b162dc28f95a64cf6"
+                     "5587a919a57eef92934fc9410df7f09fa82f975328ed82ff29cc3e15"
+                     "a971f56f4ac2dcb289252575e02a6cdb7fcc6cddd7b0dca9c422e63e"
+                     "b2b8f05", 16),
+            'p': int("f3722b9b911c6aede9eaeeaa406283de66a097f39a7225df6c3c916e"
+                     "57920d356e50478d307dbfd146bfb91b6f68ecbbcf54b3d19c33a4b1"
+                     "7293fea3e3d6bff8ac4cca93a805386f062a8a27ae906ef5da94d279"
+                     "fd7b3d7289e00956f76bae9c0d2b8d11742ca5809630632aae58f9c6"
+                     "dce00c7380581deffde2187b022f83c6ceaeaadb0844a17fcbb04039"
+                     "ca6843c91f0c9058b22434b263c3dfda8de8429e087c5be97fc5c9db"
+                     "9526031ad3a218bd9916fb4a3c27966d208b1e360014c01e95530c14"
+                     "8fb3cd27e6a7250d3c3b81dcd220ca14548dbccf99ebb9e334db6bcd"
+                     "14e632c98dd3f9860af7ae450f1b7809b45f0ec10e6f27672beebc99"
+                     "63befc73", 16),
+            'q': int(
+                "a9a17de95a29091bf8e07dab53ea1aba9403be3c61027c6c8f48bac5",
+                16),
+            'x1': int(
+                "9ee22ac51664e40e0a24dbb94142dba40605e2b6eeaaa0268a0f6847",
+                16),
+            'x2': int(
+                "438093a468236658821bf64eb08456139963d4fb27121c3ed6c55876",
+                16),
+            'y1': int(
+                "c2630c9d38ed5c825d1c6a3eba7143f3fc8a049c8bcd1efc212d2af64eca9"
+                "94308208691d330aa8f27fc4a1e55de4e512113996d21375a667f8c26d76d"
+                "ee2f6809b15432a33fb735aca5c2263940f58712bded08f55443dee300b94"
+                "89589e0462bd6bce19deaec4adc12fa61a694c8c5c999b28211d7835bac0f"
+                "fd2b316850823e2dc1d1f58e05cbf75c673036d116b3f03b9687c89f9c2a0"
+                "d43c4ffc9a605addbdcce0cb3790c6db846156bb857a7b3df40dc6ed04d19"
+                "cc9eaebb6bbc034e77c3d882a1a62317cce25b6130f0803e3bc49b5e36768"
+                "260073a617034872be0b50bed32740224beaf582d67fbcfef3b3ecc18f9c7"
+                "1c782e9a68495ef31dc7986e", 16),
+            'y2': int(
+                "e192da8e1244e27221c1765344a5bb379dce741d427a734b4bdb6c4d16b24"
+                "90bd37564d745008e63ae46ef332331d79887ac63298ce143e125f8b320c0"
+                "f859b7f5f2c1e0053e4a7a16997e6143ff702300c9863ae7caef5c1dfca0e"
+                "cf5197c557745b793f0790a4fe678aeb93fdb52490d4f273a5553944dda3a"
+                "c8b9b792c9b67f8d7b9496398e432a423ae87ebeba688be3ed67eddd7575f"
+                "a56431cd48579bf53c903bbe066dd78b23c0996ef3a880f0d91315104366a"
+                "82f01abdecce96fd371f94e8420f8bc5b896c801df573554f749b03d0d28b"
+                "1e1a990bc61c7e9659342ac7e268e9c0b7c40fdaab394f29cf0a54f780022"
+                "f9a03b0bd28eb7db8b0b1b47", 16),
+            'z': binascii.unhexlify(
+                b"56f8f40fa4b8f3580f9014b30d60a42933a53a62182a690142f458dc275c"
+                b"3b2f0e721bc5ee6e890b14516419110f5252ff1cceea8e274b2987aa78e3"
+                b"bae90c1935b276b7a1f1c944f79d4774b7a85b3355bdf25cb02bddfbda4e"
+                b"e7918bc93a5c9ca6d7e8fdedbda8e6c8a6ca794bad055a52b19c14895822"
+                b"7344cbddd70271d4610316cfea1e559b0bc3a12d15023b30d9f2db602053"
+                b"a0569c3bd2ce1faf59280ecd339f845dbcaaf2e883c5cc6263996f866b18"
+                b"b75d049d4c82097af8a5ce353e14416b3eeb31ba9bc4f6f3dbd846c5299f"
+                b"b5c0043a1b95b9149b39d14df9e6a69547abf8a4d518475576730ed52877"
+                b"9366568e46b7dd4ed787cb72d0733c93"
+            )
+        }
+    ]
+
+    assert expected == load_kasvs_dh_vectors(vector_data)
+
+
+def test_load_kasvs_ecdh_vectors_empty_vector_data():
+    assert [] == load_kasvs_ecdh_vectors([])
+
+
+def test_load_kasvs_ecdh_vectors():
+    vector_data = textwrap.dedent("""
+    #  CAVS 11.0
+    #  Parameter set(s) supported: EA EB EC ED EE
+    #  CAVSid: CAVSid (in hex: 434156536964)
+    #  IUTid: In hex: a1b2c3d4e5
+    [EA]
+
+    [Curve selected:  P-192]
+    [SHA(s) supported (Used for hashing Z):  SHA1]
+    [EB]
+
+    [Curve selected:  P-224]
+    [SHA(s) supported (Used for hashing Z):  SHA224]
+    [EC]
+
+    [Curve selected:  P-256]
+    [SHA(s) supported (Used for hashing Z):  SHA256]
+    [ED]
+
+    [Curve selected:  P-384]
+    [SHA(s) supported (Used for hashing Z):  SHA384]
+    [EE]
+
+    [Curve selected:  P-521]
+    [SHA(s) supported (Used for hashing Z):  SHA512]
+    #  Generated on Thu Mar 17 19:46:10 2011
+
+
+
+    [EA - SHA1]
+
+
+    COUNT = 0
+    dsCAVS = f70c297a683d6b7ef82b5af7349606c4447c8b4fc6fa5e80
+    QsCAVSx = f7b5061fb557e516c50abf541d97dbfd76ca7172b22cf590
+    QsCAVSy = 135e15e21f9e85c76205fd148a92ac19f9e6243ddab322d1
+    dsIUT = a5b4bbad57f101ca48021cb7440cd681a9d40cd51b99d917
+    QsIUTx = 79a77fcb18a32cdb59ed5d87740f29e8565d649dbf01ce86
+    QsIUTy = f7187efaa0b1573f1fb00905d46810b880bf738b4c720bb7
+    Z = 26382468d721761e14a87dc3bee67340095c6455962d1ba3
+    CAVSHashZZ = af52ba700d3bbba7ce2916d6b729422c26c32364
+    Result = P (0 - Correct)
+
+
+
+    COUNT = 2
+    dsCAVS = 5f909dcb0ccce58c82fada748c47297579e6a981b5518a96
+    QsCAVSx = 537f1ecfda0e366de393a9bc8188fcc280311bffefe21ecf
+    QsCAVSy = a1fa1f98498d65f2754caff4e5303a4066a5ff89fde95381
+    dsIUT = 3357aa7f47f3e09421602cc12cdce4434c68e330d44de05e
+    QsIUTx = 6a33d43d9c72173eabc7a771a5687748c4774c62762e96ec
+    QsIUTy = 8033f238b3abc69470aad4be8dbe4f60a2fd50207626c56a
+    Z = 3153034f6617326f19c35be8c99a0585431adf09d2f8e0fd
+    CAVSHashZZ = f8414e30c2d382e28d2a57a2447fdc203baa416b
+    Result = F (8 - Z changed )
+
+
+
+    COUNT = 8
+    dsCAVS = 8fcfaf0524cc868fad20e50410a2205319f1327308d98dc8
+    QsCAVSx = 9b0243d80a9e328738080fb4d46bc450243d0efb7ead0c92
+    QsCAVSy = ad5bebad7f03849693071537f60ef858cad214123beee7c7
+    dsIUT = bba95dac90289cb68ca2b006f9757219b70579c299ad7a7d
+    QsIUTx = 7733dc0cb365cd6312724196b9b4eb491fd4d2e31b9afdb1
+    QsIUTy = 92ffa3722acc5b94d772258ba2d471b06c0f53f56fcd8662
+    Z = 0f3c6e4a29a08296ae730f56a1ebf819ea2edfa6f0434e40
+    CAVSHashZZ = c124545eed4b83a799e7e90371d806b5684a1bd2
+    Result = P (13 - Z value should have leading 0 nibble )
+
+
+    [EB - SHA224]
+
+
+    COUNT = 0
+    dsCAVS = e53a88af7cf8ce6bf13c8b9ad191494e37a6acc1368c71f4306e39e5
+    QsCAVSx = 3a24217c4b957fea922eec9d9ac52d5cb4b3fcd95efde1e4fa0dd6e2
+    QsCAVSy = 775b94025a808eb6f4af14ea4b57dca576c35373c6dc198b15b981df
+    dsIUT = 09f51e302c6a0fe6ff48f34c208c6af91e70f65f88102e6fcab9af4a
+    QsIUTx = c5d5706ccd7424c74fd616e699865af96e56f39adea6aa059e5092b5
+    QsIUTy = f0729077bb602404d56d2f7e2ba5bb2f383df4a5425567881ff0165d
+    Z = b1259ceedfb663d9515089cf727e7024fb3d86cbcec611b4ba0b4ab6
+    CAVSHashZZ = 8b21fd05a4b50e401908cd8f26757f5c57f22b69f170aa7381f8596d
+    Result = P (0 - Correct)
+
+
+
+    [EC - SHA256]
+
+
+    COUNT = 0
+    dsCAVS = 305dfb4a8850cc59280891147baf457bfe5e2bae984571634a77dc8d3472fa9b
+    QsCAVSx = 202cb5a224e6c2a84e624094486edf04116c8d68ec1f4a0e0ed9ee090e1a900b
+    QsCAVSy = cacf3a5789bb33954be600425d62d9eae5371f90f88167258814213e4a4f4b1a
+    dsIUT = 72cc52808f294b64b6f7233c3d2f5d96cc1d29287320e39e1c151deef0bc14eb
+    QsIUTx = 49a768c9a4ca56e374f685dd76a461b1016c59dcded2c8d8cbd9f23ca453831f
+    QsIUTy = b1e3bb9b5f12a3b5ae788535d4554bd8c46e0e6130075e4e437d3854cf8f1c34
+    Z = c0147c3c2691b450b5edc08b51aea224d9f4359ff67aab6da3146f396dbceaea
+    CAVSHashZZ = ea9ffd54511979ab8c4b387784972cbd05fc5fd4ff78e048b0026557b56a5\
+1dd
+    Result = F (2 - CAVS's Static public key Y fails PKV 5.6.2.5)
+
+
+
+    [ED - SHA384]
+
+
+    COUNT = 0
+    dsCAVS = 0e5c98ff2d2a3aab14ad0067b60dbe64e4f541ab5bed11c5a0c55ae1e60b51ff5\
+faaf377837977d80cbfdc33c2ff542b
+    QsCAVSx = d1bf2ac21637d66d6398aac01dcd56ac6f065fb45d1f6f16747bab9e9b01b463\
+0b59b20927aea147355bf41838acb482
+    QsCAVSy = 4c9e23f1c5a41647d094086bf4ed31708651f21d996c47780688ac10f77deee2\
+e43b5241b6caecd2fd5444bc50472e0e
+    dsIUT = f865418473e5bf7d2e1bbcd9bd5a9270c003a9dd35e778133ca59fcab4bb64fe24\
+d6800e7047bdd033abc8bfa8db35b5
+    QsIUTx = 32b72ab9b558249dcbc6cbade234f58e4f7aa5d3f6420ea99a5f997e8c2a91fb7\
+fd83779d0d2169428683771c745fd1a
+    QsIUTy = c749e02a3719bb56bf1dfc4ba3820309c01ab6e84cb29db7cdd80f127233f5295\
+687f8178f3a8704c1063b84c2ee472f
+    Z = a781430e6078a179df3f9ee27cd8fdc6188f161b6c4ccc4053ef6c6ca6fc222946883a\
+53c06db08f0a020023ced055aa
+    CAVSHashZZ = ccb70d0adbabe4d8956519db0d536605cbb366aed58fc55718f56ae3648fa\
+5c9ee7bae56cc463587cb74e2f9c6ace1cb
+    Result = P (0 - Correct)
+
+
+
+    [EE - SHA512]
+
+
+    COUNT = 0
+    dsCAVS = 0000002fef62381162942889a6094a6bb9ac1f4ddf66d9cda9f618232d31b90c5\
+0d7da78a47ed91d40cae946898571db972dc294b109815f38feee9eaac0d5f7c3250728
+    QsCAVSx = 0000004b05ffa025113390797f2736174aa1c784f4dd34e764ee40d40e4d2442\
+677ebea3498086c9473e5c92789cbdb02bb327bbd61d58690f6a83d9ca73bccbde37dec4
+    QsCAVSy = 0000004da67cffc98070b82af61feba78787efefb13bd810d80ff92304788e49\
+a4e5b634b3565474a8ecb1615d7b1b77a7a27875adb73a8a5d8f3f84e5e8b744cda250b0
+    dsIUT = 00000311a5e520e238141527671a38cb6f776d96a9f82ef70dffa11dc0895f4060\
+f1abbb9ad6fd259e4a7beaf5f7266ea1bb45bcbfebfda2705e5c551e710fb1d745f57e
+    QsIUTx = 0000010ba3778cb2cc965834c0a9593adc6a222692656d657fb0d15293edf0ab3\
+3762384a96a16fddea7540b7ccbcca46ec4ac9bcf95fdb5aa18e158aab4d91981bd733e
+    QsIUTy = 0000018522df93ddd636e5bc94daecdc600fa241686ec18634fd30b7cbdfdc9ff\
+ba1166ac08df34a31896f6fad191414929261ebd7187afb72919f8a0c926be37f99c1e5
+    Z = 01a5e4b31be4b1346e53906b6767b1fe94ec1a8a5abc28fb6f01518c056959af3bc933\
+5dddab178b52318cc5512559931b8dc18de0ce810c2c7f15769d7ce70e719c
+    CAVSHashZZ = d2d6538feb65d609f377b81a027dc800eed07b69c0e9eedb243369202ed47\
+f47021022a6c9b45ed791d09d9540eb81ea065fc1959eca365001ee39928c343d75
+    Result = F (7 - IUT's Static private key d changed-prikey validity)
+
+
+
+    """).splitlines()
+
+    expected = [
+        {'errno': 0,
+         'fail': False,
+         'COUNT': 0,
+         'CAVS': {
+             'd': int("f70c297a683d6b7ef82b5af7349606c4447c8b4fc6fa5e80", 16),
+             'x': int("f7b5061fb557e516c50abf541d97dbfd76ca7172b22cf590", 16),
+             'y': int("135e15e21f9e85c76205fd148a92ac19f9e6243ddab322d1", 16)},
+         'IUT': {
+             'd': int("a5b4bbad57f101ca48021cb7440cd681a9d40cd51b99d917", 16),
+             'x': int("79a77fcb18a32cdb59ed5d87740f29e8565d649dbf01ce86", 16),
+             'y': int("f7187efaa0b1573f1fb00905d46810b880bf738b4c720bb7", 16)},
+         'Z': int("26382468d721761e14a87dc3bee67340095c6455962d1ba3", 16),
+         'curve': 'secp192r1'},
+
+        {'errno': 8,
+         'fail': True,
+         'COUNT': 2,
+         'CAVS': {
+             'd': int("5f909dcb0ccce58c82fada748c47297579e6a981b5518a96", 16),
+             'x': int("537f1ecfda0e366de393a9bc8188fcc280311bffefe21ecf", 16),
+             'y': int("a1fa1f98498d65f2754caff4e5303a4066a5ff89fde95381", 16)},
+         'IUT': {
+             'd': int("3357aa7f47f3e09421602cc12cdce4434c68e330d44de05e", 16),
+             'x': int("6a33d43d9c72173eabc7a771a5687748c4774c62762e96ec", 16),
+             'y': int("8033f238b3abc69470aad4be8dbe4f60a2fd50207626c56a", 16)},
+         'Z': int("3153034f6617326f19c35be8c99a0585431adf09d2f8e0fd", 16),
+         'curve': 'secp192r1'},
+
+        {'errno': 13,
+         'fail': False,
+         'COUNT': 8,
+         'CAVS': {
+             'd': int("8fcfaf0524cc868fad20e50410a2205319f1327308d98dc8", 16),
+             'x': int("9b0243d80a9e328738080fb4d46bc450243d0efb7ead0c92", 16),
+             'y': int("ad5bebad7f03849693071537f60ef858cad214123beee7c7", 16)},
+         'IUT': {
+             'd': int("bba95dac90289cb68ca2b006f9757219b70579c299ad7a7d", 16),
+             'x': int("7733dc0cb365cd6312724196b9b4eb491fd4d2e31b9afdb1", 16),
+             'y': int("92ffa3722acc5b94d772258ba2d471b06c0f53f56fcd8662", 16)},
+         'Z': int("0f3c6e4a29a08296ae730f56a1ebf819ea2edfa6f0434e40", 16),
+         'curve': 'secp192r1'},
+
+        {'errno': 0,
+         'fail': False,
+         'COUNT': 0,
+         'CAVS': {
+             'd': int("e53a88af7cf8ce6bf13c8b9ad191494e37a6acc1368c71f4"
+                      "306e39e5", 16),
+             'x': int("3a24217c4b957fea922eec9d9ac52d5cb4b3fcd95efde1e4"
+                      "fa0dd6e2", 16),
+             'y': int("775b94025a808eb6f4af14ea4b57dca576c35373c6dc198b"
+                      "15b981df", 16)},
+         'IUT': {
+             'd': int("09f51e302c6a0fe6ff48f34c208c6af91e70f65f88102e6f"
+                      "cab9af4a", 16),
+             'x': int("c5d5706ccd7424c74fd616e699865af96e56f39adea6aa05"
+                      "9e5092b5", 16),
+             'y': int("f0729077bb602404d56d2f7e2ba5bb2f383df4a542556788"
+                      "1ff0165d", 16)},
+         'Z': int("b1259ceedfb663d9515089cf727e7024fb3d86cbcec611b4"
+                  "ba0b4ab6", 16),
+         'curve': 'secp224r1'},
+
+        {'errno': 2,
+         'fail': True,
+         'COUNT': 0,
+         'CAVS': {
+             'd': int("305dfb4a8850cc59280891147baf457bfe5e2bae98457163"
+                      "4a77dc8d3472fa9b", 16),
+             'x': int("202cb5a224e6c2a84e624094486edf04116c8d68ec1f4a0e"
+                      "0ed9ee090e1a900b", 16),
+             'y': int("cacf3a5789bb33954be600425d62d9eae5371f90f8816725"
+                      "8814213e4a4f4b1a", 16)},
+         'IUT': {
+             'd': int("72cc52808f294b64b6f7233c3d2f5d96cc1d29287320e39e"
+                      "1c151deef0bc14eb", 16),
+             'x': int("49a768c9a4ca56e374f685dd76a461b1016c59dcded2c8d8"
+                      "cbd9f23ca453831f", 16),
+             'y': int("b1e3bb9b5f12a3b5ae788535d4554bd8c46e0e6130075e4e"
+                      "437d3854cf8f1c34", 16)},
+         'Z': int("c0147c3c2691b450b5edc08b51aea224d9f4359ff67aab6d"
+                  "a3146f396dbceaea", 16),
+         'curve': 'secp256r1'},
+
+        {'errno': 0,
+         'fail': False,
+         'COUNT': 0,
+         'CAVS': {
+             'd': int("0e5c98ff2d2a3aab14ad0067b60dbe64e4f541ab5bed11c5"
+                      "a0c55ae1e60b51ff5faaf377837977d80cbfdc33c2ff542b", 16),
+             'x': int("d1bf2ac21637d66d6398aac01dcd56ac6f065fb45d1f6f16"
+                      "747bab9e9b01b4630b59b20927aea147355bf41838acb482", 16),
+             'y': int("4c9e23f1c5a41647d094086bf4ed31708651f21d996c4778"
+                      "0688ac10f77deee2e43b5241b6caecd2fd5444bc50472e0e", 16)},
+         'IUT': {
+             'd': int("f865418473e5bf7d2e1bbcd9bd5a9270c003a9dd35e77813"
+                      "3ca59fcab4bb64fe24d6800e7047bdd033abc8bfa8db35b5", 16),
+             'x': int("32b72ab9b558249dcbc6cbade234f58e4f7aa5d3f6420ea9"
+                      "9a5f997e8c2a91fb7fd83779d0d2169428683771c745fd1a", 16),
+             'y': int("c749e02a3719bb56bf1dfc4ba3820309c01ab6e84cb29db7"
+                      "cdd80f127233f5295687f8178f3a8704c1063b84c2ee472f", 16)},
+         'Z': int("a781430e6078a179df3f9ee27cd8fdc6188f161b6c4ccc40"
+                  "53ef6c6ca6fc222946883a53c06db08f0a020023ced055aa", 16),
+         'curve': 'secp384r1'},
+
+        {'errno': 7,
+         'fail': True,
+         'COUNT': 0,
+         'CAVS': {
+             'd': int("0000002fef62381162942889a6094a6bb9ac1f4ddf66d9cd"
+                      "a9f618232d31b90c50d7da78a47ed91d40cae946898571db"
+                      "972dc294b109815f38feee9eaac0d5f7c3250728", 16),
+             'x': int("0000004b05ffa025113390797f2736174aa1c784f4dd34e7"
+                      "64ee40d40e4d2442677ebea3498086c9473e5c92789cbdb0"
+                      "2bb327bbd61d58690f6a83d9ca73bccbde37dec4", 16),
+             'y': int("0000004da67cffc98070b82af61feba78787efefb13bd810"
+                      "d80ff92304788e49a4e5b634b3565474a8ecb1615d7b1b77"
+                      "a7a27875adb73a8a5d8f3f84e5e8b744cda250b0", 16)},
+         'IUT': {
+             'd': int("00000311a5e520e238141527671a38cb6f776d96a9f82ef7"
+                      "0dffa11dc0895f4060f1abbb9ad6fd259e4a7beaf5f7266e"
+                      "a1bb45bcbfebfda2705e5c551e710fb1d745f57e", 16),
+             'x': int("0000010ba3778cb2cc965834c0a9593adc6a222692656d65"
+                      "7fb0d15293edf0ab33762384a96a16fddea7540b7ccbcca4"
+                      "6ec4ac9bcf95fdb5aa18e158aab4d91981bd733e", 16),
+             'y': int("0000018522df93ddd636e5bc94daecdc600fa241686ec186"
+                      "34fd30b7cbdfdc9ffba1166ac08df34a31896f6fad191414"
+                      "929261ebd7187afb72919f8a0c926be37f99c1e5", 16)},
+         'Z': int("01a5e4b31be4b1346e53906b6767b1fe94ec1a8a5abc28fb"
+                  "6f01518c056959af3bc9335dddab178b52318cc551255993"
+                  "1b8dc18de0ce810c2c7f15769d7ce70e719c", 16),
+         'curve': 'secp521r1'}
+    ]
+
+    assert expected == load_kasvs_ecdh_vectors(vector_data)
+
+
+def test_load_kasvs_ecdh_kdf_vectors():
+    vector_data = textwrap.dedent("""
+    #  Parameter set(s) supported: EB EC ED EE
+    #  CAVSid: CAVSid (in hex: 434156536964)
+    #  IUTid: In hex: a1b2c3d4e5
+    [EB]
+
+    [Curve selected:  P-224]
+    [SHA(s) supported (Used in the KDF function):  SHA224 SHA256 SHA384 SHA512]
+    [MAC algorithm supported:  HMAC]
+    [HMAC SHAs supported:  SHA512]
+    [HMACKeySize(in bits):  112]
+    [HMAC Tag length(in bits):  64]
+
+    #  Generated on Mon Dec 22 11:45:18 2014
+
+
+
+    [EB - SHA224]
+
+
+    COUNT = 50
+    dsCAVS = 540904b67b3716823dd621ed72ad3dbc615887b4f56f910b78a57199
+    QsCAVSx = 28e5f3a72d8f6b8499dd1bcdfceafcecec68a0d715789bcf4b55fe15
+    QsCAVSy = 8c8006a7da7c1a19f5328d7e865522b0c0dfb9a29b2c46dc96590d2a
+    Nonce = 4eefb2a29a0e89c3898a7affdfa60dd7
+    dsIUT = 5e717ae889fc8d67be11c2ebe1a7d3550051448d68a040b2dee8e327
+    QsIUTx = ae7f3db340b647d61713f5374c019f1be2b28573cb6219bb7b747223
+    QsIUTy = 800e6bffcf97c15864ec6e5673fb83359b45f89b8a26a27f6f3dfbff
+    NonceDKMIUT = bb7f1b40d14ebd70443393990b57
+    OI = a1b2c3d4e5bb7f1b40d14ebd70443393990b574341565369645b1582daab9cc6c30d6\
+1fdcf1cdfc7e9a304651e0fdb
+    CAVSTag = 84de198c3a958c62
+    Z = 43f23b2c760d686fc99cc008b63aea92f866e224265af60d2d8ae540
+    MacData = 5374616e646172642054657374204d6573736167654eefb2a29a0e89c3898a7a\
+ffdfa60dd7
+    DKM = ad65fa2d12541c3a21f3cd223efb
+    Result = F (12 - Tag changed )
+    """).splitlines()
+
+    expected = [
+        {'errno': 12,
+         'fail': True,
+         'COUNT': 50,
+         'CAVS': {
+             'd': int("540904b67b3716823dd621ed72ad3dbc615887b4f56f910b"
+                      "78a57199", 16),
+             'x': int("28e5f3a72d8f6b8499dd1bcdfceafcecec68a0d715789bcf"
+                      "4b55fe15", 16),
+             'y': int("8c8006a7da7c1a19f5328d7e865522b0c0dfb9a29b2c46dc"
+                      "96590d2a", 16)},
+         'IUT': {
+             'd': int("5e717ae889fc8d67be11c2ebe1a7d3550051448d68a040b2"
+                      "dee8e327", 16),
+             'x': int("ae7f3db340b647d61713f5374c019f1be2b28573cb6219bb"
+                      "7b747223", 16),
+             'y': int("800e6bffcf97c15864ec6e5673fb83359b45f89b8a26a27f"
+                      "6f3dfbff", 16)},
+         'OI': int("a1b2c3d4e5bb7f1b40d14ebd70443393990b574341565369"
+                   "645b1582daab9cc6c30d61fdcf1cdfc7e9a304651e0fdb", 16),
+         'Z': int("43f23b2c760d686fc99cc008b63aea92f866e224265af60d"
+                  "2d8ae540", 16),
+         'DKM': int("ad65fa2d12541c3a21f3cd223efb", 16),
+         'curve': 'secp224r1'}
+    ]
+
+    assert expected == load_kasvs_ecdh_vectors(vector_data)
+
+
+def test_load_x963_vectors():
+    vector_data = textwrap.dedent("""
+    # CAVS 12.0
+    # 'ANS X9.63-2001' information for sample
+
+    [SHA-1]
+    [shared secret length = 192]
+    [SharedInfo length = 0]
+    [key data length = 128]
+
+    COUNT = 0
+    Z = 1c7d7b5f0597b03d06a018466ed1a93e30ed4b04dc64ccdd
+    SharedInfo =
+        Counter = 00000001
+        Hash input 1 = 1c7d7b5f0597b03d06a018466ed1a93e30ed4b04dc64ccdd00000001
+        K1 = bf71dffd8f4d99223936beb46fee8ccc60439b7e
+    key_data = bf71dffd8f4d99223936beb46fee8ccc
+
+    COUNT = 1
+    Z = 5ed096510e3fcf782ceea98e9737993e2b21370f6cda2ab1
+    SharedInfo =
+        Counter = 00000001
+        Hash input 1 = 5ed096510e3fcf782ceea98e9737993e2b21370f6cda2ab100000001
+        K1 = ec3e224446bfd7b3be1df404104af953c1b2d0f5
+    key_data = ec3e224446bfd7b3be1df404104af953
+
+    [SHA-512]
+    [shared secret length = 521]
+    [SharedInfo length = 128]
+    [key data length = 1024]
+
+    COUNT = 0
+    Z = 00aa5bb79b33e389fa58ceadc047197f14e73712f452caa9fc4c9adb369348b8150739\
+2f1a86ddfdb7c4ff8231c4bd0f44e44a1b55b1404747a9e2e753f55ef05a2d
+    SharedInfo = e3b5b4c1b0d5cf1d2b3a2f9937895d31
+        Counter = 00000001
+        Hash input 1 = 00aa5bb79b33e389fa58ceadc047197f14e73712f452caa9fc4c9ad\
+b369348b81507392f1a86ddfdb7c4ff8231c4bd0f44e44a1b55b1404747a9e2e753f55ef05a2d0\
+0000001e3b5b4c1b0d5cf1d2b3a2f9937895d31
+        K1 = 4463f869f3cc18769b52264b0112b5858f7ad32a5a2d96d8cffabf7fa733633d6\
+e4dd2a599acceb3ea54a6217ce0b50eef4f6b40a5c30250a5a8eeee20800226
+        Counter = 00000002
+        Hash input 2 = 00aa5bb79b33e389fa58ceadc047197f14e73712f452caa9fc4c9ad\
+b369348b81507392f1a86ddfdb7c4ff8231c4bd0f44e44a1b55b1404747a9e2e753f55ef05a2d0\
+0000002e3b5b4c1b0d5cf1d2b3a2f9937895d31
+        K2 = 7089dbf351f3f5022aa9638bf1ee419dea9c4ff745a25ac27bda33ca08bd56dd1\
+a59b4106cf2dbbc0ab2aa8e2efa7b17902d34276951ceccab87f9661c3e8816
+    key_data = 4463f869f3cc18769b52264b0112b5858f7ad32a5a2d96d8cffabf7fa733633\
+d6e4dd2a599acceb3ea54a6217ce0b50eef4f6b40a5c30250a5a8eeee208002267089dbf351f3f\
+5022aa9638bf1ee419dea9c4ff745a25ac27bda33ca08bd56dd1a59b4106cf2dbbc0ab2aa8e2ef\
+a7b17902d34276951ceccab87f9661c3e8816
+    """).splitlines()
+
+    assert load_x963_vectors(vector_data) == [
+        {"hash": "SHA-1", "count": 0,
+         "shared_secret_length": 192,
+         "Z": "1c7d7b5f0597b03d06a018466ed1a93e30ed4b04dc64ccdd",
+         "sharedinfo_length": 0,
+         "key_data_length": 128,
+         "key_data": "bf71dffd8f4d99223936beb46fee8ccc"},
+        {"hash": "SHA-1", "count": 1,
+         "shared_secret_length": 192,
+         "Z": "5ed096510e3fcf782ceea98e9737993e2b21370f6cda2ab1",
+         "sharedinfo_length": 0,
+         "key_data_length": 128,
+         "key_data": "ec3e224446bfd7b3be1df404104af953"},
+        {"hash": "SHA-512", "count": 0,
+         "shared_secret_length": 521,
+         "Z": "00aa5bb79b33e389fa58ceadc047197f14e73712f452caa9fc4c9adb369348b\
+81507392f1a86ddfdb7c4ff8231c4bd0f44e44a1b55b1404747a9e2e753f55ef05a2d",
+         "sharedinfo_length": 128,
+         "sharedinfo": "e3b5b4c1b0d5cf1d2b3a2f9937895d31",
+         "key_data_length": 1024,
+         "key_data": "4463f869f3cc18769b52264b0112b5858f7ad32a5a2d96d8cffabf7f\
+a733633d6e4dd2a599acceb3ea54a6217ce0b50eef4f6b40a5c30250a5a8eeee208002267089db\
+f351f3f5022aa9638bf1ee419dea9c4ff745a25ac27bda33ca08bd56dd1a59b4106cf2dbbc0ab2\
+aa8e2efa7b17902d34276951ceccab87f9661c3e8816"},
+    ]
+
+
+def test_vector_version():
+    assert cryptography.__version__ == cryptography_vectors.__version__
+
+
+def test_raises_unsupported_algorithm_wrong_type():
+    # Check that it raises if the wrong type of exception is raised.
+    class TestException(Exception):
+        pass
+
+    with pytest.raises(TestException):
+        with raises_unsupported_algorithm(None):
+            raise TestException
+
+
+def test_raises_unsupported_algorithm_wrong_reason():
+    # Check that it fails if the wrong reason code is raised.
+    with pytest.raises(AssertionError):
+        with raises_unsupported_algorithm(None):
+            raise UnsupportedAlgorithm("An error.",
+                                       _Reasons.BACKEND_MISSING_INTERFACE)
+
+
+def test_raises_unsupported_no_exc():
+    # Check that it fails if no exception is raised.
+    with pytest.raises(pytest.fail.Exception):
+        with raises_unsupported_algorithm(
+            _Reasons.BACKEND_MISSING_INTERFACE
+        ):
+            pass
+
+
+def test_raises_unsupported_algorithm():
+    # Check that it doesn't assert if the right things are raised.
+    with raises_unsupported_algorithm(
+        _Reasons.BACKEND_MISSING_INTERFACE
+    ) as exc_info:
+        raise UnsupportedAlgorithm("An error.",
+                                   _Reasons.BACKEND_MISSING_INTERFACE)
+    assert exc_info.type is UnsupportedAlgorithm
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/test_warnings.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/test_warnings.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/test_warnings.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/test_warnings.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,47 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import sys
+import types
+import warnings
+
+from cryptography.utils import deprecated
+
+
+class TestDeprecated(object):
+    def test_deprecated(self, monkeypatch):
+        mod = types.ModuleType("TestDeprecated/test_deprecated")
+        monkeypatch.setitem(sys.modules, mod.__name__, mod)
+        mod.X = deprecated(
+            value=1,
+            module_name=mod.__name__,
+            message="deprecated message text",
+            warning_class=DeprecationWarning
+        )
+        mod.Y = deprecated(
+            value=2,
+            module_name=mod.__name__,
+            message="more deprecated text",
+            warning_class=PendingDeprecationWarning,
+        )
+        mod = sys.modules[mod.__name__]
+        mod.Z = 3
+
+        with warnings.catch_warnings(record=True) as log:
+            warnings.simplefilter("always", PendingDeprecationWarning)
+            warnings.simplefilter("always", DeprecationWarning)
+            assert mod.X == 1
+            assert mod.Y == 2
+            assert mod.Z == 3
+
+        [msg1, msg2] = log
+        assert msg1.category is DeprecationWarning
+        assert msg1.message.args == ("deprecated message text",)
+
+        assert msg2.category is PendingDeprecationWarning
+        assert msg2.message.args == ("more deprecated text",)
+
+        assert "Y" in dir(mod)
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/test_x509_ext.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/test_x509_ext.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/test_x509_ext.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/test_x509_ext.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,3031 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import binascii
+import ipaddress
+import os
+
+import pytest
+
+import six
+
+from cryptography import x509
+from cryptography.hazmat.backends.interfaces import (
+    DSABackend, EllipticCurveBackend, RSABackend, X509Backend
+)
+from cryptography.hazmat.primitives.asymmetric import ec
+from cryptography.x509.oid import (
+    AuthorityInformationAccessOID, ExtendedKeyUsageOID, ExtensionOID, NameOID
+)
+
+from .hazmat.primitives.test_ec import _skip_curve_unsupported
+from .test_x509 import _load_cert
+
+
+class TestExtension(object):
+    def test_not_an_oid(self):
+        bc = x509.BasicConstraints(ca=False, path_length=None)
+        with pytest.raises(TypeError):
+            x509.Extension("notanoid", True, bc)
+
+    def test_critical_not_a_bool(self):
+        bc = x509.BasicConstraints(ca=False, path_length=None)
+        with pytest.raises(TypeError):
+            x509.Extension(ExtensionOID.BASIC_CONSTRAINTS, "notabool", bc)
+
+    def test_repr(self):
+        bc = x509.BasicConstraints(ca=False, path_length=None)
+        ext = x509.Extension(ExtensionOID.BASIC_CONSTRAINTS, True, bc)
+        assert repr(ext) == (
+            "<Extension(oid=<ObjectIdentifier(oid=2.5.29.19, name=basicConst"
+            "raints)>, critical=True, value=<BasicConstraints(ca=False, path"
+            "_length=None)>)>"
+        )
+
+    def test_eq(self):
+        ext1 = x509.Extension(
+            x509.ObjectIdentifier('1.2.3.4'), False, 'value'
+        )
+        ext2 = x509.Extension(
+            x509.ObjectIdentifier('1.2.3.4'), False, 'value'
+        )
+        assert ext1 == ext2
+
+    def test_ne(self):
+        ext1 = x509.Extension(
+            x509.ObjectIdentifier('1.2.3.4'), False, 'value'
+        )
+        ext2 = x509.Extension(
+            x509.ObjectIdentifier('1.2.3.5'), False, 'value'
+        )
+        ext3 = x509.Extension(
+            x509.ObjectIdentifier('1.2.3.4'), True, 'value'
+        )
+        ext4 = x509.Extension(
+            x509.ObjectIdentifier('1.2.3.4'), False, 'value4'
+        )
+        assert ext1 != ext2
+        assert ext1 != ext3
+        assert ext1 != ext4
+        assert ext1 != object()
+
+
+class TestNoticeReference(object):
+    def test_notice_numbers_not_all_int(self):
+        with pytest.raises(TypeError):
+            x509.NoticeReference("org", [1, 2, "three"])
+
+    def test_notice_numbers_none(self):
+        with pytest.raises(TypeError):
+            x509.NoticeReference("org", None)
+
+    def test_repr(self):
+        nr = x509.NoticeReference(u"org", [1, 3, 4])
+
+        if six.PY3:
+            assert repr(nr) == (
+                "<NoticeReference(organization='org', notice_numbers=[1, 3, 4"
+                "])>"
+            )
+        else:
+            assert repr(nr) == (
+                "<NoticeReference(organization=u'org', notice_numbers=[1, 3, "
+                "4])>"
+            )
+
+    def test_eq(self):
+        nr = x509.NoticeReference("org", [1, 2])
+        nr2 = x509.NoticeReference("org", [1, 2])
+        assert nr == nr2
+
+    def test_ne(self):
+        nr = x509.NoticeReference("org", [1, 2])
+        nr2 = x509.NoticeReference("org", [1])
+        nr3 = x509.NoticeReference(None, [1, 2])
+        assert nr != nr2
+        assert nr != nr3
+        assert nr != object()
+
+
+class TestUserNotice(object):
+    def test_notice_reference_invalid(self):
+        with pytest.raises(TypeError):
+            x509.UserNotice("invalid", None)
+
+    def test_notice_reference_none(self):
+        un = x509.UserNotice(None, "text")
+        assert un.notice_reference is None
+        assert un.explicit_text == "text"
+
+    def test_repr(self):
+        un = x509.UserNotice(x509.NoticeReference(u"org", [1]), u"text")
+        if six.PY3:
+            assert repr(un) == (
+                "<UserNotice(notice_reference=<NoticeReference(organization='"
+                "org', notice_numbers=[1])>, explicit_text='text')>"
+            )
+        else:
+            assert repr(un) == (
+                "<UserNotice(notice_reference=<NoticeReference(organization=u"
+                "'org', notice_numbers=[1])>, explicit_text=u'text')>"
+            )
+
+    def test_eq(self):
+        nr = x509.NoticeReference("org", [1, 2])
+        nr2 = x509.NoticeReference("org", [1, 2])
+        un = x509.UserNotice(nr, "text")
+        un2 = x509.UserNotice(nr2, "text")
+        assert un == un2
+
+    def test_ne(self):
+        nr = x509.NoticeReference("org", [1, 2])
+        nr2 = x509.NoticeReference("org", [1])
+        un = x509.UserNotice(nr, "text")
+        un2 = x509.UserNotice(nr2, "text")
+        un3 = x509.UserNotice(nr, "text3")
+        assert un != un2
+        assert un != un3
+        assert un != object()
+
+
+class TestPolicyInformation(object):
+    def test_invalid_policy_identifier(self):
+        with pytest.raises(TypeError):
+            x509.PolicyInformation("notanoid", None)
+
+    def test_none_policy_qualifiers(self):
+        pi = x509.PolicyInformation(x509.ObjectIdentifier("1.2.3"), None)
+        assert pi.policy_identifier == x509.ObjectIdentifier("1.2.3")
+        assert pi.policy_qualifiers is None
+
+    def test_policy_qualifiers(self):
+        pq = [u"string"]
+        pi = x509.PolicyInformation(x509.ObjectIdentifier("1.2.3"), pq)
+        assert pi.policy_identifier == x509.ObjectIdentifier("1.2.3")
+        assert pi.policy_qualifiers == pq
+
+    def test_invalid_policy_identifiers(self):
+        with pytest.raises(TypeError):
+            x509.PolicyInformation(x509.ObjectIdentifier("1.2.3"), [1, 2])
+
+    def test_repr(self):
+        pq = [u"string", x509.UserNotice(None, u"hi")]
+        pi = x509.PolicyInformation(x509.ObjectIdentifier("1.2.3"), pq)
+        if six.PY3:
+            assert repr(pi) == (
+                "<PolicyInformation(policy_identifier=<ObjectIdentifier(oid=1."
+                "2.3, name=Unknown OID)>, policy_qualifiers=['string', <UserNo"
+                "tice(notice_reference=None, explicit_text='hi')>])>"
+            )
+        else:
+            assert repr(pi) == (
+                "<PolicyInformation(policy_identifier=<ObjectIdentifier(oid=1."
+                "2.3, name=Unknown OID)>, policy_qualifiers=[u'string', <UserN"
+                "otice(notice_reference=None, explicit_text=u'hi')>])>"
+            )
+
+    def test_eq(self):
+        pi = x509.PolicyInformation(
+            x509.ObjectIdentifier("1.2.3"),
+            [u"string", x509.UserNotice(None, u"hi")]
+        )
+        pi2 = x509.PolicyInformation(
+            x509.ObjectIdentifier("1.2.3"),
+            [u"string", x509.UserNotice(None, u"hi")]
+        )
+        assert pi == pi2
+
+    def test_ne(self):
+        pi = x509.PolicyInformation(
+            x509.ObjectIdentifier("1.2.3"), [u"string"]
+        )
+        pi2 = x509.PolicyInformation(
+            x509.ObjectIdentifier("1.2.3"), [u"string2"]
+        )
+        pi3 = x509.PolicyInformation(
+            x509.ObjectIdentifier("1.2.3.4"), [u"string"]
+        )
+        assert pi != pi2
+        assert pi != pi3
+        assert pi != object()
+
+
+class TestCertificatePolicies(object):
+    def test_invalid_policies(self):
+        pq = [u"string"]
+        pi = x509.PolicyInformation(x509.ObjectIdentifier("1.2.3"), pq)
+        with pytest.raises(TypeError):
+            x509.CertificatePolicies([1, pi])
+
+    def test_iter_len(self):
+        pq = [u"string"]
+        pi = x509.PolicyInformation(x509.ObjectIdentifier("1.2.3"), pq)
+        cp = x509.CertificatePolicies([pi])
+        assert len(cp) == 1
+        for policyinfo in cp:
+            assert policyinfo == pi
+
+    def test_repr(self):
+        pq = [u"string"]
+        pi = x509.PolicyInformation(x509.ObjectIdentifier("1.2.3"), pq)
+        cp = x509.CertificatePolicies([pi])
+        if six.PY3:
+            assert repr(cp) == (
+                "<CertificatePolicies([<PolicyInformation(policy_identifier=<O"
+                "bjectIdentifier(oid=1.2.3, name=Unknown OID)>, policy_qualifi"
+                "ers=['string'])>])>"
+            )
+        else:
+            assert repr(cp) == (
+                "<CertificatePolicies([<PolicyInformation(policy_identifier=<O"
+                "bjectIdentifier(oid=1.2.3, name=Unknown OID)>, policy_qualifi"
+                "ers=[u'string'])>])>"
+            )
+
+    def test_eq(self):
+        pi = x509.PolicyInformation(
+            x509.ObjectIdentifier("1.2.3"), [u"string"]
+        )
+        cp = x509.CertificatePolicies([pi])
+        pi2 = x509.PolicyInformation(
+            x509.ObjectIdentifier("1.2.3"), [u"string"]
+        )
+        cp2 = x509.CertificatePolicies([pi2])
+        assert cp == cp2
+
+    def test_ne(self):
+        pi = x509.PolicyInformation(
+            x509.ObjectIdentifier("1.2.3"), [u"string"]
+        )
+        cp = x509.CertificatePolicies([pi])
+        pi2 = x509.PolicyInformation(
+            x509.ObjectIdentifier("1.2.3"), [u"string2"]
+        )
+        cp2 = x509.CertificatePolicies([pi2])
+        assert cp != cp2
+        assert cp != object()
+
+
+@pytest.mark.requires_backend_interface(interface=RSABackend)
+@pytest.mark.requires_backend_interface(interface=X509Backend)
+class TestCertificatePoliciesExtension(object):
+    def test_cps_uri_policy_qualifier(self, backend):
+        cert = _load_cert(
+            os.path.join("x509", "custom", "cp_cps_uri.pem"),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+
+        cp = cert.extensions.get_extension_for_oid(
+            ExtensionOID.CERTIFICATE_POLICIES
+        ).value
+
+        assert cp == x509.CertificatePolicies([
+            x509.PolicyInformation(
+                x509.ObjectIdentifier("2.16.840.1.12345.1.2.3.4.1"),
+                [u"http://other.com/cps"]
+            )
+        ])
+
+    def test_user_notice_with_notice_reference(self, backend):
+        cert = _load_cert(
+            os.path.join(
+                "x509", "custom", "cp_user_notice_with_notice_reference.pem"
+            ),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+
+        cp = cert.extensions.get_extension_for_oid(
+            ExtensionOID.CERTIFICATE_POLICIES
+        ).value
+
+        assert cp == x509.CertificatePolicies([
+            x509.PolicyInformation(
+                x509.ObjectIdentifier("2.16.840.1.12345.1.2.3.4.1"),
+                [
+                    u"http://example.com/cps",
+                    u"http://other.com/cps",
+                    x509.UserNotice(
+                        x509.NoticeReference(u"my org", [1, 2, 3, 4]),
+                        u"thing"
+                    )
+                ]
+            )
+        ])
+
+    def test_user_notice_with_explicit_text(self, backend):
+        cert = _load_cert(
+            os.path.join(
+                "x509", "custom", "cp_user_notice_with_explicit_text.pem"
+            ),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+
+        cp = cert.extensions.get_extension_for_oid(
+            ExtensionOID.CERTIFICATE_POLICIES
+        ).value
+
+        assert cp == x509.CertificatePolicies([
+            x509.PolicyInformation(
+                x509.ObjectIdentifier("2.16.840.1.12345.1.2.3.4.1"),
+                [x509.UserNotice(None, u"thing")]
+            )
+        ])
+
+    def test_user_notice_no_explicit_text(self, backend):
+        cert = _load_cert(
+            os.path.join(
+                "x509", "custom", "cp_user_notice_no_explicit_text.pem"
+            ),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+
+        cp = cert.extensions.get_extension_for_oid(
+            ExtensionOID.CERTIFICATE_POLICIES
+        ).value
+
+        assert cp == x509.CertificatePolicies([
+            x509.PolicyInformation(
+                x509.ObjectIdentifier("2.16.840.1.12345.1.2.3.4.1"),
+                [
+                    x509.UserNotice(
+                        x509.NoticeReference(u"my org", [1, 2, 3, 4]),
+                        None
+                    )
+                ]
+            )
+        ])
+
+
+class TestKeyUsage(object):
+    def test_key_agreement_false_encipher_decipher_true(self):
+        with pytest.raises(ValueError):
+            x509.KeyUsage(
+                digital_signature=False,
+                content_commitment=False,
+                key_encipherment=False,
+                data_encipherment=False,
+                key_agreement=False,
+                key_cert_sign=False,
+                crl_sign=False,
+                encipher_only=True,
+                decipher_only=False
+            )
+
+        with pytest.raises(ValueError):
+            x509.KeyUsage(
+                digital_signature=False,
+                content_commitment=False,
+                key_encipherment=False,
+                data_encipherment=False,
+                key_agreement=False,
+                key_cert_sign=False,
+                crl_sign=False,
+                encipher_only=True,
+                decipher_only=True
+            )
+
+        with pytest.raises(ValueError):
+            x509.KeyUsage(
+                digital_signature=False,
+                content_commitment=False,
+                key_encipherment=False,
+                data_encipherment=False,
+                key_agreement=False,
+                key_cert_sign=False,
+                crl_sign=False,
+                encipher_only=False,
+                decipher_only=True
+            )
+
+    def test_properties_key_agreement_true(self):
+        ku = x509.KeyUsage(
+            digital_signature=True,
+            content_commitment=True,
+            key_encipherment=False,
+            data_encipherment=False,
+            key_agreement=False,
+            key_cert_sign=True,
+            crl_sign=False,
+            encipher_only=False,
+            decipher_only=False
+        )
+        assert ku.digital_signature is True
+        assert ku.content_commitment is True
+        assert ku.key_encipherment is False
+        assert ku.data_encipherment is False
+        assert ku.key_agreement is False
+        assert ku.key_cert_sign is True
+        assert ku.crl_sign is False
+
+    def test_key_agreement_true_properties(self):
+        ku = x509.KeyUsage(
+            digital_signature=False,
+            content_commitment=False,
+            key_encipherment=False,
+            data_encipherment=False,
+            key_agreement=True,
+            key_cert_sign=False,
+            crl_sign=False,
+            encipher_only=False,
+            decipher_only=True
+        )
+        assert ku.key_agreement is True
+        assert ku.encipher_only is False
+        assert ku.decipher_only is True
+
+    def test_key_agreement_false_properties(self):
+        ku = x509.KeyUsage(
+            digital_signature=False,
+            content_commitment=False,
+            key_encipherment=False,
+            data_encipherment=False,
+            key_agreement=False,
+            key_cert_sign=False,
+            crl_sign=False,
+            encipher_only=False,
+            decipher_only=False
+        )
+        assert ku.key_agreement is False
+        with pytest.raises(ValueError):
+            ku.encipher_only
+
+        with pytest.raises(ValueError):
+            ku.decipher_only
+
+    def test_repr_key_agreement_false(self):
+        ku = x509.KeyUsage(
+            digital_signature=True,
+            content_commitment=True,
+            key_encipherment=False,
+            data_encipherment=False,
+            key_agreement=False,
+            key_cert_sign=True,
+            crl_sign=False,
+            encipher_only=False,
+            decipher_only=False
+        )
+        assert repr(ku) == (
+            "<KeyUsage(digital_signature=True, content_commitment=True, key_en"
+            "cipherment=False, data_encipherment=False, key_agreement=False, k"
+            "ey_cert_sign=True, crl_sign=False, encipher_only=None, decipher_o"
+            "nly=None)>"
+        )
+
+    def test_repr_key_agreement_true(self):
+        ku = x509.KeyUsage(
+            digital_signature=True,
+            content_commitment=True,
+            key_encipherment=False,
+            data_encipherment=False,
+            key_agreement=True,
+            key_cert_sign=True,
+            crl_sign=False,
+            encipher_only=False,
+            decipher_only=False
+        )
+        assert repr(ku) == (
+            "<KeyUsage(digital_signature=True, content_commitment=True, key_en"
+            "cipherment=False, data_encipherment=False, key_agreement=True, k"
+            "ey_cert_sign=True, crl_sign=False, encipher_only=False, decipher_"
+            "only=False)>"
+        )
+
+    def test_eq(self):
+        ku = x509.KeyUsage(
+            digital_signature=False,
+            content_commitment=False,
+            key_encipherment=False,
+            data_encipherment=False,
+            key_agreement=True,
+            key_cert_sign=False,
+            crl_sign=False,
+            encipher_only=False,
+            decipher_only=True
+        )
+        ku2 = x509.KeyUsage(
+            digital_signature=False,
+            content_commitment=False,
+            key_encipherment=False,
+            data_encipherment=False,
+            key_agreement=True,
+            key_cert_sign=False,
+            crl_sign=False,
+            encipher_only=False,
+            decipher_only=True
+        )
+        assert ku == ku2
+
+    def test_ne(self):
+        ku = x509.KeyUsage(
+            digital_signature=False,
+            content_commitment=False,
+            key_encipherment=False,
+            data_encipherment=False,
+            key_agreement=True,
+            key_cert_sign=False,
+            crl_sign=False,
+            encipher_only=False,
+            decipher_only=True
+        )
+        ku2 = x509.KeyUsage(
+            digital_signature=False,
+            content_commitment=False,
+            key_encipherment=False,
+            data_encipherment=False,
+            key_agreement=False,
+            key_cert_sign=False,
+            crl_sign=False,
+            encipher_only=False,
+            decipher_only=False
+        )
+        assert ku != ku2
+        assert ku != object()
+
+
+class TestSubjectKeyIdentifier(object):
+    def test_properties(self):
+        value = binascii.unhexlify(b"092384932230498bc980aa8098456f6ff7ff3ac9")
+        ski = x509.SubjectKeyIdentifier(value)
+        assert ski.digest == value
+
+    def test_repr(self):
+        ski = x509.SubjectKeyIdentifier(
+            binascii.unhexlify(b"092384932230498bc980aa8098456f6ff7ff3ac9")
+        )
+        ext = x509.Extension(ExtensionOID.SUBJECT_KEY_IDENTIFIER, False, ski)
+        if six.PY3:
+            assert repr(ext) == (
+                "<Extension(oid=<ObjectIdentifier(oid=2.5.29.14, name=subjectK"
+                "eyIdentifier)>, critical=False, value=<SubjectKeyIdentifier(d"
+                "igest=b\'\\t#\\x84\\x93\"0I\\x8b\\xc9\\x80\\xaa\\x80\\x98Eoo"
+                "\\xf7\\xff:\\xc9\')>)>"
+            )
+        else:
+            assert repr(ext) == (
+                "<Extension(oid=<ObjectIdentifier(oid=2.5.29.14, name=subjectK"
+                "eyIdentifier)>, critical=False, value=<SubjectKeyIdentifier(d"
+                "igest=\'\\t#\\x84\\x93\"0I\\x8b\\xc9\\x80\\xaa\\x80\\x98Eoo"
+                "\\xf7\\xff:\\xc9\')>)>"
+            )
+
+    def test_eq(self):
+        ski = x509.SubjectKeyIdentifier(
+            binascii.unhexlify(b"092384932230498bc980aa8098456f6ff7ff3ac9")
+        )
+        ski2 = x509.SubjectKeyIdentifier(
+            binascii.unhexlify(b"092384932230498bc980aa8098456f6ff7ff3ac9")
+        )
+        assert ski == ski2
+
+    def test_ne(self):
+        ski = x509.SubjectKeyIdentifier(
+            binascii.unhexlify(b"092384932230498bc980aa8098456f6ff7ff3ac9")
+        )
+        ski2 = x509.SubjectKeyIdentifier(
+            binascii.unhexlify(b"aa8098456f6ff7ff3ac9092384932230498bc980")
+        )
+        assert ski != ski2
+        assert ski != object()
+
+
+class TestAuthorityKeyIdentifier(object):
+    def test_authority_cert_issuer_not_generalname(self):
+        with pytest.raises(TypeError):
+            x509.AuthorityKeyIdentifier(b"identifier", ["notname"], 3)
+
+    def test_authority_cert_serial_number_not_integer(self):
+        dirname = x509.DirectoryName(
+            x509.Name([
+                x509.NameAttribute(x509.ObjectIdentifier('oid'), u'value1'),
+                x509.NameAttribute(x509.ObjectIdentifier('oid2'), u'value2'),
+            ])
+        )
+        with pytest.raises(TypeError):
+            x509.AuthorityKeyIdentifier(b"identifier", [dirname], "notanint")
+
+    def test_authority_issuer_none_serial_not_none(self):
+        with pytest.raises(ValueError):
+            x509.AuthorityKeyIdentifier(b"identifier", None, 3)
+
+    def test_authority_issuer_not_none_serial_none(self):
+        dirname = x509.DirectoryName(
+            x509.Name([
+                x509.NameAttribute(x509.ObjectIdentifier('oid'), u'value1'),
+                x509.NameAttribute(x509.ObjectIdentifier('oid2'), u'value2'),
+            ])
+        )
+        with pytest.raises(ValueError):
+            x509.AuthorityKeyIdentifier(b"identifier", [dirname], None)
+
+    def test_authority_cert_serial_and_issuer_none(self):
+        aki = x509.AuthorityKeyIdentifier(b"id", None, None)
+        assert aki.key_identifier == b"id"
+        assert aki.authority_cert_issuer is None
+        assert aki.authority_cert_serial_number is None
+
+    def test_repr(self):
+        dirname = x509.DirectoryName(
+            x509.Name([x509.NameAttribute(NameOID.COMMON_NAME, u'myCN')])
+        )
+        aki = x509.AuthorityKeyIdentifier(b"digest", [dirname], 1234)
+
+        if six.PY3:
+            assert repr(aki) == (
+                "<AuthorityKeyIdentifier(key_identifier=b'digest', authority_"
+                "cert_issuer=[<DirectoryName(value=<Name([<NameAttribute(oid="
+                "<ObjectIdentifier(oid=2.5.4.3, name=commonName)>, value='myC"
+                "N')>])>)>], authority_cert_serial_number=1234)>"
+            )
+        else:
+            assert repr(aki) == (
+                "<AuthorityKeyIdentifier(key_identifier='digest', authority_ce"
+                "rt_issuer=[<DirectoryName(value=<Name([<NameAttribute(oid=<Ob"
+                "jectIdentifier(oid=2.5.4.3, name=commonName)>, value=u'myCN')"
+                ">])>)>], authority_cert_serial_number=1234)>"
+            )
+
+    def test_eq(self):
+        dirname = x509.DirectoryName(
+            x509.Name([x509.NameAttribute(NameOID.COMMON_NAME, u'myCN')])
+        )
+        aki = x509.AuthorityKeyIdentifier(b"digest", [dirname], 1234)
+        dirname2 = x509.DirectoryName(
+            x509.Name([x509.NameAttribute(NameOID.COMMON_NAME, u'myCN')])
+        )
+        aki2 = x509.AuthorityKeyIdentifier(b"digest", [dirname2], 1234)
+        assert aki == aki2
+
+    def test_ne(self):
+        dirname = x509.DirectoryName(
+            x509.Name([x509.NameAttribute(NameOID.COMMON_NAME, u'myCN')])
+        )
+        dirname5 = x509.DirectoryName(
+            x509.Name([x509.NameAttribute(NameOID.COMMON_NAME, u'aCN')])
+        )
+        aki = x509.AuthorityKeyIdentifier(b"digest", [dirname], 1234)
+        aki2 = x509.AuthorityKeyIdentifier(b"diges", [dirname], 1234)
+        aki3 = x509.AuthorityKeyIdentifier(b"digest", None, None)
+        aki4 = x509.AuthorityKeyIdentifier(b"digest", [dirname], 12345)
+        aki5 = x509.AuthorityKeyIdentifier(b"digest", [dirname5], 12345)
+        assert aki != aki2
+        assert aki != aki3
+        assert aki != aki4
+        assert aki != aki5
+        assert aki != object()
+
+
+class TestBasicConstraints(object):
+    def test_ca_not_boolean(self):
+        with pytest.raises(TypeError):
+            x509.BasicConstraints(ca="notbool", path_length=None)
+
+    def test_path_length_not_ca(self):
+        with pytest.raises(ValueError):
+            x509.BasicConstraints(ca=False, path_length=0)
+
+    def test_path_length_not_int(self):
+        with pytest.raises(TypeError):
+            x509.BasicConstraints(ca=True, path_length=1.1)
+
+        with pytest.raises(TypeError):
+            x509.BasicConstraints(ca=True, path_length="notint")
+
+    def test_path_length_negative(self):
+        with pytest.raises(TypeError):
+            x509.BasicConstraints(ca=True, path_length=-1)
+
+    def test_repr(self):
+        na = x509.BasicConstraints(ca=True, path_length=None)
+        assert repr(na) == (
+            "<BasicConstraints(ca=True, path_length=None)>"
+        )
+
+    def test_eq(self):
+        na = x509.BasicConstraints(ca=True, path_length=None)
+        na2 = x509.BasicConstraints(ca=True, path_length=None)
+        assert na == na2
+
+    def test_ne(self):
+        na = x509.BasicConstraints(ca=True, path_length=None)
+        na2 = x509.BasicConstraints(ca=True, path_length=1)
+        na3 = x509.BasicConstraints(ca=False, path_length=None)
+        assert na != na2
+        assert na != na3
+        assert na != object()
+
+
+class TestExtendedKeyUsage(object):
+    def test_not_all_oids(self):
+        with pytest.raises(TypeError):
+            x509.ExtendedKeyUsage(["notoid"])
+
+    def test_iter_len(self):
+        eku = x509.ExtendedKeyUsage([
+            x509.ObjectIdentifier("1.3.6.1.5.5.7.3.1"),
+            x509.ObjectIdentifier("1.3.6.1.5.5.7.3.2"),
+        ])
+        assert len(eku) == 2
+        assert list(eku) == [
+            ExtendedKeyUsageOID.SERVER_AUTH,
+            ExtendedKeyUsageOID.CLIENT_AUTH
+        ]
+
+    def test_repr(self):
+        eku = x509.ExtendedKeyUsage([
+            x509.ObjectIdentifier("1.3.6.1.5.5.7.3.1"),
+            x509.ObjectIdentifier("1.3.6.1.5.5.7.3.2"),
+        ])
+        assert repr(eku) == (
+            "<ExtendedKeyUsage([<ObjectIdentifier(oid=1.3.6.1.5.5.7.3.1, name="
+            "serverAuth)>, <ObjectIdentifier(oid=1.3.6.1.5.5.7.3.2, name=clien"
+            "tAuth)>])>"
+        )
+
+    def test_eq(self):
+        eku = x509.ExtendedKeyUsage([
+            x509.ObjectIdentifier("1.3.6"), x509.ObjectIdentifier("1.3.7")
+        ])
+        eku2 = x509.ExtendedKeyUsage([
+            x509.ObjectIdentifier("1.3.6"), x509.ObjectIdentifier("1.3.7")
+        ])
+        assert eku == eku2
+
+    def test_ne(self):
+        eku = x509.ExtendedKeyUsage([x509.ObjectIdentifier("1.3.6")])
+        eku2 = x509.ExtendedKeyUsage([x509.ObjectIdentifier("1.3.6.1")])
+        assert eku != eku2
+        assert eku != object()
+
+
+@pytest.mark.requires_backend_interface(interface=RSABackend)
+@pytest.mark.requires_backend_interface(interface=X509Backend)
+class TestExtensions(object):
+    def test_no_extensions(self, backend):
+        cert = _load_cert(
+            os.path.join("x509", "verisign_md2_root.pem"),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+        ext = cert.extensions
+        assert len(ext) == 0
+        assert list(ext) == []
+        with pytest.raises(x509.ExtensionNotFound) as exc:
+            ext.get_extension_for_oid(ExtensionOID.BASIC_CONSTRAINTS)
+
+        assert exc.value.oid == ExtensionOID.BASIC_CONSTRAINTS
+
+    def test_one_extension(self, backend):
+        cert = _load_cert(
+            os.path.join(
+                "x509", "custom", "basic_constraints_not_critical.pem"
+            ),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+        extensions = cert.extensions
+        ext = extensions.get_extension_for_oid(ExtensionOID.BASIC_CONSTRAINTS)
+        assert ext is not None
+        assert ext.value.ca is False
+
+    def test_duplicate_extension(self, backend):
+        cert = _load_cert(
+            os.path.join(
+                "x509", "custom", "two_basic_constraints.pem"
+            ),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+        with pytest.raises(x509.DuplicateExtension) as exc:
+            cert.extensions
+
+        assert exc.value.oid == ExtensionOID.BASIC_CONSTRAINTS
+
+    def test_unsupported_critical_extension(self, backend):
+        cert = _load_cert(
+            os.path.join(
+                "x509", "custom", "unsupported_extension_critical.pem"
+            ),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+        with pytest.raises(x509.UnsupportedExtension) as exc:
+            cert.extensions
+
+        assert exc.value.oid == x509.ObjectIdentifier("1.2.3.4")
+
+    def test_unsupported_extension(self, backend):
+        # TODO: this will raise an exception when all extensions are complete
+        cert = _load_cert(
+            os.path.join(
+                "x509", "custom", "unsupported_extension.pem"
+            ),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+        extensions = cert.extensions
+        assert len(extensions) == 0
+
+    def test_no_extensions_get_for_class(self, backend):
+        cert = _load_cert(
+            os.path.join(
+                "x509", "cryptography.io.pem"
+            ),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+        exts = cert.extensions
+        with pytest.raises(x509.ExtensionNotFound) as exc:
+            exts.get_extension_for_class(x509.IssuerAlternativeName)
+        assert exc.value.oid == ExtensionOID.ISSUER_ALTERNATIVE_NAME
+
+    def test_one_extension_get_for_class(self, backend):
+        cert = _load_cert(
+            os.path.join(
+                "x509", "custom", "basic_constraints_not_critical.pem"
+            ),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+        ext = cert.extensions.get_extension_for_class(x509.BasicConstraints)
+        assert ext is not None
+        assert isinstance(ext.value, x509.BasicConstraints)
+
+    def test_repr(self, backend):
+        cert = _load_cert(
+            os.path.join(
+                "x509", "custom", "basic_constraints_not_critical.pem"
+            ),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+        assert repr(cert.extensions) == (
+            "<Extensions([<Extension(oid=<ObjectIdentifier(oid=2.5.29.19, name"
+            "=basicConstraints)>, critical=False, value=<BasicConstraints(ca=F"
+            "alse, path_length=None)>)>])>"
+        )
+
+
+@pytest.mark.requires_backend_interface(interface=RSABackend)
+@pytest.mark.requires_backend_interface(interface=X509Backend)
+class TestBasicConstraintsExtension(object):
+    def test_ca_true_pathlen_6(self, backend):
+        cert = _load_cert(
+            os.path.join(
+                "x509", "PKITS_data", "certs", "pathLenConstraint6CACert.crt"
+            ),
+            x509.load_der_x509_certificate,
+            backend
+        )
+        ext = cert.extensions.get_extension_for_oid(
+            ExtensionOID.BASIC_CONSTRAINTS
+        )
+        assert ext is not None
+        assert ext.critical is True
+        assert ext.value.ca is True
+        assert ext.value.path_length == 6
+
+    def test_path_length_zero(self, backend):
+        cert = _load_cert(
+            os.path.join("x509", "custom", "bc_path_length_zero.pem"),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+        ext = cert.extensions.get_extension_for_oid(
+            ExtensionOID.BASIC_CONSTRAINTS
+        )
+        assert ext is not None
+        assert ext.critical is True
+        assert ext.value.ca is True
+        assert ext.value.path_length == 0
+
+    def test_ca_true_no_pathlen(self, backend):
+        cert = _load_cert(
+            os.path.join("x509", "PKITS_data", "certs", "GoodCACert.crt"),
+            x509.load_der_x509_certificate,
+            backend
+        )
+        ext = cert.extensions.get_extension_for_oid(
+            ExtensionOID.BASIC_CONSTRAINTS
+        )
+        assert ext is not None
+        assert ext.critical is True
+        assert ext.value.ca is True
+        assert ext.value.path_length is None
+
+    def test_ca_false(self, backend):
+        cert = _load_cert(
+            os.path.join("x509", "cryptography.io.pem"),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+        ext = cert.extensions.get_extension_for_oid(
+            ExtensionOID.BASIC_CONSTRAINTS
+        )
+        assert ext is not None
+        assert ext.critical is True
+        assert ext.value.ca is False
+        assert ext.value.path_length is None
+
+    def test_no_basic_constraints(self, backend):
+        cert = _load_cert(
+            os.path.join(
+                "x509",
+                "PKITS_data",
+                "certs",
+                "ValidCertificatePathTest1EE.crt"
+            ),
+            x509.load_der_x509_certificate,
+            backend
+        )
+        with pytest.raises(x509.ExtensionNotFound):
+            cert.extensions.get_extension_for_oid(
+                ExtensionOID.BASIC_CONSTRAINTS
+            )
+
+    def test_basic_constraint_not_critical(self, backend):
+        cert = _load_cert(
+            os.path.join(
+                "x509", "custom", "basic_constraints_not_critical.pem"
+            ),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+        ext = cert.extensions.get_extension_for_oid(
+            ExtensionOID.BASIC_CONSTRAINTS
+        )
+        assert ext is not None
+        assert ext.critical is False
+        assert ext.value.ca is False
+
+
+class TestSubjectKeyIdentifierExtension(object):
+    @pytest.mark.requires_backend_interface(interface=RSABackend)
+    @pytest.mark.requires_backend_interface(interface=X509Backend)
+    def test_subject_key_identifier(self, backend):
+        cert = _load_cert(
+            os.path.join("x509", "PKITS_data", "certs", "GoodCACert.crt"),
+            x509.load_der_x509_certificate,
+            backend
+        )
+        ext = cert.extensions.get_extension_for_oid(
+            ExtensionOID.SUBJECT_KEY_IDENTIFIER
+        )
+        ski = ext.value
+        assert ext is not None
+        assert ext.critical is False
+        assert ski.digest == binascii.unhexlify(
+            b"580184241bbc2b52944a3da510721451f5af3ac9"
+        )
+
+    @pytest.mark.requires_backend_interface(interface=RSABackend)
+    @pytest.mark.requires_backend_interface(interface=X509Backend)
+    def test_no_subject_key_identifier(self, backend):
+        cert = _load_cert(
+            os.path.join("x509", "custom", "bc_path_length_zero.pem"),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+        with pytest.raises(x509.ExtensionNotFound):
+            cert.extensions.get_extension_for_oid(
+                ExtensionOID.SUBJECT_KEY_IDENTIFIER
+            )
+
+    @pytest.mark.requires_backend_interface(interface=RSABackend)
+    @pytest.mark.requires_backend_interface(interface=X509Backend)
+    def test_from_rsa_public_key(self, backend):
+        cert = _load_cert(
+            os.path.join("x509", "PKITS_data", "certs", "GoodCACert.crt"),
+            x509.load_der_x509_certificate,
+            backend
+        )
+        ext = cert.extensions.get_extension_for_oid(
+            ExtensionOID.SUBJECT_KEY_IDENTIFIER
+        )
+        ski = x509.SubjectKeyIdentifier.from_public_key(
+            cert.public_key()
+        )
+        assert ext.value == ski
+
+    @pytest.mark.requires_backend_interface(interface=DSABackend)
+    @pytest.mark.requires_backend_interface(interface=X509Backend)
+    def test_from_dsa_public_key(self, backend):
+        cert = _load_cert(
+            os.path.join("x509", "custom", "dsa_selfsigned_ca.pem"),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+
+        ext = cert.extensions.get_extension_for_oid(
+            ExtensionOID.SUBJECT_KEY_IDENTIFIER
+        )
+        ski = x509.SubjectKeyIdentifier.from_public_key(
+            cert.public_key()
+        )
+        assert ext.value == ski
+
+    @pytest.mark.requires_backend_interface(interface=EllipticCurveBackend)
+    @pytest.mark.requires_backend_interface(interface=X509Backend)
+    def test_from_ec_public_key(self, backend):
+        _skip_curve_unsupported(backend, ec.SECP384R1())
+        cert = _load_cert(
+            os.path.join("x509", "ecdsa_root.pem"),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+
+        ext = cert.extensions.get_extension_for_oid(
+            ExtensionOID.SUBJECT_KEY_IDENTIFIER
+        )
+        ski = x509.SubjectKeyIdentifier.from_public_key(
+            cert.public_key()
+        )
+        assert ext.value == ski
+
+
+@pytest.mark.requires_backend_interface(interface=RSABackend)
+@pytest.mark.requires_backend_interface(interface=X509Backend)
+class TestKeyUsageExtension(object):
+    def test_no_key_usage(self, backend):
+        cert = _load_cert(
+            os.path.join("x509", "verisign_md2_root.pem"),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+        ext = cert.extensions
+        with pytest.raises(x509.ExtensionNotFound) as exc:
+            ext.get_extension_for_oid(ExtensionOID.KEY_USAGE)
+
+        assert exc.value.oid == ExtensionOID.KEY_USAGE
+
+    def test_all_purposes(self, backend):
+        cert = _load_cert(
+            os.path.join(
+                "x509", "custom", "all_key_usages.pem"
+            ),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+        extensions = cert.extensions
+        ext = extensions.get_extension_for_oid(ExtensionOID.KEY_USAGE)
+        assert ext is not None
+
+        ku = ext.value
+        assert ku.digital_signature is True
+        assert ku.content_commitment is True
+        assert ku.key_encipherment is True
+        assert ku.data_encipherment is True
+        assert ku.key_agreement is True
+        assert ku.key_cert_sign is True
+        assert ku.crl_sign is True
+        assert ku.encipher_only is True
+        assert ku.decipher_only is True
+
+    def test_key_cert_sign_crl_sign(self, backend):
+        cert = _load_cert(
+            os.path.join(
+                "x509", "PKITS_data", "certs", "pathLenConstraint6CACert.crt"
+            ),
+            x509.load_der_x509_certificate,
+            backend
+        )
+        ext = cert.extensions.get_extension_for_oid(ExtensionOID.KEY_USAGE)
+        assert ext is not None
+        assert ext.critical is True
+
+        ku = ext.value
+        assert ku.digital_signature is False
+        assert ku.content_commitment is False
+        assert ku.key_encipherment is False
+        assert ku.data_encipherment is False
+        assert ku.key_agreement is False
+        assert ku.key_cert_sign is True
+        assert ku.crl_sign is True
+
+
+@pytest.mark.parametrize(
+    "name", [
+        x509.RFC822Name,
+        x509.DNSName,
+        x509.UniformResourceIdentifier
+    ]
+)
+class TestTextGeneralNames(object):
+    def test_not_text(self, name):
+        with pytest.raises(TypeError):
+            name(b"notaunicodestring")
+
+        with pytest.raises(TypeError):
+            name(1.3)
+
+    def test_repr(self, name):
+        gn = name(u"string")
+        assert repr(gn) == "<{0}(value=string)>".format(name.__name__)
+
+    def test_eq(self, name):
+        gn = name(u"string")
+        gn2 = name(u"string")
+        assert gn == gn2
+
+    def test_ne(self, name):
+        gn = name(u"string")
+        gn2 = name(u"string2")
+        assert gn != gn2
+        assert gn != object()
+
+
+class TestDirectoryName(object):
+    def test_not_name(self):
+        with pytest.raises(TypeError):
+            x509.DirectoryName(b"notaname")
+
+        with pytest.raises(TypeError):
+            x509.DirectoryName(1.3)
+
+    def test_repr(self):
+        name = x509.Name([x509.NameAttribute(NameOID.COMMON_NAME, u'value1')])
+        gn = x509.DirectoryName(x509.Name([name]))
+        if six.PY3:
+            assert repr(gn) == (
+                "<DirectoryName(value=<Name([<Name([<NameAttribute(oid=<Object"
+                "Identifier(oid=2.5.4.3, name=commonName)>, value='value1')>])"
+                ">])>)>"
+            )
+        else:
+            assert repr(gn) == (
+                "<DirectoryName(value=<Name([<Name([<NameAttribute(oid=<Object"
+                "Identifier(oid=2.5.4.3, name=commonName)>, value=u'value1')>]"
+                ")>])>)>"
+            )
+
+    def test_eq(self):
+        name = x509.Name([
+            x509.NameAttribute(x509.ObjectIdentifier('oid'), u'value1')
+        ])
+        name2 = x509.Name([
+            x509.NameAttribute(x509.ObjectIdentifier('oid'), u'value1')
+        ])
+        gn = x509.DirectoryName(x509.Name([name]))
+        gn2 = x509.DirectoryName(x509.Name([name2]))
+        assert gn == gn2
+
+    def test_ne(self):
+        name = x509.Name([
+            x509.NameAttribute(x509.ObjectIdentifier('oid'), u'value1')
+        ])
+        name2 = x509.Name([
+            x509.NameAttribute(x509.ObjectIdentifier('oid'), u'value2')
+        ])
+        gn = x509.DirectoryName(x509.Name([name]))
+        gn2 = x509.DirectoryName(x509.Name([name2]))
+        assert gn != gn2
+        assert gn != object()
+
+
+class TestRFC822Name(object):
+    def test_invalid_email(self):
+        with pytest.raises(ValueError):
+            x509.RFC822Name(u"Name <email>")
+
+        with pytest.raises(ValueError):
+            x509.RFC822Name(u"")
+
+    def test_single_label(self):
+        gn = x509.RFC822Name(u"administrator")
+        assert gn.value == u"administrator"
+
+    def test_idna(self):
+        gn = x509.RFC822Name(u"email@em\xe5\xefl.com")
+        assert gn.value == u"email@em\xe5\xefl.com"
+        assert gn._encoded == b"email@xn--eml-vla4c.com"
+
+
+class TestUniformResourceIdentifier(object):
+    def test_no_parsed_hostname(self):
+        gn = x509.UniformResourceIdentifier(u"singlelabel")
+        assert gn.value == u"singlelabel"
+
+    def test_with_port(self):
+        gn = x509.UniformResourceIdentifier(u"singlelabel:443/test")
+        assert gn.value == u"singlelabel:443/test"
+
+    def test_idna_no_port(self):
+        gn = x509.UniformResourceIdentifier(
+            u"http://\u043f\u044b\u043a\u0430.cryptography"
+        )
+        assert gn.value == u"http://\u043f\u044b\u043a\u0430.cryptography"
+        assert gn._encoded == b"http://xn--80ato2c.cryptography"
+
+    def test_idna_with_port(self):
+        gn = x509.UniformResourceIdentifier(
+            u"gopher://\u043f\u044b\u043a\u0430.cryptography:70/some/path"
+        )
+        assert gn.value == (
+            u"gopher://\u043f\u044b\u043a\u0430.cryptography:70/some/path"
+        )
+        assert gn._encoded == b"gopher://xn--80ato2c.cryptography:70/some/path"
+
+    def test_query_and_fragment(self):
+        gn = x509.UniformResourceIdentifier(
+            u"ldap://cryptography:90/path?query=true#somedata"
+        )
+        assert gn.value == u"ldap://cryptography:90/path?query=true#somedata"
+
+
+class TestRegisteredID(object):
+    def test_not_oid(self):
+        with pytest.raises(TypeError):
+            x509.RegisteredID(b"notanoid")
+
+        with pytest.raises(TypeError):
+            x509.RegisteredID(1.3)
+
+    def test_repr(self):
+        gn = x509.RegisteredID(NameOID.COMMON_NAME)
+        assert repr(gn) == (
+            "<RegisteredID(value=<ObjectIdentifier(oid=2.5.4.3, name=commonNam"
+            "e)>)>"
+        )
+
+    def test_eq(self):
+        gn = x509.RegisteredID(NameOID.COMMON_NAME)
+        gn2 = x509.RegisteredID(NameOID.COMMON_NAME)
+        assert gn == gn2
+
+    def test_ne(self):
+        gn = x509.RegisteredID(NameOID.COMMON_NAME)
+        gn2 = x509.RegisteredID(ExtensionOID.BASIC_CONSTRAINTS)
+        assert gn != gn2
+        assert gn != object()
+
+
+class TestIPAddress(object):
+    def test_not_ipaddress(self):
+        with pytest.raises(TypeError):
+            x509.IPAddress(b"notanipaddress")
+
+        with pytest.raises(TypeError):
+            x509.IPAddress(1.3)
+
+    def test_repr(self):
+        gn = x509.IPAddress(ipaddress.IPv4Address(u"127.0.0.1"))
+        assert repr(gn) == "<IPAddress(value=127.0.0.1)>"
+
+        gn2 = x509.IPAddress(ipaddress.IPv6Address(u"ff::"))
+        assert repr(gn2) == "<IPAddress(value=ff::)>"
+
+        gn3 = x509.IPAddress(ipaddress.IPv4Network(u"192.168.0.0/24"))
+        assert repr(gn3) == "<IPAddress(value=192.168.0.0/24)>"
+
+        gn4 = x509.IPAddress(ipaddress.IPv6Network(u"ff::/96"))
+        assert repr(gn4) == "<IPAddress(value=ff::/96)>"
+
+    def test_eq(self):
+        gn = x509.IPAddress(ipaddress.IPv4Address(u"127.0.0.1"))
+        gn2 = x509.IPAddress(ipaddress.IPv4Address(u"127.0.0.1"))
+        assert gn == gn2
+
+    def test_ne(self):
+        gn = x509.IPAddress(ipaddress.IPv4Address(u"127.0.0.1"))
+        gn2 = x509.IPAddress(ipaddress.IPv4Address(u"127.0.0.2"))
+        assert gn != gn2
+        assert gn != object()
+
+
+class TestOtherName(object):
+    def test_invalid_args(self):
+        with pytest.raises(TypeError):
+            x509.OtherName(b"notanobjectidentifier", b"derdata")
+
+        with pytest.raises(TypeError):
+            x509.OtherName(x509.ObjectIdentifier("1.2.3.4"), u"notderdata")
+
+    def test_repr(self):
+        gn = x509.OtherName(x509.ObjectIdentifier("1.2.3.4"), b"derdata")
+        if six.PY3:
+            assert repr(gn) == (
+                "<OtherName(type_id=<ObjectIdentifier(oid=1.2.3.4, "
+                "name=Unknown OID)>, value=b'derdata')>"
+            )
+        else:
+            assert repr(gn) == (
+                "<OtherName(type_id=<ObjectIdentifier(oid=1.2.3.4, "
+                "name=Unknown OID)>, value='derdata')>"
+            )
+
+        gn = x509.OtherName(x509.ObjectIdentifier("2.5.4.65"), b"derdata")
+        if six.PY3:
+            assert repr(gn) == (
+                "<OtherName(type_id=<ObjectIdentifier(oid=2.5.4.65, "
+                "name=pseudonym)>, value=b'derdata')>"
+            )
+        else:
+            assert repr(gn) == (
+                "<OtherName(type_id=<ObjectIdentifier(oid=2.5.4.65, "
+                "name=pseudonym)>, value='derdata')>"
+            )
+
+    def test_eq(self):
+        gn = x509.OtherName(x509.ObjectIdentifier("1.2.3.4"), b"derdata")
+        gn2 = x509.OtherName(x509.ObjectIdentifier("1.2.3.4"), b"derdata")
+        assert gn == gn2
+
+    def test_ne(self):
+        gn = x509.OtherName(x509.ObjectIdentifier("1.2.3.4"), b"derdata")
+        assert gn != object()
+
+        gn2 = x509.OtherName(x509.ObjectIdentifier("1.2.3.4"), b"derdata2")
+        assert gn != gn2
+
+        gn2 = x509.OtherName(x509.ObjectIdentifier("1.2.3.5"), b"derdata")
+        assert gn != gn2
+
+
+class TestGeneralNames(object):
+    def test_get_values_for_type(self):
+        gns = x509.GeneralNames(
+            [x509.DNSName(u"cryptography.io")]
+        )
+        names = gns.get_values_for_type(x509.DNSName)
+        assert names == [u"cryptography.io"]
+
+    def test_iter_names(self):
+        gns = x509.GeneralNames([
+            x509.DNSName(u"cryptography.io"),
+            x509.DNSName(u"crypto.local"),
+        ])
+        assert len(gns) == 2
+        assert list(gns) == [
+            x509.DNSName(u"cryptography.io"),
+            x509.DNSName(u"crypto.local"),
+        ]
+
+    def test_invalid_general_names(self):
+        with pytest.raises(TypeError):
+            x509.GeneralNames(
+                [x509.DNSName(u"cryptography.io"), "invalid"]
+            )
+
+    def test_repr(self):
+        gns = x509.GeneralNames(
+            [
+                x509.DNSName(u"cryptography.io")
+            ]
+        )
+        assert repr(gns) == (
+            "<GeneralNames([<DNSName(value=cryptography.io)>])>"
+        )
+
+    def test_eq(self):
+        gns = x509.GeneralNames(
+            [x509.DNSName(u"cryptography.io")]
+        )
+        gns2 = x509.GeneralNames(
+            [x509.DNSName(u"cryptography.io")]
+        )
+        assert gns == gns2
+
+    def test_ne(self):
+        gns = x509.GeneralNames(
+            [x509.DNSName(u"cryptography.io")]
+        )
+        gns2 = x509.GeneralNames(
+            [x509.RFC822Name(u"admin@cryptography.io")]
+        )
+        assert gns != gns2
+        assert gns != object()
+
+
+class TestIssuerAlternativeName(object):
+    def test_get_values_for_type(self):
+        san = x509.IssuerAlternativeName(
+            [x509.DNSName(u"cryptography.io")]
+        )
+        names = san.get_values_for_type(x509.DNSName)
+        assert names == [u"cryptography.io"]
+
+    def test_iter_names(self):
+        san = x509.IssuerAlternativeName([
+            x509.DNSName(u"cryptography.io"),
+            x509.DNSName(u"crypto.local"),
+        ])
+        assert len(san) == 2
+        assert list(san) == [
+            x509.DNSName(u"cryptography.io"),
+            x509.DNSName(u"crypto.local"),
+        ]
+
+    def test_invalid_general_names(self):
+        with pytest.raises(TypeError):
+            x509.IssuerAlternativeName(
+                [x509.DNSName(u"cryptography.io"), "invalid"]
+            )
+
+    def test_repr(self):
+        san = x509.IssuerAlternativeName(
+            [
+                x509.DNSName(u"cryptography.io")
+            ]
+        )
+        assert repr(san) == (
+            "<IssuerAlternativeName("
+            "<GeneralNames([<DNSName(value=cryptography.io)>])>)>"
+        )
+
+    def test_eq(self):
+        san = x509.IssuerAlternativeName(
+            [x509.DNSName(u"cryptography.io")]
+        )
+        san2 = x509.IssuerAlternativeName(
+            [x509.DNSName(u"cryptography.io")]
+        )
+        assert san == san2
+
+    def test_ne(self):
+        san = x509.IssuerAlternativeName(
+            [x509.DNSName(u"cryptography.io")]
+        )
+        san2 = x509.IssuerAlternativeName(
+            [x509.RFC822Name(u"admin@cryptography.io")]
+        )
+        assert san != san2
+        assert san != object()
+
+
+@pytest.mark.requires_backend_interface(interface=RSABackend)
+@pytest.mark.requires_backend_interface(interface=X509Backend)
+class TestRSAIssuerAlternativeNameExtension(object):
+    def test_uri(self, backend):
+        cert = _load_cert(
+            os.path.join("x509", "custom", "ian_uri.pem"),
+            x509.load_pem_x509_certificate,
+            backend,
+        )
+        ext = cert.extensions.get_extension_for_oid(
+            ExtensionOID.ISSUER_ALTERNATIVE_NAME
+        )
+        assert list(ext.value) == [
+            x509.UniformResourceIdentifier(u"http://path.to.root/root.crt"),
+        ]
+
+
+class TestSubjectAlternativeName(object):
+    def test_get_values_for_type(self):
+        san = x509.SubjectAlternativeName(
+            [x509.DNSName(u"cryptography.io")]
+        )
+        names = san.get_values_for_type(x509.DNSName)
+        assert names == [u"cryptography.io"]
+
+    def test_iter_names(self):
+        san = x509.SubjectAlternativeName([
+            x509.DNSName(u"cryptography.io"),
+            x509.DNSName(u"crypto.local"),
+        ])
+        assert len(san) == 2
+        assert list(san) == [
+            x509.DNSName(u"cryptography.io"),
+            x509.DNSName(u"crypto.local"),
+        ]
+
+    def test_invalid_general_names(self):
+        with pytest.raises(TypeError):
+            x509.SubjectAlternativeName(
+                [x509.DNSName(u"cryptography.io"), "invalid"]
+            )
+
+    def test_repr(self):
+        san = x509.SubjectAlternativeName(
+            [
+                x509.DNSName(u"cryptography.io")
+            ]
+        )
+        assert repr(san) == (
+            "<SubjectAlternativeName("
+            "<GeneralNames([<DNSName(value=cryptography.io)>])>)>"
+        )
+
+    def test_eq(self):
+        san = x509.SubjectAlternativeName(
+            [x509.DNSName(u"cryptography.io")]
+        )
+        san2 = x509.SubjectAlternativeName(
+            [x509.DNSName(u"cryptography.io")]
+        )
+        assert san == san2
+
+    def test_ne(self):
+        san = x509.SubjectAlternativeName(
+            [x509.DNSName(u"cryptography.io")]
+        )
+        san2 = x509.SubjectAlternativeName(
+            [x509.RFC822Name(u"admin@cryptography.io")]
+        )
+        assert san != san2
+        assert san != object()
+
+
+@pytest.mark.requires_backend_interface(interface=RSABackend)
+@pytest.mark.requires_backend_interface(interface=X509Backend)
+class TestRSASubjectAlternativeNameExtension(object):
+    def test_dns_name(self, backend):
+        cert = _load_cert(
+            os.path.join("x509", "cryptography.io.pem"),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+        ext = cert.extensions.get_extension_for_oid(
+            ExtensionOID.SUBJECT_ALTERNATIVE_NAME
+        )
+        assert ext is not None
+        assert ext.critical is False
+
+        san = ext.value
+
+        dns = san.get_values_for_type(x509.DNSName)
+        assert dns == [u"www.cryptography.io", u"cryptography.io"]
+
+    def test_wildcard_dns_name(self, backend):
+        cert = _load_cert(
+            os.path.join("x509", "wildcard_san.pem"),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+        ext = cert.extensions.get_extension_for_oid(
+            ExtensionOID.SUBJECT_ALTERNATIVE_NAME
+        )
+
+        dns = ext.value.get_values_for_type(x509.DNSName)
+        assert dns == [
+            u'*.langui.sh',
+            u'langui.sh',
+            u'*.saseliminator.com',
+            u'saseliminator.com'
+        ]
+
+    def test_san_empty_hostname(self, backend):
+        cert = _load_cert(
+            os.path.join(
+                "x509", "custom", "san_empty_hostname.pem"
+            ),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+        san = cert.extensions.get_extension_for_oid(
+            ExtensionOID.SUBJECT_ALTERNATIVE_NAME
+        )
+
+        dns = san.value.get_values_for_type(x509.DNSName)
+        assert dns == [u'']
+
+    def test_san_wildcard_idna_dns_name(self, backend):
+        cert = _load_cert(
+            os.path.join("x509", "custom", "san_wildcard_idna.pem"),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+        ext = cert.extensions.get_extension_for_oid(
+            ExtensionOID.SUBJECT_ALTERNATIVE_NAME
+        )
+
+        dns = ext.value.get_values_for_type(x509.DNSName)
+        assert dns == [u'*.\u043f\u044b\u043a\u0430.cryptography']
+
+    def test_unsupported_gn(self, backend):
+        cert = _load_cert(
+            os.path.join("x509", "san_x400address.der"),
+            x509.load_der_x509_certificate,
+            backend
+        )
+        with pytest.raises(x509.UnsupportedGeneralNameType) as exc:
+            cert.extensions
+
+        assert exc.value.type == 3
+
+    def test_registered_id(self, backend):
+        cert = _load_cert(
+            os.path.join(
+                "x509", "custom", "san_registered_id.pem"
+            ),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+        ext = cert.extensions.get_extension_for_oid(
+            ExtensionOID.SUBJECT_ALTERNATIVE_NAME
+        )
+        assert ext is not None
+        assert ext.critical is False
+
+        san = ext.value
+        rid = san.get_values_for_type(x509.RegisteredID)
+        assert rid == [x509.ObjectIdentifier("1.2.3.4")]
+
+    def test_uri(self, backend):
+        cert = _load_cert(
+            os.path.join(
+                "x509", "custom", "san_uri_with_port.pem"
+            ),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+        ext = cert.extensions.get_extension_for_oid(
+            ExtensionOID.SUBJECT_ALTERNATIVE_NAME
+        )
+        assert ext is not None
+        uri = ext.value.get_values_for_type(
+            x509.UniformResourceIdentifier
+        )
+        assert uri == [
+            u"gopher://\u043f\u044b\u043a\u0430.cryptography:70/path?q=s#hel"
+            u"lo",
+            u"http://someregulardomain.com",
+        ]
+
+    def test_ipaddress(self, backend):
+        cert = _load_cert(
+            os.path.join(
+                "x509", "custom", "san_ipaddr.pem"
+            ),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+        ext = cert.extensions.get_extension_for_oid(
+            ExtensionOID.SUBJECT_ALTERNATIVE_NAME
+        )
+        assert ext is not None
+        assert ext.critical is False
+
+        san = ext.value
+
+        ip = san.get_values_for_type(x509.IPAddress)
+        assert [
+            ipaddress.ip_address(u"127.0.0.1"),
+            ipaddress.ip_address(u"ff::")
+        ] == ip
+
+    def test_dirname(self, backend):
+        cert = _load_cert(
+            os.path.join(
+                "x509", "custom", "san_dirname.pem"
+            ),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+        ext = cert.extensions.get_extension_for_oid(
+            ExtensionOID.SUBJECT_ALTERNATIVE_NAME
+        )
+        assert ext is not None
+        assert ext.critical is False
+
+        san = ext.value
+
+        dirname = san.get_values_for_type(x509.DirectoryName)
+        assert [
+            x509.Name([
+                x509.NameAttribute(NameOID.COMMON_NAME, u'test'),
+                x509.NameAttribute(NameOID.ORGANIZATION_NAME, u'Org'),
+                x509.NameAttribute(NameOID.STATE_OR_PROVINCE_NAME, u'Texas'),
+            ])
+        ] == dirname
+
+    def test_rfc822name(self, backend):
+        cert = _load_cert(
+            os.path.join(
+                "x509", "custom", "san_rfc822_idna.pem"
+            ),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+        ext = cert.extensions.get_extension_for_oid(
+            ExtensionOID.SUBJECT_ALTERNATIVE_NAME
+        )
+        assert ext is not None
+        assert ext.critical is False
+
+        san = ext.value
+
+        rfc822name = san.get_values_for_type(x509.RFC822Name)
+        assert [u"email@em\xe5\xefl.com"] == rfc822name
+
+    def test_idna2003_invalid(self, backend):
+        cert = _load_cert(
+            os.path.join(
+                "x509", "custom", "san_idna2003_dnsname.pem"
+            ),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+        with pytest.raises(UnicodeError):
+            cert.extensions
+
+    def test_unicode_rfc822_name_dns_name_uri(self, backend):
+        cert = _load_cert(
+            os.path.join(
+                "x509", "custom", "san_idna_names.pem"
+            ),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+        ext = cert.extensions.get_extension_for_oid(
+            ExtensionOID.SUBJECT_ALTERNATIVE_NAME
+        )
+        assert ext is not None
+        rfc822_name = ext.value.get_values_for_type(x509.RFC822Name)
+        dns_name = ext.value.get_values_for_type(x509.DNSName)
+        uri = ext.value.get_values_for_type(x509.UniformResourceIdentifier)
+        assert rfc822_name == [u"email@\u043f\u044b\u043a\u0430.cryptography"]
+        assert dns_name == [u"\u043f\u044b\u043a\u0430.cryptography"]
+        assert uri == [u"https://www.\u043f\u044b\u043a\u0430.cryptography"]
+
+    def test_rfc822name_dnsname_ipaddress_directoryname_uri(self, backend):
+        cert = _load_cert(
+            os.path.join(
+                "x509", "custom", "san_email_dns_ip_dirname_uri.pem"
+            ),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+        ext = cert.extensions.get_extension_for_oid(
+            ExtensionOID.SUBJECT_ALTERNATIVE_NAME
+        )
+        assert ext is not None
+        assert ext.critical is False
+
+        san = ext.value
+
+        rfc822_name = san.get_values_for_type(x509.RFC822Name)
+        uri = san.get_values_for_type(x509.UniformResourceIdentifier)
+        dns = san.get_values_for_type(x509.DNSName)
+        ip = san.get_values_for_type(x509.IPAddress)
+        dirname = san.get_values_for_type(x509.DirectoryName)
+        assert [u"user@cryptography.io"] == rfc822_name
+        assert [u"https://cryptography.io"] == uri
+        assert [u"cryptography.io"] == dns
+        assert [
+            x509.Name([
+                x509.NameAttribute(NameOID.COMMON_NAME, u'dirCN'),
+                x509.NameAttribute(
+                    NameOID.ORGANIZATION_NAME, u'Cryptographic Authority'
+                ),
+            ])
+        ] == dirname
+        assert [
+            ipaddress.ip_address(u"127.0.0.1"),
+            ipaddress.ip_address(u"ff::")
+        ] == ip
+
+    def test_invalid_rfc822name(self, backend):
+        cert = _load_cert(
+            os.path.join(
+                "x509", "custom", "san_rfc822_names.pem"
+            ),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+        with pytest.raises(ValueError) as exc:
+            cert.extensions
+
+        assert 'Invalid rfc822name value' in str(exc.value)
+
+    def test_other_name(self, backend):
+        cert = _load_cert(
+            os.path.join(
+                "x509", "custom", "san_other_name.pem"
+            ),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+
+        ext = cert.extensions.get_extension_for_oid(
+            ExtensionOID.SUBJECT_ALTERNATIVE_NAME
+        )
+        assert ext is not None
+        assert ext.critical is False
+
+        expected = x509.OtherName(x509.ObjectIdentifier("1.2.3.4"),
+                                  b'\x16\x0bHello World')
+        assert len(ext.value) == 1
+        assert list(ext.value)[0] == expected
+
+        othernames = ext.value.get_values_for_type(x509.OtherName)
+        assert othernames == [expected]
+
+
+@pytest.mark.requires_backend_interface(interface=RSABackend)
+@pytest.mark.requires_backend_interface(interface=X509Backend)
+class TestExtendedKeyUsageExtension(object):
+    def test_eku(self, backend):
+        cert = _load_cert(
+            os.path.join(
+                "x509", "custom", "extended_key_usage.pem"
+            ),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+        ext = cert.extensions.get_extension_for_oid(
+            ExtensionOID.EXTENDED_KEY_USAGE
+        )
+        assert ext is not None
+        assert ext.critical is False
+
+        assert [
+            x509.ObjectIdentifier("1.3.6.1.5.5.7.3.1"),
+            x509.ObjectIdentifier("1.3.6.1.5.5.7.3.2"),
+            x509.ObjectIdentifier("1.3.6.1.5.5.7.3.3"),
+            x509.ObjectIdentifier("1.3.6.1.5.5.7.3.4"),
+            x509.ObjectIdentifier("1.3.6.1.5.5.7.3.9"),
+            x509.ObjectIdentifier("1.3.6.1.5.5.7.3.8"),
+            x509.ObjectIdentifier("2.5.29.37.0"),
+            x509.ObjectIdentifier("2.16.840.1.113730.4.1"),
+        ] == list(ext.value)
+
+
+class TestAccessDescription(object):
+    def test_invalid_access_method(self):
+        with pytest.raises(ValueError):
+            x509.AccessDescription("notanoid", x509.DNSName(u"test"))
+
+    def test_invalid_access_location(self):
+        with pytest.raises(TypeError):
+            x509.AccessDescription(
+                AuthorityInformationAccessOID.CA_ISSUERS, "invalid"
+            )
+
+    def test_repr(self):
+        ad = x509.AccessDescription(
+            AuthorityInformationAccessOID.OCSP,
+            x509.UniformResourceIdentifier(u"http://ocsp.domain.com")
+        )
+        assert repr(ad) == (
+            "<AccessDescription(access_method=<ObjectIdentifier(oid=1.3.6.1.5."
+            "5.7.48.1, name=OCSP)>, access_location=<UniformResourceIdentifier"
+            "(value=http://ocsp.domain.com)>)>"
+        )
+
+    def test_eq(self):
+        ad = x509.AccessDescription(
+            AuthorityInformationAccessOID.OCSP,
+            x509.UniformResourceIdentifier(u"http://ocsp.domain.com")
+        )
+        ad2 = x509.AccessDescription(
+            AuthorityInformationAccessOID.OCSP,
+            x509.UniformResourceIdentifier(u"http://ocsp.domain.com")
+        )
+        assert ad == ad2
+
+    def test_ne(self):
+        ad = x509.AccessDescription(
+            AuthorityInformationAccessOID.OCSP,
+            x509.UniformResourceIdentifier(u"http://ocsp.domain.com")
+        )
+        ad2 = x509.AccessDescription(
+            AuthorityInformationAccessOID.CA_ISSUERS,
+            x509.UniformResourceIdentifier(u"http://ocsp.domain.com")
+        )
+        ad3 = x509.AccessDescription(
+            AuthorityInformationAccessOID.OCSP,
+            x509.UniformResourceIdentifier(u"http://notthesame")
+        )
+        assert ad != ad2
+        assert ad != ad3
+        assert ad != object()
+
+
+class TestAuthorityInformationAccess(object):
+    def test_invalid_descriptions(self):
+        with pytest.raises(TypeError):
+            x509.AuthorityInformationAccess(["notanAccessDescription"])
+
+    def test_iter_len(self):
+        aia = x509.AuthorityInformationAccess([
+            x509.AccessDescription(
+                AuthorityInformationAccessOID.OCSP,
+                x509.UniformResourceIdentifier(u"http://ocsp.domain.com")
+            ),
+            x509.AccessDescription(
+                AuthorityInformationAccessOID.CA_ISSUERS,
+                x509.UniformResourceIdentifier(u"http://domain.com/ca.crt")
+            )
+        ])
+        assert len(aia) == 2
+        assert list(aia) == [
+            x509.AccessDescription(
+                AuthorityInformationAccessOID.OCSP,
+                x509.UniformResourceIdentifier(u"http://ocsp.domain.com")
+            ),
+            x509.AccessDescription(
+                AuthorityInformationAccessOID.CA_ISSUERS,
+                x509.UniformResourceIdentifier(u"http://domain.com/ca.crt")
+            )
+        ]
+
+    def test_repr(self):
+        aia = x509.AuthorityInformationAccess([
+            x509.AccessDescription(
+                AuthorityInformationAccessOID.OCSP,
+                x509.UniformResourceIdentifier(u"http://ocsp.domain.com")
+            ),
+            x509.AccessDescription(
+                AuthorityInformationAccessOID.CA_ISSUERS,
+                x509.UniformResourceIdentifier(u"http://domain.com/ca.crt")
+            )
+        ])
+        assert repr(aia) == (
+            "<AuthorityInformationAccess([<AccessDescription(access_method=<Ob"
+            "jectIdentifier(oid=1.3.6.1.5.5.7.48.1, name=OCSP)>, access_locati"
+            "on=<UniformResourceIdentifier(value=http://ocsp.domain.com)>)>, <"
+            "AccessDescription(access_method=<ObjectIdentifier(oid=1.3.6.1.5.5"
+            ".7.48.2, name=caIssuers)>, access_location=<UniformResourceIdenti"
+            "fier(value=http://domain.com/ca.crt)>)>])>"
+        )
+
+    def test_eq(self):
+        aia = x509.AuthorityInformationAccess([
+            x509.AccessDescription(
+                AuthorityInformationAccessOID.OCSP,
+                x509.UniformResourceIdentifier(u"http://ocsp.domain.com")
+            ),
+            x509.AccessDescription(
+                AuthorityInformationAccessOID.CA_ISSUERS,
+                x509.UniformResourceIdentifier(u"http://domain.com/ca.crt")
+            )
+        ])
+        aia2 = x509.AuthorityInformationAccess([
+            x509.AccessDescription(
+                AuthorityInformationAccessOID.OCSP,
+                x509.UniformResourceIdentifier(u"http://ocsp.domain.com")
+            ),
+            x509.AccessDescription(
+                AuthorityInformationAccessOID.CA_ISSUERS,
+                x509.UniformResourceIdentifier(u"http://domain.com/ca.crt")
+            )
+        ])
+        assert aia == aia2
+
+    def test_ne(self):
+        aia = x509.AuthorityInformationAccess([
+            x509.AccessDescription(
+                AuthorityInformationAccessOID.OCSP,
+                x509.UniformResourceIdentifier(u"http://ocsp.domain.com")
+            ),
+            x509.AccessDescription(
+                AuthorityInformationAccessOID.CA_ISSUERS,
+                x509.UniformResourceIdentifier(u"http://domain.com/ca.crt")
+            )
+        ])
+        aia2 = x509.AuthorityInformationAccess([
+            x509.AccessDescription(
+                AuthorityInformationAccessOID.OCSP,
+                x509.UniformResourceIdentifier(u"http://ocsp.domain.com")
+            ),
+        ])
+
+        assert aia != aia2
+        assert aia != object()
+
+
+@pytest.mark.requires_backend_interface(interface=RSABackend)
+@pytest.mark.requires_backend_interface(interface=X509Backend)
+class TestAuthorityInformationAccessExtension(object):
+    def test_aia_ocsp_ca_issuers(self, backend):
+        cert = _load_cert(
+            os.path.join("x509", "cryptography.io.pem"),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+        ext = cert.extensions.get_extension_for_oid(
+            ExtensionOID.AUTHORITY_INFORMATION_ACCESS
+        )
+        assert ext is not None
+        assert ext.critical is False
+
+        assert ext.value == x509.AuthorityInformationAccess([
+            x509.AccessDescription(
+                AuthorityInformationAccessOID.OCSP,
+                x509.UniformResourceIdentifier(u"http://gv.symcd.com")
+            ),
+            x509.AccessDescription(
+                AuthorityInformationAccessOID.CA_ISSUERS,
+                x509.UniformResourceIdentifier(u"http://gv.symcb.com/gv.crt")
+            ),
+        ])
+
+    def test_aia_multiple_ocsp_ca_issuers(self, backend):
+        cert = _load_cert(
+            os.path.join("x509", "custom", "aia_ocsp_ca_issuers.pem"),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+        ext = cert.extensions.get_extension_for_oid(
+            ExtensionOID.AUTHORITY_INFORMATION_ACCESS
+        )
+        assert ext is not None
+        assert ext.critical is False
+
+        assert ext.value == x509.AuthorityInformationAccess([
+            x509.AccessDescription(
+                AuthorityInformationAccessOID.OCSP,
+                x509.UniformResourceIdentifier(u"http://ocsp.domain.com")
+            ),
+            x509.AccessDescription(
+                AuthorityInformationAccessOID.OCSP,
+                x509.UniformResourceIdentifier(u"http://ocsp2.domain.com")
+            ),
+            x509.AccessDescription(
+                AuthorityInformationAccessOID.CA_ISSUERS,
+                x509.DirectoryName(x509.Name([
+                    x509.NameAttribute(NameOID.COMMON_NAME, u"myCN"),
+                    x509.NameAttribute(NameOID.ORGANIZATION_NAME,
+                                       u"some Org"),
+                ]))
+            ),
+        ])
+
+    def test_aia_ocsp_only(self, backend):
+        cert = _load_cert(
+            os.path.join("x509", "custom", "aia_ocsp.pem"),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+        ext = cert.extensions.get_extension_for_oid(
+            ExtensionOID.AUTHORITY_INFORMATION_ACCESS
+        )
+        assert ext is not None
+        assert ext.critical is False
+
+        assert ext.value == x509.AuthorityInformationAccess([
+            x509.AccessDescription(
+                AuthorityInformationAccessOID.OCSP,
+                x509.UniformResourceIdentifier(u"http://ocsp.domain.com")
+            ),
+        ])
+
+    def test_aia_ca_issuers_only(self, backend):
+        cert = _load_cert(
+            os.path.join("x509", "custom", "aia_ca_issuers.pem"),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+        ext = cert.extensions.get_extension_for_oid(
+            ExtensionOID.AUTHORITY_INFORMATION_ACCESS
+        )
+        assert ext is not None
+        assert ext.critical is False
+
+        assert ext.value == x509.AuthorityInformationAccess([
+            x509.AccessDescription(
+                AuthorityInformationAccessOID.CA_ISSUERS,
+                x509.DirectoryName(x509.Name([
+                    x509.NameAttribute(NameOID.COMMON_NAME, u"myCN"),
+                    x509.NameAttribute(NameOID.ORGANIZATION_NAME,
+                                       u"some Org"),
+                ]))
+            ),
+        ])
+
+
+@pytest.mark.requires_backend_interface(interface=RSABackend)
+@pytest.mark.requires_backend_interface(interface=X509Backend)
+class TestAuthorityKeyIdentifierExtension(object):
+    def test_aki_keyid(self, backend):
+        cert = _load_cert(
+            os.path.join(
+                "x509", "cryptography.io.pem"
+            ),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+        ext = cert.extensions.get_extension_for_oid(
+            ExtensionOID.AUTHORITY_KEY_IDENTIFIER
+        )
+        assert ext is not None
+        assert ext.critical is False
+
+        assert ext.value.key_identifier == (
+            b"\xc3\x9c\xf3\xfc\xd3F\x084\xbb\xceF\x7f\xa0|[\xf3\xe2\x08\xcbY"
+        )
+        assert ext.value.authority_cert_issuer is None
+        assert ext.value.authority_cert_serial_number is None
+
+    def test_aki_all_fields(self, backend):
+        cert = _load_cert(
+            os.path.join(
+                "x509", "custom", "authority_key_identifier.pem"
+            ),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+        ext = cert.extensions.get_extension_for_oid(
+            ExtensionOID.AUTHORITY_KEY_IDENTIFIER
+        )
+        assert ext is not None
+        assert ext.critical is False
+
+        assert ext.value.key_identifier == (
+            b"9E>\xca=b\x1d\xea\x86I\xf6Z\xab@\xb7\xa4p\x98\xf1\xec"
+        )
+        assert ext.value.authority_cert_issuer == [
+            x509.DirectoryName(
+                x509.Name([
+                    x509.NameAttribute(
+                        NameOID.ORGANIZATION_NAME, u"PyCA"
+                    ),
+                    x509.NameAttribute(
+                        NameOID.COMMON_NAME, u"cryptography.io"
+                    )
+                ])
+            )
+        ]
+        assert ext.value.authority_cert_serial_number == 3
+
+    def test_aki_no_keyid(self, backend):
+        cert = _load_cert(
+            os.path.join(
+                "x509", "custom", "authority_key_identifier_no_keyid.pem"
+            ),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+        ext = cert.extensions.get_extension_for_oid(
+            ExtensionOID.AUTHORITY_KEY_IDENTIFIER
+        )
+        assert ext is not None
+        assert ext.critical is False
+
+        assert ext.value.key_identifier is None
+        assert ext.value.authority_cert_issuer == [
+            x509.DirectoryName(
+                x509.Name([
+                    x509.NameAttribute(
+                        NameOID.ORGANIZATION_NAME, u"PyCA"
+                    ),
+                    x509.NameAttribute(
+                        NameOID.COMMON_NAME, u"cryptography.io"
+                    )
+                ])
+            )
+        ]
+        assert ext.value.authority_cert_serial_number == 3
+
+    def test_from_certificate(self, backend):
+        issuer_cert = _load_cert(
+            os.path.join("x509", "rapidssl_sha256_ca_g3.pem"),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+        cert = _load_cert(
+            os.path.join("x509", "cryptography.io.pem"),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+        ext = cert.extensions.get_extension_for_oid(
+            ExtensionOID.AUTHORITY_KEY_IDENTIFIER
+        )
+        aki = x509.AuthorityKeyIdentifier.from_issuer_public_key(
+            issuer_cert.public_key()
+        )
+        assert ext.value == aki
+
+
+class TestNameConstraints(object):
+    def test_ipaddress_wrong_type(self):
+        with pytest.raises(TypeError):
+            x509.NameConstraints(
+                permitted_subtrees=[
+                    x509.IPAddress(ipaddress.IPv4Address(u"127.0.0.1"))
+                ],
+                excluded_subtrees=None
+            )
+
+        with pytest.raises(TypeError):
+            x509.NameConstraints(
+                permitted_subtrees=None,
+                excluded_subtrees=[
+                    x509.IPAddress(ipaddress.IPv4Address(u"127.0.0.1"))
+                ]
+            )
+
+    def test_ipaddress_allowed_type(self):
+        permitted = [x509.IPAddress(ipaddress.IPv4Network(u"192.168.0.0/29"))]
+        excluded = [x509.IPAddress(ipaddress.IPv4Network(u"10.10.0.0/24"))]
+        nc = x509.NameConstraints(
+            permitted_subtrees=permitted,
+            excluded_subtrees=excluded
+        )
+        assert nc.permitted_subtrees == permitted
+        assert nc.excluded_subtrees == excluded
+
+    def test_invalid_permitted_subtrees(self):
+        with pytest.raises(TypeError):
+            x509.NameConstraints("badpermitted", None)
+
+    def test_invalid_excluded_subtrees(self):
+        with pytest.raises(TypeError):
+            x509.NameConstraints(None, "badexcluded")
+
+    def test_no_subtrees(self):
+        with pytest.raises(ValueError):
+            x509.NameConstraints(None, None)
+
+    def test_permitted_none(self):
+        excluded = [x509.DNSName(u"name.local")]
+        nc = x509.NameConstraints(
+            permitted_subtrees=None, excluded_subtrees=excluded
+        )
+        assert nc.permitted_subtrees is None
+        assert nc.excluded_subtrees is not None
+
+    def test_excluded_none(self):
+        permitted = [x509.DNSName(u"name.local")]
+        nc = x509.NameConstraints(
+            permitted_subtrees=permitted, excluded_subtrees=None
+        )
+        assert nc.permitted_subtrees is not None
+        assert nc.excluded_subtrees is None
+
+    def test_repr(self):
+        permitted = [x509.DNSName(u"name.local"), x509.DNSName(u"name2.local")]
+        nc = x509.NameConstraints(
+            permitted_subtrees=permitted,
+            excluded_subtrees=None
+        )
+        assert repr(nc) == (
+            "<NameConstraints(permitted_subtrees=[<DNSName(value=name.local)>"
+            ", <DNSName(value=name2.local)>], excluded_subtrees=None)>"
+        )
+
+    def test_eq(self):
+        nc = x509.NameConstraints(
+            permitted_subtrees=[x509.DNSName(u"name.local")],
+            excluded_subtrees=[x509.DNSName(u"name2.local")]
+        )
+        nc2 = x509.NameConstraints(
+            permitted_subtrees=[x509.DNSName(u"name.local")],
+            excluded_subtrees=[x509.DNSName(u"name2.local")]
+        )
+        assert nc == nc2
+
+    def test_ne(self):
+        nc = x509.NameConstraints(
+            permitted_subtrees=[x509.DNSName(u"name.local")],
+            excluded_subtrees=[x509.DNSName(u"name2.local")]
+        )
+        nc2 = x509.NameConstraints(
+            permitted_subtrees=[x509.DNSName(u"name.local")],
+            excluded_subtrees=None
+        )
+        nc3 = x509.NameConstraints(
+            permitted_subtrees=None,
+            excluded_subtrees=[x509.DNSName(u"name2.local")]
+        )
+
+        assert nc != nc2
+        assert nc != nc3
+        assert nc != object()
+
+
+@pytest.mark.requires_backend_interface(interface=RSABackend)
+@pytest.mark.requires_backend_interface(interface=X509Backend)
+class TestNameConstraintsExtension(object):
+    def test_permitted_excluded(self, backend):
+        cert = _load_cert(
+            os.path.join(
+                "x509", "custom", "nc_permitted_excluded_2.pem"
+            ),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+        nc = cert.extensions.get_extension_for_oid(
+            ExtensionOID.NAME_CONSTRAINTS
+        ).value
+        assert nc == x509.NameConstraints(
+            permitted_subtrees=[
+                x509.DNSName(u"zombo.local"),
+            ],
+            excluded_subtrees=[
+                x509.DirectoryName(x509.Name([
+                    x509.NameAttribute(NameOID.COMMON_NAME, u"zombo")
+                ]))
+            ]
+        )
+
+    def test_permitted(self, backend):
+        cert = _load_cert(
+            os.path.join(
+                "x509", "custom", "nc_permitted_2.pem"
+            ),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+        nc = cert.extensions.get_extension_for_oid(
+            ExtensionOID.NAME_CONSTRAINTS
+        ).value
+        assert nc == x509.NameConstraints(
+            permitted_subtrees=[
+                x509.DNSName(u"zombo.local"),
+            ],
+            excluded_subtrees=None
+        )
+
+    def test_permitted_with_leading_period(self, backend):
+        cert = _load_cert(
+            os.path.join(
+                "x509", "custom", "nc_permitted.pem"
+            ),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+        nc = cert.extensions.get_extension_for_oid(
+            ExtensionOID.NAME_CONSTRAINTS
+        ).value
+        assert nc == x509.NameConstraints(
+            permitted_subtrees=[
+                x509.DNSName(u".cryptography.io"),
+                x509.UniformResourceIdentifier(u"ftp://cryptography.test")
+            ],
+            excluded_subtrees=None
+        )
+
+    def test_excluded_with_leading_period(self, backend):
+        cert = _load_cert(
+            os.path.join(
+                "x509", "custom", "nc_excluded.pem"
+            ),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+        nc = cert.extensions.get_extension_for_oid(
+            ExtensionOID.NAME_CONSTRAINTS
+        ).value
+        assert nc == x509.NameConstraints(
+            permitted_subtrees=None,
+            excluded_subtrees=[
+                x509.DNSName(u".cryptography.io"),
+                x509.UniformResourceIdentifier(u"gopher://cryptography.test")
+            ]
+        )
+
+    def test_permitted_excluded_with_ips(self, backend):
+        cert = _load_cert(
+            os.path.join(
+                "x509", "custom", "nc_permitted_excluded.pem"
+            ),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+        nc = cert.extensions.get_extension_for_oid(
+            ExtensionOID.NAME_CONSTRAINTS
+        ).value
+        assert nc == x509.NameConstraints(
+            permitted_subtrees=[
+                x509.IPAddress(ipaddress.IPv4Network(u"192.168.0.0/24")),
+                x509.IPAddress(ipaddress.IPv6Network(u"FF:0:0:0:0:0:0:0/96")),
+            ],
+            excluded_subtrees=[
+                x509.DNSName(u".domain.com"),
+                x509.UniformResourceIdentifier(u"http://test.local"),
+            ]
+        )
+
+    def test_single_ip_netmask(self, backend):
+        cert = _load_cert(
+            os.path.join(
+                "x509", "custom", "nc_single_ip_netmask.pem"
+            ),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+        nc = cert.extensions.get_extension_for_oid(
+            ExtensionOID.NAME_CONSTRAINTS
+        ).value
+        assert nc == x509.NameConstraints(
+            permitted_subtrees=[
+                x509.IPAddress(ipaddress.IPv6Network(u"FF:0:0:0:0:0:0:0/128")),
+                x509.IPAddress(ipaddress.IPv4Network(u"192.168.0.1/32")),
+            ],
+            excluded_subtrees=None
+        )
+
+    def test_invalid_netmask(self, backend):
+        cert = _load_cert(
+            os.path.join(
+                "x509", "custom", "nc_invalid_ip_netmask.pem"
+            ),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+        with pytest.raises(ValueError):
+            cert.extensions.get_extension_for_oid(
+                ExtensionOID.NAME_CONSTRAINTS
+            )
+
+
+class TestDistributionPoint(object):
+    def test_distribution_point_full_name_not_general_names(self):
+        with pytest.raises(TypeError):
+            x509.DistributionPoint(["notgn"], None, None, None)
+
+    def test_distribution_point_relative_name_not_name(self):
+        with pytest.raises(TypeError):
+            x509.DistributionPoint(None, "notname", None, None)
+
+    def test_distribution_point_full_and_relative_not_none(self):
+        with pytest.raises(ValueError):
+            x509.DistributionPoint("data", "notname", None, None)
+
+    def test_crl_issuer_not_general_names(self):
+        with pytest.raises(TypeError):
+            x509.DistributionPoint(None, None, None, ["notgn"])
+
+    def test_reason_not_reasonflags(self):
+        with pytest.raises(TypeError):
+            x509.DistributionPoint(
+                [x509.UniformResourceIdentifier(u"http://crypt.og/crl")],
+                None,
+                frozenset(["notreasonflags"]),
+                None
+            )
+
+    def test_reason_not_frozenset(self):
+        with pytest.raises(TypeError):
+            x509.DistributionPoint(
+                [x509.UniformResourceIdentifier(u"http://crypt.og/crl")],
+                None,
+                [x509.ReasonFlags.ca_compromise],
+                None
+            )
+
+    def test_disallowed_reasons(self):
+        with pytest.raises(ValueError):
+            x509.DistributionPoint(
+                [x509.UniformResourceIdentifier(u"http://crypt.og/crl")],
+                None,
+                frozenset([x509.ReasonFlags.unspecified]),
+                None
+            )
+
+        with pytest.raises(ValueError):
+            x509.DistributionPoint(
+                [x509.UniformResourceIdentifier(u"http://crypt.og/crl")],
+                None,
+                frozenset([x509.ReasonFlags.remove_from_crl]),
+                None
+            )
+
+    def test_reason_only(self):
+        with pytest.raises(ValueError):
+            x509.DistributionPoint(
+                None,
+                None,
+                frozenset([x509.ReasonFlags.aa_compromise]),
+                None
+            )
+
+    def test_eq(self):
+        dp = x509.DistributionPoint(
+            [x509.UniformResourceIdentifier(u"http://crypt.og/crl")],
+            None,
+            frozenset([x509.ReasonFlags.superseded]),
+            [
+                x509.DirectoryName(
+                    x509.Name([
+                        x509.NameAttribute(
+                            NameOID.COMMON_NAME, u"Important CA"
+                        )
+                    ])
+                )
+            ],
+        )
+        dp2 = x509.DistributionPoint(
+            [x509.UniformResourceIdentifier(u"http://crypt.og/crl")],
+            None,
+            frozenset([x509.ReasonFlags.superseded]),
+            [
+                x509.DirectoryName(
+                    x509.Name([
+                        x509.NameAttribute(
+                            NameOID.COMMON_NAME, u"Important CA"
+                        )
+                    ])
+                )
+            ],
+        )
+        assert dp == dp2
+
+    def test_ne(self):
+        dp = x509.DistributionPoint(
+            [x509.UniformResourceIdentifier(u"http://crypt.og/crl")],
+            None,
+            frozenset([x509.ReasonFlags.superseded]),
+            [
+                x509.DirectoryName(
+                    x509.Name([
+                        x509.NameAttribute(
+                            NameOID.COMMON_NAME, u"Important CA"
+                        )
+                    ])
+                )
+            ],
+        )
+        dp2 = x509.DistributionPoint(
+            [x509.UniformResourceIdentifier(u"http://crypt.og/crl")],
+            None,
+            None,
+            None
+        )
+        assert dp != dp2
+        assert dp != object()
+
+    def test_repr(self):
+        dp = x509.DistributionPoint(
+            None,
+            x509.Name([
+                x509.NameAttribute(NameOID.COMMON_NAME, u"myCN")
+            ]),
+            frozenset([x509.ReasonFlags.ca_compromise]),
+            [
+                x509.DirectoryName(
+                    x509.Name([
+                        x509.NameAttribute(
+                            NameOID.COMMON_NAME, u"Important CA"
+                        )
+                    ])
+                )
+            ],
+        )
+        if six.PY3:
+            assert repr(dp) == (
+                "<DistributionPoint(full_name=None, relative_name=<Name([<Name"
+                "Attribute(oid=<ObjectIdentifier(oid=2.5.4.3, name=commonName)"
+                ">, value='myCN')>])>, reasons=frozenset({<ReasonFlags.ca_comp"
+                "romise: 'cACompromise'>}), crl_issuer=[<DirectoryName(value=<"
+                "Name([<NameAttribute(oid=<ObjectIdentifier(oid=2.5.4.3, name="
+                "commonName)>, value='Important CA')>])>)>])>"
+            )
+        else:
+            assert repr(dp) == (
+                "<DistributionPoint(full_name=None, relative_name=<Name([<Name"
+                "Attribute(oid=<ObjectIdentifier(oid=2.5.4.3, name=commonName)"
+                ">, value=u'myCN')>])>, reasons=frozenset([<ReasonFlags.ca_com"
+                "promise: 'cACompromise'>]), crl_issuer=[<DirectoryName(value="
+                "<Name([<NameAttribute(oid=<ObjectIdentifier(oid=2.5.4.3, name"
+                "=commonName)>, value=u'Important CA')>])>)>])>"
+            )
+
+
+class TestCRLDistributionPoints(object):
+    def test_invalid_distribution_points(self):
+        with pytest.raises(TypeError):
+            x509.CRLDistributionPoints(["notadistributionpoint"])
+
+    def test_iter_len(self):
+        cdp = x509.CRLDistributionPoints([
+            x509.DistributionPoint(
+                [x509.UniformResourceIdentifier(u"http://domain")],
+                None,
+                None,
+                None
+            ),
+            x509.DistributionPoint(
+                [x509.UniformResourceIdentifier(u"ftp://domain")],
+                None,
+                frozenset([
+                    x509.ReasonFlags.key_compromise,
+                    x509.ReasonFlags.ca_compromise,
+                ]),
+                None
+            ),
+        ])
+        assert len(cdp) == 2
+        assert list(cdp) == [
+            x509.DistributionPoint(
+                [x509.UniformResourceIdentifier(u"http://domain")],
+                None,
+                None,
+                None
+            ),
+            x509.DistributionPoint(
+                [x509.UniformResourceIdentifier(u"ftp://domain")],
+                None,
+                frozenset([
+                    x509.ReasonFlags.key_compromise,
+                    x509.ReasonFlags.ca_compromise,
+                ]),
+                None
+            ),
+        ]
+
+    def test_repr(self):
+        cdp = x509.CRLDistributionPoints([
+            x509.DistributionPoint(
+                [x509.UniformResourceIdentifier(u"ftp://domain")],
+                None,
+                frozenset([x509.ReasonFlags.key_compromise]),
+                None
+            ),
+        ])
+        if six.PY3:
+            assert repr(cdp) == (
+                "<CRLDistributionPoints([<DistributionPoint(full_name=[<Unifo"
+                "rmResourceIdentifier(value=ftp://domain)>], relative_name=No"
+                "ne, reasons=frozenset({<ReasonFlags.key_compromise: 'keyComp"
+                "romise'>}), crl_issuer=None)>])>"
+            )
+        else:
+            assert repr(cdp) == (
+                "<CRLDistributionPoints([<DistributionPoint(full_name=[<Unifo"
+                "rmResourceIdentifier(value=ftp://domain)>], relative_name=No"
+                "ne, reasons=frozenset([<ReasonFlags.key_compromise: 'keyComp"
+                "romise'>]), crl_issuer=None)>])>"
+            )
+
+    def test_eq(self):
+        cdp = x509.CRLDistributionPoints([
+            x509.DistributionPoint(
+                [x509.UniformResourceIdentifier(u"ftp://domain")],
+                None,
+                frozenset([
+                    x509.ReasonFlags.key_compromise,
+                    x509.ReasonFlags.ca_compromise,
+                ]),
+                [x509.UniformResourceIdentifier(u"uri://thing")],
+            ),
+        ])
+        cdp2 = x509.CRLDistributionPoints([
+            x509.DistributionPoint(
+                [x509.UniformResourceIdentifier(u"ftp://domain")],
+                None,
+                frozenset([
+                    x509.ReasonFlags.key_compromise,
+                    x509.ReasonFlags.ca_compromise,
+                ]),
+                [x509.UniformResourceIdentifier(u"uri://thing")],
+            ),
+        ])
+        assert cdp == cdp2
+
+    def test_ne(self):
+        cdp = x509.CRLDistributionPoints([
+            x509.DistributionPoint(
+                [x509.UniformResourceIdentifier(u"ftp://domain")],
+                None,
+                frozenset([
+                    x509.ReasonFlags.key_compromise,
+                    x509.ReasonFlags.ca_compromise,
+                ]),
+                [x509.UniformResourceIdentifier(u"uri://thing")],
+            ),
+        ])
+        cdp2 = x509.CRLDistributionPoints([
+            x509.DistributionPoint(
+                [x509.UniformResourceIdentifier(u"ftp://domain2")],
+                None,
+                frozenset([
+                    x509.ReasonFlags.key_compromise,
+                    x509.ReasonFlags.ca_compromise,
+                ]),
+                [x509.UniformResourceIdentifier(u"uri://thing")],
+            ),
+        ])
+        cdp3 = x509.CRLDistributionPoints([
+            x509.DistributionPoint(
+                [x509.UniformResourceIdentifier(u"ftp://domain")],
+                None,
+                frozenset([x509.ReasonFlags.key_compromise]),
+                [x509.UniformResourceIdentifier(u"uri://thing")],
+            ),
+        ])
+        cdp4 = x509.CRLDistributionPoints([
+            x509.DistributionPoint(
+                [x509.UniformResourceIdentifier(u"ftp://domain")],
+                None,
+                frozenset([
+                    x509.ReasonFlags.key_compromise,
+                    x509.ReasonFlags.ca_compromise,
+                ]),
+                [x509.UniformResourceIdentifier(u"uri://thing2")],
+            ),
+        ])
+        assert cdp != cdp2
+        assert cdp != cdp3
+        assert cdp != cdp4
+        assert cdp != object()
+
+
+@pytest.mark.requires_backend_interface(interface=RSABackend)
+@pytest.mark.requires_backend_interface(interface=X509Backend)
+class TestCRLDistributionPointsExtension(object):
+    def test_fullname_and_crl_issuer(self, backend):
+        cert = _load_cert(
+            os.path.join(
+                "x509", "PKITS_data", "certs", "ValidcRLIssuerTest28EE.crt"
+            ),
+            x509.load_der_x509_certificate,
+            backend
+        )
+
+        cdps = cert.extensions.get_extension_for_oid(
+            ExtensionOID.CRL_DISTRIBUTION_POINTS
+        ).value
+
+        assert cdps == x509.CRLDistributionPoints([
+            x509.DistributionPoint(
+                full_name=[x509.DirectoryName(
+                    x509.Name([
+                        x509.NameAttribute(NameOID.COUNTRY_NAME, u"US"),
+                        x509.NameAttribute(
+                            NameOID.ORGANIZATION_NAME,
+                            u"Test Certificates 2011"
+                        ),
+                        x509.NameAttribute(
+                            NameOID.ORGANIZATIONAL_UNIT_NAME,
+                            u"indirectCRL CA3 cRLIssuer"
+                        ),
+                        x509.NameAttribute(
+                            NameOID.COMMON_NAME,
+                            u"indirect CRL for indirectCRL CA3"
+                        ),
+                    ])
+                )],
+                relative_name=None,
+                reasons=None,
+                crl_issuer=[x509.DirectoryName(
+                    x509.Name([
+                        x509.NameAttribute(NameOID.COUNTRY_NAME, u"US"),
+                        x509.NameAttribute(
+                            NameOID.ORGANIZATION_NAME,
+                            u"Test Certificates 2011"
+                        ),
+                        x509.NameAttribute(
+                            NameOID.ORGANIZATIONAL_UNIT_NAME,
+                            u"indirectCRL CA3 cRLIssuer"
+                        ),
+                    ])
+                )],
+            )
+        ])
+
+    def test_relativename_and_crl_issuer(self, backend):
+        cert = _load_cert(
+            os.path.join(
+                "x509", "PKITS_data", "certs", "ValidcRLIssuerTest29EE.crt"
+            ),
+            x509.load_der_x509_certificate,
+            backend
+        )
+
+        cdps = cert.extensions.get_extension_for_oid(
+            ExtensionOID.CRL_DISTRIBUTION_POINTS
+        ).value
+
+        assert cdps == x509.CRLDistributionPoints([
+            x509.DistributionPoint(
+                full_name=None,
+                relative_name=x509.Name([
+                    x509.NameAttribute(
+                        NameOID.COMMON_NAME,
+                        u"indirect CRL for indirectCRL CA3"
+                    ),
+                ]),
+                reasons=None,
+                crl_issuer=[x509.DirectoryName(
+                    x509.Name([
+                        x509.NameAttribute(NameOID.COUNTRY_NAME, u"US"),
+                        x509.NameAttribute(
+                            NameOID.ORGANIZATION_NAME,
+                            u"Test Certificates 2011"
+                        ),
+                        x509.NameAttribute(
+                            NameOID.ORGANIZATIONAL_UNIT_NAME,
+                            u"indirectCRL CA3 cRLIssuer"
+                        ),
+                    ])
+                )],
+            )
+        ])
+
+    def test_fullname_crl_issuer_reasons(self, backend):
+        cert = _load_cert(
+            os.path.join(
+                "x509", "custom", "cdp_fullname_reasons_crl_issuer.pem"
+            ),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+
+        cdps = cert.extensions.get_extension_for_oid(
+            ExtensionOID.CRL_DISTRIBUTION_POINTS
+        ).value
+
+        assert cdps == x509.CRLDistributionPoints([
+            x509.DistributionPoint(
+                full_name=[x509.UniformResourceIdentifier(
+                    u"http://myhost.com/myca.crl"
+                )],
+                relative_name=None,
+                reasons=frozenset([
+                    x509.ReasonFlags.key_compromise,
+                    x509.ReasonFlags.ca_compromise
+                ]),
+                crl_issuer=[x509.DirectoryName(
+                    x509.Name([
+                        x509.NameAttribute(NameOID.COUNTRY_NAME, u"US"),
+                        x509.NameAttribute(
+                            NameOID.ORGANIZATION_NAME, u"PyCA"
+                        ),
+                        x509.NameAttribute(
+                            NameOID.COMMON_NAME, u"cryptography CA"
+                        ),
+                    ])
+                )],
+            )
+        ])
+
+    def test_all_reasons(self, backend):
+        cert = _load_cert(
+            os.path.join(
+                "x509", "custom", "cdp_all_reasons.pem"
+            ),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+
+        cdps = cert.extensions.get_extension_for_oid(
+            ExtensionOID.CRL_DISTRIBUTION_POINTS
+        ).value
+
+        assert cdps == x509.CRLDistributionPoints([
+            x509.DistributionPoint(
+                full_name=[x509.UniformResourceIdentifier(
+                    u"http://domain.com/some.crl"
+                )],
+                relative_name=None,
+                reasons=frozenset([
+                    x509.ReasonFlags.key_compromise,
+                    x509.ReasonFlags.ca_compromise,
+                    x509.ReasonFlags.affiliation_changed,
+                    x509.ReasonFlags.superseded,
+                    x509.ReasonFlags.privilege_withdrawn,
+                    x509.ReasonFlags.cessation_of_operation,
+                    x509.ReasonFlags.aa_compromise,
+                    x509.ReasonFlags.certificate_hold,
+                ]),
+                crl_issuer=None
+            )
+        ])
+
+    def test_single_reason(self, backend):
+        cert = _load_cert(
+            os.path.join(
+                "x509", "custom", "cdp_reason_aa_compromise.pem"
+            ),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+
+        cdps = cert.extensions.get_extension_for_oid(
+            ExtensionOID.CRL_DISTRIBUTION_POINTS
+        ).value
+
+        assert cdps == x509.CRLDistributionPoints([
+            x509.DistributionPoint(
+                full_name=[x509.UniformResourceIdentifier(
+                    u"http://domain.com/some.crl"
+                )],
+                relative_name=None,
+                reasons=frozenset([x509.ReasonFlags.aa_compromise]),
+                crl_issuer=None
+            )
+        ])
+
+    def test_crl_issuer_only(self, backend):
+        cert = _load_cert(
+            os.path.join(
+                "x509", "custom", "cdp_crl_issuer.pem"
+            ),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+
+        cdps = cert.extensions.get_extension_for_oid(
+            ExtensionOID.CRL_DISTRIBUTION_POINTS
+        ).value
+
+        assert cdps == x509.CRLDistributionPoints([
+            x509.DistributionPoint(
+                full_name=None,
+                relative_name=None,
+                reasons=None,
+                crl_issuer=[x509.DirectoryName(
+                    x509.Name([
+                        x509.NameAttribute(
+                            NameOID.COMMON_NAME, u"cryptography CA"
+                        ),
+                    ])
+                )],
+            )
+        ])
+
+    def test_crl_empty_hostname(self, backend):
+        cert = _load_cert(
+            os.path.join(
+                "x509", "custom", "cdp_empty_hostname.pem"
+            ),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+
+        cdps = cert.extensions.get_extension_for_oid(
+            ExtensionOID.CRL_DISTRIBUTION_POINTS
+        ).value
+
+        assert cdps == x509.CRLDistributionPoints([
+            x509.DistributionPoint(
+                full_name=[x509.UniformResourceIdentifier(
+                    u"ldap:/CN=A,OU=B,dc=C,DC=D?E?F?G?H=I"
+                )],
+                relative_name=None,
+                reasons=None,
+                crl_issuer=None
+            )
+        ])
+
+
+@pytest.mark.requires_backend_interface(interface=RSABackend)
+@pytest.mark.requires_backend_interface(interface=X509Backend)
+class TestOCSPNoCheckExtension(object):
+    def test_nocheck(self, backend):
+        cert = _load_cert(
+            os.path.join(
+                "x509", "custom", "ocsp_nocheck.pem"
+            ),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+        ext = cert.extensions.get_extension_for_oid(
+            ExtensionOID.OCSP_NO_CHECK
+        )
+        assert isinstance(ext.value, x509.OCSPNoCheck)
+
+
+class TestInhibitAnyPolicy(object):
+    def test_not_int(self):
+        with pytest.raises(TypeError):
+            x509.InhibitAnyPolicy("notint")
+
+    def test_negative_int(self):
+        with pytest.raises(ValueError):
+            x509.InhibitAnyPolicy(-1)
+
+    def test_repr(self):
+        iap = x509.InhibitAnyPolicy(0)
+        assert repr(iap) == "<InhibitAnyPolicy(skip_certs=0)>"
+
+    def test_eq(self):
+        iap = x509.InhibitAnyPolicy(1)
+        iap2 = x509.InhibitAnyPolicy(1)
+        assert iap == iap2
+
+    def test_ne(self):
+        iap = x509.InhibitAnyPolicy(1)
+        iap2 = x509.InhibitAnyPolicy(4)
+        assert iap != iap2
+        assert iap != object()
+
+
+@pytest.mark.requires_backend_interface(interface=RSABackend)
+@pytest.mark.requires_backend_interface(interface=X509Backend)
+class TestInhibitAnyPolicyExtension(object):
+    def test_nocheck(self, backend):
+        cert = _load_cert(
+            os.path.join(
+                "x509", "custom", "inhibit_any_policy_5.pem"
+            ),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+        iap = cert.extensions.get_extension_for_oid(
+            ExtensionOID.INHIBIT_ANY_POLICY
+        ).value
+        assert iap.skip_certs == 5
+
+
+@pytest.mark.requires_backend_interface(interface=RSABackend)
+@pytest.mark.requires_backend_interface(interface=X509Backend)
+class TestInvalidExtension(object):
+    def test_invalid_certificate_policies_data(self, backend):
+        cert = _load_cert(
+            os.path.join(
+                "x509", "custom", "cp_invalid.pem"
+            ),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+        with pytest.raises(ValueError):
+            cert.extensions
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/test_x509.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/test_x509.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/test_x509.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/test_x509.py	2015-11-19 05:01:40.000000000 +0100
@@ -0,0 +1,2924 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import binascii
+import datetime
+import ipaddress
+import os
+
+from pyasn1.codec.der import decoder
+
+from pyasn1_modules import rfc2459
+
+import pytest
+
+import six
+
+from cryptography import utils, x509
+from cryptography.exceptions import UnsupportedAlgorithm
+from cryptography.hazmat.backends.interfaces import (
+    DSABackend, EllipticCurveBackend, RSABackend, X509Backend
+)
+from cryptography.hazmat.primitives import hashes, serialization
+from cryptography.hazmat.primitives.asymmetric import dsa, ec, rsa
+from cryptography.x509.oid import (
+    AuthorityInformationAccessOID, ExtendedKeyUsageOID, ExtensionOID, NameOID
+)
+
+from .hazmat.primitives.fixtures_dsa import DSA_KEY_2048
+from .hazmat.primitives.fixtures_rsa import RSA_KEY_2048, RSA_KEY_512
+from .hazmat.primitives.test_ec import _skip_curve_unsupported
+from .utils import load_vectors_from_file
+
+
+@utils.register_interface(x509.ExtensionType)
+class DummyExtension(object):
+    oid = x509.ObjectIdentifier("1.2.3.4")
+
+
+@utils.register_interface(x509.GeneralName)
+class FakeGeneralName(object):
+    def __init__(self, value):
+        self._value = value
+
+    value = utils.read_only_property("_value")
+
+
+def _load_cert(filename, loader, backend):
+    cert = load_vectors_from_file(
+        filename=filename,
+        loader=lambda pemfile: loader(pemfile.read(), backend),
+        mode="rb"
+    )
+    return cert
+
+
+@pytest.mark.requires_backend_interface(interface=X509Backend)
+class TestCertificateRevocationList(object):
+    def test_load_pem_crl(self, backend):
+        crl = _load_cert(
+            os.path.join("x509", "custom", "crl_all_reasons.pem"),
+            x509.load_pem_x509_crl,
+            backend
+        )
+
+        assert isinstance(crl, x509.CertificateRevocationList)
+        fingerprint = binascii.hexlify(crl.fingerprint(hashes.SHA1()))
+        assert fingerprint == b"3234b0cb4c0cedf6423724b736729dcfc9e441ef"
+        assert isinstance(crl.signature_hash_algorithm, hashes.SHA256)
+
+    def test_load_der_crl(self, backend):
+        crl = _load_cert(
+            os.path.join("x509", "PKITS_data", "crls", "GoodCACRL.crl"),
+            x509.load_der_x509_crl,
+            backend
+        )
+
+        assert isinstance(crl, x509.CertificateRevocationList)
+        fingerprint = binascii.hexlify(crl.fingerprint(hashes.SHA1()))
+        assert fingerprint == b"dd3db63c50f4c4a13e090f14053227cb1011a5ad"
+        assert isinstance(crl.signature_hash_algorithm, hashes.SHA256)
+
+    def test_invalid_pem(self, backend):
+        with pytest.raises(ValueError):
+            x509.load_pem_x509_crl(b"notacrl", backend)
+
+    def test_invalid_der(self, backend):
+        with pytest.raises(ValueError):
+            x509.load_der_x509_crl(b"notacrl", backend)
+
+    def test_unknown_signature_algorithm(self, backend):
+        crl = _load_cert(
+            os.path.join(
+                "x509", "custom", "crl_md2_unknown_crit_entry_ext.pem"
+            ),
+            x509.load_pem_x509_crl,
+            backend
+        )
+
+        with pytest.raises(UnsupportedAlgorithm):
+                crl.signature_hash_algorithm()
+
+    def test_issuer(self, backend):
+        crl = _load_cert(
+            os.path.join("x509", "PKITS_data", "crls", "GoodCACRL.crl"),
+            x509.load_der_x509_crl,
+            backend
+        )
+
+        assert isinstance(crl.issuer, x509.Name)
+        assert list(crl.issuer) == [
+            x509.NameAttribute(x509.OID_COUNTRY_NAME, u'US'),
+            x509.NameAttribute(
+                x509.OID_ORGANIZATION_NAME, u'Test Certificates 2011'
+            ),
+            x509.NameAttribute(x509.OID_COMMON_NAME, u'Good CA')
+        ]
+        assert crl.issuer.get_attributes_for_oid(x509.OID_COMMON_NAME) == [
+            x509.NameAttribute(x509.OID_COMMON_NAME, u'Good CA')
+        ]
+
+    def test_equality(self, backend):
+        crl1 = _load_cert(
+            os.path.join("x509", "PKITS_data", "crls", "GoodCACRL.crl"),
+            x509.load_der_x509_crl,
+            backend
+        )
+
+        crl2 = _load_cert(
+            os.path.join("x509", "PKITS_data", "crls", "GoodCACRL.crl"),
+            x509.load_der_x509_crl,
+            backend
+        )
+
+        crl3 = _load_cert(
+            os.path.join("x509", "custom", "crl_all_reasons.pem"),
+            x509.load_pem_x509_crl,
+            backend
+        )
+
+        assert crl1 == crl2
+        assert crl1 != crl3
+        assert crl1 != object()
+
+    def test_update_dates(self, backend):
+        crl = _load_cert(
+            os.path.join("x509", "custom", "crl_all_reasons.pem"),
+            x509.load_pem_x509_crl,
+            backend
+        )
+
+        assert isinstance(crl.next_update, datetime.datetime)
+        assert isinstance(crl.last_update, datetime.datetime)
+
+        assert crl.next_update.isoformat() == "2016-01-01T00:00:00"
+        assert crl.last_update.isoformat() == "2015-01-01T00:00:00"
+
+    def test_revoked_cert_retrieval(self, backend):
+        crl = _load_cert(
+            os.path.join("x509", "custom", "crl_all_reasons.pem"),
+            x509.load_pem_x509_crl,
+            backend
+        )
+
+        for r in crl:
+            assert isinstance(r, x509.RevokedCertificate)
+
+        # Check that len() works for CRLs.
+        assert len(crl) == 12
+
+    def test_extensions(self, backend):
+        crl = _load_cert(
+            os.path.join("x509", "custom", "crl_all_reasons.pem"),
+            x509.load_pem_x509_crl,
+            backend
+        )
+
+        # CRL extensions are currently not supported in the OpenSSL backend.
+        with pytest.raises(NotImplementedError):
+            crl.extensions
+
+
+@pytest.mark.requires_backend_interface(interface=X509Backend)
+class TestRevokedCertificate(object):
+
+    def test_revoked_basics(self, backend):
+        crl = _load_cert(
+            os.path.join("x509", "custom", "crl_all_reasons.pem"),
+            x509.load_pem_x509_crl,
+            backend
+        )
+
+        for i, rev in enumerate(crl):
+            assert isinstance(rev, x509.RevokedCertificate)
+            assert isinstance(rev.serial_number, int)
+            assert isinstance(rev.revocation_date, datetime.datetime)
+            assert isinstance(rev.extensions, x509.Extensions)
+
+            assert rev.serial_number == i
+            assert rev.revocation_date.isoformat() == "2015-01-01T00:00:00"
+
+    def test_revoked_extensions(self, backend):
+        crl = _load_cert(
+            os.path.join("x509", "custom", "crl_all_reasons.pem"),
+            x509.load_pem_x509_crl,
+            backend
+        )
+
+        exp_issuer = x509.GeneralNames([
+            x509.DirectoryName(x509.Name([
+                x509.NameAttribute(x509.OID_COUNTRY_NAME, u"US"),
+                x509.NameAttribute(x509.OID_COMMON_NAME, u"cryptography.io"),
+            ]))
+        ])
+
+        # First revoked cert doesn't have extensions, test if it is handled
+        # correctly.
+        rev0 = crl[0]
+        # It should return an empty Extensions object.
+        assert isinstance(rev0.extensions, x509.Extensions)
+        assert len(rev0.extensions) == 0
+        with pytest.raises(x509.ExtensionNotFound):
+            rev0.extensions.get_extension_for_oid(x509.OID_CRL_REASON)
+        with pytest.raises(x509.ExtensionNotFound):
+            rev0.extensions.get_extension_for_oid(x509.OID_CERTIFICATE_ISSUER)
+        with pytest.raises(x509.ExtensionNotFound):
+            rev0.extensions.get_extension_for_oid(x509.OID_INVALIDITY_DATE)
+
+        # Test manual retrieval of extension values.
+        rev1 = crl[1]
+        assert isinstance(rev1.extensions, x509.Extensions)
+
+        reason = rev1.extensions.get_extension_for_oid(
+            x509.OID_CRL_REASON).value
+        assert reason == x509.ReasonFlags.unspecified
+
+        issuer = rev1.extensions.get_extension_for_oid(
+            x509.OID_CERTIFICATE_ISSUER).value
+        assert issuer == exp_issuer
+
+        date = rev1.extensions.get_extension_for_oid(
+            x509.OID_INVALIDITY_DATE).value
+        assert isinstance(date, datetime.datetime)
+        assert date.isoformat() == "2015-01-01T00:00:00"
+
+        # Check if all reason flags can be found in the CRL.
+        flags = set(x509.ReasonFlags)
+        for rev in crl:
+            try:
+                r = rev.extensions.get_extension_for_oid(x509.OID_CRL_REASON)
+            except x509.ExtensionNotFound:
+                # Not all revoked certs have a reason extension.
+                pass
+            else:
+                flags.discard(r.value)
+
+        assert len(flags) == 0
+
+    def test_duplicate_entry_ext(self, backend):
+        crl = _load_cert(
+            os.path.join("x509", "custom", "crl_dup_entry_ext.pem"),
+            x509.load_pem_x509_crl,
+            backend
+        )
+
+        with pytest.raises(x509.DuplicateExtension):
+            crl[0].extensions
+
+    def test_unsupported_crit_entry_ext(self, backend):
+        crl = _load_cert(
+            os.path.join(
+                "x509", "custom", "crl_md2_unknown_crit_entry_ext.pem"
+            ),
+            x509.load_pem_x509_crl,
+            backend
+        )
+
+        with pytest.raises(x509.UnsupportedExtension):
+            crl[0].extensions
+
+    def test_unsupported_reason(self, backend):
+        crl = _load_cert(
+            os.path.join(
+                "x509", "custom", "crl_unsupported_reason.pem"
+            ),
+            x509.load_pem_x509_crl,
+            backend
+        )
+
+        with pytest.raises(ValueError):
+            crl[0].extensions
+
+    def test_invalid_cert_issuer_ext(self, backend):
+        crl = _load_cert(
+            os.path.join(
+                "x509", "custom", "crl_inval_cert_issuer_entry_ext.pem"
+            ),
+            x509.load_pem_x509_crl,
+            backend
+        )
+
+        with pytest.raises(ValueError):
+            crl[0].extensions
+
+
+@pytest.mark.requires_backend_interface(interface=RSABackend)
+@pytest.mark.requires_backend_interface(interface=X509Backend)
+class TestRSACertificate(object):
+    def test_load_pem_cert(self, backend):
+        cert = _load_cert(
+            os.path.join("x509", "custom", "post2000utctime.pem"),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+        assert isinstance(cert, x509.Certificate)
+        assert cert.serial == 11559813051657483483
+        fingerprint = binascii.hexlify(cert.fingerprint(hashes.SHA1()))
+        assert fingerprint == b"2b619ed04bfc9c3b08eb677d272192286a0947a8"
+        assert isinstance(cert.signature_hash_algorithm, hashes.SHA1)
+
+    def test_load_der_cert(self, backend):
+        cert = _load_cert(
+            os.path.join("x509", "PKITS_data", "certs", "GoodCACert.crt"),
+            x509.load_der_x509_certificate,
+            backend
+        )
+        assert isinstance(cert, x509.Certificate)
+        assert cert.serial == 2
+        fingerprint = binascii.hexlify(cert.fingerprint(hashes.SHA1()))
+        assert fingerprint == b"6f49779533d565e8b7c1062503eab41492c38e4d"
+        assert isinstance(cert.signature_hash_algorithm, hashes.SHA256)
+
+    def test_issuer(self, backend):
+        cert = _load_cert(
+            os.path.join(
+                "x509", "PKITS_data", "certs",
+                "Validpre2000UTCnotBeforeDateTest3EE.crt"
+            ),
+            x509.load_der_x509_certificate,
+            backend
+        )
+        issuer = cert.issuer
+        assert isinstance(issuer, x509.Name)
+        assert list(issuer) == [
+            x509.NameAttribute(NameOID.COUNTRY_NAME, u'US'),
+            x509.NameAttribute(
+                NameOID.ORGANIZATION_NAME, u'Test Certificates 2011'
+            ),
+            x509.NameAttribute(NameOID.COMMON_NAME, u'Good CA')
+        ]
+        assert issuer.get_attributes_for_oid(NameOID.COMMON_NAME) == [
+            x509.NameAttribute(NameOID.COMMON_NAME, u'Good CA')
+        ]
+
+    def test_all_issuer_name_types(self, backend):
+        cert = _load_cert(
+            os.path.join(
+                "x509", "custom",
+                "all_supported_names.pem"
+            ),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+        issuer = cert.issuer
+
+        assert isinstance(issuer, x509.Name)
+        assert list(issuer) == [
+            x509.NameAttribute(NameOID.COUNTRY_NAME, u'US'),
+            x509.NameAttribute(NameOID.COUNTRY_NAME, u'CA'),
+            x509.NameAttribute(NameOID.STATE_OR_PROVINCE_NAME, u'Texas'),
+            x509.NameAttribute(NameOID.STATE_OR_PROVINCE_NAME, u'Illinois'),
+            x509.NameAttribute(NameOID.LOCALITY_NAME, u'Chicago'),
+            x509.NameAttribute(NameOID.LOCALITY_NAME, u'Austin'),
+            x509.NameAttribute(NameOID.ORGANIZATION_NAME, u'Zero, LLC'),
+            x509.NameAttribute(NameOID.ORGANIZATION_NAME, u'One, LLC'),
+            x509.NameAttribute(NameOID.COMMON_NAME, u'common name 0'),
+            x509.NameAttribute(NameOID.COMMON_NAME, u'common name 1'),
+            x509.NameAttribute(NameOID.ORGANIZATIONAL_UNIT_NAME, u'OU 0'),
+            x509.NameAttribute(NameOID.ORGANIZATIONAL_UNIT_NAME, u'OU 1'),
+            x509.NameAttribute(NameOID.DN_QUALIFIER, u'dnQualifier0'),
+            x509.NameAttribute(NameOID.DN_QUALIFIER, u'dnQualifier1'),
+            x509.NameAttribute(NameOID.SERIAL_NUMBER, u'123'),
+            x509.NameAttribute(NameOID.SERIAL_NUMBER, u'456'),
+            x509.NameAttribute(NameOID.TITLE, u'Title 0'),
+            x509.NameAttribute(NameOID.TITLE, u'Title 1'),
+            x509.NameAttribute(NameOID.SURNAME, u'Surname 0'),
+            x509.NameAttribute(NameOID.SURNAME, u'Surname 1'),
+            x509.NameAttribute(NameOID.GIVEN_NAME, u'Given Name 0'),
+            x509.NameAttribute(NameOID.GIVEN_NAME, u'Given Name 1'),
+            x509.NameAttribute(NameOID.PSEUDONYM, u'Incognito 0'),
+            x509.NameAttribute(NameOID.PSEUDONYM, u'Incognito 1'),
+            x509.NameAttribute(NameOID.GENERATION_QUALIFIER, u'Last Gen'),
+            x509.NameAttribute(NameOID.GENERATION_QUALIFIER, u'Next Gen'),
+            x509.NameAttribute(NameOID.DOMAIN_COMPONENT, u'dc0'),
+            x509.NameAttribute(NameOID.DOMAIN_COMPONENT, u'dc1'),
+            x509.NameAttribute(NameOID.EMAIL_ADDRESS, u'test0@test.local'),
+            x509.NameAttribute(NameOID.EMAIL_ADDRESS, u'test1@test.local'),
+        ]
+
+    def test_subject(self, backend):
+        cert = _load_cert(
+            os.path.join(
+                "x509", "PKITS_data", "certs",
+                "Validpre2000UTCnotBeforeDateTest3EE.crt"
+            ),
+            x509.load_der_x509_certificate,
+            backend
+        )
+        subject = cert.subject
+        assert isinstance(subject, x509.Name)
+        assert list(subject) == [
+            x509.NameAttribute(NameOID.COUNTRY_NAME, u'US'),
+            x509.NameAttribute(
+                NameOID.ORGANIZATION_NAME, u'Test Certificates 2011'
+            ),
+            x509.NameAttribute(
+                NameOID.COMMON_NAME,
+                u'Valid pre2000 UTC notBefore Date EE Certificate Test3'
+            )
+        ]
+        assert subject.get_attributes_for_oid(NameOID.COMMON_NAME) == [
+            x509.NameAttribute(
+                NameOID.COMMON_NAME,
+                u'Valid pre2000 UTC notBefore Date EE Certificate Test3'
+            )
+        ]
+
+    def test_unicode_name(self, backend):
+        cert = _load_cert(
+            os.path.join(
+                "x509", "custom",
+                "utf8_common_name.pem"
+            ),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+        assert cert.subject.get_attributes_for_oid(NameOID.COMMON_NAME) == [
+            x509.NameAttribute(
+                NameOID.COMMON_NAME,
+                u'We heart UTF8!\u2122'
+            )
+        ]
+        assert cert.issuer.get_attributes_for_oid(NameOID.COMMON_NAME) == [
+            x509.NameAttribute(
+                NameOID.COMMON_NAME,
+                u'We heart UTF8!\u2122'
+            )
+        ]
+
+    def test_all_subject_name_types(self, backend):
+        cert = _load_cert(
+            os.path.join(
+                "x509", "custom",
+                "all_supported_names.pem"
+            ),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+        subject = cert.subject
+        assert isinstance(subject, x509.Name)
+        assert list(subject) == [
+            x509.NameAttribute(NameOID.COUNTRY_NAME, u'AU'),
+            x509.NameAttribute(NameOID.COUNTRY_NAME, u'DE'),
+            x509.NameAttribute(NameOID.STATE_OR_PROVINCE_NAME, u'California'),
+            x509.NameAttribute(NameOID.STATE_OR_PROVINCE_NAME, u'New York'),
+            x509.NameAttribute(NameOID.LOCALITY_NAME, u'San Francisco'),
+            x509.NameAttribute(NameOID.LOCALITY_NAME, u'Ithaca'),
+            x509.NameAttribute(NameOID.ORGANIZATION_NAME, u'Org Zero, LLC'),
+            x509.NameAttribute(NameOID.ORGANIZATION_NAME, u'Org One, LLC'),
+            x509.NameAttribute(NameOID.COMMON_NAME, u'CN 0'),
+            x509.NameAttribute(NameOID.COMMON_NAME, u'CN 1'),
+            x509.NameAttribute(
+                NameOID.ORGANIZATIONAL_UNIT_NAME, u'Engineering 0'
+            ),
+            x509.NameAttribute(
+                NameOID.ORGANIZATIONAL_UNIT_NAME, u'Engineering 1'
+            ),
+            x509.NameAttribute(NameOID.DN_QUALIFIER, u'qualified0'),
+            x509.NameAttribute(NameOID.DN_QUALIFIER, u'qualified1'),
+            x509.NameAttribute(NameOID.SERIAL_NUMBER, u'789'),
+            x509.NameAttribute(NameOID.SERIAL_NUMBER, u'012'),
+            x509.NameAttribute(NameOID.TITLE, u'Title IX'),
+            x509.NameAttribute(NameOID.TITLE, u'Title X'),
+            x509.NameAttribute(NameOID.SURNAME, u'Last 0'),
+            x509.NameAttribute(NameOID.SURNAME, u'Last 1'),
+            x509.NameAttribute(NameOID.GIVEN_NAME, u'First 0'),
+            x509.NameAttribute(NameOID.GIVEN_NAME, u'First 1'),
+            x509.NameAttribute(NameOID.PSEUDONYM, u'Guy Incognito 0'),
+            x509.NameAttribute(NameOID.PSEUDONYM, u'Guy Incognito 1'),
+            x509.NameAttribute(NameOID.GENERATION_QUALIFIER, u'32X'),
+            x509.NameAttribute(NameOID.GENERATION_QUALIFIER, u'Dreamcast'),
+            x509.NameAttribute(NameOID.DOMAIN_COMPONENT, u'dc2'),
+            x509.NameAttribute(NameOID.DOMAIN_COMPONENT, u'dc3'),
+            x509.NameAttribute(NameOID.EMAIL_ADDRESS, u'test2@test.local'),
+            x509.NameAttribute(NameOID.EMAIL_ADDRESS, u'test3@test.local'),
+        ]
+
+    def test_load_good_ca_cert(self, backend):
+        cert = _load_cert(
+            os.path.join("x509", "PKITS_data", "certs", "GoodCACert.crt"),
+            x509.load_der_x509_certificate,
+            backend
+        )
+
+        assert cert.not_valid_before == datetime.datetime(2010, 1, 1, 8, 30)
+        assert cert.not_valid_after == datetime.datetime(2030, 12, 31, 8, 30)
+        assert cert.serial == 2
+        public_key = cert.public_key()
+        assert isinstance(public_key, rsa.RSAPublicKey)
+        assert cert.version is x509.Version.v3
+        fingerprint = binascii.hexlify(cert.fingerprint(hashes.SHA1()))
+        assert fingerprint == b"6f49779533d565e8b7c1062503eab41492c38e4d"
+
+    def test_utc_pre_2000_not_before_cert(self, backend):
+        cert = _load_cert(
+            os.path.join(
+                "x509", "PKITS_data", "certs",
+                "Validpre2000UTCnotBeforeDateTest3EE.crt"
+            ),
+            x509.load_der_x509_certificate,
+            backend
+        )
+
+        assert cert.not_valid_before == datetime.datetime(1950, 1, 1, 12, 1)
+
+    def test_pre_2000_utc_not_after_cert(self, backend):
+        cert = _load_cert(
+            os.path.join(
+                "x509", "PKITS_data", "certs",
+                "Invalidpre2000UTCEEnotAfterDateTest7EE.crt"
+            ),
+            x509.load_der_x509_certificate,
+            backend
+        )
+
+        assert cert.not_valid_after == datetime.datetime(1999, 1, 1, 12, 1)
+
+    def test_post_2000_utc_cert(self, backend):
+        cert = _load_cert(
+            os.path.join("x509", "custom", "post2000utctime.pem"),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+        assert cert.not_valid_before == datetime.datetime(
+            2014, 11, 26, 21, 41, 20
+        )
+        assert cert.not_valid_after == datetime.datetime(
+            2014, 12, 26, 21, 41, 20
+        )
+
+    def test_generalized_time_not_before_cert(self, backend):
+        cert = _load_cert(
+            os.path.join(
+                "x509", "PKITS_data", "certs",
+                "ValidGeneralizedTimenotBeforeDateTest4EE.crt"
+            ),
+            x509.load_der_x509_certificate,
+            backend
+        )
+        assert cert.not_valid_before == datetime.datetime(2002, 1, 1, 12, 1)
+        assert cert.not_valid_after == datetime.datetime(2030, 12, 31, 8, 30)
+        assert cert.version is x509.Version.v3
+
+    def test_generalized_time_not_after_cert(self, backend):
+        cert = _load_cert(
+            os.path.join(
+                "x509", "PKITS_data", "certs",
+                "ValidGeneralizedTimenotAfterDateTest8EE.crt"
+            ),
+            x509.load_der_x509_certificate,
+            backend
+        )
+        assert cert.not_valid_before == datetime.datetime(2010, 1, 1, 8, 30)
+        assert cert.not_valid_after == datetime.datetime(2050, 1, 1, 12, 1)
+        assert cert.version is x509.Version.v3
+
+    def test_invalid_version_cert(self, backend):
+        cert = _load_cert(
+            os.path.join("x509", "custom", "invalid_version.pem"),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+        with pytest.raises(x509.InvalidVersion) as exc:
+            cert.version
+
+        assert exc.value.parsed_version == 7
+
+    def test_eq(self, backend):
+        cert = _load_cert(
+            os.path.join("x509", "custom", "post2000utctime.pem"),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+        cert2 = _load_cert(
+            os.path.join("x509", "custom", "post2000utctime.pem"),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+        assert cert == cert2
+
+    def test_ne(self, backend):
+        cert = _load_cert(
+            os.path.join("x509", "custom", "post2000utctime.pem"),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+        cert2 = _load_cert(
+            os.path.join(
+                "x509", "PKITS_data", "certs",
+                "ValidGeneralizedTimenotAfterDateTest8EE.crt"
+            ),
+            x509.load_der_x509_certificate,
+            backend
+        )
+        assert cert != cert2
+        assert cert != object()
+
+    def test_hash(self, backend):
+        cert1 = _load_cert(
+            os.path.join("x509", "custom", "post2000utctime.pem"),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+        cert2 = _load_cert(
+            os.path.join("x509", "custom", "post2000utctime.pem"),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+        cert3 = _load_cert(
+            os.path.join(
+                "x509", "PKITS_data", "certs",
+                "ValidGeneralizedTimenotAfterDateTest8EE.crt"
+            ),
+            x509.load_der_x509_certificate,
+            backend
+        )
+
+        assert hash(cert1) == hash(cert2)
+        assert hash(cert1) != hash(cert3)
+
+    def test_version_1_cert(self, backend):
+        cert = _load_cert(
+            os.path.join("x509", "v1_cert.pem"),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+        assert cert.version is x509.Version.v1
+
+    def test_invalid_pem(self, backend):
+        with pytest.raises(ValueError):
+            x509.load_pem_x509_certificate(b"notacert", backend)
+
+    def test_invalid_der(self, backend):
+        with pytest.raises(ValueError):
+            x509.load_der_x509_certificate(b"notacert", backend)
+
+    def test_unsupported_signature_hash_algorithm_cert(self, backend):
+        cert = _load_cert(
+            os.path.join("x509", "verisign_md2_root.pem"),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+        with pytest.raises(UnsupportedAlgorithm):
+            cert.signature_hash_algorithm
+
+    def test_public_bytes_pem(self, backend):
+        # Load an existing certificate.
+        cert = _load_cert(
+            os.path.join("x509", "PKITS_data", "certs", "GoodCACert.crt"),
+            x509.load_der_x509_certificate,
+            backend
+        )
+
+        # Encode it to PEM and load it back.
+        cert = x509.load_pem_x509_certificate(cert.public_bytes(
+            encoding=serialization.Encoding.PEM,
+        ), backend)
+
+        # We should recover what we had to start with.
+        assert cert.not_valid_before == datetime.datetime(2010, 1, 1, 8, 30)
+        assert cert.not_valid_after == datetime.datetime(2030, 12, 31, 8, 30)
+        assert cert.serial == 2
+        public_key = cert.public_key()
+        assert isinstance(public_key, rsa.RSAPublicKey)
+        assert cert.version is x509.Version.v3
+        fingerprint = binascii.hexlify(cert.fingerprint(hashes.SHA1()))
+        assert fingerprint == b"6f49779533d565e8b7c1062503eab41492c38e4d"
+
+    def test_public_bytes_der(self, backend):
+        # Load an existing certificate.
+        cert = _load_cert(
+            os.path.join("x509", "PKITS_data", "certs", "GoodCACert.crt"),
+            x509.load_der_x509_certificate,
+            backend
+        )
+
+        # Encode it to DER and load it back.
+        cert = x509.load_der_x509_certificate(cert.public_bytes(
+            encoding=serialization.Encoding.DER,
+        ), backend)
+
+        # We should recover what we had to start with.
+        assert cert.not_valid_before == datetime.datetime(2010, 1, 1, 8, 30)
+        assert cert.not_valid_after == datetime.datetime(2030, 12, 31, 8, 30)
+        assert cert.serial == 2
+        public_key = cert.public_key()
+        assert isinstance(public_key, rsa.RSAPublicKey)
+        assert cert.version is x509.Version.v3
+        fingerprint = binascii.hexlify(cert.fingerprint(hashes.SHA1()))
+        assert fingerprint == b"6f49779533d565e8b7c1062503eab41492c38e4d"
+
+    def test_public_bytes_invalid_encoding(self, backend):
+        cert = _load_cert(
+            os.path.join("x509", "PKITS_data", "certs", "GoodCACert.crt"),
+            x509.load_der_x509_certificate,
+            backend
+        )
+
+        with pytest.raises(TypeError):
+            cert.public_bytes('NotAnEncoding')
+
+    @pytest.mark.parametrize(
+        ("cert_path", "loader_func", "encoding"),
+        [
+            (
+                os.path.join("x509", "v1_cert.pem"),
+                x509.load_pem_x509_certificate,
+                serialization.Encoding.PEM,
+            ),
+            (
+                os.path.join("x509", "PKITS_data", "certs", "GoodCACert.crt"),
+                x509.load_der_x509_certificate,
+                serialization.Encoding.DER,
+            ),
+        ]
+    )
+    def test_public_bytes_match(self, cert_path, loader_func, encoding,
+                                backend):
+        cert_bytes = load_vectors_from_file(
+            cert_path, lambda pemfile: pemfile.read(), mode="rb"
+        )
+        cert = loader_func(cert_bytes, backend)
+        serialized = cert.public_bytes(encoding)
+        assert serialized == cert_bytes
+
+    def test_certificate_repr(self, backend):
+        cert = _load_cert(
+            os.path.join(
+                "x509", "cryptography.io.pem"
+            ),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+        if six.PY3:
+            assert repr(cert) == (
+                "<Certificate(subject=<Name([<NameAttribute(oid=<ObjectIdentif"
+                "ier(oid=2.5.4.11, name=organizationalUnitName)>, value='GT487"
+                "42965')>, <NameAttribute(oid=<ObjectIdentifier(oid=2.5.4.11, "
+                "name=organizationalUnitName)>, value='See www.rapidssl.com/re"
+                "sources/cps (c)14')>, <NameAttribute(oid=<ObjectIdentifier(oi"
+                "d=2.5.4.11, name=organizationalUnitName)>, value='Domain Cont"
+                "rol Validated - RapidSSL(R)')>, <NameAttribute(oid=<ObjectIde"
+                "ntifier(oid=2.5.4.3, name=commonName)>, value='www.cryptograp"
+                "hy.io')>])>, ...)>"
+            )
+        else:
+            assert repr(cert) == (
+                "<Certificate(subject=<Name([<NameAttribute(oid=<ObjectIdentif"
+                "ier(oid=2.5.4.11, name=organizationalUnitName)>, value=u'GT48"
+                "742965')>, <NameAttribute(oid=<ObjectIdentifier(oid=2.5.4.11,"
+                " name=organizationalUnitName)>, value=u'See www.rapidssl.com/"
+                "resources/cps (c)14')>, <NameAttribute(oid=<ObjectIdentifier("
+                "oid=2.5.4.11, name=organizationalUnitName)>, value=u'Domain C"
+                "ontrol Validated - RapidSSL(R)')>, <NameAttribute(oid=<Object"
+                "Identifier(oid=2.5.4.3, name=commonName)>, value=u'www.crypto"
+                "graphy.io')>])>, ...)>"
+            )
+
+
+@pytest.mark.requires_backend_interface(interface=RSABackend)
+@pytest.mark.requires_backend_interface(interface=X509Backend)
+class TestRSACertificateRequest(object):
+    @pytest.mark.parametrize(
+        ("path", "loader_func"),
+        [
+            [
+                os.path.join("x509", "requests", "rsa_sha1.pem"),
+                x509.load_pem_x509_csr
+            ],
+            [
+                os.path.join("x509", "requests", "rsa_sha1.der"),
+                x509.load_der_x509_csr
+            ],
+        ]
+    )
+    def test_load_rsa_certificate_request(self, path, loader_func, backend):
+        request = _load_cert(path, loader_func, backend)
+        assert isinstance(request.signature_hash_algorithm, hashes.SHA1)
+        public_key = request.public_key()
+        assert isinstance(public_key, rsa.RSAPublicKey)
+        subject = request.subject
+        assert isinstance(subject, x509.Name)
+        assert list(subject) == [
+            x509.NameAttribute(NameOID.COUNTRY_NAME, u'US'),
+            x509.NameAttribute(NameOID.STATE_OR_PROVINCE_NAME, u'Texas'),
+            x509.NameAttribute(NameOID.LOCALITY_NAME, u'Austin'),
+            x509.NameAttribute(NameOID.ORGANIZATION_NAME, u'PyCA'),
+            x509.NameAttribute(NameOID.COMMON_NAME, u'cryptography.io'),
+        ]
+        extensions = request.extensions
+        assert isinstance(extensions, x509.Extensions)
+        assert list(extensions) == []
+
+    @pytest.mark.parametrize(
+        "loader_func",
+        [x509.load_pem_x509_csr, x509.load_der_x509_csr]
+    )
+    def test_invalid_certificate_request(self, loader_func, backend):
+        with pytest.raises(ValueError):
+            loader_func(b"notacsr", backend)
+
+    def test_unsupported_signature_hash_algorithm_request(self, backend):
+        request = _load_cert(
+            os.path.join("x509", "requests", "rsa_md4.pem"),
+            x509.load_pem_x509_csr,
+            backend
+        )
+        with pytest.raises(UnsupportedAlgorithm):
+            request.signature_hash_algorithm
+
+    def test_duplicate_extension(self, backend):
+        request = _load_cert(
+            os.path.join(
+                "x509", "requests", "two_basic_constraints.pem"
+            ),
+            x509.load_pem_x509_csr,
+            backend
+        )
+        with pytest.raises(x509.DuplicateExtension) as exc:
+            request.extensions
+
+        assert exc.value.oid == ExtensionOID.BASIC_CONSTRAINTS
+
+    def test_unsupported_critical_extension(self, backend):
+        request = _load_cert(
+            os.path.join(
+                "x509", "requests", "unsupported_extension_critical.pem"
+            ),
+            x509.load_pem_x509_csr,
+            backend
+        )
+        with pytest.raises(x509.UnsupportedExtension) as exc:
+            request.extensions
+
+        assert exc.value.oid == x509.ObjectIdentifier('1.2.3.4')
+
+    def test_unsupported_extension(self, backend):
+        request = _load_cert(
+            os.path.join(
+                "x509", "requests", "unsupported_extension.pem"
+            ),
+            x509.load_pem_x509_csr,
+            backend
+        )
+        extensions = request.extensions
+        assert len(extensions) == 0
+
+    def test_request_basic_constraints(self, backend):
+        request = _load_cert(
+            os.path.join(
+                "x509", "requests", "basic_constraints.pem"
+            ),
+            x509.load_pem_x509_csr,
+            backend
+        )
+        extensions = request.extensions
+        assert isinstance(extensions, x509.Extensions)
+        assert list(extensions) == [
+            x509.Extension(
+                ExtensionOID.BASIC_CONSTRAINTS,
+                True,
+                x509.BasicConstraints(ca=True, path_length=1),
+            ),
+        ]
+
+    def test_subject_alt_name(self, backend):
+        request = _load_cert(
+            os.path.join("x509", "requests", "san_rsa_sha1.pem"),
+            x509.load_pem_x509_csr,
+            backend,
+        )
+        ext = request.extensions.get_extension_for_oid(
+            ExtensionOID.SUBJECT_ALTERNATIVE_NAME
+        )
+        assert list(ext.value) == [
+            x509.DNSName(u"cryptography.io"),
+            x509.DNSName(u"sub.cryptography.io"),
+        ]
+
+    def test_public_bytes_pem(self, backend):
+        # Load an existing CSR.
+        request = _load_cert(
+            os.path.join("x509", "requests", "rsa_sha1.pem"),
+            x509.load_pem_x509_csr,
+            backend
+        )
+
+        # Encode it to PEM and load it back.
+        request = x509.load_pem_x509_csr(request.public_bytes(
+            encoding=serialization.Encoding.PEM,
+        ), backend)
+
+        # We should recover what we had to start with.
+        assert isinstance(request.signature_hash_algorithm, hashes.SHA1)
+        public_key = request.public_key()
+        assert isinstance(public_key, rsa.RSAPublicKey)
+        subject = request.subject
+        assert isinstance(subject, x509.Name)
+        assert list(subject) == [
+            x509.NameAttribute(NameOID.COUNTRY_NAME, u'US'),
+            x509.NameAttribute(NameOID.STATE_OR_PROVINCE_NAME, u'Texas'),
+            x509.NameAttribute(NameOID.LOCALITY_NAME, u'Austin'),
+            x509.NameAttribute(NameOID.ORGANIZATION_NAME, u'PyCA'),
+            x509.NameAttribute(NameOID.COMMON_NAME, u'cryptography.io'),
+        ]
+
+    def test_public_bytes_der(self, backend):
+        # Load an existing CSR.
+        request = _load_cert(
+            os.path.join("x509", "requests", "rsa_sha1.pem"),
+            x509.load_pem_x509_csr,
+            backend
+        )
+
+        # Encode it to DER and load it back.
+        request = x509.load_der_x509_csr(request.public_bytes(
+            encoding=serialization.Encoding.DER,
+        ), backend)
+
+        # We should recover what we had to start with.
+        assert isinstance(request.signature_hash_algorithm, hashes.SHA1)
+        public_key = request.public_key()
+        assert isinstance(public_key, rsa.RSAPublicKey)
+        subject = request.subject
+        assert isinstance(subject, x509.Name)
+        assert list(subject) == [
+            x509.NameAttribute(NameOID.COUNTRY_NAME, u'US'),
+            x509.NameAttribute(NameOID.STATE_OR_PROVINCE_NAME, u'Texas'),
+            x509.NameAttribute(NameOID.LOCALITY_NAME, u'Austin'),
+            x509.NameAttribute(NameOID.ORGANIZATION_NAME, u'PyCA'),
+            x509.NameAttribute(NameOID.COMMON_NAME, u'cryptography.io'),
+        ]
+
+    def test_public_bytes_invalid_encoding(self, backend):
+        request = _load_cert(
+            os.path.join("x509", "requests", "rsa_sha1.pem"),
+            x509.load_pem_x509_csr,
+            backend
+        )
+
+        with pytest.raises(TypeError):
+            request.public_bytes('NotAnEncoding')
+
+    @pytest.mark.parametrize(
+        ("request_path", "loader_func", "encoding"),
+        [
+            (
+                os.path.join("x509", "requests", "rsa_sha1.pem"),
+                x509.load_pem_x509_csr,
+                serialization.Encoding.PEM,
+            ),
+            (
+                os.path.join("x509", "requests", "rsa_sha1.der"),
+                x509.load_der_x509_csr,
+                serialization.Encoding.DER,
+            ),
+        ]
+    )
+    def test_public_bytes_match(self, request_path, loader_func, encoding,
+                                backend):
+        request_bytes = load_vectors_from_file(
+            request_path, lambda pemfile: pemfile.read(), mode="rb"
+        )
+        request = loader_func(request_bytes, backend)
+        serialized = request.public_bytes(encoding)
+        assert serialized == request_bytes
+
+    def test_eq(self, backend):
+        request1 = _load_cert(
+            os.path.join("x509", "requests", "rsa_sha1.pem"),
+            x509.load_pem_x509_csr,
+            backend
+        )
+        request2 = _load_cert(
+            os.path.join("x509", "requests", "rsa_sha1.pem"),
+            x509.load_pem_x509_csr,
+            backend
+        )
+
+        assert request1 == request2
+
+    def test_ne(self, backend):
+        request1 = _load_cert(
+            os.path.join("x509", "requests", "rsa_sha1.pem"),
+            x509.load_pem_x509_csr,
+            backend
+        )
+        request2 = _load_cert(
+            os.path.join("x509", "requests", "san_rsa_sha1.pem"),
+            x509.load_pem_x509_csr,
+            backend
+        )
+
+        assert request1 != request2
+        assert request1 != object()
+
+    def test_hash(self, backend):
+        request1 = _load_cert(
+            os.path.join("x509", "requests", "rsa_sha1.pem"),
+            x509.load_pem_x509_csr,
+            backend
+        )
+        request2 = _load_cert(
+            os.path.join("x509", "requests", "rsa_sha1.pem"),
+            x509.load_pem_x509_csr,
+            backend
+        )
+        request3 = _load_cert(
+            os.path.join("x509", "requests", "san_rsa_sha1.pem"),
+            x509.load_pem_x509_csr,
+            backend
+        )
+
+        assert hash(request1) == hash(request2)
+        assert hash(request1) != hash(request3)
+
+    def test_build_cert(self, backend):
+        issuer_private_key = RSA_KEY_2048.private_key(backend)
+        subject_private_key = RSA_KEY_2048.private_key(backend)
+
+        not_valid_before = datetime.datetime(2002, 1, 1, 12, 1)
+        not_valid_after = datetime.datetime(2030, 12, 31, 8, 30)
+
+        builder = x509.CertificateBuilder().serial_number(
+            777
+        ).issuer_name(x509.Name([
+            x509.NameAttribute(NameOID.COUNTRY_NAME, u'US'),
+            x509.NameAttribute(NameOID.STATE_OR_PROVINCE_NAME, u'Texas'),
+            x509.NameAttribute(NameOID.LOCALITY_NAME, u'Austin'),
+            x509.NameAttribute(NameOID.ORGANIZATION_NAME, u'PyCA'),
+            x509.NameAttribute(NameOID.COMMON_NAME, u'cryptography.io'),
+        ])).subject_name(x509.Name([
+            x509.NameAttribute(NameOID.COUNTRY_NAME, u'US'),
+            x509.NameAttribute(NameOID.STATE_OR_PROVINCE_NAME, u'Texas'),
+            x509.NameAttribute(NameOID.LOCALITY_NAME, u'Austin'),
+            x509.NameAttribute(NameOID.ORGANIZATION_NAME, u'PyCA'),
+            x509.NameAttribute(NameOID.COMMON_NAME, u'cryptography.io'),
+        ])).public_key(
+            subject_private_key.public_key()
+        ).add_extension(
+            x509.BasicConstraints(ca=False, path_length=None), True,
+        ).add_extension(
+            x509.SubjectAlternativeName([x509.DNSName(u"cryptography.io")]),
+            critical=False,
+        ).not_valid_before(
+            not_valid_before
+        ).not_valid_after(
+            not_valid_after
+        )
+
+        cert = builder.sign(issuer_private_key, hashes.SHA1(), backend)
+
+        assert cert.version is x509.Version.v3
+        assert cert.not_valid_before == not_valid_before
+        assert cert.not_valid_after == not_valid_after
+        basic_constraints = cert.extensions.get_extension_for_oid(
+            ExtensionOID.BASIC_CONSTRAINTS
+        )
+        assert basic_constraints.value.ca is False
+        assert basic_constraints.value.path_length is None
+        subject_alternative_name = cert.extensions.get_extension_for_oid(
+            ExtensionOID.SUBJECT_ALTERNATIVE_NAME
+        )
+        assert list(subject_alternative_name.value) == [
+            x509.DNSName(u"cryptography.io"),
+        ]
+
+    def test_build_cert_printable_string_country_name(self, backend):
+        issuer_private_key = RSA_KEY_2048.private_key(backend)
+        subject_private_key = RSA_KEY_2048.private_key(backend)
+
+        not_valid_before = datetime.datetime(2002, 1, 1, 12, 1)
+        not_valid_after = datetime.datetime(2030, 12, 31, 8, 30)
+
+        builder = x509.CertificateBuilder().serial_number(
+            777
+        ).issuer_name(x509.Name([
+            x509.NameAttribute(NameOID.COUNTRY_NAME, u'US'),
+            x509.NameAttribute(NameOID.STATE_OR_PROVINCE_NAME, u'Texas'),
+        ])).subject_name(x509.Name([
+            x509.NameAttribute(NameOID.COUNTRY_NAME, u'US'),
+            x509.NameAttribute(NameOID.STATE_OR_PROVINCE_NAME, u'Texas'),
+        ])).public_key(
+            subject_private_key.public_key()
+        ).not_valid_before(
+            not_valid_before
+        ).not_valid_after(
+            not_valid_after
+        )
+
+        cert = builder.sign(issuer_private_key, hashes.SHA256(), backend)
+
+        parsed, _ = decoder.decode(
+            cert.public_bytes(serialization.Encoding.DER),
+            asn1Spec=rfc2459.Certificate()
+        )
+        tbs_cert = parsed.getComponentByName('tbsCertificate')
+        subject = tbs_cert.getComponentByName('subject')
+        issuer = tbs_cert.getComponentByName('issuer')
+        # \x13 is printable string. The first byte of the value of the
+        # node corresponds to the ASN.1 string type.
+        assert subject[0][0][0][1][0] == b"\x13"[0]
+        assert issuer[0][0][0][1][0] == b"\x13"[0]
+
+
+class TestCertificateBuilder(object):
+    @pytest.mark.requires_backend_interface(interface=RSABackend)
+    @pytest.mark.requires_backend_interface(interface=X509Backend)
+    def test_checks_for_unsupported_extensions(self, backend):
+        private_key = RSA_KEY_2048.private_key(backend)
+        builder = x509.CertificateBuilder().subject_name(x509.Name([
+            x509.NameAttribute(NameOID.COUNTRY_NAME, u'US'),
+        ])).issuer_name(x509.Name([
+            x509.NameAttribute(NameOID.COUNTRY_NAME, u'US'),
+        ])).public_key(
+            private_key.public_key()
+        ).serial_number(
+            777
+        ).not_valid_before(
+            datetime.datetime(1999, 1, 1)
+        ).not_valid_after(
+            datetime.datetime(2020, 1, 1)
+        ).add_extension(
+            DummyExtension(), False
+        )
+
+        with pytest.raises(NotImplementedError):
+            builder.sign(private_key, hashes.SHA1(), backend)
+
+    @pytest.mark.requires_backend_interface(interface=RSABackend)
+    @pytest.mark.requires_backend_interface(interface=X509Backend)
+    def test_no_subject_name(self, backend):
+        subject_private_key = RSA_KEY_2048.private_key(backend)
+        builder = x509.CertificateBuilder().serial_number(
+            777
+        ).issuer_name(x509.Name([
+            x509.NameAttribute(NameOID.COUNTRY_NAME, u'US'),
+        ])).public_key(
+            subject_private_key.public_key()
+        ).not_valid_before(
+            datetime.datetime(2002, 1, 1, 12, 1)
+        ).not_valid_after(
+            datetime.datetime(2030, 12, 31, 8, 30)
+        )
+        with pytest.raises(ValueError):
+            builder.sign(subject_private_key, hashes.SHA256(), backend)
+
+    @pytest.mark.requires_backend_interface(interface=RSABackend)
+    @pytest.mark.requires_backend_interface(interface=X509Backend)
+    def test_no_issuer_name(self, backend):
+        subject_private_key = RSA_KEY_2048.private_key(backend)
+        builder = x509.CertificateBuilder().serial_number(
+            777
+        ).subject_name(x509.Name([
+            x509.NameAttribute(NameOID.COUNTRY_NAME, u'US'),
+        ])).public_key(
+            subject_private_key.public_key()
+        ).not_valid_before(
+            datetime.datetime(2002, 1, 1, 12, 1)
+        ).not_valid_after(
+            datetime.datetime(2030, 12, 31, 8, 30)
+        )
+        with pytest.raises(ValueError):
+            builder.sign(subject_private_key, hashes.SHA256(), backend)
+
+    @pytest.mark.requires_backend_interface(interface=RSABackend)
+    @pytest.mark.requires_backend_interface(interface=X509Backend)
+    def test_no_public_key(self, backend):
+        subject_private_key = RSA_KEY_2048.private_key(backend)
+        builder = x509.CertificateBuilder().serial_number(
+            777
+        ).issuer_name(x509.Name([
+            x509.NameAttribute(NameOID.COUNTRY_NAME, u'US'),
+        ])).subject_name(x509.Name([
+            x509.NameAttribute(NameOID.COUNTRY_NAME, u'US'),
+        ])).not_valid_before(
+            datetime.datetime(2002, 1, 1, 12, 1)
+        ).not_valid_after(
+            datetime.datetime(2030, 12, 31, 8, 30)
+        )
+        with pytest.raises(ValueError):
+            builder.sign(subject_private_key, hashes.SHA256(), backend)
+
+    @pytest.mark.requires_backend_interface(interface=RSABackend)
+    @pytest.mark.requires_backend_interface(interface=X509Backend)
+    def test_no_not_valid_before(self, backend):
+        subject_private_key = RSA_KEY_2048.private_key(backend)
+        builder = x509.CertificateBuilder().serial_number(
+            777
+        ).issuer_name(x509.Name([
+            x509.NameAttribute(NameOID.COUNTRY_NAME, u'US'),
+        ])).subject_name(x509.Name([
+            x509.NameAttribute(NameOID.COUNTRY_NAME, u'US'),
+        ])).public_key(
+            subject_private_key.public_key()
+        ).not_valid_after(
+            datetime.datetime(2030, 12, 31, 8, 30)
+        )
+        with pytest.raises(ValueError):
+            builder.sign(subject_private_key, hashes.SHA256(), backend)
+
+    @pytest.mark.requires_backend_interface(interface=RSABackend)
+    @pytest.mark.requires_backend_interface(interface=X509Backend)
+    def test_no_not_valid_after(self, backend):
+        subject_private_key = RSA_KEY_2048.private_key(backend)
+        builder = x509.CertificateBuilder().serial_number(
+            777
+        ).issuer_name(x509.Name([
+            x509.NameAttribute(NameOID.COUNTRY_NAME, u'US'),
+        ])).subject_name(x509.Name([
+            x509.NameAttribute(NameOID.COUNTRY_NAME, u'US'),
+        ])).public_key(
+            subject_private_key.public_key()
+        ).not_valid_before(
+            datetime.datetime(2002, 1, 1, 12, 1)
+        )
+        with pytest.raises(ValueError):
+            builder.sign(subject_private_key, hashes.SHA256(), backend)
+
+    @pytest.mark.requires_backend_interface(interface=RSABackend)
+    @pytest.mark.requires_backend_interface(interface=X509Backend)
+    def test_no_serial_number(self, backend):
+        subject_private_key = RSA_KEY_2048.private_key(backend)
+        builder = x509.CertificateBuilder().issuer_name(x509.Name([
+            x509.NameAttribute(NameOID.COUNTRY_NAME, u'US'),
+        ])).subject_name(x509.Name([
+            x509.NameAttribute(NameOID.COUNTRY_NAME, u'US'),
+        ])).public_key(
+            subject_private_key.public_key()
+        ).not_valid_before(
+            datetime.datetime(2002, 1, 1, 12, 1)
+        ).not_valid_after(
+            datetime.datetime(2030, 12, 31, 8, 30)
+        )
+        with pytest.raises(ValueError):
+            builder.sign(subject_private_key, hashes.SHA256(), backend)
+
+    def test_issuer_name_must_be_a_name_type(self):
+        builder = x509.CertificateBuilder()
+
+        with pytest.raises(TypeError):
+            builder.issuer_name("subject")
+
+        with pytest.raises(TypeError):
+            builder.issuer_name(object)
+
+    def test_issuer_name_may_only_be_set_once(self):
+        name = x509.Name([
+            x509.NameAttribute(NameOID.COUNTRY_NAME, u'US'),
+        ])
+        builder = x509.CertificateBuilder().issuer_name(name)
+
+        with pytest.raises(ValueError):
+            builder.issuer_name(name)
+
+    def test_subject_name_must_be_a_name_type(self):
+        builder = x509.CertificateBuilder()
+
+        with pytest.raises(TypeError):
+            builder.subject_name("subject")
+
+        with pytest.raises(TypeError):
+            builder.subject_name(object)
+
+    def test_subject_name_may_only_be_set_once(self):
+        name = x509.Name([
+            x509.NameAttribute(NameOID.COUNTRY_NAME, u'US'),
+        ])
+        builder = x509.CertificateBuilder().subject_name(name)
+
+        with pytest.raises(ValueError):
+            builder.subject_name(name)
+
+    @pytest.mark.requires_backend_interface(interface=RSABackend)
+    @pytest.mark.requires_backend_interface(interface=X509Backend)
+    def test_public_key_must_be_public_key(self, backend):
+        private_key = RSA_KEY_2048.private_key(backend)
+        builder = x509.CertificateBuilder()
+
+        with pytest.raises(TypeError):
+            builder.public_key(private_key)
+
+    @pytest.mark.requires_backend_interface(interface=RSABackend)
+    @pytest.mark.requires_backend_interface(interface=X509Backend)
+    def test_public_key_may_only_be_set_once(self, backend):
+        private_key = RSA_KEY_2048.private_key(backend)
+        public_key = private_key.public_key()
+        builder = x509.CertificateBuilder().public_key(public_key)
+
+        with pytest.raises(ValueError):
+            builder.public_key(public_key)
+
+    def test_serial_number_must_be_an_integer_type(self):
+        with pytest.raises(TypeError):
+            x509.CertificateBuilder().serial_number(10.0)
+
+    def test_serial_number_must_be_non_negative(self):
+        with pytest.raises(ValueError):
+            x509.CertificateBuilder().serial_number(-10)
+
+    def test_serial_number_must_be_less_than_160_bits_long(self):
+        with pytest.raises(ValueError):
+            # 2 raised to the 160th power is actually 161 bits
+            x509.CertificateBuilder().serial_number(2 ** 160)
+
+    def test_serial_number_may_only_be_set_once(self):
+        builder = x509.CertificateBuilder().serial_number(10)
+
+        with pytest.raises(ValueError):
+            builder.serial_number(20)
+
+    def test_invalid_not_valid_after(self):
+        with pytest.raises(TypeError):
+            x509.CertificateBuilder().not_valid_after(104204304504)
+
+        with pytest.raises(TypeError):
+            x509.CertificateBuilder().not_valid_after(datetime.time())
+
+        with pytest.raises(ValueError):
+            x509.CertificateBuilder().not_valid_after(
+                datetime.datetime(1960, 8, 10)
+            )
+
+    def test_not_valid_after_may_only_be_set_once(self):
+        builder = x509.CertificateBuilder().not_valid_after(
+            datetime.datetime.now()
+        )
+
+        with pytest.raises(ValueError):
+            builder.not_valid_after(
+                datetime.datetime.now()
+            )
+
+    def test_invalid_not_valid_before(self):
+        with pytest.raises(TypeError):
+            x509.CertificateBuilder().not_valid_before(104204304504)
+
+        with pytest.raises(TypeError):
+            x509.CertificateBuilder().not_valid_before(datetime.time())
+
+        with pytest.raises(ValueError):
+            x509.CertificateBuilder().not_valid_before(
+                datetime.datetime(1960, 8, 10)
+            )
+
+    def test_not_valid_before_may_only_be_set_once(self):
+        builder = x509.CertificateBuilder().not_valid_before(
+            datetime.datetime.now()
+        )
+
+        with pytest.raises(ValueError):
+            builder.not_valid_before(
+                datetime.datetime.now()
+            )
+
+    def test_add_extension_checks_for_duplicates(self):
+        builder = x509.CertificateBuilder().add_extension(
+            x509.BasicConstraints(ca=False, path_length=None), True,
+        )
+
+        with pytest.raises(ValueError):
+            builder.add_extension(
+                x509.BasicConstraints(ca=False, path_length=None), True,
+            )
+
+    def test_add_invalid_extension_type(self):
+        builder = x509.CertificateBuilder()
+
+        with pytest.raises(TypeError):
+            builder.add_extension(object(), False)
+
+    @pytest.mark.requires_backend_interface(interface=RSABackend)
+    @pytest.mark.requires_backend_interface(interface=X509Backend)
+    def test_sign_with_unsupported_hash(self, backend):
+        private_key = RSA_KEY_2048.private_key(backend)
+        builder = x509.CertificateBuilder()
+        builder = builder.subject_name(
+            x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, u'US')])
+        ).issuer_name(
+            x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, u'US')])
+        ).serial_number(
+            1
+        ).public_key(
+            private_key.public_key()
+        ).not_valid_before(
+            datetime.datetime(2002, 1, 1, 12, 1)
+        ).not_valid_after(
+            datetime.datetime(2032, 1, 1, 12, 1)
+        )
+
+        with pytest.raises(TypeError):
+            builder.sign(private_key, object(), backend)
+
+    @pytest.mark.requires_backend_interface(interface=DSABackend)
+    @pytest.mark.requires_backend_interface(interface=X509Backend)
+    def test_sign_with_dsa_private_key_is_unsupported(self, backend):
+        if backend._lib.OPENSSL_VERSION_NUMBER >= 0x10001000:
+            pytest.skip("Requires an older OpenSSL. Must be < 1.0.1")
+
+        private_key = DSA_KEY_2048.private_key(backend)
+        builder = x509.CertificateBuilder()
+        builder = builder.subject_name(
+            x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, u'US')])
+        ).issuer_name(
+            x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, u'US')])
+        ).serial_number(
+            1
+        ).public_key(
+            private_key.public_key()
+        ).not_valid_before(
+            datetime.datetime(2002, 1, 1, 12, 1)
+        ).not_valid_after(
+            datetime.datetime(2032, 1, 1, 12, 1)
+        )
+
+        with pytest.raises(NotImplementedError):
+            builder.sign(private_key, hashes.SHA512(), backend)
+
+    @pytest.mark.requires_backend_interface(interface=EllipticCurveBackend)
+    @pytest.mark.requires_backend_interface(interface=X509Backend)
+    def test_sign_with_ec_private_key_is_unsupported(self, backend):
+        if backend._lib.OPENSSL_VERSION_NUMBER >= 0x10001000:
+            pytest.skip("Requires an older OpenSSL. Must be < 1.0.1")
+
+        _skip_curve_unsupported(backend, ec.SECP256R1())
+        private_key = ec.generate_private_key(ec.SECP256R1(), backend)
+        builder = x509.CertificateBuilder()
+        builder = builder.subject_name(
+            x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, u'US')])
+        ).issuer_name(
+            x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, u'US')])
+        ).serial_number(
+            1
+        ).public_key(
+            private_key.public_key()
+        ).not_valid_before(
+            datetime.datetime(2002, 1, 1, 12, 1)
+        ).not_valid_after(
+            datetime.datetime(2032, 1, 1, 12, 1)
+        )
+
+        with pytest.raises(NotImplementedError):
+            builder.sign(private_key, hashes.SHA512(), backend)
+
+    @pytest.mark.parametrize(
+        "cdp",
+        [
+            x509.CRLDistributionPoints([
+                x509.DistributionPoint(
+                    full_name=None,
+                    relative_name=x509.Name([
+                        x509.NameAttribute(
+                            NameOID.COMMON_NAME,
+                            u"indirect CRL for indirectCRL CA3"
+                        ),
+                    ]),
+                    reasons=None,
+                    crl_issuer=[x509.DirectoryName(
+                        x509.Name([
+                            x509.NameAttribute(NameOID.COUNTRY_NAME, u"US"),
+                            x509.NameAttribute(
+                                NameOID.ORGANIZATION_NAME,
+                                u"Test Certificates 2011"
+                            ),
+                            x509.NameAttribute(
+                                NameOID.ORGANIZATIONAL_UNIT_NAME,
+                                u"indirectCRL CA3 cRLIssuer"
+                            ),
+                        ])
+                    )],
+                )
+            ]),
+            x509.CRLDistributionPoints([
+                x509.DistributionPoint(
+                    full_name=[x509.DirectoryName(
+                        x509.Name([
+                            x509.NameAttribute(NameOID.COUNTRY_NAME, u"US"),
+                        ])
+                    )],
+                    relative_name=None,
+                    reasons=None,
+                    crl_issuer=[x509.DirectoryName(
+                        x509.Name([
+                            x509.NameAttribute(
+                                NameOID.ORGANIZATION_NAME,
+                                u"cryptography Testing"
+                            ),
+                        ])
+                    )],
+                )
+            ]),
+            x509.CRLDistributionPoints([
+                x509.DistributionPoint(
+                    full_name=[
+                        x509.UniformResourceIdentifier(
+                            u"http://myhost.com/myca.crl"
+                        ),
+                        x509.UniformResourceIdentifier(
+                            u"http://backup.myhost.com/myca.crl"
+                        )
+                    ],
+                    relative_name=None,
+                    reasons=frozenset([
+                        x509.ReasonFlags.key_compromise,
+                        x509.ReasonFlags.ca_compromise
+                    ]),
+                    crl_issuer=[x509.DirectoryName(
+                        x509.Name([
+                            x509.NameAttribute(NameOID.COUNTRY_NAME, u"US"),
+                            x509.NameAttribute(
+                                NameOID.COMMON_NAME, u"cryptography CA"
+                            ),
+                        ])
+                    )],
+                )
+            ]),
+            x509.CRLDistributionPoints([
+                x509.DistributionPoint(
+                    full_name=[x509.UniformResourceIdentifier(
+                        u"http://domain.com/some.crl"
+                    )],
+                    relative_name=None,
+                    reasons=frozenset([
+                        x509.ReasonFlags.key_compromise,
+                        x509.ReasonFlags.ca_compromise,
+                        x509.ReasonFlags.affiliation_changed,
+                        x509.ReasonFlags.superseded,
+                        x509.ReasonFlags.privilege_withdrawn,
+                        x509.ReasonFlags.cessation_of_operation,
+                        x509.ReasonFlags.aa_compromise,
+                        x509.ReasonFlags.certificate_hold,
+                    ]),
+                    crl_issuer=None
+                )
+            ]),
+            x509.CRLDistributionPoints([
+                x509.DistributionPoint(
+                    full_name=None,
+                    relative_name=None,
+                    reasons=None,
+                    crl_issuer=[x509.DirectoryName(
+                        x509.Name([
+                            x509.NameAttribute(
+                                NameOID.COMMON_NAME, u"cryptography CA"
+                            ),
+                        ])
+                    )],
+                )
+            ]),
+            x509.CRLDistributionPoints([
+                x509.DistributionPoint(
+                    full_name=[x509.UniformResourceIdentifier(
+                        u"http://domain.com/some.crl"
+                    )],
+                    relative_name=None,
+                    reasons=frozenset([x509.ReasonFlags.aa_compromise]),
+                    crl_issuer=None
+                )
+            ])
+        ]
+    )
+    @pytest.mark.requires_backend_interface(interface=RSABackend)
+    @pytest.mark.requires_backend_interface(interface=X509Backend)
+    def test_crl_distribution_points(self, backend, cdp):
+        issuer_private_key = RSA_KEY_2048.private_key(backend)
+        subject_private_key = RSA_KEY_2048.private_key(backend)
+
+        builder = x509.CertificateBuilder().serial_number(
+            4444444
+        ).issuer_name(x509.Name([
+            x509.NameAttribute(NameOID.LOCALITY_NAME, u'Austin'),
+        ])).subject_name(x509.Name([
+            x509.NameAttribute(NameOID.LOCALITY_NAME, u'Austin'),
+        ])).public_key(
+            subject_private_key.public_key()
+        ).add_extension(
+            cdp,
+            critical=False,
+        ).not_valid_before(
+            datetime.datetime(2002, 1, 1, 12, 1)
+        ).not_valid_after(
+            datetime.datetime(2030, 12, 31, 8, 30)
+        )
+
+        cert = builder.sign(issuer_private_key, hashes.SHA1(), backend)
+
+        ext = cert.extensions.get_extension_for_oid(
+            ExtensionOID.CRL_DISTRIBUTION_POINTS
+        )
+        assert ext.critical is False
+        assert ext.value == cdp
+
+    @pytest.mark.requires_backend_interface(interface=DSABackend)
+    @pytest.mark.requires_backend_interface(interface=X509Backend)
+    def test_build_cert_with_dsa_private_key(self, backend):
+        if backend._lib.OPENSSL_VERSION_NUMBER < 0x10001000:
+            pytest.skip("Requires a newer OpenSSL. Must be >= 1.0.1")
+
+        issuer_private_key = DSA_KEY_2048.private_key(backend)
+        subject_private_key = DSA_KEY_2048.private_key(backend)
+
+        not_valid_before = datetime.datetime(2002, 1, 1, 12, 1)
+        not_valid_after = datetime.datetime(2030, 12, 31, 8, 30)
+
+        builder = x509.CertificateBuilder().serial_number(
+            777
+        ).issuer_name(x509.Name([
+            x509.NameAttribute(NameOID.COUNTRY_NAME, u'US'),
+        ])).subject_name(x509.Name([
+            x509.NameAttribute(NameOID.COUNTRY_NAME, u'US'),
+        ])).public_key(
+            subject_private_key.public_key()
+        ).add_extension(
+            x509.BasicConstraints(ca=False, path_length=None), True,
+        ).add_extension(
+            x509.SubjectAlternativeName([x509.DNSName(u"cryptography.io")]),
+            critical=False,
+        ).not_valid_before(
+            not_valid_before
+        ).not_valid_after(
+            not_valid_after
+        )
+
+        cert = builder.sign(issuer_private_key, hashes.SHA1(), backend)
+
+        assert cert.version is x509.Version.v3
+        assert cert.not_valid_before == not_valid_before
+        assert cert.not_valid_after == not_valid_after
+        basic_constraints = cert.extensions.get_extension_for_oid(
+            ExtensionOID.BASIC_CONSTRAINTS
+        )
+        assert basic_constraints.value.ca is False
+        assert basic_constraints.value.path_length is None
+        subject_alternative_name = cert.extensions.get_extension_for_oid(
+            ExtensionOID.SUBJECT_ALTERNATIVE_NAME
+        )
+        assert list(subject_alternative_name.value) == [
+            x509.DNSName(u"cryptography.io"),
+        ]
+
+    @pytest.mark.requires_backend_interface(interface=EllipticCurveBackend)
+    @pytest.mark.requires_backend_interface(interface=X509Backend)
+    def test_build_cert_with_ec_private_key(self, backend):
+        if backend._lib.OPENSSL_VERSION_NUMBER < 0x10001000:
+            pytest.skip("Requires a newer OpenSSL. Must be >= 1.0.1")
+
+        _skip_curve_unsupported(backend, ec.SECP256R1())
+        issuer_private_key = ec.generate_private_key(ec.SECP256R1(), backend)
+        subject_private_key = ec.generate_private_key(ec.SECP256R1(), backend)
+
+        not_valid_before = datetime.datetime(2002, 1, 1, 12, 1)
+        not_valid_after = datetime.datetime(2030, 12, 31, 8, 30)
+
+        builder = x509.CertificateBuilder().serial_number(
+            777
+        ).issuer_name(x509.Name([
+            x509.NameAttribute(NameOID.COUNTRY_NAME, u'US'),
+        ])).subject_name(x509.Name([
+            x509.NameAttribute(NameOID.COUNTRY_NAME, u'US'),
+        ])).public_key(
+            subject_private_key.public_key()
+        ).add_extension(
+            x509.BasicConstraints(ca=False, path_length=None), True,
+        ).add_extension(
+            x509.SubjectAlternativeName([x509.DNSName(u"cryptography.io")]),
+            critical=False,
+        ).not_valid_before(
+            not_valid_before
+        ).not_valid_after(
+            not_valid_after
+        )
+
+        cert = builder.sign(issuer_private_key, hashes.SHA1(), backend)
+
+        assert cert.version is x509.Version.v3
+        assert cert.not_valid_before == not_valid_before
+        assert cert.not_valid_after == not_valid_after
+        basic_constraints = cert.extensions.get_extension_for_oid(
+            ExtensionOID.BASIC_CONSTRAINTS
+        )
+        assert basic_constraints.value.ca is False
+        assert basic_constraints.value.path_length is None
+        subject_alternative_name = cert.extensions.get_extension_for_oid(
+            ExtensionOID.SUBJECT_ALTERNATIVE_NAME
+        )
+        assert list(subject_alternative_name.value) == [
+            x509.DNSName(u"cryptography.io"),
+        ]
+
+    @pytest.mark.requires_backend_interface(interface=RSABackend)
+    @pytest.mark.requires_backend_interface(interface=X509Backend)
+    def test_build_cert_with_rsa_key_too_small(self, backend):
+        issuer_private_key = RSA_KEY_512.private_key(backend)
+        subject_private_key = RSA_KEY_512.private_key(backend)
+
+        not_valid_before = datetime.datetime(2002, 1, 1, 12, 1)
+        not_valid_after = datetime.datetime(2030, 12, 31, 8, 30)
+
+        builder = x509.CertificateBuilder().serial_number(
+            777
+        ).issuer_name(x509.Name([
+            x509.NameAttribute(NameOID.COUNTRY_NAME, u'US'),
+        ])).subject_name(x509.Name([
+            x509.NameAttribute(NameOID.COUNTRY_NAME, u'US'),
+        ])).public_key(
+            subject_private_key.public_key()
+        ).not_valid_before(
+            not_valid_before
+        ).not_valid_after(
+            not_valid_after
+        )
+
+        with pytest.raises(ValueError):
+            builder.sign(issuer_private_key, hashes.SHA512(), backend)
+
+    @pytest.mark.parametrize(
+        "cp",
+        [
+            x509.CertificatePolicies([
+                x509.PolicyInformation(
+                    x509.ObjectIdentifier("2.16.840.1.12345.1.2.3.4.1"),
+                    [u"http://other.com/cps"]
+                )
+            ]),
+            x509.CertificatePolicies([
+                x509.PolicyInformation(
+                    x509.ObjectIdentifier("2.16.840.1.12345.1.2.3.4.1"),
+                    None
+                )
+            ]),
+            x509.CertificatePolicies([
+                x509.PolicyInformation(
+                    x509.ObjectIdentifier("2.16.840.1.12345.1.2.3.4.1"),
+                    [
+                        u"http://example.com/cps",
+                        u"http://other.com/cps",
+                        x509.UserNotice(
+                            x509.NoticeReference(u"my org", [1, 2, 3, 4]),
+                            u"thing"
+                        )
+                    ]
+                )
+            ]),
+            x509.CertificatePolicies([
+                x509.PolicyInformation(
+                    x509.ObjectIdentifier("2.16.840.1.12345.1.2.3.4.1"),
+                    [
+                        u"http://example.com/cps",
+                        x509.UserNotice(
+                            x509.NoticeReference(u"UTF8\u2122'", [1, 2, 3, 4]),
+                            u"We heart UTF8!\u2122"
+                        )
+                    ]
+                )
+            ]),
+            x509.CertificatePolicies([
+                x509.PolicyInformation(
+                    x509.ObjectIdentifier("2.16.840.1.12345.1.2.3.4.1"),
+                    [x509.UserNotice(None, u"thing")]
+                )
+            ]),
+            x509.CertificatePolicies([
+                x509.PolicyInformation(
+                    x509.ObjectIdentifier("2.16.840.1.12345.1.2.3.4.1"),
+                    [
+                        x509.UserNotice(
+                            x509.NoticeReference(u"my org", [1, 2, 3, 4]),
+                            None
+                        )
+                    ]
+                )
+            ])
+        ]
+    )
+    @pytest.mark.requires_backend_interface(interface=RSABackend)
+    @pytest.mark.requires_backend_interface(interface=X509Backend)
+    def test_certificate_policies(self, cp, backend):
+        issuer_private_key = RSA_KEY_2048.private_key(backend)
+        subject_private_key = RSA_KEY_2048.private_key(backend)
+
+        not_valid_before = datetime.datetime(2002, 1, 1, 12, 1)
+        not_valid_after = datetime.datetime(2030, 12, 31, 8, 30)
+
+        cert = x509.CertificateBuilder().subject_name(
+            x509.Name([x509.NameAttribute(x509.OID_COUNTRY_NAME, u'US')])
+        ).issuer_name(
+            x509.Name([x509.NameAttribute(x509.OID_COUNTRY_NAME, u'US')])
+        ).not_valid_before(
+            not_valid_before
+        ).not_valid_after(
+            not_valid_after
+        ).public_key(
+            subject_private_key.public_key()
+        ).serial_number(
+            123
+        ).add_extension(
+            cp, critical=False
+        ).sign(issuer_private_key, hashes.SHA256(), backend)
+
+        ext = cert.extensions.get_extension_for_oid(
+            x509.OID_CERTIFICATE_POLICIES
+        )
+        assert ext.value == cp
+
+    @pytest.mark.requires_backend_interface(interface=RSABackend)
+    @pytest.mark.requires_backend_interface(interface=X509Backend)
+    def test_issuer_alt_name(self, backend):
+        issuer_private_key = RSA_KEY_2048.private_key(backend)
+        subject_private_key = RSA_KEY_2048.private_key(backend)
+
+        not_valid_before = datetime.datetime(2002, 1, 1, 12, 1)
+        not_valid_after = datetime.datetime(2030, 12, 31, 8, 30)
+
+        cert = x509.CertificateBuilder().subject_name(
+            x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, u'US')])
+        ).issuer_name(
+            x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, u'US')])
+        ).not_valid_before(
+            not_valid_before
+        ).not_valid_after(
+            not_valid_after
+        ).public_key(
+            subject_private_key.public_key()
+        ).serial_number(
+            123
+        ).add_extension(
+            x509.IssuerAlternativeName([
+                x509.DNSName(u"myissuer"),
+                x509.RFC822Name(u"email@domain.com"),
+            ]), critical=False
+        ).sign(issuer_private_key, hashes.SHA256(), backend)
+
+        ext = cert.extensions.get_extension_for_oid(
+            ExtensionOID.ISSUER_ALTERNATIVE_NAME
+        )
+        assert ext.critical is False
+        assert ext.value == x509.IssuerAlternativeName([
+            x509.DNSName(u"myissuer"),
+            x509.RFC822Name(u"email@domain.com"),
+        ])
+
+    @pytest.mark.requires_backend_interface(interface=RSABackend)
+    @pytest.mark.requires_backend_interface(interface=X509Backend)
+    def test_extended_key_usage(self, backend):
+        issuer_private_key = RSA_KEY_2048.private_key(backend)
+        subject_private_key = RSA_KEY_2048.private_key(backend)
+
+        not_valid_before = datetime.datetime(2002, 1, 1, 12, 1)
+        not_valid_after = datetime.datetime(2030, 12, 31, 8, 30)
+
+        cert = x509.CertificateBuilder().subject_name(
+            x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, u'US')])
+        ).issuer_name(
+            x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, u'US')])
+        ).not_valid_before(
+            not_valid_before
+        ).not_valid_after(
+            not_valid_after
+        ).public_key(
+            subject_private_key.public_key()
+        ).serial_number(
+            123
+        ).add_extension(
+            x509.ExtendedKeyUsage([
+                ExtendedKeyUsageOID.CLIENT_AUTH,
+                ExtendedKeyUsageOID.SERVER_AUTH,
+                ExtendedKeyUsageOID.CODE_SIGNING,
+            ]), critical=False
+        ).sign(issuer_private_key, hashes.SHA256(), backend)
+
+        eku = cert.extensions.get_extension_for_oid(
+            ExtensionOID.EXTENDED_KEY_USAGE
+        )
+        assert eku.critical is False
+        assert eku.value == x509.ExtendedKeyUsage([
+            ExtendedKeyUsageOID.CLIENT_AUTH,
+            ExtendedKeyUsageOID.SERVER_AUTH,
+            ExtendedKeyUsageOID.CODE_SIGNING,
+        ])
+
+    @pytest.mark.requires_backend_interface(interface=RSABackend)
+    @pytest.mark.requires_backend_interface(interface=X509Backend)
+    def test_inhibit_any_policy(self, backend):
+        issuer_private_key = RSA_KEY_2048.private_key(backend)
+        subject_private_key = RSA_KEY_2048.private_key(backend)
+
+        not_valid_before = datetime.datetime(2002, 1, 1, 12, 1)
+        not_valid_after = datetime.datetime(2030, 12, 31, 8, 30)
+
+        cert = x509.CertificateBuilder().subject_name(
+            x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, u'US')])
+        ).issuer_name(
+            x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, u'US')])
+        ).not_valid_before(
+            not_valid_before
+        ).not_valid_after(
+            not_valid_after
+        ).public_key(
+            subject_private_key.public_key()
+        ).serial_number(
+            123
+        ).add_extension(
+            x509.InhibitAnyPolicy(3), critical=False
+        ).sign(issuer_private_key, hashes.SHA256(), backend)
+
+        ext = cert.extensions.get_extension_for_oid(
+            ExtensionOID.INHIBIT_ANY_POLICY
+        )
+        assert ext.value == x509.InhibitAnyPolicy(3)
+
+    @pytest.mark.requires_backend_interface(interface=RSABackend)
+    @pytest.mark.requires_backend_interface(interface=X509Backend)
+    def test_key_usage(self, backend):
+        issuer_private_key = RSA_KEY_2048.private_key(backend)
+        subject_private_key = RSA_KEY_2048.private_key(backend)
+
+        not_valid_before = datetime.datetime(2002, 1, 1, 12, 1)
+        not_valid_after = datetime.datetime(2030, 12, 31, 8, 30)
+
+        cert = x509.CertificateBuilder().subject_name(
+            x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, u'US')])
+        ).issuer_name(
+            x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, u'US')])
+        ).not_valid_before(
+            not_valid_before
+        ).not_valid_after(
+            not_valid_after
+        ).public_key(
+            subject_private_key.public_key()
+        ).serial_number(
+            123
+        ).add_extension(
+            x509.KeyUsage(
+                digital_signature=True,
+                content_commitment=True,
+                key_encipherment=False,
+                data_encipherment=False,
+                key_agreement=False,
+                key_cert_sign=True,
+                crl_sign=False,
+                encipher_only=False,
+                decipher_only=False
+            ),
+            critical=False
+        ).sign(issuer_private_key, hashes.SHA256(), backend)
+
+        ext = cert.extensions.get_extension_for_oid(ExtensionOID.KEY_USAGE)
+        assert ext.critical is False
+        assert ext.value == x509.KeyUsage(
+            digital_signature=True,
+            content_commitment=True,
+            key_encipherment=False,
+            data_encipherment=False,
+            key_agreement=False,
+            key_cert_sign=True,
+            crl_sign=False,
+            encipher_only=False,
+            decipher_only=False
+        )
+
+    @pytest.mark.requires_backend_interface(interface=RSABackend)
+    @pytest.mark.requires_backend_interface(interface=X509Backend)
+    def test_build_ca_request_with_path_length_none(self, backend):
+        private_key = RSA_KEY_2048.private_key(backend)
+
+        request = x509.CertificateSigningRequestBuilder().subject_name(
+            x509.Name([
+                x509.NameAttribute(NameOID.ORGANIZATION_NAME,
+                                   u'PyCA'),
+            ])
+        ).add_extension(
+            x509.BasicConstraints(ca=True, path_length=None), critical=True
+        ).sign(private_key, hashes.SHA1(), backend)
+
+        loaded_request = x509.load_pem_x509_csr(
+            request.public_bytes(encoding=serialization.Encoding.PEM), backend
+        )
+        subject = loaded_request.subject
+        assert isinstance(subject, x509.Name)
+        basic_constraints = request.extensions.get_extension_for_oid(
+            ExtensionOID.BASIC_CONSTRAINTS
+        )
+        assert basic_constraints.value.path_length is None
+
+
+@pytest.mark.requires_backend_interface(interface=X509Backend)
+class TestCertificateSigningRequestBuilder(object):
+    @pytest.mark.requires_backend_interface(interface=RSABackend)
+    def test_sign_invalid_hash_algorithm(self, backend):
+        private_key = RSA_KEY_2048.private_key(backend)
+
+        builder = x509.CertificateSigningRequestBuilder().subject_name(
+            x509.Name([])
+        )
+        with pytest.raises(TypeError):
+            builder.sign(private_key, 'NotAHash', backend)
+
+    @pytest.mark.requires_backend_interface(interface=RSABackend)
+    def test_no_subject_name(self, backend):
+        private_key = RSA_KEY_2048.private_key(backend)
+
+        builder = x509.CertificateSigningRequestBuilder()
+        with pytest.raises(ValueError):
+            builder.sign(private_key, hashes.SHA256(), backend)
+
+    @pytest.mark.requires_backend_interface(interface=RSABackend)
+    def test_build_ca_request_with_rsa(self, backend):
+        private_key = RSA_KEY_2048.private_key(backend)
+
+        request = x509.CertificateSigningRequestBuilder().subject_name(
+            x509.Name([
+                x509.NameAttribute(NameOID.ORGANIZATION_NAME, u'PyCA'),
+            ])
+        ).add_extension(
+            x509.BasicConstraints(ca=True, path_length=2), critical=True
+        ).sign(private_key, hashes.SHA1(), backend)
+
+        assert isinstance(request.signature_hash_algorithm, hashes.SHA1)
+        public_key = request.public_key()
+        assert isinstance(public_key, rsa.RSAPublicKey)
+        subject = request.subject
+        assert isinstance(subject, x509.Name)
+        assert list(subject) == [
+            x509.NameAttribute(NameOID.ORGANIZATION_NAME, u'PyCA'),
+        ]
+        basic_constraints = request.extensions.get_extension_for_oid(
+            ExtensionOID.BASIC_CONSTRAINTS
+        )
+        assert basic_constraints.value.ca is True
+        assert basic_constraints.value.path_length == 2
+
+    @pytest.mark.requires_backend_interface(interface=RSABackend)
+    def test_build_ca_request_with_unicode(self, backend):
+        private_key = RSA_KEY_2048.private_key(backend)
+
+        request = x509.CertificateSigningRequestBuilder().subject_name(
+            x509.Name([
+                x509.NameAttribute(NameOID.ORGANIZATION_NAME,
+                                   u'PyCA\U0001f37a'),
+            ])
+        ).add_extension(
+            x509.BasicConstraints(ca=True, path_length=2), critical=True
+        ).sign(private_key, hashes.SHA1(), backend)
+
+        loaded_request = x509.load_pem_x509_csr(
+            request.public_bytes(encoding=serialization.Encoding.PEM), backend
+        )
+        subject = loaded_request.subject
+        assert isinstance(subject, x509.Name)
+        assert list(subject) == [
+            x509.NameAttribute(NameOID.ORGANIZATION_NAME, u'PyCA\U0001f37a'),
+        ]
+
+    @pytest.mark.requires_backend_interface(interface=RSABackend)
+    def test_build_nonca_request_with_rsa(self, backend):
+        private_key = RSA_KEY_2048.private_key(backend)
+
+        request = x509.CertificateSigningRequestBuilder().subject_name(
+            x509.Name([
+                x509.NameAttribute(NameOID.COUNTRY_NAME, u'US'),
+            ])
+        ).add_extension(
+            x509.BasicConstraints(ca=False, path_length=None), critical=True,
+        ).sign(private_key, hashes.SHA1(), backend)
+
+        assert isinstance(request.signature_hash_algorithm, hashes.SHA1)
+        public_key = request.public_key()
+        assert isinstance(public_key, rsa.RSAPublicKey)
+        subject = request.subject
+        assert isinstance(subject, x509.Name)
+        assert list(subject) == [
+            x509.NameAttribute(NameOID.COUNTRY_NAME, u'US'),
+        ]
+        basic_constraints = request.extensions.get_extension_for_oid(
+            ExtensionOID.BASIC_CONSTRAINTS
+        )
+        assert basic_constraints.value.ca is False
+        assert basic_constraints.value.path_length is None
+
+    @pytest.mark.requires_backend_interface(interface=EllipticCurveBackend)
+    def test_build_ca_request_with_ec(self, backend):
+        if backend._lib.OPENSSL_VERSION_NUMBER < 0x10001000:
+            pytest.skip("Requires a newer OpenSSL. Must be >= 1.0.1")
+
+        _skip_curve_unsupported(backend, ec.SECP256R1())
+        private_key = ec.generate_private_key(ec.SECP256R1(), backend)
+
+        request = x509.CertificateSigningRequestBuilder().subject_name(
+            x509.Name([
+                x509.NameAttribute(NameOID.STATE_OR_PROVINCE_NAME, u'Texas'),
+            ])
+        ).add_extension(
+            x509.BasicConstraints(ca=True, path_length=2), critical=True
+        ).sign(private_key, hashes.SHA1(), backend)
+
+        assert isinstance(request.signature_hash_algorithm, hashes.SHA1)
+        public_key = request.public_key()
+        assert isinstance(public_key, ec.EllipticCurvePublicKey)
+        subject = request.subject
+        assert isinstance(subject, x509.Name)
+        assert list(subject) == [
+            x509.NameAttribute(NameOID.STATE_OR_PROVINCE_NAME, u'Texas'),
+        ]
+        basic_constraints = request.extensions.get_extension_for_oid(
+            ExtensionOID.BASIC_CONSTRAINTS
+        )
+        assert basic_constraints.value.ca is True
+        assert basic_constraints.value.path_length == 2
+
+    @pytest.mark.requires_backend_interface(interface=DSABackend)
+    def test_build_ca_request_with_dsa(self, backend):
+        if backend._lib.OPENSSL_VERSION_NUMBER < 0x10001000:
+            pytest.skip("Requires a newer OpenSSL. Must be >= 1.0.1")
+
+        private_key = DSA_KEY_2048.private_key(backend)
+
+        request = x509.CertificateSigningRequestBuilder().subject_name(
+            x509.Name([
+                x509.NameAttribute(NameOID.COUNTRY_NAME, u'US'),
+            ])
+        ).add_extension(
+            x509.BasicConstraints(ca=True, path_length=2), critical=True
+        ).sign(private_key, hashes.SHA1(), backend)
+
+        assert isinstance(request.signature_hash_algorithm, hashes.SHA1)
+        public_key = request.public_key()
+        assert isinstance(public_key, dsa.DSAPublicKey)
+        subject = request.subject
+        assert isinstance(subject, x509.Name)
+        assert list(subject) == [
+            x509.NameAttribute(NameOID.COUNTRY_NAME, u'US'),
+        ]
+        basic_constraints = request.extensions.get_extension_for_oid(
+            ExtensionOID.BASIC_CONSTRAINTS
+        )
+        assert basic_constraints.value.ca is True
+        assert basic_constraints.value.path_length == 2
+
+    def test_add_duplicate_extension(self):
+        builder = x509.CertificateSigningRequestBuilder().add_extension(
+            x509.BasicConstraints(True, 2), critical=True,
+        )
+        with pytest.raises(ValueError):
+            builder.add_extension(
+                x509.BasicConstraints(True, 2), critical=True,
+            )
+
+    def test_set_invalid_subject(self):
+        builder = x509.CertificateSigningRequestBuilder()
+        with pytest.raises(TypeError):
+            builder.subject_name('NotAName')
+
+    def test_add_invalid_extension_type(self):
+        builder = x509.CertificateSigningRequestBuilder()
+
+        with pytest.raises(TypeError):
+            builder.add_extension(object(), False)
+
+    def test_add_unsupported_extension(self, backend):
+        private_key = RSA_KEY_2048.private_key(backend)
+        builder = x509.CertificateSigningRequestBuilder()
+        builder = builder.subject_name(
+            x509.Name([
+                x509.NameAttribute(NameOID.COUNTRY_NAME, u'US'),
+            ])
+        ).add_extension(
+            x509.SubjectAlternativeName([x509.DNSName(u"cryptography.io")]),
+            critical=False,
+        ).add_extension(
+            DummyExtension(), False
+        )
+        with pytest.raises(NotImplementedError):
+            builder.sign(private_key, hashes.SHA256(), backend)
+
+    def test_key_usage(self, backend):
+        private_key = RSA_KEY_2048.private_key(backend)
+        builder = x509.CertificateSigningRequestBuilder()
+        request = builder.subject_name(
+            x509.Name([
+                x509.NameAttribute(NameOID.COUNTRY_NAME, u'US'),
+            ])
+        ).add_extension(
+            x509.KeyUsage(
+                digital_signature=True,
+                content_commitment=True,
+                key_encipherment=False,
+                data_encipherment=False,
+                key_agreement=False,
+                key_cert_sign=True,
+                crl_sign=False,
+                encipher_only=False,
+                decipher_only=False
+            ),
+            critical=False
+        ).sign(private_key, hashes.SHA256(), backend)
+        assert len(request.extensions) == 1
+        ext = request.extensions.get_extension_for_oid(ExtensionOID.KEY_USAGE)
+        assert ext.critical is False
+        assert ext.value == x509.KeyUsage(
+            digital_signature=True,
+            content_commitment=True,
+            key_encipherment=False,
+            data_encipherment=False,
+            key_agreement=False,
+            key_cert_sign=True,
+            crl_sign=False,
+            encipher_only=False,
+            decipher_only=False
+        )
+
+    def test_key_usage_key_agreement_bit(self, backend):
+        private_key = RSA_KEY_2048.private_key(backend)
+        builder = x509.CertificateSigningRequestBuilder()
+        request = builder.subject_name(
+            x509.Name([
+                x509.NameAttribute(NameOID.COUNTRY_NAME, u'US'),
+            ])
+        ).add_extension(
+            x509.KeyUsage(
+                digital_signature=False,
+                content_commitment=False,
+                key_encipherment=False,
+                data_encipherment=False,
+                key_agreement=True,
+                key_cert_sign=True,
+                crl_sign=False,
+                encipher_only=False,
+                decipher_only=True
+            ),
+            critical=False
+        ).sign(private_key, hashes.SHA256(), backend)
+        assert len(request.extensions) == 1
+        ext = request.extensions.get_extension_for_oid(ExtensionOID.KEY_USAGE)
+        assert ext.critical is False
+        assert ext.value == x509.KeyUsage(
+            digital_signature=False,
+            content_commitment=False,
+            key_encipherment=False,
+            data_encipherment=False,
+            key_agreement=True,
+            key_cert_sign=True,
+            crl_sign=False,
+            encipher_only=False,
+            decipher_only=True
+        )
+
+    def test_add_two_extensions(self, backend):
+        private_key = RSA_KEY_2048.private_key(backend)
+        builder = x509.CertificateSigningRequestBuilder()
+        request = builder.subject_name(
+            x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, u'US')])
+        ).add_extension(
+            x509.SubjectAlternativeName([x509.DNSName(u"cryptography.io")]),
+            critical=False,
+        ).add_extension(
+            x509.BasicConstraints(ca=True, path_length=2), critical=True
+        ).sign(private_key, hashes.SHA1(), backend)
+
+        assert isinstance(request.signature_hash_algorithm, hashes.SHA1)
+        public_key = request.public_key()
+        assert isinstance(public_key, rsa.RSAPublicKey)
+        basic_constraints = request.extensions.get_extension_for_oid(
+            ExtensionOID.BASIC_CONSTRAINTS
+        )
+        assert basic_constraints.value.ca is True
+        assert basic_constraints.value.path_length == 2
+        ext = request.extensions.get_extension_for_oid(
+            ExtensionOID.SUBJECT_ALTERNATIVE_NAME
+        )
+        assert list(ext.value) == [x509.DNSName(u"cryptography.io")]
+
+    def test_set_subject_twice(self):
+        builder = x509.CertificateSigningRequestBuilder()
+        builder = builder.subject_name(
+            x509.Name([
+                x509.NameAttribute(NameOID.COUNTRY_NAME, u'US'),
+            ])
+        )
+        with pytest.raises(ValueError):
+            builder.subject_name(
+                x509.Name([
+                    x509.NameAttribute(NameOID.COUNTRY_NAME, u'US'),
+                ])
+            )
+
+    def test_subject_alt_names(self, backend):
+        private_key = RSA_KEY_2048.private_key(backend)
+
+        csr = x509.CertificateSigningRequestBuilder().subject_name(
+            x509.Name([
+                x509.NameAttribute(NameOID.COMMON_NAME, u"SAN"),
+            ])
+        ).add_extension(
+            x509.SubjectAlternativeName([
+                x509.DNSName(u"example.com"),
+                x509.DNSName(u"*.example.com"),
+                x509.RegisteredID(x509.ObjectIdentifier("1.2.3.4.5.6.7")),
+                x509.DirectoryName(x509.Name([
+                    x509.NameAttribute(NameOID.COMMON_NAME, u'PyCA'),
+                    x509.NameAttribute(
+                        NameOID.ORGANIZATION_NAME, u'We heart UTF8!\u2122'
+                    )
+                ])),
+                x509.IPAddress(ipaddress.ip_address(u"127.0.0.1")),
+                x509.IPAddress(ipaddress.ip_address(u"ff::")),
+                x509.OtherName(
+                    type_id=x509.ObjectIdentifier("1.2.3.3.3.3"),
+                    value=b"0\x03\x02\x01\x05"
+                ),
+                x509.RFC822Name(u"test@example.com"),
+                x509.RFC822Name(u"email"),
+                x509.RFC822Name(u"email@em\xe5\xefl.com"),
+                x509.UniformResourceIdentifier(
+                    u"https://\u043f\u044b\u043a\u0430.cryptography"
+                ),
+                x509.UniformResourceIdentifier(
+                    u"gopher://cryptography:70/some/path"
+                ),
+            ]),
+            critical=False,
+        ).sign(private_key, hashes.SHA256(), backend)
+
+        assert len(csr.extensions) == 1
+        ext = csr.extensions.get_extension_for_oid(
+            ExtensionOID.SUBJECT_ALTERNATIVE_NAME
+        )
+        assert not ext.critical
+        assert ext.oid == ExtensionOID.SUBJECT_ALTERNATIVE_NAME
+        assert list(ext.value) == [
+            x509.DNSName(u"example.com"),
+            x509.DNSName(u"*.example.com"),
+            x509.RegisteredID(x509.ObjectIdentifier("1.2.3.4.5.6.7")),
+            x509.DirectoryName(x509.Name([
+                x509.NameAttribute(NameOID.COMMON_NAME, u'PyCA'),
+                x509.NameAttribute(
+                    NameOID.ORGANIZATION_NAME, u'We heart UTF8!\u2122'
+                ),
+            ])),
+            x509.IPAddress(ipaddress.ip_address(u"127.0.0.1")),
+            x509.IPAddress(ipaddress.ip_address(u"ff::")),
+            x509.OtherName(
+                type_id=x509.ObjectIdentifier("1.2.3.3.3.3"),
+                value=b"0\x03\x02\x01\x05"
+            ),
+            x509.RFC822Name(u"test@example.com"),
+            x509.RFC822Name(u"email"),
+            x509.RFC822Name(u"email@em\xe5\xefl.com"),
+            x509.UniformResourceIdentifier(
+                u"https://\u043f\u044b\u043a\u0430.cryptography"
+            ),
+            x509.UniformResourceIdentifier(
+                u"gopher://cryptography:70/some/path"
+            ),
+        ]
+
+    def test_invalid_asn1_othername(self, backend):
+        private_key = RSA_KEY_2048.private_key(backend)
+
+        builder = x509.CertificateSigningRequestBuilder().subject_name(
+            x509.Name([
+                x509.NameAttribute(NameOID.COMMON_NAME, u"SAN"),
+            ])
+        ).add_extension(
+            x509.SubjectAlternativeName([
+                x509.OtherName(
+                    type_id=x509.ObjectIdentifier("1.2.3.3.3.3"),
+                    value=b"\x01\x02\x01\x05"
+                ),
+            ]),
+            critical=False,
+        )
+        with pytest.raises(ValueError):
+            builder.sign(private_key, hashes.SHA256(), backend)
+
+    def test_subject_alt_name_unsupported_general_name(self, backend):
+        private_key = RSA_KEY_2048.private_key(backend)
+
+        builder = x509.CertificateSigningRequestBuilder().subject_name(
+            x509.Name([
+                x509.NameAttribute(NameOID.COMMON_NAME, u"SAN"),
+            ])
+        ).add_extension(
+            x509.SubjectAlternativeName([FakeGeneralName("")]),
+            critical=False,
+        )
+
+        with pytest.raises(ValueError):
+            builder.sign(private_key, hashes.SHA256(), backend)
+
+    def test_extended_key_usage(self, backend):
+        private_key = RSA_KEY_2048.private_key(backend)
+        builder = x509.CertificateSigningRequestBuilder()
+        request = builder.subject_name(
+            x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, u'US')])
+        ).add_extension(
+            x509.ExtendedKeyUsage([
+                ExtendedKeyUsageOID.CLIENT_AUTH,
+                ExtendedKeyUsageOID.SERVER_AUTH,
+                ExtendedKeyUsageOID.CODE_SIGNING,
+            ]), critical=False
+        ).sign(private_key, hashes.SHA256(), backend)
+
+        eku = request.extensions.get_extension_for_oid(
+            ExtensionOID.EXTENDED_KEY_USAGE
+        )
+        assert eku.critical is False
+        assert eku.value == x509.ExtendedKeyUsage([
+            ExtendedKeyUsageOID.CLIENT_AUTH,
+            ExtendedKeyUsageOID.SERVER_AUTH,
+            ExtendedKeyUsageOID.CODE_SIGNING,
+        ])
+
+    @pytest.mark.requires_backend_interface(interface=RSABackend)
+    def test_rsa_key_too_small(self, backend):
+        private_key = rsa.generate_private_key(65537, 512, backend)
+        builder = x509.CertificateSigningRequestBuilder()
+        builder = builder.subject_name(
+            x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, u'US')])
+        )
+
+        with pytest.raises(ValueError) as exc:
+            builder.sign(private_key, hashes.SHA512(), backend)
+
+        assert str(exc.value) == "Digest too big for RSA key"
+
+    @pytest.mark.requires_backend_interface(interface=RSABackend)
+    @pytest.mark.requires_backend_interface(interface=X509Backend)
+    def test_build_cert_with_aia(self, backend):
+        issuer_private_key = RSA_KEY_2048.private_key(backend)
+        subject_private_key = RSA_KEY_2048.private_key(backend)
+
+        not_valid_before = datetime.datetime(2002, 1, 1, 12, 1)
+        not_valid_after = datetime.datetime(2030, 12, 31, 8, 30)
+
+        aia = x509.AuthorityInformationAccess([
+            x509.AccessDescription(
+                AuthorityInformationAccessOID.OCSP,
+                x509.UniformResourceIdentifier(u"http://ocsp.domain.com")
+            ),
+            x509.AccessDescription(
+                AuthorityInformationAccessOID.CA_ISSUERS,
+                x509.UniformResourceIdentifier(u"http://domain.com/ca.crt")
+            )
+        ])
+
+        builder = x509.CertificateBuilder().serial_number(
+            777
+        ).issuer_name(x509.Name([
+            x509.NameAttribute(NameOID.COUNTRY_NAME, u'US'),
+        ])).subject_name(x509.Name([
+            x509.NameAttribute(NameOID.COUNTRY_NAME, u'US'),
+        ])).public_key(
+            subject_private_key.public_key()
+        ).add_extension(
+            aia, critical=False
+        ).not_valid_before(
+            not_valid_before
+        ).not_valid_after(
+            not_valid_after
+        )
+
+        cert = builder.sign(issuer_private_key, hashes.SHA1(), backend)
+
+        ext = cert.extensions.get_extension_for_oid(
+            ExtensionOID.AUTHORITY_INFORMATION_ACCESS
+        )
+        assert ext.value == aia
+
+    @pytest.mark.requires_backend_interface(interface=RSABackend)
+    @pytest.mark.requires_backend_interface(interface=X509Backend)
+    def test_build_cert_with_ski(self, backend):
+        issuer_private_key = RSA_KEY_2048.private_key(backend)
+        subject_private_key = RSA_KEY_2048.private_key(backend)
+
+        not_valid_before = datetime.datetime(2002, 1, 1, 12, 1)
+        not_valid_after = datetime.datetime(2030, 12, 31, 8, 30)
+
+        ski = x509.SubjectKeyIdentifier.from_public_key(
+            subject_private_key.public_key()
+        )
+
+        builder = x509.CertificateBuilder().serial_number(
+            777
+        ).issuer_name(x509.Name([
+            x509.NameAttribute(NameOID.COUNTRY_NAME, u'US'),
+        ])).subject_name(x509.Name([
+            x509.NameAttribute(NameOID.COUNTRY_NAME, u'US'),
+        ])).public_key(
+            subject_private_key.public_key()
+        ).add_extension(
+            ski, critical=False
+        ).not_valid_before(
+            not_valid_before
+        ).not_valid_after(
+            not_valid_after
+        )
+
+        cert = builder.sign(issuer_private_key, hashes.SHA1(), backend)
+
+        ext = cert.extensions.get_extension_for_oid(
+            ExtensionOID.SUBJECT_KEY_IDENTIFIER
+        )
+        assert ext.value == ski
+
+    @pytest.mark.parametrize(
+        "aki",
+        [
+            x509.AuthorityKeyIdentifier(
+                b"\xc3\x9c\xf3\xfc\xd3F\x084\xbb\xceF\x7f\xa0|[\xf3\xe2\x08"
+                b"\xcbY",
+                None,
+                None
+            ),
+            x509.AuthorityKeyIdentifier(
+                b"\xc3\x9c\xf3\xfc\xd3F\x084\xbb\xceF\x7f\xa0|[\xf3\xe2\x08"
+                b"\xcbY",
+                [
+                    x509.DirectoryName(
+                        x509.Name([
+                            x509.NameAttribute(
+                                NameOID.ORGANIZATION_NAME, u"PyCA"
+                            ),
+                            x509.NameAttribute(
+                                NameOID.COMMON_NAME, u"cryptography CA"
+                            )
+                        ])
+                    )
+                ],
+                333
+            ),
+            x509.AuthorityKeyIdentifier(
+                None,
+                [
+                    x509.DirectoryName(
+                        x509.Name([
+                            x509.NameAttribute(
+                                NameOID.ORGANIZATION_NAME, u"PyCA"
+                            ),
+                            x509.NameAttribute(
+                                NameOID.COMMON_NAME, u"cryptography CA"
+                            )
+                        ])
+                    )
+                ],
+                333
+            ),
+        ]
+    )
+    @pytest.mark.requires_backend_interface(interface=RSABackend)
+    @pytest.mark.requires_backend_interface(interface=X509Backend)
+    def test_build_cert_with_aki(self, aki, backend):
+        issuer_private_key = RSA_KEY_2048.private_key(backend)
+        subject_private_key = RSA_KEY_2048.private_key(backend)
+
+        not_valid_before = datetime.datetime(2002, 1, 1, 12, 1)
+        not_valid_after = datetime.datetime(2030, 12, 31, 8, 30)
+
+        builder = x509.CertificateBuilder().serial_number(
+            777
+        ).issuer_name(x509.Name([
+            x509.NameAttribute(NameOID.COUNTRY_NAME, u'US'),
+        ])).subject_name(x509.Name([
+            x509.NameAttribute(NameOID.COUNTRY_NAME, u'US'),
+        ])).public_key(
+            subject_private_key.public_key()
+        ).add_extension(
+            aki, critical=False
+        ).not_valid_before(
+            not_valid_before
+        ).not_valid_after(
+            not_valid_after
+        )
+
+        cert = builder.sign(issuer_private_key, hashes.SHA256(), backend)
+
+        ext = cert.extensions.get_extension_for_oid(
+            ExtensionOID.AUTHORITY_KEY_IDENTIFIER
+        )
+        assert ext.value == aki
+
+    def test_ocsp_nocheck(self, backend):
+        issuer_private_key = RSA_KEY_2048.private_key(backend)
+        subject_private_key = RSA_KEY_2048.private_key(backend)
+
+        not_valid_before = datetime.datetime(2002, 1, 1, 12, 1)
+        not_valid_after = datetime.datetime(2030, 12, 31, 8, 30)
+
+        builder = x509.CertificateBuilder().serial_number(
+            777
+        ).issuer_name(x509.Name([
+            x509.NameAttribute(NameOID.COUNTRY_NAME, u'US'),
+        ])).subject_name(x509.Name([
+            x509.NameAttribute(NameOID.COUNTRY_NAME, u'US'),
+        ])).public_key(
+            subject_private_key.public_key()
+        ).add_extension(
+            x509.OCSPNoCheck(), critical=False
+        ).not_valid_before(
+            not_valid_before
+        ).not_valid_after(
+            not_valid_after
+        )
+
+        cert = builder.sign(issuer_private_key, hashes.SHA256(), backend)
+
+        ext = cert.extensions.get_extension_for_oid(
+            ExtensionOID.OCSP_NO_CHECK
+        )
+        assert isinstance(ext.value, x509.OCSPNoCheck)
+
+
+@pytest.mark.requires_backend_interface(interface=DSABackend)
+@pytest.mark.requires_backend_interface(interface=X509Backend)
+class TestDSACertificate(object):
+    def test_load_dsa_cert(self, backend):
+        cert = _load_cert(
+            os.path.join("x509", "custom", "dsa_selfsigned_ca.pem"),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+        assert isinstance(cert.signature_hash_algorithm, hashes.SHA1)
+        public_key = cert.public_key()
+        assert isinstance(public_key, dsa.DSAPublicKey)
+        num = public_key.public_numbers()
+        assert num.y == int(
+            "4c08bfe5f2d76649c80acf7d431f6ae2124b217abc8c9f6aca776ddfa94"
+            "53b6656f13e543684cd5f6431a314377d2abfa068b7080cb8ddc065afc2"
+            "dea559f0b584c97a2b235b9b69b46bc6de1aed422a6f341832618bcaae2"
+            "198aba388099dafb05ff0b5efecb3b0ae169a62e1c72022af50ae68af3b"
+            "033c18e6eec1f7df4692c456ccafb79cc7e08da0a5786e9816ceda651d6"
+            "1b4bb7b81c2783da97cea62df67af5e85991fdc13aff10fc60e06586386"
+            "b96bb78d65750f542f86951e05a6d81baadbcd35a2e5cad4119923ae6a2"
+            "002091a3d17017f93c52970113cdc119970b9074ca506eac91c3dd37632"
+            "5df4af6b3911ef267d26623a5a1c5df4a6d13f1c", 16
+        )
+        assert num.parameter_numbers.g == int(
+            "4b7ced71dc353965ecc10d441a9a06fc24943a32d66429dd5ef44d43e67"
+            "d789d99770aec32c0415dc92970880872da45fef8dd1e115a3e4801387b"
+            "a6d755861f062fd3b6e9ea8e2641152339b828315b1528ee6c7b79458d2"
+            "1f3db973f6fc303f9397174c2799dd2351282aa2d8842c357a73495bbaa"
+            "c4932786414c55e60d73169f5761036fba29e9eebfb049f8a3b1b7cee6f"
+            "3fbfa136205f130bee2cf5b9c38dc1095d4006f2e73335c07352c64130a"
+            "1ab2b89f13b48f628d3cc3868beece9bb7beade9f830eacc6fa241425c0"
+            "b3fcc0df416a0c89f7bf35668d765ec95cdcfbe9caff49cfc156c668c76"
+            "fa6247676a6d3ac945844a083509c6a1b436baca", 16
+        )
+        assert num.parameter_numbers.p == int(
+            "bfade6048e373cd4e48b677e878c8e5b08c02102ae04eb2cb5c46a523a3"
+            "af1c73d16b24f34a4964781ae7e50500e21777754a670bd19a7420d6330"
+            "84e5556e33ca2c0e7d547ea5f46a07a01bf8669ae3bdec042d9b2ae5e6e"
+            "cf49f00ba9dac99ab6eff140d2cedf722ee62c2f9736857971444c25d0a"
+            "33d2017dc36d682a1054fe2a9428dda355a851ce6e6d61e03e419fd4ca4"
+            "e703313743d86caa885930f62ed5bf342d8165627681e9cc3244ba72aa2"
+            "2148400a6bbe80154e855d042c9dc2a3405f1e517be9dea50562f56da93"
+            "f6085f844a7e705c1f043e65751c583b80d29103e590ccb26efdaa0893d"
+            "833e36468f3907cfca788a3cb790f0341c8a31bf", 16
+        )
+        assert num.parameter_numbers.q == int(
+            "822ff5d234e073b901cf5941f58e1f538e71d40d", 16
+        )
+
+    @pytest.mark.parametrize(
+        ("path", "loader_func"),
+        [
+            [
+                os.path.join("x509", "requests", "dsa_sha1.pem"),
+                x509.load_pem_x509_csr
+            ],
+            [
+                os.path.join("x509", "requests", "dsa_sha1.der"),
+                x509.load_der_x509_csr
+            ],
+        ]
+    )
+    def test_load_dsa_request(self, path, loader_func, backend):
+        request = _load_cert(path, loader_func, backend)
+        assert isinstance(request.signature_hash_algorithm, hashes.SHA1)
+        public_key = request.public_key()
+        assert isinstance(public_key, dsa.DSAPublicKey)
+        subject = request.subject
+        assert isinstance(subject, x509.Name)
+        assert list(subject) == [
+            x509.NameAttribute(NameOID.COMMON_NAME, u'cryptography.io'),
+            x509.NameAttribute(NameOID.ORGANIZATION_NAME, u'PyCA'),
+            x509.NameAttribute(NameOID.COUNTRY_NAME, u'US'),
+            x509.NameAttribute(NameOID.STATE_OR_PROVINCE_NAME, u'Texas'),
+            x509.NameAttribute(NameOID.LOCALITY_NAME, u'Austin'),
+        ]
+
+
+@pytest.mark.requires_backend_interface(interface=EllipticCurveBackend)
+@pytest.mark.requires_backend_interface(interface=X509Backend)
+class TestECDSACertificate(object):
+    def test_load_ecdsa_cert(self, backend):
+        _skip_curve_unsupported(backend, ec.SECP384R1())
+        cert = _load_cert(
+            os.path.join("x509", "ecdsa_root.pem"),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+        assert isinstance(cert.signature_hash_algorithm, hashes.SHA384)
+        public_key = cert.public_key()
+        assert isinstance(public_key, ec.EllipticCurvePublicKey)
+        num = public_key.public_numbers()
+        assert num.x == int(
+            "dda7d9bb8ab80bfb0b7f21d2f0bebe73f3335d1abc34eadec69bbcd095f"
+            "6f0ccd00bba615b51467e9e2d9fee8e630c17", 16
+        )
+        assert num.y == int(
+            "ec0770f5cf842e40839ce83f416d3badd3a4145936789d0343ee10136c7"
+            "2deae88a7a16bb543ce67dc23ff031ca3e23e", 16
+        )
+        assert isinstance(num.curve, ec.SECP384R1)
+
+    def test_load_ecdsa_no_named_curve(self, backend):
+        _skip_curve_unsupported(backend, ec.SECP256R1())
+        cert = _load_cert(
+            os.path.join("x509", "custom", "ec_no_named_curve.pem"),
+            x509.load_pem_x509_certificate,
+            backend
+        )
+        with pytest.raises(NotImplementedError):
+            cert.public_key()
+
+    @pytest.mark.parametrize(
+        ("path", "loader_func"),
+        [
+            [
+                os.path.join("x509", "requests", "ec_sha256.pem"),
+                x509.load_pem_x509_csr
+            ],
+            [
+                os.path.join("x509", "requests", "ec_sha256.der"),
+                x509.load_der_x509_csr
+            ],
+        ]
+    )
+    def test_load_ecdsa_certificate_request(self, path, loader_func, backend):
+        _skip_curve_unsupported(backend, ec.SECP384R1())
+        request = _load_cert(path, loader_func, backend)
+        assert isinstance(request.signature_hash_algorithm, hashes.SHA256)
+        public_key = request.public_key()
+        assert isinstance(public_key, ec.EllipticCurvePublicKey)
+        subject = request.subject
+        assert isinstance(subject, x509.Name)
+        assert list(subject) == [
+            x509.NameAttribute(NameOID.COMMON_NAME, u'cryptography.io'),
+            x509.NameAttribute(NameOID.ORGANIZATION_NAME, u'PyCA'),
+            x509.NameAttribute(NameOID.COUNTRY_NAME, u'US'),
+            x509.NameAttribute(NameOID.STATE_OR_PROVINCE_NAME, u'Texas'),
+            x509.NameAttribute(NameOID.LOCALITY_NAME, u'Austin'),
+        ]
+
+
+@pytest.mark.requires_backend_interface(interface=X509Backend)
+class TestOtherCertificate(object):
+    def test_unsupported_subject_public_key_info(self, backend):
+        cert = _load_cert(
+            os.path.join(
+                "x509", "custom", "unsupported_subject_public_key_info.pem"
+            ),
+            x509.load_pem_x509_certificate,
+            backend,
+        )
+
+        with pytest.raises(ValueError):
+            cert.public_key()
+
+
+class TestNameAttribute(object):
+    def test_init_bad_oid(self):
+        with pytest.raises(TypeError):
+            x509.NameAttribute(None, u'value')
+
+    def test_init_bad_value(self):
+        with pytest.raises(TypeError):
+            x509.NameAttribute(
+                x509.ObjectIdentifier('oid'),
+                b'bytes'
+            )
+
+    def test_eq(self):
+        assert x509.NameAttribute(
+            x509.ObjectIdentifier('oid'), u'value'
+        ) == x509.NameAttribute(
+            x509.ObjectIdentifier('oid'), u'value'
+        )
+
+    def test_ne(self):
+        assert x509.NameAttribute(
+            x509.ObjectIdentifier('2.5.4.3'), u'value'
+        ) != x509.NameAttribute(
+            x509.ObjectIdentifier('2.5.4.5'), u'value'
+        )
+        assert x509.NameAttribute(
+            x509.ObjectIdentifier('oid'), u'value'
+        ) != x509.NameAttribute(
+            x509.ObjectIdentifier('oid'), u'value2'
+        )
+        assert x509.NameAttribute(
+            x509.ObjectIdentifier('oid'), u'value'
+        ) != object()
+
+    def test_repr(self):
+        na = x509.NameAttribute(x509.ObjectIdentifier('2.5.4.3'), u'value')
+        if six.PY3:
+            assert repr(na) == (
+                "<NameAttribute(oid=<ObjectIdentifier(oid=2.5.4.3, name=commo"
+                "nName)>, value='value')>"
+            )
+        else:
+            assert repr(na) == (
+                "<NameAttribute(oid=<ObjectIdentifier(oid=2.5.4.3, name=commo"
+                "nName)>, value=u'value')>"
+            )
+
+
+class TestObjectIdentifier(object):
+    def test_eq(self):
+        oid1 = x509.ObjectIdentifier('oid')
+        oid2 = x509.ObjectIdentifier('oid')
+        assert oid1 == oid2
+
+    def test_ne(self):
+        oid1 = x509.ObjectIdentifier('oid')
+        assert oid1 != x509.ObjectIdentifier('oid1')
+        assert oid1 != object()
+
+    def test_repr(self):
+        oid = x509.ObjectIdentifier("2.5.4.3")
+        assert repr(oid) == "<ObjectIdentifier(oid=2.5.4.3, name=commonName)>"
+        oid = x509.ObjectIdentifier("oid1")
+        assert repr(oid) == "<ObjectIdentifier(oid=oid1, name=Unknown OID)>"
+
+    def test_name_property(self):
+        oid = x509.ObjectIdentifier("2.5.4.3")
+        assert oid._name == 'commonName'
+        oid = x509.ObjectIdentifier("oid1")
+        assert oid._name == 'Unknown OID'
+
+
+class TestName(object):
+    def test_eq(self):
+        name1 = x509.Name([
+            x509.NameAttribute(x509.ObjectIdentifier('oid'), u'value1'),
+            x509.NameAttribute(x509.ObjectIdentifier('oid2'), u'value2'),
+        ])
+        name2 = x509.Name([
+            x509.NameAttribute(x509.ObjectIdentifier('oid'), u'value1'),
+            x509.NameAttribute(x509.ObjectIdentifier('oid2'), u'value2'),
+        ])
+        assert name1 == name2
+
+    def test_ne(self):
+        name1 = x509.Name([
+            x509.NameAttribute(x509.ObjectIdentifier('oid'), u'value1'),
+            x509.NameAttribute(x509.ObjectIdentifier('oid2'), u'value2'),
+        ])
+        name2 = x509.Name([
+            x509.NameAttribute(x509.ObjectIdentifier('oid2'), u'value2'),
+            x509.NameAttribute(x509.ObjectIdentifier('oid'), u'value1'),
+        ])
+        assert name1 != name2
+        assert name1 != object()
+
+    def test_hash(self):
+        name1 = x509.Name([
+            x509.NameAttribute(x509.ObjectIdentifier('oid'), u'value1'),
+            x509.NameAttribute(x509.ObjectIdentifier('oid2'), u'value2'),
+        ])
+        name2 = x509.Name([
+            x509.NameAttribute(x509.ObjectIdentifier('oid'), u'value1'),
+            x509.NameAttribute(x509.ObjectIdentifier('oid2'), u'value2'),
+        ])
+        name3 = x509.Name([
+            x509.NameAttribute(x509.ObjectIdentifier('oid2'), u'value2'),
+            x509.NameAttribute(x509.ObjectIdentifier('oid'), u'value1'),
+        ])
+
+        assert hash(name1) == hash(name2)
+        assert hash(name1) != hash(name3)
+
+    def test_repr(self):
+        name = x509.Name([
+            x509.NameAttribute(NameOID.COMMON_NAME, u'cryptography.io'),
+            x509.NameAttribute(NameOID.ORGANIZATION_NAME, u'PyCA'),
+        ])
+
+        if six.PY3:
+            assert repr(name) == (
+                "<Name([<NameAttribute(oid=<ObjectIdentifier(oid=2.5.4.3, name"
+                "=commonName)>, value='cryptography.io')>, <NameAttribute(oid="
+                "<ObjectIdentifier(oid=2.5.4.10, name=organizationName)>, valu"
+                "e='PyCA')>])>"
+            )
+        else:
+            assert repr(name) == (
+                "<Name([<NameAttribute(oid=<ObjectIdentifier(oid=2.5.4.3, name"
+                "=commonName)>, value=u'cryptography.io')>, <NameAttribute(oid"
+                "=<ObjectIdentifier(oid=2.5.4.10, name=organizationName)>, val"
+                "ue=u'PyCA')>])>"
+            )
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/utils.py hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/utils.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/cryptography-1.1.1/tests/utils.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/cryptography-1.1.1/tests/utils.py	2015-11-19 05:01:35.000000000 +0100
@@ -0,0 +1,811 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+from __future__ import absolute_import, division, print_function
+
+import binascii
+import collections
+import math
+import re
+from contextlib import contextmanager
+
+import pytest
+
+import six
+
+from cryptography.exceptions import UnsupportedAlgorithm
+
+import cryptography_vectors
+
+
+HashVector = collections.namedtuple("HashVector", ["message", "digest"])
+KeyedHashVector = collections.namedtuple(
+    "KeyedHashVector", ["message", "digest", "key"]
+)
+
+
+def select_backends(names, backend_list):
+    if names is None:
+        return backend_list
+    split_names = [x.strip() for x in names.split(',')]
+    selected_backends = []
+    for backend in backend_list:
+        if backend.name in split_names:
+            selected_backends.append(backend)
+
+    if len(selected_backends) > 0:
+        return selected_backends
+    else:
+        raise ValueError(
+            "No backend selected. Tried to select: {0}".format(split_names)
+        )
+
+
+def skip_if_empty(backend_list, required_interfaces):
+    if not backend_list:
+        pytest.skip(
+            "No backends provided supply the interface: {0}".format(
+                ", ".join(iface.__name__ for iface in required_interfaces)
+            )
+        )
+
+
+def check_backend_support(item):
+    supported = item.keywords.get("supported")
+    if supported and "backend" in item.funcargs:
+        for mark in supported:
+            if not mark.kwargs["only_if"](item.funcargs["backend"]):
+                pytest.skip("{0} ({1})".format(
+                    mark.kwargs["skip_message"], item.funcargs["backend"]
+                ))
+    elif supported:
+        raise ValueError("This mark is only available on methods that take a "
+                         "backend")
+
+
+@contextmanager
+def raises_unsupported_algorithm(reason):
+    with pytest.raises(UnsupportedAlgorithm) as exc_info:
+        yield exc_info
+
+    assert exc_info.value._reason is reason
+
+
+def load_vectors_from_file(filename, loader, mode="r"):
+    with cryptography_vectors.open_vector_file(filename, mode) as vector_file:
+        return loader(vector_file)
+
+
+def load_nist_vectors(vector_data):
+    test_data = None
+    data = []
+
+    for line in vector_data:
+        line = line.strip()
+
+        # Blank lines, comments, and section headers are ignored
+        if not line or line.startswith("#") or (line.startswith("[") and
+                                                line.endswith("]")):
+            continue
+
+        if line.strip() == "FAIL":
+            test_data["fail"] = True
+            continue
+
+        # Build our data using a simple Key = Value format
+        name, value = [c.strip() for c in line.split("=")]
+
+        # Some tests (PBKDF2) contain \0, which should be interpreted as a
+        # null character rather than literal.
+        value = value.replace("\\0", "\0")
+
+        # COUNT is a special token that indicates a new block of data
+        if name.upper() == "COUNT":
+            test_data = {}
+            data.append(test_data)
+            continue
+        # For all other tokens we simply want the name, value stored in
+        # the dictionary
+        else:
+            test_data[name.lower()] = value.encode("ascii")
+
+    return data
+
+
+def load_cryptrec_vectors(vector_data):
+    cryptrec_list = []
+
+    for line in vector_data:
+        line = line.strip()
+
+        # Blank lines and comments are ignored
+        if not line or line.startswith("#"):
+            continue
+
+        if line.startswith("K"):
+            key = line.split(" : ")[1].replace(" ", "").encode("ascii")
+        elif line.startswith("P"):
+            pt = line.split(" : ")[1].replace(" ", "").encode("ascii")
+        elif line.startswith("C"):
+            ct = line.split(" : ")[1].replace(" ", "").encode("ascii")
+            # after a C is found the K+P+C tuple is complete
+            # there are many P+C pairs for each K
+            cryptrec_list.append({
+                "key": key,
+                "plaintext": pt,
+                "ciphertext": ct
+            })
+        else:
+            raise ValueError("Invalid line in file '{}'".format(line))
+    return cryptrec_list
+
+
+def load_hash_vectors(vector_data):
+    vectors = []
+    key = None
+    msg = None
+    md = None
+
+    for line in vector_data:
+        line = line.strip()
+
+        if not line or line.startswith("#") or line.startswith("["):
+            continue
+
+        if line.startswith("Len"):
+            length = int(line.split(" = ")[1])
+        elif line.startswith("Key"):
+            # HMAC vectors contain a key attribute. Hash vectors do not.
+            key = line.split(" = ")[1].encode("ascii")
+        elif line.startswith("Msg"):
+            # In the NIST vectors they have chosen to represent an empty
+            # string as hex 00, which is of course not actually an empty
+            # string. So we parse the provided length and catch this edge case.
+            msg = line.split(" = ")[1].encode("ascii") if length > 0 else b""
+        elif line.startswith("MD"):
+            md = line.split(" = ")[1]
+            # after MD is found the Msg+MD (+ potential key) tuple is complete
+            if key is not None:
+                vectors.append(KeyedHashVector(msg, md, key))
+                key = None
+                msg = None
+                md = None
+            else:
+                vectors.append(HashVector(msg, md))
+                msg = None
+                md = None
+        else:
+            raise ValueError("Unknown line in hash vector")
+    return vectors
+
+
+def load_pkcs1_vectors(vector_data):
+    """
+    Loads data out of RSA PKCS #1 vector files.
+    """
+    private_key_vector = None
+    public_key_vector = None
+    attr = None
+    key = None
+    example_vector = None
+    examples = []
+    vectors = []
+    for line in vector_data:
+        if (
+            line.startswith("# PSS Example") or
+            line.startswith("# OAEP Example") or
+            line.startswith("# PKCS#1 v1.5")
+        ):
+            if example_vector:
+                for key, value in six.iteritems(example_vector):
+                    hex_str = "".join(value).replace(" ", "").encode("ascii")
+                    example_vector[key] = hex_str
+                examples.append(example_vector)
+
+            attr = None
+            example_vector = collections.defaultdict(list)
+
+        if line.startswith("# Message"):
+            attr = "message"
+            continue
+        elif line.startswith("# Salt"):
+            attr = "salt"
+            continue
+        elif line.startswith("# Seed"):
+            attr = "seed"
+            continue
+        elif line.startswith("# Signature"):
+            attr = "signature"
+            continue
+        elif line.startswith("# Encryption"):
+            attr = "encryption"
+            continue
+        elif (
+            example_vector and
+            line.startswith("# =============================================")
+        ):
+            for key, value in six.iteritems(example_vector):
+                hex_str = "".join(value).replace(" ", "").encode("ascii")
+                example_vector[key] = hex_str
+            examples.append(example_vector)
+            example_vector = None
+            attr = None
+        elif example_vector and line.startswith("#"):
+            continue
+        else:
+            if attr is not None and example_vector is not None:
+                example_vector[attr].append(line.strip())
+                continue
+
+        if (
+            line.startswith("# Example") or
+            line.startswith("# =============================================")
+        ):
+            if key:
+                assert private_key_vector
+                assert public_key_vector
+
+                for key, value in six.iteritems(public_key_vector):
+                    hex_str = "".join(value).replace(" ", "")
+                    public_key_vector[key] = int(hex_str, 16)
+
+                for key, value in six.iteritems(private_key_vector):
+                    hex_str = "".join(value).replace(" ", "")
+                    private_key_vector[key] = int(hex_str, 16)
+
+                private_key_vector["examples"] = examples
+                examples = []
+
+                assert (
+                    private_key_vector['public_exponent'] ==
+                    public_key_vector['public_exponent']
+                )
+
+                assert (
+                    private_key_vector['modulus'] ==
+                    public_key_vector['modulus']
+                )
+
+                vectors.append(
+                    (private_key_vector, public_key_vector)
+                )
+
+            public_key_vector = collections.defaultdict(list)
+            private_key_vector = collections.defaultdict(list)
+            key = None
+            attr = None
+
+        if private_key_vector is None or public_key_vector is None:
+            continue
+
+        if line.startswith("# Private key"):
+            key = private_key_vector
+        elif line.startswith("# Public key"):
+            key = public_key_vector
+        elif line.startswith("# Modulus:"):
+            attr = "modulus"
+        elif line.startswith("# Public exponent:"):
+            attr = "public_exponent"
+        elif line.startswith("# Exponent:"):
+            if key is public_key_vector:
+                attr = "public_exponent"
+            else:
+                assert key is private_key_vector
+                attr = "private_exponent"
+        elif line.startswith("# Prime 1:"):
+            attr = "p"
+        elif line.startswith("# Prime 2:"):
+            attr = "q"
+        elif line.startswith("# Prime exponent 1:"):
+            attr = "dmp1"
+        elif line.startswith("# Prime exponent 2:"):
+            attr = "dmq1"
+        elif line.startswith("# Coefficient:"):
+            attr = "iqmp"
+        elif line.startswith("#"):
+            attr = None
+        else:
+            if key is not None and attr is not None:
+                key[attr].append(line.strip())
+    return vectors
+
+
+def load_rsa_nist_vectors(vector_data):
+    test_data = None
+    p = None
+    salt_length = None
+    data = []
+
+    for line in vector_data:
+        line = line.strip()
+
+        # Blank lines and section headers are ignored
+        if not line or line.startswith("["):
+            continue
+
+        if line.startswith("# Salt len:"):
+            salt_length = int(line.split(":")[1].strip())
+            continue
+        elif line.startswith("#"):
+            continue
+
+        # Build our data using a simple Key = Value format
+        name, value = [c.strip() for c in line.split("=")]
+
+        if name == "n":
+            n = int(value, 16)
+        elif name == "e" and p is None:
+            e = int(value, 16)
+        elif name == "p":
+            p = int(value, 16)
+        elif name == "q":
+            q = int(value, 16)
+        elif name == "SHAAlg":
+            if p is None:
+                test_data = {
+                    "modulus": n,
+                    "public_exponent": e,
+                    "salt_length": salt_length,
+                    "algorithm": value,
+                    "fail": False
+                }
+            else:
+                test_data = {
+                    "modulus": n,
+                    "p": p,
+                    "q": q,
+                    "algorithm": value
+                }
+                if salt_length is not None:
+                    test_data["salt_length"] = salt_length
+            data.append(test_data)
+        elif name == "e" and p is not None:
+            test_data["public_exponent"] = int(value, 16)
+        elif name == "d":
+            test_data["private_exponent"] = int(value, 16)
+        elif name == "Result":
+            test_data["fail"] = value.startswith("F")
+        # For all other tokens we simply want the name, value stored in
+        # the dictionary
+        else:
+            test_data[name.lower()] = value.encode("ascii")
+
+    return data
+
+
+def load_fips_dsa_key_pair_vectors(vector_data):
+    """
+    Loads data out of the FIPS DSA KeyPair vector files.
+    """
+    vectors = []
+    # When reading_key_data is set to True it tells the loader to continue
+    # constructing dictionaries. We set reading_key_data to False during the
+    # blocks of the vectors of N=224 because we don't support it.
+    reading_key_data = True
+    for line in vector_data:
+        line = line.strip()
+
+        if not line or line.startswith("#"):
+            continue
+        elif line.startswith("[mod = L=1024"):
+            continue
+        elif line.startswith("[mod = L=2048, N=224"):
+            reading_key_data = False
+            continue
+        elif line.startswith("[mod = L=2048, N=256"):
+            reading_key_data = True
+            continue
+        elif line.startswith("[mod = L=3072"):
+            continue
+
+        if reading_key_data:
+            if line.startswith("P"):
+                vectors.append({'p': int(line.split("=")[1], 16)})
+            elif line.startswith("Q"):
+                vectors[-1]['q'] = int(line.split("=")[1], 16)
+            elif line.startswith("G"):
+                vectors[-1]['g'] = int(line.split("=")[1], 16)
+            elif line.startswith("X") and 'x' not in vectors[-1]:
+                vectors[-1]['x'] = int(line.split("=")[1], 16)
+            elif line.startswith("X") and 'x' in vectors[-1]:
+                vectors.append({'p': vectors[-1]['p'],
+                                'q': vectors[-1]['q'],
+                                'g': vectors[-1]['g'],
+                                'x': int(line.split("=")[1], 16)
+                                })
+            elif line.startswith("Y"):
+                vectors[-1]['y'] = int(line.split("=")[1], 16)
+
+    return vectors
+
+
+def load_fips_dsa_sig_vectors(vector_data):
+    """
+    Loads data out of the FIPS DSA SigVer vector files.
+    """
+    vectors = []
+    sha_regex = re.compile(
+        r"\[mod = L=...., N=..., SHA-(?P<sha>1|224|256|384|512)\]"
+    )
+    # When reading_key_data is set to True it tells the loader to continue
+    # constructing dictionaries. We set reading_key_data to False during the
+    # blocks of the vectors of N=224 because we don't support it.
+    reading_key_data = True
+
+    for line in vector_data:
+        line = line.strip()
+
+        if not line or line.startswith("#"):
+            continue
+
+        sha_match = sha_regex.match(line)
+        if sha_match:
+            digest_algorithm = "SHA-{0}".format(sha_match.group("sha"))
+
+        if line.startswith("[mod = L=2048, N=224"):
+            reading_key_data = False
+            continue
+        elif line.startswith("[mod = L=2048, N=256"):
+            reading_key_data = True
+            continue
+
+        if not reading_key_data or line.startswith("[mod"):
+            continue
+
+        name, value = [c.strip() for c in line.split("=")]
+
+        if name == "P":
+            vectors.append({'p': int(value, 16),
+                            'digest_algorithm': digest_algorithm})
+        elif name == "Q":
+            vectors[-1]['q'] = int(value, 16)
+        elif name == "G":
+            vectors[-1]['g'] = int(value, 16)
+        elif name == "Msg" and 'msg' not in vectors[-1]:
+            hexmsg = value.strip().encode("ascii")
+            vectors[-1]['msg'] = binascii.unhexlify(hexmsg)
+        elif name == "Msg" and 'msg' in vectors[-1]:
+            hexmsg = value.strip().encode("ascii")
+            vectors.append({'p': vectors[-1]['p'],
+                            'q': vectors[-1]['q'],
+                            'g': vectors[-1]['g'],
+                            'digest_algorithm':
+                            vectors[-1]['digest_algorithm'],
+                            'msg': binascii.unhexlify(hexmsg)})
+        elif name == "X":
+            vectors[-1]['x'] = int(value, 16)
+        elif name == "Y":
+            vectors[-1]['y'] = int(value, 16)
+        elif name == "R":
+            vectors[-1]['r'] = int(value, 16)
+        elif name == "S":
+            vectors[-1]['s'] = int(value, 16)
+        elif name == "Result":
+            vectors[-1]['result'] = value.split("(")[0].strip()
+
+    return vectors
+
+
+# http://tools.ietf.org/html/rfc4492#appendix-A
+_ECDSA_CURVE_NAMES = {
+    "P-192": "secp192r1",
+    "P-224": "secp224r1",
+    "P-256": "secp256r1",
+    "P-384": "secp384r1",
+    "P-521": "secp521r1",
+
+    "K-163": "sect163k1",
+    "K-233": "sect233k1",
+    "K-256": "secp256k1",
+    "K-283": "sect283k1",
+    "K-409": "sect409k1",
+    "K-571": "sect571k1",
+
+    "B-163": "sect163r2",
+    "B-233": "sect233r1",
+    "B-283": "sect283r1",
+    "B-409": "sect409r1",
+    "B-571": "sect571r1",
+}
+
+
+def load_fips_ecdsa_key_pair_vectors(vector_data):
+    """
+    Loads data out of the FIPS ECDSA KeyPair vector files.
+    """
+    vectors = []
+    key_data = None
+    for line in vector_data:
+        line = line.strip()
+
+        if not line or line.startswith("#"):
+            continue
+
+        if line[1:-1] in _ECDSA_CURVE_NAMES:
+            curve_name = _ECDSA_CURVE_NAMES[line[1:-1]]
+
+        elif line.startswith("d = "):
+            if key_data is not None:
+                vectors.append(key_data)
+
+            key_data = {
+                "curve": curve_name,
+                "d": int(line.split("=")[1], 16)
+            }
+
+        elif key_data is not None:
+            if line.startswith("Qx = "):
+                key_data["x"] = int(line.split("=")[1], 16)
+            elif line.startswith("Qy = "):
+                key_data["y"] = int(line.split("=")[1], 16)
+
+    assert key_data is not None
+    vectors.append(key_data)
+
+    return vectors
+
+
+def load_fips_ecdsa_signing_vectors(vector_data):
+    """
+    Loads data out of the FIPS ECDSA SigGen vector files.
+    """
+    vectors = []
+
+    curve_rx = re.compile(
+        r"\[(?P<curve>[PKB]-[0-9]{3}),SHA-(?P<sha>1|224|256|384|512)\]"
+    )
+
+    data = None
+    for line in vector_data:
+        line = line.strip()
+
+        curve_match = curve_rx.match(line)
+        if curve_match:
+            curve_name = _ECDSA_CURVE_NAMES[curve_match.group("curve")]
+            digest_name = "SHA-{0}".format(curve_match.group("sha"))
+
+        elif line.startswith("Msg = "):
+            if data is not None:
+                vectors.append(data)
+
+            hexmsg = line.split("=")[1].strip().encode("ascii")
+
+            data = {
+                "curve": curve_name,
+                "digest_algorithm": digest_name,
+                "message": binascii.unhexlify(hexmsg)
+            }
+
+        elif data is not None:
+            if line.startswith("Qx = "):
+                data["x"] = int(line.split("=")[1], 16)
+            elif line.startswith("Qy = "):
+                data["y"] = int(line.split("=")[1], 16)
+            elif line.startswith("R = "):
+                data["r"] = int(line.split("=")[1], 16)
+            elif line.startswith("S = "):
+                data["s"] = int(line.split("=")[1], 16)
+            elif line.startswith("d = "):
+                data["d"] = int(line.split("=")[1], 16)
+            elif line.startswith("Result = "):
+                data["fail"] = line.split("=")[1].strip()[0] == "F"
+
+    assert data is not None
+    vectors.append(data)
+    return vectors
+
+
+def load_kasvs_dh_vectors(vector_data):
+    """
+    Loads data out of the KASVS key exchange vector data
+    """
+
+    result_rx = re.compile(r"([FP]) \(([0-9]+) -")
+
+    vectors = []
+    data = {
+        "fail_z": False,
+        "fail_agree": False
+    }
+
+    for line in vector_data:
+        line = line.strip()
+
+        if not line or line.startswith("#"):
+            continue
+
+        if line.startswith("P = "):
+            data["p"] = int(line.split("=")[1], 16)
+        elif line.startswith("Q = "):
+            data["q"] = int(line.split("=")[1], 16)
+        elif line.startswith("G = "):
+            data["g"] = int(line.split("=")[1], 16)
+        elif line.startswith("Z = "):
+            z_hex = line.split("=")[1].strip().encode("ascii")
+            data["z"] = binascii.unhexlify(z_hex)
+        elif line.startswith("XstatCAVS = "):
+            data["x1"] = int(line.split("=")[1], 16)
+        elif line.startswith("YstatCAVS = "):
+            data["y1"] = int(line.split("=")[1], 16)
+        elif line.startswith("XstatIUT = "):
+            data["x2"] = int(line.split("=")[1], 16)
+        elif line.startswith("YstatIUT = "):
+            data["y2"] = int(line.split("=")[1], 16)
+        elif line.startswith("Result = "):
+            result_str = line.split("=")[1].strip()
+            match = result_rx.match(result_str)
+
+            if match.group(1) == "F":
+                if int(match.group(2)) in (5, 10):
+                    data["fail_z"] = True
+                else:
+                    data["fail_agree"] = True
+
+            vectors.append(data)
+
+            data = {
+                "p": data["p"],
+                "q": data["q"],
+                "g": data["g"],
+                "fail_z": False,
+                "fail_agree": False
+            }
+
+    return vectors
+
+
+def load_kasvs_ecdh_vectors(vector_data):
+    """
+    Loads data out of the KASVS key exchange vector data
+    """
+
+    curve_name_map = {
+        "P-192": "secp192r1",
+        "P-224": "secp224r1",
+        "P-256": "secp256r1",
+        "P-384": "secp384r1",
+        "P-521": "secp521r1",
+    }
+
+    result_rx = re.compile(r"([FP]) \(([0-9]+) -")
+
+    tags = []
+    sets = {}
+    vectors = []
+
+    # find info in header
+    for line in vector_data:
+        line = line.strip()
+
+        if line.startswith("#"):
+            parm = line.split("Parameter set(s) supported:")
+            if len(parm) == 2:
+                names = parm[1].strip().split()
+                for n in names:
+                    tags.append("[%s]" % n)
+                break
+
+    # Sets Metadata
+    tag = None
+    curve = None
+    for line in vector_data:
+        line = line.strip()
+
+        if not line or line.startswith("#"):
+            continue
+
+        if line in tags:
+            tag = line
+            curve = None
+        elif line.startswith("[Curve selected:"):
+            curve = curve_name_map[line.split(':')[1].strip()[:-1]]
+
+        if tag is not None and curve is not None:
+            sets[tag.strip("[]")] = curve
+            tag = None
+        if len(tags) == len(sets):
+            break
+
+    # Data
+    data = {
+        "CAVS": {},
+        "IUT": {},
+    }
+    tag = None
+    for line in vector_data:
+        line = line.strip()
+
+        if not line or line.startswith("#"):
+            continue
+
+        if line.startswith("["):
+            tag = line.split()[0][1:]
+        elif line.startswith("COUNT = "):
+            data["COUNT"] = int(line.split("=")[1])
+        elif line.startswith("dsCAVS = "):
+            data["CAVS"]["d"] = int(line.split("=")[1], 16)
+        elif line.startswith("QsCAVSx = "):
+            data["CAVS"]["x"] = int(line.split("=")[1], 16)
+        elif line.startswith("QsCAVSy = "):
+            data["CAVS"]["y"] = int(line.split("=")[1], 16)
+        elif line.startswith("dsIUT = "):
+            data["IUT"]["d"] = int(line.split("=")[1], 16)
+        elif line.startswith("QsIUTx = "):
+            data["IUT"]["x"] = int(line.split("=")[1], 16)
+        elif line.startswith("QsIUTy = "):
+            data["IUT"]["y"] = int(line.split("=")[1], 16)
+        elif line.startswith("OI = "):
+            data["OI"] = int(line.split("=")[1], 16)
+        elif line.startswith("Z = "):
+            data["Z"] = int(line.split("=")[1], 16)
+        elif line.startswith("DKM = "):
+            data["DKM"] = int(line.split("=")[1], 16)
+        elif line.startswith("Result = "):
+            result_str = line.split("=")[1].strip()
+            match = result_rx.match(result_str)
+
+            if match.group(1) == "F":
+                data["fail"] = True
+            else:
+                data["fail"] = False
+            data["errno"] = int(match.group(2))
+
+            data["curve"] = sets[tag]
+
+            vectors.append(data)
+
+            data = {
+                "CAVS": {},
+                "IUT": {},
+            }
+
+    return vectors
+
+
+def load_x963_vectors(vector_data):
+    """
+    Loads data out of the X9.63 vector data
+    """
+
+    vectors = []
+
+    # Sets Metadata
+    hashname = None
+    vector = {}
+    for line in vector_data:
+        line = line.strip()
+
+        if line.startswith("[SHA"):
+            hashname = line[1:-1]
+            shared_secret_len = 0
+            shared_info_len = 0
+            key_data_len = 0
+        elif line.startswith("[shared secret length"):
+            shared_secret_len = int(line[1:-1].split("=")[1].strip())
+        elif line.startswith("[SharedInfo length"):
+            shared_info_len = int(line[1:-1].split("=")[1].strip())
+        elif line.startswith("[key data length"):
+            key_data_len = int(line[1:-1].split("=")[1].strip())
+        elif line.startswith("COUNT"):
+            count = int(line.split("=")[1].strip())
+            vector["hash"] = hashname
+            vector["count"] = count
+            vector["shared_secret_length"] = shared_secret_len
+            vector["sharedinfo_length"] = shared_info_len
+            vector["key_data_length"] = key_data_len
+        elif line.startswith("Z"):
+            vector["Z"] = line.split("=")[1].strip()
+            assert math.ceil(shared_secret_len / 8) * 2 == len(vector["Z"])
+        elif line.startswith("SharedInfo"):
+            if shared_info_len != 0:
+                vector["sharedinfo"] = line.split("=")[1].strip()
+                silen = len(vector["sharedinfo"])
+                assert math.ceil(shared_info_len / 8) * 2 == silen
+        elif line.startswith("key_data"):
+            vector["key_data"] = line.split("=")[1].strip()
+            assert math.ceil(key_data_len / 8) * 2 == len(vector["key_data"])
+            vectors.append(vector)
+            vector = {}
+
+    return vectors
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/ChangeLog hue-release-3.9.0/desktop/core/ext-py/pyopenssl/ChangeLog
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/ChangeLog	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/ChangeLog	2015-04-15 01:02:27.000000000 +0200
@@ -1,3 +1,185 @@
+2011-09-02  Hynek Schlawack  <hs@ox.cx>
+
+	* Release 0.15.1
+
+2015-04-14  Glyph Lefkowitz  <glyph@twistedmatrix.com>
+
+	* OpenSSL/SSL.py, OpenSSL/test/test_ssl.py: Fix a regression
+	  present in 0.15, where when an error occurs and no errno() is set,
+	  a KeyError is raised.  This happens, for example, if
+	  Connection.shutdown() is called when the underlying transport has
+	  gone away.
+
+2011-09-02  Hynek Schlawack  <hs@ox.cx>
+
+	* Release 0.15
+
+2015-04-12  Jean-Paul Calderone  <exarkun@twistedmatrix.com>
+
+	* OpenSSL/rand.py, OpenSSL/SSL.py: APIs which previously accepted
+	  filenames only as bytes now accept them as either bytes or
+	  unicode (and respect sys.getfilesystemencoding()).
+
+2015-03-23  Jean-Paul Calderone  <exarkun@twistedmatrix.com>
+
+	* OpenSSL/SSL.py: Add Cory Benfield's next-protocol-negotiation
+	  (NPN) bindings.
+
+2015-03-15  Jean-Paul Calderone  <exarkun@twistedmatrix.com>
+
+	* OpenSSL/SSL.py: Add ``Connection.recv_into``, mirroring the
+	  builtin ``socket.recv_into``.  Based on work from Cory Benfield.
+	* OpenSSL/test/test_ssl.py: Add tests for ``recv_into``.
+
+2015-01-30  Stephen Holsapple <sholsapp@gmail.com>
+
+	* OpenSSL/crypto.py: Expose ``X509StoreContext`` for verifying certificates.
+	* OpenSSL/test/test_crypto.py: Add intermediate certificates for
+
+2015-01-08  Paul Aurich <paul@darkrain42.org>
+
+	* OpenSSL/SSL.py: ``Connection.shutdown`` now propagates errors from the
+	  underlying socket.
+
+2014-12-11  Jean-Paul Calderone  <exarkun@twistedmatrix.com>
+
+	* OpenSSL/SSL.py: Fixed a regression ``Context.check_privatekey``
+	  causing it to always succeed - even if it should fail.
+
+2014-08-21  Alex Gaynor  <alex.gaynor@gmail.com>
+
+	* OpenSSL/crypto.py: Fixed a regression where calling ``load_pkcs7_data``
+	  with ``FILETYPE_ASN1`` would fail with a ``NameError``.
+
+2014-05-05  Jean-Paul Calderone  <exarkun@twistedmatrix.com>
+
+	* OpenSSL/SSL.py: Fix a regression in which the first argument of
+	  the "verify" callback was incorrectly passed a ``Context`` instance
+	  instead of the ``Connection`` instance.
+	* OpenSSL/test/test_ssl.py: Add a test for the value passed as the
+	  first argument of the "verify" callback.
+
+2014-04-19  Jean-Paul Calderone  <exarkun@twistedmatrix.com>
+
+	* OpenSSL/crypto.py: Based on work from Alex Gaynor, Andrew
+	  Lutomirski, Tobias Oberstein, Laurens Van Houtven, and Hynek
+	  Schlawack, add ``get_elliptic_curve`` and ``get_elliptic_curves``
+	  to support TLS ECDHE modes.
+	* OpenSSL/SSL.py: Add ``Context.set_tmp_ecdh`` to configure a TLS
+	  context with a particular elliptic curve for ECDHE modes.
+
+2014-04-19  Markus Unterwaditzer <markus@unterwaditzer.net>
+
+	* OpenSSL/SSL.py: ``Connection.send`` and ``Connection.sendall``
+	  now also accept the ``buffer`` type as data.
+
+2014-04-05  Stephen Holsapple <sholsapp@gmail.com>
+
+	* OpenSSL/crypto.py: Make ``load_pkcs12`` backwards compatible with
+	  pyOpenSSL 0.13 by making passphrase optional.
+
+2014-03-30  Fedor Brunner  <fedor.brunner@azet.sk>
+
+	* OpenSSL/SSL.py: Add ``get_finished``, ``get_peer_finished``
+	  methods to ``Connection``. If you use these methods to
+	  implement TLS channel binding (RFC 5929) disable session
+	  resumption because triple handshake attacks against TLS.
+	  <https://www.ietf.org/mail-archive/web/tls/current/msg11337.html>
+	  <https://secure-resumption.com/tlsauth.pdf>
+
+2014-03-29  Fedor Brunner  <fedor.brunner@azet.sk>
+
+	* OpenSSL/SSL.py: Add ``get_cipher_name``, ``get_cipher_bits``,
+	  and ``get_cipher_version`` to ``Connection``.
+
+2014-03-28  Jean-Paul Calderone  <exarkun@twistedmatrix.com>
+
+	* OpenSSL/tsafe.py: Replace the use of ``apply`` (which has been
+	  removed in Python 3) with the equivalent syntax.
+
+2014-03-28  Jonathan Giannuzzi  <jonathan@giannuzzi.be>
+
+	* OpenSSL/crypto.py: Fix memory leak in _X509_REVOKED_dup.
+	* leakcheck/crypto.py: Add checks for _X509_REVOKED_dup, CRL.add_revoked
+	  and CRL.get_revoked.
+	* setup.py: Require cryptography 0.3 to have the ASN1_TIME_free binding.
+
+2014-03-02  Stephen Holsapple  <sholsapp@gmail.com>
+
+	* OpenSSL/crypto.py: Add ``get_extensions`` method to ``X509Req``.
+
+2014-02-23  Jean-Paul Calderone  <exarkun@twistedmatrix.com>
+
+	* Release 0.14
+
+2014-01-09  Jean-Paul Calderone  <exarkun@twistedmatrix.com>
+
+	* OpenSSL: Port to the cffi-based OpenSSL bindings provided by
+	  <https://github.com/pyca/cryptography>
+
+2013-10-06  Jean-Paul Calderone  <exarkun@twistedmatrix.com>
+
+	* OpenSSL/ssl/context.c: Add support for negotiating TLS v1.1 or
+	  v1.2.
+
+2013-10-03  Christian Heimes  <christian@python.org>
+
+	* OpenSSL/crypto/x509.c: Fix an inconsistency in memory management
+	  in X509.get_serial_number which leads to crashes on some runtimes
+	  (certain Windows/Python 3.3 environments, at least).
+
+2013-08-11  Christian Heimes  <christian@python.org>
+
+	* OpenSSL/crypto/x509ext.c: Fix handling of NULL bytes inside
+	  subjectAltName general names when formatting an X509 extension
+	  as a string.
+	* OpenSSL/crypto/x509.c: Fix memory leak in get_extension().
+
+2012-04-03  Jean-Paul Calderone  <exarkun@twistedmatrix.com>
+
+	* OpenSSL/crypto/pkey.c: Release the GIL around RSA and DSA key
+	  generation, based on code from INADA Naoki.
+
+2012-02-13  Jean-Paul Calderone  <exarkun@twistedmatrix.com>
+
+	* OpenSSL/ssl/ssl.c: Add session cache related constants for use
+	  with the new Context.set_session_cache_mode method.
+
+	* OpenSSL/ssl/context.c: Add new Context methods
+	  set_session_cache_mode and get_session_cache_mode.
+
+2011-11-01  Jean-Paul Calderone  <exarkun@twistedmatrix.com>
+
+	* OpenSSL/crypto/pkey.c: Raise TypeError when trying to check a
+	  PKey instance which has no private component, instead of crashing.
+	  Based on fix by <lp:~dataway>.
+
+2011-09-14  Å½iga Seilnacht <lp:ziga-seilnacht>
+
+	* OpenSSL/crypto/crypto.c: Allow exceptions from passphrase
+	  callbacks to propagate up out of load_privatekey
+	* OpenSSL/crypto/crypto.c: Raise an exception when a too-long
+	  passphrase is returned from a passphrase callback, instead of
+	  silently truncating it.
+	* OpenSSL/crypto/crypto.c: Fix a memory leak when a passphrase
+	  callback returns the wrong type.
+
+2011-09-13  Jean-Paul Calderone  <exarkun@twistedmatrix.com>
+
+	* OpenSSL/crypto/crl.c: Add error handling for the use of
+	  X509_CRL_sign.
+
+2011-09-11  Jonathan Ballet  <lp:multani>
+
+	* doc/: Convert the LaTeX documentation to Sphinx-using ReST.
+	* OpenSSL/: Convert the epytext API documentation to Sphinx-using ReST.
+
+2011-09-08  Guillermo Gonzalez  <guillermo.gonzalez@canonical.com>
+
+	* OpenSSL/ssl/context.c: Add Context.set_mode method.
+	* OpenSSL/ssl/ssl.c: Add MODE_RELEASE_BUFFERS and OP_NO_COMPRESSION
+	  constants.
+
 2011-09-02  Jean-Paul Calderone  <exarkun@twistedmatrix.com>
 
 	* Release 0.13
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/CONTRIBUTING.rst hue-release-3.9.0/desktop/core/ext-py/pyopenssl/CONTRIBUTING.rst
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/CONTRIBUTING.rst	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/CONTRIBUTING.rst	2014-08-14 22:37:39.000000000 +0200
@@ -0,0 +1,43 @@
+Contributing
+============
+
+First of all, thank you for your interest in contributing to pyOpenSSL!
+
+Filing bug reports
+------------------
+
+Bug reports are very welcome.
+Please file them on the Github issue tracker.
+Good bug reports come with extensive descriptions of the error and how to reproduce it.
+Reporters are strongly encouraged to include an `short, self contained, correct example <http://www.sscce.org/>`_.
+
+Patches
+-------
+
+All patches to pyOpenSSL should be submitted in the form of pull requests to the main pyOpenSSL repository, ``pyca/pyopenssl``.
+These pull requests should satisfy the following properties:
+
+- The branch referenced should be a `feature branch`_ focusing on one particular improvement to pyOpenSSL.
+  Create different branches and different pull requests for unrelated features or bugfixes.
+- The branch referenced should have a distinctive name (in particular, please do not open pull requests for your ``master`` branch).
+- Code should follow `PEP 8`_, especially in the "do what code around you does" sense.
+  One notable way pyOpenSSL code differs, for example, is that there should be three empty lines between module-level elements,and two empty lines between class-level elements.
+  Methods and functions are named in ``snake_case``.
+  Follow OpenSSL naming for callables whenever possible is preferred.
+- Pull requests that introduce code must test all new behavior they introduce as well as for previously untested or poorly tested behavior that they touch.
+- Pull requests are not allowed to break existing tests.
+- Pull requests that introduce features or fix bugs should note those changes in the ``ChangeLog`` text file in the root of the repository.
+  They should also document the changes, both in docstrings and in the documentation in the ``doc/`` directory.
+
+Finally, pull requests must be reviewed before merging.
+This process mirrors the `cryptography code review process`_.
+Everyone can perform reviews; this is a very valuable way to contribute, and is highly encouraged.
+
+Pull requests are merged by members of the `pyopenssl-committers team <https://github.com/orgs/pyca/teams/pyopenssl-committers>`_.
+They should, of course, keep all the requirements detailed in this document as well as the pyca/cryptography merge requirements in mind.
+
+The final responsibility for the reviewing of merged code lies with the person merging it; since pyOpenSSL is obviously a sensitive project from a security perspective, so reviewers are strongly encouraged to take this review and merge process very seriously.
+
+.. _PEP 8: http://legacy.python.org/dev/peps/pep-0008/
+.. _cryptography code review process: https://cryptography.io/en/latest/development/reviewing-patches/
+.. _feature branch: http://nvie.com/posts/a-successful-git-branching-model/
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/api/crypto.rst hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/api/crypto.rst
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/api/crypto.rst	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/api/crypto.rst	2015-04-14 04:50:11.000000000 +0200
@@ -0,0 +1,823 @@
+.. _openssl-crypto:
+
+:py:mod:`crypto` --- Generic cryptographic module
+=================================================
+
+.. py:module:: OpenSSL.crypto
+   :synopsis: Generic cryptographic module
+
+
+.. py:data:: X509Type
+
+    See :py:class:`X509`.
+
+
+.. py:class:: X509()
+
+    A class representing X.509 certificates.
+
+
+.. py:data:: X509NameType
+
+    See :py:class:`X509Name`.
+
+
+.. py:class:: X509Name(x509name)
+
+    A class representing X.509 Distinguished Names.
+
+    This constructor creates a copy of *x509name* which should be an
+    instance of :py:class:`X509Name`.
+
+
+.. py:data:: X509ReqType
+
+    See :py:class:`X509Req`.
+
+
+.. py:class:: X509Req()
+
+    A class representing X.509 certificate requests.
+
+
+.. py:data:: X509StoreType
+
+    See :py:class:`X509Store`
+
+
+.. py:data X509Store
+
+    A class representing the X.509 store.
+
+
+.. py:data:: X509StoreContext
+
+    A class representing the X.509 store context.
+
+
+.. py:data:: PKeyType
+
+    See :py:class:`PKey`.
+
+
+.. py:class:: PKey()
+
+    A class representing DSA or RSA keys.
+
+
+.. py:data:: PKCS7Type
+
+    A Python type object representing the PKCS7 object type.
+
+
+.. py:data:: PKCS12Type
+
+    A Python type object representing the PKCS12 object type.
+
+
+.. py:data:: X509ExtensionType
+
+    See :py:class:`X509Extension`.
+
+
+.. py:class:: X509Extension(typename, critical, value[, subject][, issuer])
+
+    A class representing an X.509 v3 certificate extensions.  See
+    http://openssl.org/docs/apps/x509v3_config.html#STANDARD_EXTENSIONS for
+    *typename* strings and their options.  Optional parameters *subject* and
+    *issuer* must be X509 objects.
+
+
+.. py:data:: NetscapeSPKIType
+
+    See :py:class:`NetscapeSPKI`.
+
+
+.. py:class:: NetscapeSPKI([enc])
+
+    A class representing Netscape SPKI objects.
+
+    If the *enc* argument is present, it should be a base64-encoded string
+    representing a NetscapeSPKI object, as returned by the :py:meth:`b64_encode`
+    method.
+
+
+.. py:class:: CRL()
+
+    A class representing Certifcate Revocation List objects.
+
+
+.. py:class:: Revoked()
+
+    A class representing Revocation objects of CRL.
+
+
+.. py:data:: FILETYPE_PEM
+             FILETYPE_ASN1
+
+    File type constants.
+
+
+.. py:data:: TYPE_RSA
+             TYPE_DSA
+
+    Key type constants.
+
+
+.. py:exception:: Error
+
+    Generic exception used in the :py:mod:`.crypto` module.
+
+
+.. py:function:: get_elliptic_curves
+
+    Return a set of objects representing the elliptic curves supported in the
+    OpenSSL build in use.
+
+    The curve objects have a :py:class:`unicode` ``name`` attribute by which
+    they identify themselves.
+
+    The curve objects are useful as values for the argument accepted by
+    :py:meth:`Context.set_tmp_ecdh` to specify which elliptical curve should be
+    used for ECDHE key exchange.
+
+
+.. py:function:: get_elliptic_curve
+
+    Return a single curve object selected by name.
+
+    See :py:func:`get_elliptic_curves` for information about curve objects.
+
+    If the named curve is not supported then :py:class:`ValueError` is raised.
+
+
+.. py:function:: dump_certificate(type, cert)
+
+    Dump the certificate *cert* into a buffer string encoded with the type
+    *type*.
+
+
+.. py:function:: dump_certificate_request(type, req)
+
+    Dump the certificate request *req* into a buffer string encoded with the
+    type *type*.
+
+
+.. py:function:: dump_privatekey(type, pkey[, cipher, passphrase])
+
+    Dump the private key *pkey* into a buffer string encoded with the type
+    *type*, optionally (if *type* is :py:const:`FILETYPE_PEM`) encrypting it
+    using *cipher* and *passphrase*.
+
+    *passphrase* must be either a string or a callback for providing the
+    pass phrase.
+
+
+.. py:function:: load_certificate(type, buffer)
+
+    Load a certificate (X509) from the string *buffer* encoded with the
+    type *type*.
+
+
+.. py:function:: load_certificate_request(type, buffer)
+
+    Load a certificate request (X509Req) from the string *buffer* encoded with
+    the type *type*.
+
+
+.. py:function:: load_privatekey(type, buffer[, passphrase])
+
+    Load a private key (PKey) from the string *buffer* encoded with the type
+    *type* (must be one of :py:const:`FILETYPE_PEM` and
+    :py:const:`FILETYPE_ASN1`).
+
+    *passphrase* must be either a string or a callback for providing the pass
+    phrase.
+
+
+.. py:function:: load_crl(type, buffer)
+
+    Load Certificate Revocation List (CRL) data from a string *buffer*.
+    *buffer* encoded with the type *type*.  The type *type* must either
+    :py:const:`FILETYPE_PEM` or :py:const:`FILETYPE_ASN1`).
+
+
+.. py:function:: load_pkcs7_data(type, buffer)
+
+    Load pkcs7 data from the string *buffer* encoded with the type *type*.
+
+
+.. py:function:: load_pkcs12(buffer[, passphrase])
+
+    Load pkcs12 data from the string *buffer*. If the pkcs12 structure is
+    encrypted, a *passphrase* must be included.  The MAC is always
+    checked and thus required.
+
+    See also the man page for the C function :py:func:`PKCS12_parse`.
+
+
+.. py:function:: sign(key, data, digest)
+
+    Sign a data string using the given key and message digest.
+
+    *key* is a :py:class:`PKey` instance.  *data* is a ``str`` instance.
+    *digest* is a ``str`` naming a supported message digest type, for example
+    :py:const:`sha1`.
+
+    .. versionadded:: 0.11
+
+
+.. py:function:: verify(certificate, signature, data, digest)
+
+    Verify the signature for a data string.
+
+    *certificate* is a :py:class:`X509` instance corresponding to the private
+    key which generated the signature.  *signature* is a *str* instance giving
+    the signature itself.  *data* is a *str* instance giving the data to which
+    the signature applies.  *digest* is a *str* instance naming the message
+    digest type of the signature, for example :py:const:`sha1`.
+
+    .. versionadded:: 0.11
+
+
+.. _openssl-x509:
+
+X509 objects
+------------
+
+X509 objects have the following methods:
+
+.. py:method:: X509.get_issuer()
+
+    Return an X509Name object representing the issuer of the certificate.
+
+
+.. py:method:: X509.get_pubkey()
+
+    Return a :py:class:`PKey` object representing the public key of the certificate.
+
+
+.. py:method:: X509.get_serial_number()
+
+    Return the certificate serial number.
+
+
+.. py:method:: X509.get_signature_algorithm()
+
+    Return the signature algorithm used in the certificate.  If the algorithm is
+    undefined, raise :py:data:`ValueError`.
+
+    .. versionadded:: 0.13
+
+
+.. py:method:: X509.get_subject()
+
+    Return an :py:class:`X509Name` object representing the subject of the certificate.
+
+
+.. py:method:: X509.get_version()
+
+    Return the certificate version.
+
+
+.. py:method:: X509.get_notBefore()
+
+    Return a string giving the time before which the certificate is not valid.  The
+    string is formatted as an ASN1 GENERALIZEDTIME::
+
+        YYYYMMDDhhmmssZ
+        YYYYMMDDhhmmss+hhmm
+        YYYYMMDDhhmmss-hhmm
+
+    If no value exists for this field, :py:data:`None` is returned.
+
+
+.. py:method:: X509.get_notAfter()
+
+    Return a string giving the time after which the certificate is not valid.  The
+    string is formatted as an ASN1 GENERALIZEDTIME::
+
+        YYYYMMDDhhmmssZ
+        YYYYMMDDhhmmss+hhmm
+        YYYYMMDDhhmmss-hhmm
+
+    If no value exists for this field, :py:data:`None` is returned.
+
+
+.. py:method:: X509.set_notBefore(when)
+
+    Change the time before which the certificate is not valid.  *when* is a
+    string formatted as an ASN1 GENERALIZEDTIME::
+
+        YYYYMMDDhhmmssZ
+        YYYYMMDDhhmmss+hhmm
+        YYYYMMDDhhmmss-hhmm
+
+
+.. py:method:: X509.set_notAfter(when)
+
+    Change the time after which the certificate is not valid.  *when* is a
+    string formatted as an ASN1 GENERALIZEDTIME::
+
+        YYYYMMDDhhmmssZ
+        YYYYMMDDhhmmss+hhmm
+        YYYYMMDDhhmmss-hhmm
+
+
+
+.. py:method:: X509.gmtime_adj_notBefore(time)
+
+    Adjust the timestamp (in GMT) when the certificate starts being valid.
+
+
+.. py:method:: X509.gmtime_adj_notAfter(time)
+
+    Adjust the timestamp (in GMT) when the certificate stops being valid.
+
+
+.. py:method:: X509.has_expired()
+
+    Checks the certificate's time stamp against current time. Returns true if the
+    certificate has expired and false otherwise.
+
+
+.. py:method:: X509.set_issuer(issuer)
+
+    Set the issuer of the certificate to *issuer*.
+
+
+.. py:method:: X509.set_pubkey(pkey)
+
+    Set the public key of the certificate to *pkey*.
+
+
+.. py:method:: X509.set_serial_number(serialno)
+
+    Set the serial number of the certificate to *serialno*.
+
+
+.. py:method:: X509.set_subject(subject)
+
+    Set the subject of the certificate to *subject*.
+
+
+.. py:method:: X509.set_version(version)
+
+    Set the certificate version to *version*.
+
+
+.. py:method:: X509.sign(pkey, digest)
+
+    Sign the certificate, using the key *pkey* and the message digest algorithm
+    identified by the string *digest*.
+
+
+.. py:method:: X509.subject_name_hash()
+
+    Return the hash of the certificate subject.
+
+.. py:method:: X509.digest(digest_name)
+
+    Return a digest of the certificate, using the *digest_name* method.
+    *digest_name* must be a string describing a digest algorithm supported
+    by OpenSSL (by EVP_get_digestbyname, specifically).  For example,
+    :py:const:`"md5"` or :py:const:`"sha1"`.
+
+
+.. py:method:: X509.add_extensions(extensions)
+
+    Add the extensions in the sequence *extensions* to the certificate.
+
+
+.. py:method:: X509.get_extension_count()
+
+    Return the number of extensions on this certificate.
+
+    .. versionadded:: 0.12
+
+
+.. py:method:: X509.get_extension(index)
+
+    Retrieve the extension on this certificate at the given index.
+
+    Extensions on a certificate are kept in order.  The index parameter selects
+    which extension will be returned.  The returned object will be an
+    :py:class:`X509Extension` instance.
+
+    .. versionadded:: 0.12
+
+
+.. _openssl-x509name:
+
+X509Name objects
+----------------
+
+X509Name objects have the following methods:
+
+.. py:method:: X509Name.hash()
+
+    Return an integer giving the first four bytes of the MD5 digest of the DER
+    representation of the name.
+
+
+.. py:method:: X509Name.der()
+
+    Return a string giving the DER representation of the name.
+
+
+.. py:method:: X509Name.get_components()
+
+    Return a list of two-tuples of strings giving the components of the name.
+
+
+X509Name objects have the following members:
+
+.. py:attribute:: X509Name.countryName
+
+    The country of the entity. :py:attr:`C` may be used as an alias for
+    :py:attr:`countryName`.
+
+
+.. py:attribute:: X509Name.stateOrProvinceName
+
+    The state or province of the entity. :py:attr:`ST` may be used as an alias for
+    :py:attr:`stateOrProvinceName`.
+
+
+.. py:attribute:: X509Name.localityName
+
+    The locality of the entity. :py:attr:`L` may be used as an alias for
+    :py:attr:`localityName`.
+
+
+.. py:attribute:: X509Name.organizationName
+
+    The organization name of the entity. :py:attr:`O` may be used as an alias for
+    :py:attr:`organizationName`.
+
+
+.. py:attribute:: X509Name.organizationalUnitName
+
+    The organizational unit of the entity. :py:attr:`OU` may be used as an alias for
+    :py:attr:`organizationalUnitName`.
+
+
+.. py:attribute:: X509Name.commonName
+
+    The common name of the entity. :py:attr:`CN` may be used as an alias for
+    :py:attr:`commonName`.
+
+
+.. py:attribute:: X509Name.emailAddress
+
+    The e-mail address of the entity.
+
+
+.. _openssl-x509req:
+
+X509Req objects
+---------------
+
+X509Req objects have the following methods:
+
+.. py:method:: X509Req.get_pubkey()
+
+    Return a :py:class:`PKey` object representing the public key of the certificate request.
+
+
+.. py:method:: X509Req.get_subject()
+
+    Return an :py:class:`X509Name` object representing the subject of the certificate.
+
+
+.. py:method:: X509Req.set_pubkey(pkey)
+
+    Set the public key of the certificate request to *pkey*.
+
+
+.. py:method:: X509Req.sign(pkey, digest)
+
+    Sign the certificate request, using the key *pkey* and the message digest
+    algorithm identified by the string *digest*.
+
+
+.. py:method:: X509Req.verify(pkey)
+
+    Verify a certificate request using the public key *pkey*.
+
+
+.. py:method:: X509Req.set_version(version)
+
+    Set the version (RFC 2459, 4.1.2.1) of the certificate request to
+    *version*.
+
+
+.. py:method:: X509Req.get_version()
+
+    Get the version (RFC 2459, 4.1.2.1) of the certificate request.
+
+
+.. py:method:: X509Req.get_extensions()
+
+    Get extensions to the request.
+
+    .. versionadded:: 0.15
+
+
+.. _openssl-x509store:
+
+X509Store objects
+-----------------
+
+The X509Store object has currently just one method:
+
+.. py:method:: X509Store.add_cert(cert)
+
+    Add the certificate *cert* to the certificate store.
+
+
+X509StoreContextError objects
+-----------------------------
+
+The X509StoreContextError is an exception raised from
+`X509StoreContext.verify_certificate` in circumstances where a certificate
+cannot be verified in a provided context.
+
+The certificate for which the verification error was detected is given by the
+``certificate`` attribute of the exception instance as a :class:`X509`
+instance.
+
+Details about the verification error are given in the exception's ``args`` attribute.
+
+
+X509StoreContext objects
+------------------------
+
+The X509StoreContext object is used for verifying a certificate against a set
+of trusted certificates.
+
+
+.. py:method:: X509StoreContext.verify_certificate()
+
+    Verify a certificate in the context of this initialized `X509StoreContext`.
+    On error, raises `X509StoreContextError`, otherwise does nothing.
+
+    .. versionadded:: 0.15
+
+
+
+.. _openssl-pkey:
+
+PKey objects
+------------
+
+The PKey object has the following methods:
+
+.. py:method:: PKey.bits()
+
+    Return the number of bits of the key.
+
+
+.. py:method:: PKey.generate_key(type, bits)
+
+    Generate a public/private key pair of the type *type* (one of
+    :py:const:`TYPE_RSA` and :py:const:`TYPE_DSA`) with the size *bits*.
+
+
+.. py:method:: PKey.type()
+
+    Return the type of the key.
+
+
+.. py:method:: PKey.check()
+
+    Check the consistency of this key, returning True if it is consistent and
+    raising an exception otherwise.  This is only valid for RSA keys.  See the
+    OpenSSL RSA_check_key man page for further limitations.
+
+
+.. _openssl-pkcs7:
+
+PKCS7 objects
+-------------
+
+PKCS7 objects have the following methods:
+
+.. py:method:: PKCS7.type_is_signed()
+
+    FIXME
+
+
+.. py:method:: PKCS7.type_is_enveloped()
+
+    FIXME
+
+
+.. py:method:: PKCS7.type_is_signedAndEnveloped()
+
+    FIXME
+
+
+.. py:method:: PKCS7.type_is_data()
+
+    FIXME
+
+
+.. py:method:: PKCS7.get_type_name()
+
+    Get the type name of the PKCS7.
+
+
+.. _openssl-pkcs12:
+
+PKCS12 objects
+--------------
+
+PKCS12 objects have the following methods:
+
+.. py:method:: PKCS12.export([passphrase=None][, iter=2048][, maciter=1])
+
+    Returns a PKCS12 object as a string.
+
+    The optional *passphrase* must be a string not a callback.
+
+    See also the man page for the C function :py:func:`PKCS12_create`.
+
+
+.. py:method:: PKCS12.get_ca_certificates()
+
+    Return CA certificates within the PKCS12 object as a tuple. Returns
+    :py:const:`None` if no CA certificates are present.
+
+
+.. py:method:: PKCS12.get_certificate()
+
+    Return certificate portion of the PKCS12 structure.
+
+
+.. py:method:: PKCS12.get_friendlyname()
+
+    Return friendlyName portion of the PKCS12 structure.
+
+
+.. py:method:: PKCS12.get_privatekey()
+
+    Return private key portion of the PKCS12 structure
+
+
+.. py:method:: PKCS12.set_ca_certificates(cacerts)
+
+    Replace or set the CA certificates within the PKCS12 object with the sequence *cacerts*.
+
+    Set *cacerts* to :py:const:`None` to remove all CA certificates.
+
+
+.. py:method:: PKCS12.set_certificate(cert)
+
+    Replace or set the certificate portion of the PKCS12 structure.
+
+
+.. py:method:: PKCS12.set_friendlyname(name)
+
+    Replace or set the friendlyName portion of the PKCS12 structure.
+
+
+.. py:method:: PKCS12.set_privatekey(pkey)
+
+    Replace or set private key portion of the PKCS12 structure
+
+
+.. _openssl-509ext:
+
+X509Extension objects
+---------------------
+
+X509Extension objects have several methods:
+
+.. py:method:: X509Extension.get_critical()
+
+    Return the critical field of the extension object.
+
+
+.. py:method:: X509Extension.get_short_name()
+
+    Retrieve the short descriptive name for this extension.
+
+    The result is a byte string like :py:const:`basicConstraints`.
+
+    .. versionadded:: 0.12
+
+
+.. py:method:: X509Extension.get_data()
+
+    Retrieve the data for this extension.
+
+    The result is the ASN.1 encoded form of the extension data as a byte string.
+
+    .. versionadded:: 0.12
+
+
+.. _openssl-netscape-spki:
+
+NetscapeSPKI objects
+--------------------
+
+NetscapeSPKI objects have the following methods:
+
+.. py:method:: NetscapeSPKI.b64_encode()
+
+    Return a base64-encoded string representation of the object.
+
+
+.. py:method:: NetscapeSPKI.get_pubkey()
+
+    Return the public key of object.
+
+
+.. py:method:: NetscapeSPKI.set_pubkey(key)
+
+    Set the public key of the object to *key*.
+
+
+.. py:method:: NetscapeSPKI.sign(key, digest_name)
+
+    Sign the NetscapeSPKI object using the given *key* and *digest_name*.
+    *digest_name* must be a string describing a digest algorithm supported by
+    OpenSSL (by EVP_get_digestbyname, specifically).  For example,
+    :py:const:`"md5"` or :py:const:`"sha1"`.
+
+
+.. py:method:: NetscapeSPKI.verify(key)
+
+    Verify the NetscapeSPKI object using the given *key*.
+
+
+.. _crl:
+
+CRL objects
+-----------
+
+CRL objects have the following methods:
+
+.. py:method:: CRL.add_revoked(revoked)
+
+    Add a Revoked object to the CRL, by value not reference.
+
+
+.. py:method:: CRL.export(cert, key[, type=FILETYPE_PEM][, days=100][, digest=b'md5'])
+
+    Use *cert* and *key* to sign the CRL and return the CRL as a string.
+    *days* is the number of days before the next CRL is due.
+    *digest* is the algorithm that will be used to sign CRL.
+
+
+.. py:method:: CRL.get_revoked()
+
+    Return a tuple of Revoked objects, by value not reference.
+
+
+.. _revoked:
+
+Revoked objects
+---------------
+
+Revoked objects have the following methods:
+
+.. py:method:: Revoked.all_reasons()
+
+    Return a list of all supported reasons.
+
+
+.. py:method:: Revoked.get_reason()
+
+    Return the revocation reason as a str.  Can be
+    None, which differs from "Unspecified".
+
+
+.. py:method:: Revoked.get_rev_date()
+
+    Return the revocation date as a str.
+    The string is formatted as an ASN1 GENERALIZEDTIME.
+
+
+.. py:method:: Revoked.get_serial()
+
+    Return a str containing a hex number of the serial of the revoked certificate.
+
+
+.. py:method:: Revoked.set_reason(reason)
+
+    Set the revocation reason.  *reason* must be None or a string, but the
+    values are limited.  Spaces and case are ignored.  See
+    :py:meth:`all_reasons`.
+
+
+.. py:method:: Revoked.set_rev_date(date)
+
+    Set the revocation date.
+    The string is formatted as an ASN1 GENERALIZEDTIME.
+
+
+.. py:method:: Revoked.set_serial(serial)
+
+    *serial* is a string containing a hex number of the serial of the revoked certificate.
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/api/rand.rst hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/api/rand.rst
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/api/rand.rst	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/api/rand.rst	2014-01-10 11:06:42.000000000 +0100
@@ -0,0 +1,79 @@
+.. _openssl-rand:
+
+:py:mod:`rand` --- An interface to the OpenSSL pseudo random number generator
+=============================================================================
+
+.. py:module:: OpenSSL.rand
+   :synopsis: An interface to the OpenSSL pseudo random number generator
+
+
+This module handles the OpenSSL pseudo random number generator (PRNG) and
+declares the following:
+
+.. py:function:: add(string, entropy)
+
+    Mix bytes from *string* into the PRNG state. The *entropy* argument is
+    (the lower bound of) an estimate of how much randomness is contained in
+    *string*, measured in bytes. For more information, see e.g. :rfc:`1750`.
+
+
+.. py:function:: bytes(num_bytes)
+
+    Get some random bytes from the PRNG as a string.
+
+    This is a wrapper for the C function :py:func:`RAND_bytes`.
+
+
+.. py:function:: cleanup()
+
+    Erase the memory used by the PRNG.
+
+    This is a wrapper for the C function :py:func:`RAND_cleanup`.
+
+
+.. py:function:: egd(path[, bytes])
+
+    Query the `Entropy Gathering Daemon <http://www.lothar.com/tech/crypto/>`_ on
+    socket *path* for *bytes* bytes of random data and uses :py:func:`add` to
+    seed the PRNG. The default value of *bytes* is 255.
+
+
+.. py:function:: load_file(path[, bytes])
+
+    Read *bytes* bytes (or all of it, if *bytes* is negative) of data from the
+    file *path* to seed the PRNG. The default value of *bytes* is -1.
+
+
+.. py:function:: screen()
+
+    Add the current contents of the screen to the PRNG state.
+
+    Availability: Windows.
+
+
+.. py:function:: seed(string)
+
+    This is equivalent to calling :py:func:`add` with *entropy* as the length
+    of the string.
+
+
+.. py:function:: status()
+
+    Returns true if the PRNG has been seeded with enough data, and false otherwise.
+
+
+.. py:function:: write_file(path)
+
+    Write a number of random bytes (currently 1024) to the file *path*. This
+    file can then be used with :py:func:`load_file` to seed the PRNG again.
+
+
+.. py:exception:: Error
+
+    If the current RAND method supports any errors, this is raised when needed.
+    The default method does not raise this when the entropy pool is depleted.
+
+    Whenever this exception is raised directly, it has a list of error messages
+    from the OpenSSL error queue, where each item is a tuple *(lib, function,
+    reason)*. Here *lib*, *function* and *reason* are all strings, describing
+    where and what the problem is. See :manpage:`err(3)` for more information.
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/api/ssl.rst hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/api/ssl.rst
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/api/ssl.rst	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/api/ssl.rst	2015-04-14 03:47:26.000000000 +0200
@@ -0,0 +1,893 @@
+.. _openssl-ssl:
+
+:py:mod:`SSL` --- An interface to the SSL-specific parts of OpenSSL
+===================================================================
+
+.. py:module:: OpenSSL.SSL
+    :synopsis: An interface to the SSL-specific parts of OpenSSL
+
+
+This module handles things specific to SSL. There are two objects defined:
+Context, Connection.
+
+.. py:data:: SSLv2_METHOD
+             SSLv3_METHOD
+             SSLv23_METHOD
+             TLSv1_METHOD
+             TLSv1_1_METHOD
+             TLSv1_2_METHOD
+
+    These constants represent the different SSL methods to use when creating a
+    context object.  If the underlying OpenSSL build is missing support for any
+    of these protocols, constructing a :py:class:`Context` using the
+    corresponding :py:const:`*_METHOD` will raise an exception.
+
+
+.. py:data:: VERIFY_NONE
+             VERIFY_PEER
+             VERIFY_FAIL_IF_NO_PEER_CERT
+
+    These constants represent the verification mode used by the Context
+    object's :py:meth:`set_verify` method.
+
+
+.. py:data:: FILETYPE_PEM
+             FILETYPE_ASN1
+
+    File type constants used with the :py:meth:`use_certificate_file` and
+    :py:meth:`use_privatekey_file` methods of Context objects.
+
+
+.. py:data:: OP_SINGLE_DH_USE
+
+    Constant used with :py:meth:`set_options` of Context objects.
+
+    When this option is used, a new key will always be created when using
+    ephemeral Diffie-Hellman.
+
+
+.. py:data:: OP_EPHEMERAL_RSA
+
+    Constant used with :py:meth:`set_options` of Context objects.
+
+    When this option is used, ephemeral RSA keys will always be used when doing
+    RSA operations.
+
+
+.. py:data:: OP_NO_TICKET
+
+    Constant used with :py:meth:`set_options` of Context objects.
+
+    When this option is used, the session ticket extension will not be used.
+
+
+.. py:data:: OP_NO_COMPRESSION
+
+    Constant used with :py:meth:`set_options` of Context objects.
+
+    When this option is used, compression will not be used.
+
+
+.. py:data:: OP_NO_SSLv2
+             OP_NO_SSLv3
+             OP_NO_TLSv1
+             OP_NO_TLSv1_1
+             OP_NO_TLSv1_2
+
+    Constants used with :py:meth:`set_options` of Context objects.
+
+    Each of these options disables one version of the SSL/TLS protocol.  This
+    is interesting if you're using e.g. :py:const:`SSLv23_METHOD` to get an
+    SSLv2-compatible handshake, but don't want to use SSLv2.  If the underlying
+    OpenSSL build is missing support for any of these protocols, the
+    :py:const:`OP_NO_*` constant may be undefined.
+
+
+.. py:data:: SSLEAY_VERSION
+             SSLEAY_CFLAGS
+             SSLEAY_BUILT_ON
+             SSLEAY_PLATFORM
+             SSLEAY_DIR
+
+    Constants used with :py:meth:`SSLeay_version` to specify what OpenSSL version
+    information to retrieve.  See the man page for the :py:func:`SSLeay_version` C
+    API for details.
+
+
+.. py:data:: SESS_CACHE_OFF
+             SESS_CACHE_CLIENT
+             SESS_CACHE_SERVER
+             SESS_CACHE_BOTH
+             SESS_CACHE_NO_AUTO_CLEAR
+             SESS_CACHE_NO_INTERNAL_LOOKUP
+             SESS_CACHE_NO_INTERNAL_STORE
+             SESS_CACHE_NO_INTERNAL
+
+     Constants used with :py:meth:`Context.set_session_cache_mode` to specify
+     the behavior of the session cache and potential session reuse.  See the man
+     page for the :py:func:`SSL_CTX_set_session_cache_mode` C API for details.
+
+     .. versionadded:: 0.14
+
+
+.. py:data:: OPENSSL_VERSION_NUMBER
+
+    An integer giving the version number of the OpenSSL library used to build this
+    version of pyOpenSSL.  See the man page for the :py:func:`SSLeay_version` C API
+    for details.
+
+
+.. py:function:: SSLeay_version(type)
+
+    Retrieve a string describing some aspect of the underlying OpenSSL version.  The
+    type passed in should be one of the :py:const:`SSLEAY_*` constants defined in
+    this module.
+
+
+.. py:data:: ContextType
+
+    See :py:class:`Context`.
+
+
+.. py:class:: Context(method)
+
+    A class representing SSL contexts.  Contexts define the parameters of one or
+    more SSL connections.
+
+    *method* should be :py:const:`SSLv2_METHOD`, :py:const:`SSLv3_METHOD`,
+    :py:const:`SSLv23_METHOD`, :py:const:`TLSv1_METHOD`, :py:const:`TLSv1_1_METHOD`,
+    or :py:const:`TLSv1_2_METHOD`.
+
+
+.. py:class:: Session()
+
+    A class representing an SSL session.  A session defines certain connection
+    parameters which may be re-used to speed up the setup of subsequent
+    connections.
+
+    .. versionadded:: 0.14
+
+
+.. py:data:: ConnectionType
+
+    See :py:class:`Connection`.
+
+
+.. py:class:: Connection(context, socket)
+
+    A class representing SSL connections.
+
+    *context* should be an instance of :py:class:`Context` and *socket*
+    should be a socket [#connection-context-socket]_  object.  *socket* may be
+    *None*; in this case, the Connection is created with a memory BIO: see
+    the :py:meth:`bio_read`, :py:meth:`bio_write`, and :py:meth:`bio_shutdown`
+    methods.
+
+.. py:exception:: Error
+
+    This exception is used as a base class for the other SSL-related
+    exceptions, but may also be raised directly.
+
+    Whenever this exception is raised directly, it has a list of error messages
+    from the OpenSSL error queue, where each item is a tuple *(lib, function,
+    reason)*. Here *lib*, *function* and *reason* are all strings, describing
+    where and what the problem is. See :manpage:`err(3)` for more information.
+
+
+.. py:exception:: ZeroReturnError
+
+    This exception matches the error return code
+    :py:data:`SSL_ERROR_ZERO_RETURN`, and is raised when the SSL Connection has
+    been closed. In SSL 3.0 and TLS 1.0, this only occurs if a closure alert has
+    occurred in the protocol, i.e.  the connection has been closed cleanly. Note
+    that this does not necessarily mean that the transport layer (e.g. a socket)
+    has been closed.
+
+    It may seem a little strange that this is an exception, but it does match an
+    :py:data:`SSL_ERROR` code, and is very convenient.
+
+
+.. py:exception:: WantReadError
+
+    The operation did not complete; the same I/O method should be called again
+    later, with the same arguments. Any I/O method can lead to this since new
+    handshakes can occur at any time.
+
+    The wanted read is for **dirty** data sent over the network, not the
+    **clean** data inside the tunnel.  For a socket based SSL connection,
+    **read** means data coming at us over the network.  Until that read
+    succeeds, the attempted :py:meth:`OpenSSL.SSL.Connection.recv`,
+    :py:meth:`OpenSSL.SSL.Connection.send`, or
+    :py:meth:`OpenSSL.SSL.Connection.do_handshake` is prevented or incomplete. You
+    probably want to :py:meth:`select()` on the socket before trying again.
+
+
+.. py:exception:: WantWriteError
+
+    See :py:exc:`WantReadError`.  The socket send buffer may be too full to
+    write more data.
+
+
+.. py:exception:: WantX509LookupError
+
+    The operation did not complete because an application callback has asked to be
+    called again. The I/O method should be called again later, with the same
+    arguments.
+
+    .. note:: This won't occur in this version, as there are no such
+        callbacks in this version.
+
+
+.. py:exception:: SysCallError
+
+    The :py:exc:`SysCallError` occurs when there's an I/O error and OpenSSL's
+    error queue does not contain any information. This can mean two things: An
+    error in the transport protocol, or an end of file that violates the protocol.
+    The parameter to the exception is always a pair *(errnum,
+    errstr)*.
+
+
+
+.. _openssl-context:
+
+Context objects
+---------------
+
+Context objects have the following methods:
+
+.. :py:class:: OpenSSL.SSL.Context
+
+.. py:method:: Context.check_privatekey()
+
+    Check if the private key (loaded with :py:meth:`use_privatekey`) matches the
+    certificate (loaded with :py:meth:`use_certificate`).  Returns
+    :py:data:`None` if they match, raises :py:exc:`Error` otherwise.
+
+
+.. py:method:: Context.get_app_data()
+
+    Retrieve application data as set by :py:meth:`set_app_data`.
+
+
+.. py:method:: Context.get_cert_store()
+
+    Retrieve the certificate store (a X509Store object) that the context uses.
+    This can be used to add "trusted" certificates without using the
+    :py:meth:`load_verify_locations` method.
+
+
+.. py:method:: Context.get_timeout()
+
+    Retrieve session timeout, as set by :py:meth:`set_timeout`. The default is 300
+    seconds.
+
+
+.. py:method:: Context.get_verify_depth()
+
+    Retrieve the Context object's verify depth, as set by
+    :py:meth:`set_verify_depth`.
+
+
+.. py:method:: Context.get_verify_mode()
+
+    Retrieve the Context object's verify mode, as set by :py:meth:`set_verify`.
+
+
+.. py:method:: Context.load_client_ca(pemfile)
+
+    Read a file with PEM-formatted certificates that will be sent to the client
+    when requesting a client certificate.
+
+
+.. py:method:: Context.set_client_ca_list(certificate_authorities)
+
+    Replace the current list of preferred certificate signers that would be
+    sent to the client when requesting a client certificate with the
+    *certificate_authorities* sequence of :py:class:`OpenSSL.crypto.X509Name`'s.
+
+    .. versionadded:: 0.10
+
+
+.. py:method:: Context.add_client_ca(certificate_authority)
+
+    Extract a :py:class:`OpenSSL.crypto.X509Name` from the *certificate_authority*
+    :py:class:`OpenSSL.crypto.X509` certificate and add it to the list of preferred
+    certificate signers sent to the client when requesting a client certificate.
+
+    .. versionadded:: 0.10
+
+
+.. py:method:: Context.load_verify_locations(pemfile, capath)
+
+    Specify where CA certificates for verification purposes are located. These
+    are trusted certificates. Note that the certificates have to be in PEM
+    format.  If capath is passed, it must be a directory prepared using the
+    ``c_rehash`` tool included with OpenSSL.  Either, but not both, of
+    *pemfile* or *capath* may be :py:data:`None`.
+
+
+.. py:method:: Context.set_default_verify_paths()
+
+    Specify that the platform provided CA certificates are to be used for
+    verification purposes.  This method may not work properly on OS X.
+
+
+.. py:method:: Context.load_tmp_dh(dhfile)
+
+    Load parameters for Ephemeral Diffie-Hellman from *dhfile*.
+
+
+.. py:method:: Context.set_tmp_ecdh(curve)
+
+   Select a curve to use for ECDHE key exchange.
+
+   The valid values of *curve* are the objects returned by
+   :py:func:`OpenSSL.crypto.get_elliptic_curves` or
+   :py:func:`OpenSSL.crypto.get_elliptic_curve`.
+
+
+.. py:method:: Context.set_app_data(data)
+
+    Associate *data* with this Context object. *data* can be retrieved
+    later using the :py:meth:`get_app_data` method.
+
+
+.. py:method:: Context.set_cipher_list(ciphers)
+
+    Set the list of ciphers to be used in this context. See the OpenSSL manual for
+    more information (e.g. :manpage:`ciphers(1)`)
+
+
+.. py:method:: Context.set_info_callback(callback)
+
+    Set the information callback to *callback*. This function will be called
+    from time to time during SSL handshakes.
+
+    *callback* should take three arguments: a Connection object and two integers.
+    The first integer specifies where in the SSL handshake the function was
+    called, and the other the return code from a (possibly failed) internal
+    function call.
+
+
+.. py:method:: Context.set_options(options)
+
+    Add SSL options. Options you have set before are not cleared!
+    This method should be used with the :py:const:`OP_*` constants.
+
+
+.. py:method:: Context.set_mode(mode)
+
+   Add SSL mode. Modes you have set before are not cleared!  This method should
+   be used with the :py:const:`MODE_*` constants.
+
+
+.. py:method:: Context.set_passwd_cb(callback[, userdata])
+
+    Set the passphrase callback to *callback*. This function will be called
+    when a private key with a passphrase is loaded. *callback* must accept
+    three positional arguments.  First, an integer giving the maximum length of
+    the passphrase it may return.  If the returned passphrase is longer than
+    this, it will be truncated.  Second, a boolean value which will be true if
+    the user should be prompted for the passphrase twice and the callback should
+    verify that the two values supplied are equal. Third, the value given as the
+    *userdata* parameter to :py:meth:`set_passwd_cb`.  If an error occurs,
+    *callback* should return a false value (e.g. an empty string).
+
+
+.. py:method:: Context.set_session_cache_mode(mode)
+
+    Set the behavior of the session cache used by all connections using this
+    Context.  The previously set mode is returned.  See :py:const:`SESS_CACHE_*`
+    for details about particular modes.
+
+    .. versionadded:: 0.14
+
+
+.. py:method:: Context.get_session_cache_mode()
+
+    Get the current session cache mode.
+
+    .. versionadded:: 0.14
+
+
+.. py:method:: Context.set_session_id(name)
+
+    Set the context *name* within which a session can be reused for this
+    Context object. This is needed when doing session resumption, because there is
+    no way for a stored session to know which Context object it is associated with.
+    *name* may be any binary data.
+
+
+.. py:method:: Context.set_timeout(timeout)
+
+    Set the timeout for newly created sessions for this Context object to
+    *timeout*. *timeout* must be given in (whole) seconds. The default
+    value is 300 seconds. See the OpenSSL manual for more information (e.g.
+    :manpage:`SSL_CTX_set_timeout(3)`).
+
+
+.. py:method:: Context.set_verify(mode, callback)
+
+    Set the verification flags for this Context object to *mode* and specify
+    that *callback* should be used for verification callbacks. *mode* should be
+    one of :py:const:`VERIFY_NONE` and :py:const:`VERIFY_PEER`. If
+    :py:const:`VERIFY_PEER` is used, *mode* can be OR:ed with
+    :py:const:`VERIFY_FAIL_IF_NO_PEER_CERT` and :py:const:`VERIFY_CLIENT_ONCE`
+    to further control the behaviour.
+
+    *callback* should take five arguments: A Connection object, an X509 object,
+    and three integer variables, which are in turn potential error number, error
+    depth and return code. *callback* should return true if verification passes
+    and false otherwise.
+
+
+.. py:method:: Context.set_verify_depth(depth)
+
+    Set the maximum depth for the certificate chain verification that shall be
+    allowed for this Context object.
+
+
+.. py:method:: Context.use_certificate(cert)
+
+    Use the certificate *cert* which has to be a X509 object.
+
+
+.. py:method:: Context.add_extra_chain_cert(cert)
+
+    Adds the certificate *cert*, which has to be a X509 object, to the
+    certificate chain presented together with the certificate.
+
+
+.. py:method:: Context.use_certificate_chain_file(file)
+
+    Load a certificate chain from *file* which must be PEM encoded.
+
+
+.. py:method:: Context.use_privatekey(pkey)
+
+    Use the private key *pkey* which has to be a PKey object.
+
+
+.. py:method:: Context.use_certificate_file(file[, format])
+
+    Load the first certificate found in *file*. The certificate must be in the
+    format specified by *format*, which is either :py:const:`FILETYPE_PEM` or
+    :py:const:`FILETYPE_ASN1`. The default is :py:const:`FILETYPE_PEM`.
+
+
+.. py:method:: Context.use_privatekey_file(file[, format])
+
+    Load the first private key found in *file*. The private key must be in the
+    format specified by *format*, which is either :py:const:`FILETYPE_PEM` or
+    :py:const:`FILETYPE_ASN1`. The default is :py:const:`FILETYPE_PEM`.
+
+
+.. py:method:: Context.set_tlsext_servername_callback(callback)
+
+    Specify a one-argument callable to use as the TLS extension server name
+    callback.  When a connection using the server name extension is made using
+    this context, the callback will be invoked with the :py:class:`Connection`
+    instance.
+
+    .. versionadded:: 0.13
+
+
+.. py:method:: Context.set_npn_advertise_callback(callback)
+
+    Specify a callback function that will be called when offering `Next
+    Protocol Negotiation
+    <https://technotes.googlecode.com/git/nextprotoneg.html>`_ as a server.
+
+    *callback* should be the callback function.  It will be invoked with one
+    argument, the :py:class:`Connection` instance.  It should return a list of
+    bytestrings representing the advertised protocols, like
+    ``[b'http/1.1', b'spdy/2']``.
+
+    .. versionadded:: 0.15
+
+
+.. py:method:: Context.set_npn_select_callback(callback):
+
+    Specify a callback function that will be called when a server offers Next
+    Protocol Negotiation options.
+
+    *callback* should be the callback function.  It will be invoked with two
+    arguments: the :py:class:`Connection`, and a list of offered protocols as
+    bytestrings, e.g. ``[b'http/1.1', b'spdy/2']``.  It should return one of
+    those bytestrings, the chosen protocol.
+
+    .. versionadded:: 0.15
+
+.. py:method:: Context.set_alpn_protos(protos)
+
+    Specify the protocols that the client is prepared to speak after the TLS
+    connection has been negotiated using Application Layer Protocol
+    Negotiation.
+
+    *protos* should be a list of protocols that the client is offering, each
+    as a bytestring. For example, ``[b'http/1.1', b'spdy/2']``.
+
+
+.. py:method:: Context.set_alpn_select_callback(callback)
+
+    Specify a callback function that will be called on the server when a client
+    offers protocols using Application Layer Protocol Negotiation.
+
+    *callback* should be the callback function. It will be invoked with two
+    arguments: the :py:class:`Connection` and a list of offered protocols as
+    bytestrings, e.g. ``[b'http/1.1', b'spdy/2']``. It should return one of
+    these bytestrings, the chosen protocol.
+
+
+.. _openssl-session:
+
+Session objects
+---------------
+
+Session objects have no methods.
+
+
+.. _openssl-connection:
+
+Connection objects
+------------------
+
+Connection objects have the following methods:
+
+.. py:method:: Connection.accept()
+
+    Call the :py:meth:`accept` method of the underlying socket and set up SSL on the
+    returned socket, using the Context object supplied to this Connection object at
+    creation. Returns a pair *(conn, address)*. where *conn* is the new
+    Connection object created, and *address* is as returned by the socket's
+    :py:meth:`accept`.
+
+
+.. py:method:: Connection.bind(address)
+
+    Call the :py:meth:`bind` method of the underlying socket.
+
+
+.. py:method:: Connection.close()
+
+    Call the :py:meth:`close` method of the underlying socket. Note: If you want
+    correct SSL closure, you need to call the :py:meth:`shutdown` method first.
+
+
+.. py:method:: Connection.connect(address)
+
+    Call the :py:meth:`connect` method of the underlying socket and set up SSL on the
+    socket, using the Context object supplied to this Connection object at
+    creation.
+
+
+.. py:method:: Connection.connect_ex(address)
+
+    Call the :py:meth:`connect_ex` method of the underlying socket and set up SSL on
+    the socket, using the Context object supplied to this Connection object at
+    creation. Note that if the :py:meth:`connect_ex` method of the socket doesn't
+    return 0, SSL won't be initialized.
+
+
+.. py:method:: Connection.do_handshake()
+
+    Perform an SSL handshake (usually called after :py:meth:`renegotiate` or one of
+    :py:meth:`set_accept_state` or :py:meth:`set_accept_state`). This can raise the
+    same exceptions as :py:meth:`send` and :py:meth:`recv`.
+
+
+.. py:method:: Connection.fileno()
+
+    Retrieve the file descriptor number for the underlying socket.
+
+
+.. py:method:: Connection.listen(backlog)
+
+    Call the :py:meth:`listen` method of the underlying socket.
+
+
+.. py:method:: Connection.get_app_data()
+
+    Retrieve application data as set by :py:meth:`set_app_data`.
+
+
+.. py:method:: Connection.get_cipher_list()
+
+    Retrieve the list of ciphers used by the Connection object. WARNING: This API
+    has changed. It used to take an optional parameter and just return a string,
+    but not it returns the entire list in one go.
+
+
+.. py:method:: Connection.get_client_ca_list()
+
+    Retrieve the list of preferred client certificate issuers sent by the server
+    as :py:class:`OpenSSL.crypto.X509Name` objects.
+
+    If this is a client :py:class:`Connection`, the list will be empty until the
+    connection with the server is established.
+
+    If this is a server :py:class:`Connection`, return the list of certificate
+    authorities that will be sent or has been sent to the client, as controlled
+    by this :py:class:`Connection`'s :py:class:`Context`.
+
+    .. versionadded:: 0.10
+
+
+.. py:method:: Connection.get_context()
+
+    Retrieve the Context object associated with this Connection.
+
+
+.. py:method:: Connection.set_context(context)
+
+    Specify a replacement Context object for this Connection.
+
+
+.. py:method:: Connection.get_peer_certificate()
+
+    Retrieve the other side's certificate (if any)
+
+
+.. py:method:: Connection.get_peer_cert_chain()
+
+    Retrieve the tuple of the other side's certificate chain (if any)
+
+
+.. py:method:: Connection.getpeername()
+
+    Call the :py:meth:`getpeername` method of the underlying socket.
+
+
+.. py:method:: Connection.getsockname()
+
+    Call the :py:meth:`getsockname` method of the underlying socket.
+
+
+.. py:method:: Connection.getsockopt(level, optname[, buflen])
+
+    Call the :py:meth:`getsockopt` method of the underlying socket.
+
+
+.. py:method:: Connection.pending()
+
+    Retrieve the number of bytes that can be safely read from the SSL buffer
+    (**not** the underlying transport buffer).
+
+
+.. py:method:: Connection.recv(bufsize)
+
+    Receive data from the Connection. The return value is a string representing the
+    data received. The maximum amount of data to be received at once, is specified
+    by *bufsize*.
+
+
+.. py:method:: Connection.recv_into(buffer[, nbytes[, flags]])
+
+    Receive data from the Connection and copy it directly into the provided
+    buffer. The return value is the number of bytes read from the connection.
+    The maximum amount of data to be received at once is specified by *nbytes*.
+    *flags* is accepted for compatibility with ``socket.recv_into`` but its
+    value is ignored.
+
+.. py:method:: Connection.bio_write(bytes)
+
+    If the Connection was created with a memory BIO, this method can be used to add
+    bytes to the read end of that memory BIO.  The Connection can then read the
+    bytes (for example, in response to a call to :py:meth:`recv`).
+
+
+.. py:method:: Connection.renegotiate()
+
+    Renegotiate the SSL session. Call this if you wish to change cipher suites or
+    anything like that.
+
+
+.. py:method:: Connection.send(string)
+
+    Send the *string* data to the Connection.
+
+
+.. py:method:: Connection.bio_read(bufsize)
+
+    If the Connection was created with a memory BIO, this method can be used to
+    read bytes from the write end of that memory BIO.  Many Connection methods will
+    add bytes which must be read in this manner or the buffer will eventually fill
+    up and the Connection will be able to take no further actions.
+
+
+.. py:method:: Connection.sendall(string)
+
+    Send all of the *string* data to the Connection. This calls :py:meth:`send`
+    repeatedly until all data is sent. If an error occurs, it's impossible to tell
+    how much data has been sent.
+
+
+.. py:method:: Connection.set_accept_state()
+
+    Set the connection to work in server mode. The handshake will be handled
+    automatically by read/write.
+
+
+.. py:method:: Connection.set_app_data(data)
+
+    Associate *data* with this Connection object. *data* can be retrieved
+    later using the :py:meth:`get_app_data` method.
+
+
+.. py:method:: Connection.set_connect_state()
+
+    Set the connection to work in client mode. The handshake will be handled
+    automatically by read/write.
+
+
+.. py:method:: Connection.setblocking(flag)
+
+    Call the :py:meth:`setblocking` method of the underlying socket.
+
+
+.. py:method:: Connection.setsockopt(level, optname, value)
+
+    Call the :py:meth:`setsockopt` method of the underlying socket.
+
+
+.. py:method:: Connection.shutdown()
+
+    Send the shutdown message to the Connection. Returns true if the shutdown
+    message exchange is completed and false otherwise (in which case you call
+    :py:meth:`recv` or :py:meth:`send` when the connection becomes
+    readable/writeable.
+
+
+.. py:method:: Connection.get_shutdown()
+
+    Get the shutdown state of the Connection.  Returns a bitvector of either or
+    both of *SENT_SHUTDOWN* and *RECEIVED_SHUTDOWN*.
+
+
+.. py:method:: Connection.set_shutdown(state)
+
+    Set the shutdown state of the Connection.  *state* is a bitvector of
+    either or both of *SENT_SHUTDOWN* and *RECEIVED_SHUTDOWN*.
+
+
+.. py:method:: Connection.sock_shutdown(how)
+
+    Call the :py:meth:`shutdown` method of the underlying socket.
+
+
+.. py:method:: Connection.bio_shutdown()
+
+    If the Connection was created with a memory BIO, this method can be used to
+    indicate that *end of file* has been reached on the read end of that memory
+    BIO.
+
+
+.. py:method:: Connection.state_string()
+
+    Retrieve a verbose string detailing the state of the Connection.
+
+
+.. py:method:: Connection.client_random()
+
+    Retrieve the random value used with the client hello message.
+
+
+.. py:method:: Connection.server_random()
+
+    Retrieve the random value used with the server hello message.
+
+
+.. py:method:: Connection.master_key()
+
+    Retrieve the value of the master key for this session.
+
+
+.. py:method:: Connection.want_read()
+
+    Checks if more data has to be read from the transport layer to complete an
+    operation.
+
+
+.. py:method:: Connection.want_write()
+
+    Checks if there is data to write to the transport layer to complete an
+    operation.
+
+
+.. py:method:: Connection.set_tlsext_host_name(name)
+
+    Specify the byte string to send as the server name in the client hello message.
+
+    .. versionadded:: 0.13
+
+
+.. py:method:: Connection.get_servername()
+
+    Get the value of the server name received in the client hello message.
+
+    .. versionadded:: 0.13
+
+
+.. py:method:: Connection.get_session()
+
+    Get a :py:class:`Session` instance representing the SSL session in use by
+    the connection, or :py:obj:`None` if there is no session.
+
+    .. versionadded:: 0.14
+
+
+.. py:method:: Connection.set_session(session)
+
+    Set a new SSL session (using a :py:class:`Session` instance) to be used by
+    the connection.
+
+    .. versionadded:: 0.14
+
+
+.. py:method:: Connection.get_finished()
+
+    Obtain latest TLS Finished message that we sent, or :py:obj:`None` if
+    handshake is not completed.
+
+    .. versionadded:: 0.15
+
+
+.. py:method:: Connection.get_peer_finished()
+
+    Obtain latest TLS Finished message that we expected from peer, or
+    :py:obj:`None` if handshake is not completed.
+
+    .. versionadded:: 0.15
+
+
+.. py:method:: Connection.get_cipher_name()
+
+    Obtain the name of the currently used cipher.
+
+    .. versionadded:: 0.15
+
+
+.. py:method:: Connection.get_cipher_bits()
+
+    Obtain the number of secret bits of the currently used cipher.
+
+    .. versionadded:: 0.15
+
+
+.. py:method:: Connection.get_cipher_version()
+
+    Obtain the protocol name of the currently used cipher.
+
+    .. versionadded:: 0.15
+
+
+.. py:method:: Connection.get_next_proto_negotiated():
+
+    Get the protocol that was negotiated by Next Protocol Negotiation. Returns
+    a bytestring of the protocol name. If no protocol has been negotiated yet,
+    returns an empty string.
+
+    .. versionadded:: 0.15
+
+.. py:method:: Connection.set_alpn_protos(protos)
+
+    Specify the protocols that the client is prepared to speak after the TLS
+    connection has been negotiated using Application Layer Protocol
+    Negotiation.
+
+    *protos* should be a list of protocols that the client is offering, each
+    as a bytestring. For example, ``[b'http/1.1', b'spdy/2']``.
+
+
+.. py:method:: Connection.get_alpn_proto_negotiated()
+
+    Get the protocol that was negotiated by Application Layer Protocol
+    Negotiation. Returns a bytestring of the protocol name. If no protocol has
+    been negotiated yet, returns an empty string.
+
+
+.. Rubric:: Footnotes
+
+.. [#connection-context-socket] Actually, all that is required is an object that
+    **behaves** like a socket, you could even use files, even though it'd be
+    tricky to get the handshakes right!
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/api.rst hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/api.rst
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/api.rst	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/api.rst	2014-01-10 11:06:42.000000000 +0100
@@ -0,0 +1,18 @@
+.. _openssl:
+
+:py:mod:`OpenSSL` --- Python interface to OpenSSL
+=================================================
+
+.. py:module:: OpenSSL
+   :synopsis: Python interface to OpenSSL
+
+
+This package provides a high-level interface to the functions in the
+OpenSSL library. The following modules are defined:
+
+.. toctree::
+   :maxdepth: 2
+
+   api/crypto
+   api/rand
+   api/ssl
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/conf.py hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/conf.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/conf.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/conf.py	2015-04-15 01:02:27.000000000 +0200
@@ -0,0 +1,219 @@
+# -*- coding: utf-8 -*-
+#
+# pyOpenSSL documentation build configuration file, created by
+# sphinx-quickstart on Sat Jul 16 07:12:22 2011.
+#
+# This file is execfile()d with the current directory set to its containing dir.
+#
+# Note that not all possible configuration values are present in this
+# autogenerated file.
+#
+# All configuration values have a default; values that are commented out
+# serve to show the default.
+
+import sys, os
+
+DOC_DIR = os.path.abspath(os.path.dirname(__file__))
+sys.path.insert(0, os.path.abspath(os.path.join(DOC_DIR, "..")))
+
+# If extensions (or modules to document with autodoc) are in another directory,
+# add these directories to sys.path here. If the directory is relative to the
+# documentation root, use os.path.abspath to make it absolute, like shown here.
+#sys.path.insert(0, os.path.abspath('.'))
+
+# -- General configuration -----------------------------------------------------
+
+# If your documentation needs a minimal Sphinx version, state it here.
+needs_sphinx = '1.0'
+
+# Add any Sphinx extension module names here, as strings. They can be extensions
+# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
+extensions = []
+
+# Add any paths that contain templates here, relative to this directory.
+templates_path = ['_templates']
+
+# The suffix of source filenames.
+source_suffix = '.rst'
+
+# The encoding of source files.
+#source_encoding = 'utf-8-sig'
+
+# The master toctree document.
+master_doc = 'index'
+
+# General information about the project.
+project = u'pyOpenSSL'
+copyright = u'2011, Jean-Paul Calderone'
+
+# The version info for the project you're documenting, acts as replacement for
+# |version| and |release|, also used in various other places throughout the
+# built documents.
+#
+# The short X.Y version.
+version = '0.15.1'
+# The full version, including alpha/beta/rc tags.
+release = version
+
+# The language for content autogenerated by Sphinx. Refer to documentation
+# for a list of supported languages.
+#language = None
+
+# There are two options for replacing |today|: either, you set today to some
+# non-false value, then it is used:
+#today = ''
+# Else, today_fmt is used as the format for a strftime call.
+#today_fmt = '%B %d, %Y'
+
+# List of patterns, relative to source directory, that match files and
+# directories to ignore when looking for source files.
+exclude_patterns = ['_build']
+
+# The reST default role (used for this markup: `text`) to use for all documents.
+#default_role = None
+
+# If true, '()' will be appended to :func: etc. cross-reference text.
+#add_function_parentheses = True
+
+# If true, the current module name will be prepended to all description
+# unit titles (such as .. function::).
+#add_module_names = True
+
+# If true, sectionauthor and moduleauthor directives will be shown in the
+# output. They are ignored by default.
+#show_authors = False
+
+# The name of the Pygments (syntax highlighting) style to use.
+pygments_style = 'sphinx'
+
+# A list of ignored prefixes for module index sorting.
+#modindex_common_prefix = []
+
+
+# -- Options for HTML output ---------------------------------------------------
+
+# The theme to use for HTML and HTML Help pages.  See the documentation for
+# a list of builtin themes.
+html_theme = 'default'
+
+# Theme options are theme-specific and customize the look and feel of a theme
+# further.  For a list of options available for each theme, see the
+# documentation.
+#html_theme_options = {}
+
+# Add any paths that contain custom themes here, relative to this directory.
+#html_theme_path = []
+
+# The name for this set of Sphinx documents.  If None, it defaults to
+# "<project> v<release> documentation".
+#html_title = None
+
+# A shorter title for the navigation bar.  Default is the same as html_title.
+#html_short_title = None
+
+# The name of an image file (relative to this directory) to place at the top
+# of the sidebar.
+#html_logo = None
+
+# The name of an image file (within the static path) to use as favicon of the
+# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
+# pixels large.
+#html_favicon = None
+
+# Add any paths that contain custom static files (such as style sheets) here,
+# relative to this directory. They are copied after the builtin static files,
+# so a file named "default.css" will overwrite the builtin "default.css".
+html_static_path = ['_static']
+
+# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
+# using the given strftime format.
+#html_last_updated_fmt = '%b %d, %Y'
+
+# If true, SmartyPants will be used to convert quotes and dashes to
+# typographically correct entities.
+#html_use_smartypants = True
+
+# Custom sidebar templates, maps document names to template names.
+#html_sidebars = {}
+
+# Additional templates that should be rendered to pages, maps page names to
+# template names.
+#html_additional_pages = {}
+
+# If false, no module index is generated.
+#html_domain_indices = True
+
+# If false, no index is generated.
+#html_use_index = True
+
+# If true, the index is split into individual pages for each letter.
+#html_split_index = False
+
+# If true, links to the reST sources are added to the pages.
+#html_show_sourcelink = True
+
+# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
+#html_show_sphinx = True
+
+# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
+#html_show_copyright = True
+
+# If true, an OpenSearch description file will be output, and all pages will
+# contain a <link> tag referring to it.  The value of this option must be the
+# base URL from which the finished HTML is served.
+#html_use_opensearch = ''
+
+# This is the file name suffix for HTML files (e.g. ".xhtml").
+#html_file_suffix = None
+
+# Output file base name for HTML help builder.
+htmlhelp_basename = 'pyOpenSSLdoc'
+
+
+# -- Options for LaTeX output --------------------------------------------------
+
+# The paper size ('letter' or 'a4').
+#latex_paper_size = 'letter'
+
+# The font size ('10pt', '11pt' or '12pt').
+#latex_font_size = '10pt'
+
+# Grouping the document tree into LaTeX files. List of tuples
+# (source start file, target name, title, author, documentclass [howto/manual]).
+latex_documents = [
+  ('index', 'pyOpenSSL.tex', u'pyOpenSSL Documentation',
+   u'Jean-Paul Calderone', 'manual'),
+]
+
+# The name of an image file (relative to this directory) to place at the top of
+# the title page.
+#latex_logo = None
+
+# For "manual" documents, if this is true, then toplevel headings are parts,
+# not chapters.
+#latex_use_parts = False
+
+# If true, show page references after internal links.
+#latex_show_pagerefs = False
+
+# If true, show URL addresses after external links.
+#latex_show_urls = False
+
+# Additional stuff for the LaTeX preamble.
+#latex_preamble = ''
+
+# Documents to append as an appendix to all manuals.
+#latex_appendices = []
+
+# If false, no module index is generated.
+#latex_domain_indices = True
+
+
+# -- Options for manual page output --------------------------------------------
+
+# One entry per manual page. List of tuples
+# (source start file, name, description, authors, manual section).
+man_pages = [
+    ('index', 'pyopenssl', u'pyOpenSSL Documentation',
+     [u'Jean-Paul Calderone'], 1)
+]
BinÃ¤rdateien hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/images/pyopenssl-brand.png und hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/images/pyopenssl-brand.png sind verschieden.
BinÃ¤rdateien hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/images/pyopenssl-icon.png und hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/images/pyopenssl-icon.png sind verschieden.
BinÃ¤rdateien hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/images/pyopenssl-logo.png und hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/images/pyopenssl-logo.png sind verschieden.
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/images/pyopenssl.svg hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/images/pyopenssl.svg
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/images/pyopenssl.svg	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/images/pyopenssl.svg	2014-01-10 11:06:42.000000000 +0100
@@ -0,0 +1,152 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<!-- Created with Inkscape (http://www.inkscape.org/) -->
+<svg
+   xmlns:dc="http://purl.org/dc/elements/1.1/"
+   xmlns:cc="http://web.resource.org/cc/"
+   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
+   xmlns:svg="http://www.w3.org/2000/svg"
+   xmlns="http://www.w3.org/2000/svg"
+   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
+   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
+   width="637.02179"
+   height="374.65021"
+   id="svg2"
+   sodipodi:version="0.32"
+   inkscape:version="0.45.1"
+   sodipodi:docbase="/home/glyph"
+   sodipodi:docname="pyopenssl.svg"
+   inkscape:output_extension="org.inkscape.output.svg.inkscape"
+   version="1.0">
+  <defs
+     id="defs4" />
+  <sodipodi:namedview
+     id="base"
+     pagecolor="#ffffff"
+     bordercolor="#666666"
+     borderopacity="1.0"
+     gridtolerance="10000"
+     guidetolerance="10"
+     objecttolerance="10"
+     inkscape:pageopacity="0.0"
+     inkscape:pageshadow="2"
+     inkscape:zoom="1.4"
+     inkscape:cx="280.76485"
+     inkscape:cy="162.58007"
+     inkscape:document-units="px"
+     inkscape:current-layer="layer1"
+     showguides="true"
+     inkscape:guide-bbox="true"
+     inkscape:window-width="1243"
+     inkscape:window-height="997"
+     inkscape:window-x="31"
+     inkscape:window-y="21"
+     inkscape:showpageshadow="true"
+     showborder="false" />
+  <metadata
+     id="metadata7">
+    <rdf:RDF>
+      <cc:Work
+         rdf:about="">
+        <dc:format>image/svg+xml</dc:format>
+        <dc:type
+           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
+      </cc:Work>
+    </rdf:RDF>
+  </metadata>
+  <g
+     inkscape:label="Layer 1"
+     inkscape:groupmode="layer"
+     id="layer1"
+     transform="translate(-48,-348.42626)">
+    <g
+       id="g3322"
+       transform="translate(-46,0)">
+      <path
+         sodipodi:nodetypes="cccccc"
+         id="rect3192"
+         d="M 659.97827,570.41187 L 731.02176,570.41187 L 694.59319,588.79075 L 731.02176,607.16964 L 659.97827,607.16964 L 659.97827,570.41187 z "
+         style="fill:#e90000;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:0.67079389;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-opacity:1" />
+      <path
+         id="rect3182"
+         d="M 134.03397,541.66071 C 111.9415,541.66071 94,562.76288 94,588.78571 C 94,614.80857 111.9415,635.94196 134.03397,635.94196 C 136.3665,635.94196 138.62869,635.67498 140.85222,635.22321 L 595.87054,635.22321 L 595.87054,542.34821 L 140.85222,542.34821 C 138.62869,541.89644 136.3665,541.66071 134.03397,541.66071 z "
+         style="fill:#00b900;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:1;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1" />
+      <g
+         transform="translate(15.714286,-0.7142857)"
+         style="fill:#00b900;fill-opacity:1"
+         id="g3222">
+        <path
+           style="opacity:1;fill:#00b900;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:34.88786697;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
+           d="M 528.3125,511.0625 C 518.6717,511.04975 510.84826,518.8592 510.84375,528.5 L 510.84375,650.5 C 510.83762,655.13488 512.6761,659.58169 515.95346,662.85904 C 519.23081,666.1364 523.67762,667.97488 528.3125,667.96875 L 605.5625,667.96875 C 615.2033,667.96424 623.01275,660.1408 623,650.5 L 623,528.5 C 622.99549,518.8714 615.1911,511.06701 605.5625,511.0625 L 528.3125,511.0625 z "
+           id="rect3184"
+           sodipodi:nodetypes="cccscccccc" />
+        <path
+           style="opacity:1;fill:#00b900;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:41.47727203;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
+           d="M 584.03125,551.28125 C 572.56922,551.27611 563.27611,560.56922 563.28125,572.03125 L 563.28125,607 C 563.29337,618.44983 572.58142,627.72388 584.03125,627.71875 L 646.84375,627.71875 C 658.28138,627.70665 667.5504,618.43763 667.5625,607 L 667.5625,572.03125 C 667.56763,560.58142 658.29358,551.29337 646.84375,551.28125 L 584.03125,551.28125 z "
+           id="rect3190" />
+      </g>
+      <g
+         transform="translate(15.714286,-2.846549)"
+         id="g3218">
+        <path
+           sodipodi:type="arc"
+           style="opacity:1;fill:#ffffff;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:1;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
+           id="path3206"
+           sodipodi:cx="564.28571"
+           sodipodi:cy="551.64789"
+           sodipodi:rx="21.428572"
+           sodipodi:ry="21.428572"
+           d="M 585.71428 551.64789 A 21.428572 21.428572 0 1 1  542.85713,551.64789 A 21.428572 21.428572 0 1 1  585.71428 551.64789 z"
+           transform="translate(2.6361696,0)" />
+        <path
+           d="M 585.71428 551.64789 A 21.428572 21.428572 0 1 1  542.85713,551.64789 A 21.428572 21.428572 0 1 1  585.71428 551.64789 z"
+           sodipodi:ry="21.428572"
+           sodipodi:rx="21.428572"
+           sodipodi:cy="551.64789"
+           sodipodi:cx="564.28571"
+           id="path3208"
+           style="opacity:1;fill:#ffffff;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:1;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
+           sodipodi:type="arc"
+           transform="translate(2.6361696,80)" />
+      </g>
+      <g
+         transform="translate(15.714286,7.8520886)"
+         id="g3214">
+        <path
+           sodipodi:type="arc"
+           style="opacity:1;fill:#000000;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:1;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
+           id="path3210"
+           sodipodi:cx="564.28571"
+           sodipodi:cy="551.64789"
+           sodipodi:rx="21.428572"
+           sodipodi:ry="21.428572"
+           d="M 585.71428 551.64789 A 21.428572 21.428572 0 1 1  542.85713,551.64789 A 21.428572 21.428572 0 1 1  585.71428 551.64789 z"
+           transform="matrix(0.3666667,0,0,0.3666667,440.95238,363.99605)" />
+        <path
+           d="M 585.71428 551.64789 A 21.428572 21.428572 0 1 1  542.85713,551.64789 A 21.428572 21.428572 0 1 1  585.71428 551.64789 z"
+           sodipodi:ry="21.428572"
+           sodipodi:rx="21.428572"
+           sodipodi:cy="551.64789"
+           sodipodi:cx="564.28571"
+           id="path3212"
+           style="opacity:1;fill:#000000;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:1;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
+           sodipodi:type="arc"
+           transform="matrix(0.3666667,0,0,0.3666667,440.95238,393.32938)" />
+      </g>
+    </g>
+    <path
+       style="fill:#7f7f7f;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:50;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
+       d="M 220.092,348.42626 C 208.29083,348.42743 198.7244,357.99387 198.72322,369.79504 L 198.72322,460.05141 L 229.54768,460.05141 L 229.54768,394.58282 C 229.54853,386.11098 236.40795,379.25157 244.87978,379.25072 L 371.11584,379.25072 C 379.58768,379.25157 386.44709,386.11096 386.44794,394.58282 L 386.44794,460.05141 L 417.29911,460.05141 L 417.29911,369.79504 C 417.29792,357.99386 407.7315,348.42744 395.93033,348.42626 L 220.092,348.42626 z "
+       id="rect2182" />
+    <rect
+       style="fill:#000000;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:3;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
+       id="rect2160"
+       width="268.57144"
+       height="268.57144"
+       x="173.71428"
+       y="454.50504" />
+    <path
+       style="fill:#b3b3b3;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:1;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1;opacity:1"
+       d="M 308,488.80638 C 278.42857,488.80638 254.4375,512.8287 254.4375,542.40013 C 254.4375,562.41092 265.41804,579.85847 281.6875,589.05638 L 224.09375,688.77513 L 391.90625,688.77513 L 334.3125,589.05638 C 350.58196,579.85847 361.56251,562.41092 361.5625,542.40013 C 361.5625,512.8287 337.57142,488.80639 308,488.80638 z "
+       id="path3292" />
+  </g>
+</svg>
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/index.rst hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/index.rst
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/index.rst	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/index.rst	2014-02-10 10:21:27.000000000 +0100
@@ -0,0 +1,26 @@
+Welcome to pyOpenSSL's documentation!
+=====================================
+
+.. topic:: Abstract
+
+   This module is a rather thin wrapper around (a subset of) the OpenSSL library.
+   With thin wrapper I mean that a lot of the object methods do nothing more than
+   calling a corresponding function in the OpenSSL library.
+
+
+Contents:
+
+.. toctree::
+   :maxdepth: 3
+
+   introduction
+   api
+   internals
+
+Indices and tables
+==================
+
+* :ref:`genindex`
+* :ref:`modindex`
+* :ref:`search`
+
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/internals.rst hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/internals.rst
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/internals.rst	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/internals.rst	2014-02-10 10:21:27.000000000 +0100
@@ -0,0 +1,69 @@
+.. _internals:
+
+Internals
+=========
+
+We ran into three main problems developing this: Exceptions, callbacks and
+accessing socket methods. This is what this chapter is about.
+
+
+.. _exceptions:
+
+Exceptions
+----------
+
+We realized early that most of the exceptions would be raised by the I/O
+functions of OpenSSL, so it felt natural to mimic OpenSSL's error code system,
+translating them into Python exceptions. This naturally gives us the exceptions
+:py:exc:`.SSL.ZeroReturnError`, :py:exc:`.SSL.WantReadError`,
+:py:exc:`.SSL.WantWriteError`, :py:exc:`.SSL.WantX509LookupError` and
+:py:exc:`.SSL.SysCallError`.
+
+For more information about this, see section :ref:`openssl-ssl`.
+
+
+.. _callbacks:
+
+Callbacks
+---------
+
+Callbacks were more of a problem when pyOpenSSL was written in C.
+Having switched to being written in Python using cffi, callbacks are now straightforward.
+The problems that originally existed no longer do
+(if you are interested in the details you can find descriptions of those problems in the version control history for this document).
+
+.. _socket-methods:
+
+Accessing Socket Methods
+------------------------
+
+We quickly saw the benefit of wrapping socket methods in the
+:py:class:`.SSL.Connection` class, for an easy transition into using SSL. The
+problem here is that the :py:mod:`socket` module lacks a C API, and all the
+methods are declared static. One approach would be to have :py:mod:`.OpenSSL` as
+a submodule to the :py:mod:`socket` module, placing all the code in
+``socketmodule.c``, but this is obviously not a good solution, since you
+might not want to import tonnes of extra stuff you're not going to use when
+importing the :py:mod:`socket` module. The other approach is to somehow get a
+pointer to the method to be called, either the C function, or a callable Python
+object. This is not really a good solution either, since there's a lot of
+lookups involved.
+
+The way it works is that you have to supply a :py:class:`socket`- **like** transport
+object to the :py:class:`.SSL.Connection`. The only requirement of this object is
+that it has a :py:meth:`fileno()` method that returns a file descriptor that's
+valid at the C level (i.e. you can use the system calls read and write). If you
+want to use the :py:meth:`connect()` or :py:meth:`accept()` methods of the
+:py:class:`.SSL.Connection` object, the transport object has to supply such
+methods too. Apart from them, any method lookups in the :py:class:`.SSL.Connection`
+object that fail are passed on to the underlying transport object.
+
+Future changes might be to allow Python-level transport objects, that instead
+of having :py:meth:`fileno()` methods, have :py:meth:`read()` and :py:meth:`write()`
+methods, so more advanced features of Python can be used. This would probably
+entail some sort of OpenSSL **BIOs**, but converting Python strings back and
+forth is expensive, so this shouldn't be used unless necessary. Other nice
+things would be to be able to pass in different transport objects for reading
+and writing, but then the :py:meth:`fileno()` method of :py:class:`.SSL.Connection`
+becomes virtually useless. Also, should the method resolution be used on the
+read-transport or the write-transport?
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/introduction.rst hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/introduction.rst
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/introduction.rst	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/introduction.rst	2014-01-10 11:06:42.000000000 +0100
@@ -0,0 +1,17 @@
+.. _intro:
+
+Introduction
+============
+
+The reason pyOpenSSL was created is that the SSL support in the socket module in
+Python 2.1 (the contemporary version of Python when the pyOpenSSL project was
+begun) was severely limited.  Other OpenSSL wrappers for Python at the time were
+also limited, though in different ways.  Unfortunately, Python's standard
+library SSL support has remained weak, although other packages (such as
+`M2Crypto <http://chandlerproject.org/Projects/MeTooCrypto>`_)
+have made great advances and now equal or exceed pyOpenSSL's functionality.
+
+The reason pyOpenSSL continues to be maintained is that there is a significant
+user community around it, as well as a large amount of software which depends on
+it.  It is a great benefit to many people for pyOpenSSL to continue to exist and
+advance.
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/make.bat hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/make.bat
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/make.bat	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/make.bat	2014-01-10 11:06:42.000000000 +0100
@@ -0,0 +1,170 @@
+@ECHO OFF
+
+REM Command file for Sphinx documentation
+
+if "%SPHINXBUILD%" == "" (
+	set SPHINXBUILD=sphinx-build
+)
+set BUILDDIR=_build
+set ALLSPHINXOPTS=-d %BUILDDIR%/doctrees %SPHINXOPTS% .
+if NOT "%PAPER%" == "" (
+	set ALLSPHINXOPTS=-D latex_paper_size=%PAPER% %ALLSPHINXOPTS%
+)
+
+if "%1" == "" goto help
+
+if "%1" == "help" (
+	:help
+	echo.Please use `make ^<target^>` where ^<target^> is one of
+	echo.  html       to make standalone HTML files
+	echo.  dirhtml    to make HTML files named index.html in directories
+	echo.  singlehtml to make a single large HTML file
+	echo.  pickle     to make pickle files
+	echo.  json       to make JSON files
+	echo.  htmlhelp   to make HTML files and a HTML help project
+	echo.  qthelp     to make HTML files and a qthelp project
+	echo.  devhelp    to make HTML files and a Devhelp project
+	echo.  epub       to make an epub
+	echo.  latex      to make LaTeX files, you can set PAPER=a4 or PAPER=letter
+	echo.  text       to make text files
+	echo.  man        to make manual pages
+	echo.  changes    to make an overview over all changed/added/deprecated items
+	echo.  linkcheck  to check all external links for integrity
+	echo.  doctest    to run all doctests embedded in the documentation if enabled
+	goto end
+)
+
+if "%1" == "clean" (
+	for /d %%i in (%BUILDDIR%\*) do rmdir /q /s %%i
+	del /q /s %BUILDDIR%\*
+	goto end
+)
+
+if "%1" == "html" (
+	%SPHINXBUILD% -b html %ALLSPHINXOPTS% %BUILDDIR%/html
+	if errorlevel 1 exit /b 1
+	echo.
+	echo.Build finished. The HTML pages are in %BUILDDIR%/html.
+	goto end
+)
+
+if "%1" == "dirhtml" (
+	%SPHINXBUILD% -b dirhtml %ALLSPHINXOPTS% %BUILDDIR%/dirhtml
+	if errorlevel 1 exit /b 1
+	echo.
+	echo.Build finished. The HTML pages are in %BUILDDIR%/dirhtml.
+	goto end
+)
+
+if "%1" == "singlehtml" (
+	%SPHINXBUILD% -b singlehtml %ALLSPHINXOPTS% %BUILDDIR%/singlehtml
+	if errorlevel 1 exit /b 1
+	echo.
+	echo.Build finished. The HTML pages are in %BUILDDIR%/singlehtml.
+	goto end
+)
+
+if "%1" == "pickle" (
+	%SPHINXBUILD% -b pickle %ALLSPHINXOPTS% %BUILDDIR%/pickle
+	if errorlevel 1 exit /b 1
+	echo.
+	echo.Build finished; now you can process the pickle files.
+	goto end
+)
+
+if "%1" == "json" (
+	%SPHINXBUILD% -b json %ALLSPHINXOPTS% %BUILDDIR%/json
+	if errorlevel 1 exit /b 1
+	echo.
+	echo.Build finished; now you can process the JSON files.
+	goto end
+)
+
+if "%1" == "htmlhelp" (
+	%SPHINXBUILD% -b htmlhelp %ALLSPHINXOPTS% %BUILDDIR%/htmlhelp
+	if errorlevel 1 exit /b 1
+	echo.
+	echo.Build finished; now you can run HTML Help Workshop with the ^
+.hhp project file in %BUILDDIR%/htmlhelp.
+	goto end
+)
+
+if "%1" == "qthelp" (
+	%SPHINXBUILD% -b qthelp %ALLSPHINXOPTS% %BUILDDIR%/qthelp
+	if errorlevel 1 exit /b 1
+	echo.
+	echo.Build finished; now you can run "qcollectiongenerator" with the ^
+.qhcp project file in %BUILDDIR%/qthelp, like this:
+	echo.^> qcollectiongenerator %BUILDDIR%\qthelp\pyOpenSSL.qhcp
+	echo.To view the help file:
+	echo.^> assistant -collectionFile %BUILDDIR%\qthelp\pyOpenSSL.ghc
+	goto end
+)
+
+if "%1" == "devhelp" (
+	%SPHINXBUILD% -b devhelp %ALLSPHINXOPTS% %BUILDDIR%/devhelp
+	if errorlevel 1 exit /b 1
+	echo.
+	echo.Build finished.
+	goto end
+)
+
+if "%1" == "epub" (
+	%SPHINXBUILD% -b epub %ALLSPHINXOPTS% %BUILDDIR%/epub
+	if errorlevel 1 exit /b 1
+	echo.
+	echo.Build finished. The epub file is in %BUILDDIR%/epub.
+	goto end
+)
+
+if "%1" == "latex" (
+	%SPHINXBUILD% -b latex %ALLSPHINXOPTS% %BUILDDIR%/latex
+	if errorlevel 1 exit /b 1
+	echo.
+	echo.Build finished; the LaTeX files are in %BUILDDIR%/latex.
+	goto end
+)
+
+if "%1" == "text" (
+	%SPHINXBUILD% -b text %ALLSPHINXOPTS% %BUILDDIR%/text
+	if errorlevel 1 exit /b 1
+	echo.
+	echo.Build finished. The text files are in %BUILDDIR%/text.
+	goto end
+)
+
+if "%1" == "man" (
+	%SPHINXBUILD% -b man %ALLSPHINXOPTS% %BUILDDIR%/man
+	if errorlevel 1 exit /b 1
+	echo.
+	echo.Build finished. The manual pages are in %BUILDDIR%/man.
+	goto end
+)
+
+if "%1" == "changes" (
+	%SPHINXBUILD% -b changes %ALLSPHINXOPTS% %BUILDDIR%/changes
+	if errorlevel 1 exit /b 1
+	echo.
+	echo.The overview file is in %BUILDDIR%/changes.
+	goto end
+)
+
+if "%1" == "linkcheck" (
+	%SPHINXBUILD% -b linkcheck %ALLSPHINXOPTS% %BUILDDIR%/linkcheck
+	if errorlevel 1 exit /b 1
+	echo.
+	echo.Link check complete; look for any errors in the above output ^
+or in %BUILDDIR%/linkcheck/output.txt.
+	goto end
+)
+
+if "%1" == "doctest" (
+	%SPHINXBUILD% -b doctest %ALLSPHINXOPTS% %BUILDDIR%/doctest
+	if errorlevel 1 exit /b 1
+	echo.
+	echo.Testing of doctests in the sources finished, look at the ^
+results in %BUILDDIR%/doctest/output.txt.
+	goto end
+)
+
+:end
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/Makefile hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/Makefile
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/Makefile	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/Makefile	2014-01-10 11:06:42.000000000 +0100
@@ -1,20 +1,130 @@
-PAPER = a4
-MKHOWTO = python tools/mkhowto --$(PAPER)
+# Makefile for Sphinx documentation
+#
 
-default: html
-
-all: ps html text dvi
-
-dvi ps text: pyOpenSSL.tex
-	$(MKHOWTO) --$@ $^
-
-html: pyOpenSSL.tex
-	$(MKHOWTO) --html --iconserver . $^
-	-rm -rf html
-	mv pyOpenSSL html
+# You can set these variables from the command line.
+SPHINXOPTS    =
+SPHINXBUILD   = sphinx-build
+PAPER         =
+BUILDDIR      = _build
+
+# Internal variables.
+PAPEROPT_a4     = -D latex_paper_size=a4
+PAPEROPT_letter = -D latex_paper_size=letter
+ALLSPHINXOPTS   = -d $(BUILDDIR)/doctrees $(PAPEROPT_$(PAPER)) $(SPHINXOPTS) .
+
+.PHONY: help clean html dirhtml singlehtml pickle json htmlhelp qthelp devhelp epub latex latexpdf text man changes linkcheck doctest
+
+help:
+	@echo "Please use \`make <target>' where <target> is one of"
+	@echo "  html       to make standalone HTML files"
+	@echo "  dirhtml    to make HTML files named index.html in directories"
+	@echo "  singlehtml to make a single large HTML file"
+	@echo "  pickle     to make pickle files"
+	@echo "  json       to make JSON files"
+	@echo "  htmlhelp   to make HTML files and a HTML help project"
+	@echo "  qthelp     to make HTML files and a qthelp project"
+	@echo "  devhelp    to make HTML files and a Devhelp project"
+	@echo "  epub       to make an epub"
+	@echo "  latex      to make LaTeX files, you can set PAPER=a4 or PAPER=letter"
+	@echo "  latexpdf   to make LaTeX files and run them through pdflatex"
+	@echo "  text       to make text files"
+	@echo "  man        to make manual pages"
+	@echo "  changes    to make an overview of all changed/added/deprecated items"
+	@echo "  linkcheck  to check all external links for integrity"
+	@echo "  doctest    to run all doctests embedded in the documentation (if enabled)"
 
 clean:
-	rm -rf html pyOpenSSL.dvi pyOpenSSL.ps pyOpenSSL.txt \
-	    pyOpenSSL.l2h pyOpenSSL.how
+	-rm -rf $(BUILDDIR)/*
 
-.PHONY: default all html dvi ps text clean
+html:
+	$(SPHINXBUILD) -b html $(ALLSPHINXOPTS) $(BUILDDIR)/html
+	@echo
+	@echo "Build finished. The HTML pages are in $(BUILDDIR)/html."
+
+dirhtml:
+	$(SPHINXBUILD) -b dirhtml $(ALLSPHINXOPTS) $(BUILDDIR)/dirhtml
+	@echo
+	@echo "Build finished. The HTML pages are in $(BUILDDIR)/dirhtml."
+
+singlehtml:
+	$(SPHINXBUILD) -b singlehtml $(ALLSPHINXOPTS) $(BUILDDIR)/singlehtml
+	@echo
+	@echo "Build finished. The HTML page is in $(BUILDDIR)/singlehtml."
+
+pickle:
+	$(SPHINXBUILD) -b pickle $(ALLSPHINXOPTS) $(BUILDDIR)/pickle
+	@echo
+	@echo "Build finished; now you can process the pickle files."
+
+json:
+	$(SPHINXBUILD) -b json $(ALLSPHINXOPTS) $(BUILDDIR)/json
+	@echo
+	@echo "Build finished; now you can process the JSON files."
+
+htmlhelp:
+	$(SPHINXBUILD) -b htmlhelp $(ALLSPHINXOPTS) $(BUILDDIR)/htmlhelp
+	@echo
+	@echo "Build finished; now you can run HTML Help Workshop with the" \
+	      ".hhp project file in $(BUILDDIR)/htmlhelp."
+
+qthelp:
+	$(SPHINXBUILD) -b qthelp $(ALLSPHINXOPTS) $(BUILDDIR)/qthelp
+	@echo
+	@echo "Build finished; now you can run "qcollectiongenerator" with the" \
+	      ".qhcp project file in $(BUILDDIR)/qthelp, like this:"
+	@echo "# qcollectiongenerator $(BUILDDIR)/qthelp/pyOpenSSL.qhcp"
+	@echo "To view the help file:"
+	@echo "# assistant -collectionFile $(BUILDDIR)/qthelp/pyOpenSSL.qhc"
+
+devhelp:
+	$(SPHINXBUILD) -b devhelp $(ALLSPHINXOPTS) $(BUILDDIR)/devhelp
+	@echo
+	@echo "Build finished."
+	@echo "To view the help file:"
+	@echo "# mkdir -p $$HOME/.local/share/devhelp/pyOpenSSL"
+	@echo "# ln -s $(BUILDDIR)/devhelp $$HOME/.local/share/devhelp/pyOpenSSL"
+	@echo "# devhelp"
+
+epub:
+	$(SPHINXBUILD) -b epub $(ALLSPHINXOPTS) $(BUILDDIR)/epub
+	@echo
+	@echo "Build finished. The epub file is in $(BUILDDIR)/epub."
+
+latex:
+	$(SPHINXBUILD) -b latex $(ALLSPHINXOPTS) $(BUILDDIR)/latex
+	@echo
+	@echo "Build finished; the LaTeX files are in $(BUILDDIR)/latex."
+	@echo "Run \`make' in that directory to run these through (pdf)latex" \
+	      "(use \`make latexpdf' here to do that automatically)."
+
+latexpdf:
+	$(SPHINXBUILD) -b latex $(ALLSPHINXOPTS) $(BUILDDIR)/latex
+	@echo "Running LaTeX files through pdflatex..."
+	make -C $(BUILDDIR)/latex all-pdf
+	@echo "pdflatex finished; the PDF files are in $(BUILDDIR)/latex."
+
+text:
+	$(SPHINXBUILD) -b text $(ALLSPHINXOPTS) $(BUILDDIR)/text
+	@echo
+	@echo "Build finished. The text files are in $(BUILDDIR)/text."
+
+man:
+	$(SPHINXBUILD) -b man $(ALLSPHINXOPTS) $(BUILDDIR)/man
+	@echo
+	@echo "Build finished. The manual pages are in $(BUILDDIR)/man."
+
+changes:
+	$(SPHINXBUILD) -b changes $(ALLSPHINXOPTS) $(BUILDDIR)/changes
+	@echo
+	@echo "The overview file is in $(BUILDDIR)/changes."
+
+linkcheck:
+	$(SPHINXBUILD) -b linkcheck $(ALLSPHINXOPTS) $(BUILDDIR)/linkcheck
+	@echo
+	@echo "Link check complete; look for any errors in the above output " \
+	      "or in $(BUILDDIR)/linkcheck/output.txt."
+
+doctest:
+	$(SPHINXBUILD) -b doctest $(ALLSPHINXOPTS) $(BUILDDIR)/doctest
+	@echo "Testing of doctests in the sources finished, look at the " \
+	      "results in $(BUILDDIR)/doctest/output.txt."
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/pyOpenSSL.tex hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/pyOpenSSL.tex
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/pyOpenSSL.tex	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/pyOpenSSL.tex	1970-01-01 01:00:00.000000000 +0100
@@ -1,1451 +0,0 @@
-\documentclass{howto}
-
-\title{Python OpenSSL Manual}
-
-\release{0.13}
-
-\author{Jean-Paul Calderone}
-\authoraddress{\email{exarkun@twistedmatrix.com}}
-
-\usepackage[english]{babel}
-\usepackage[T1]{fontenc}
-
-\begin{document}
-
-\maketitle
-
-\begin{abstract}
-\noindent
-This module is a rather thin wrapper around (a subset of) the OpenSSL library.
-With thin wrapper I mean that a lot of the object methods do nothing more than
-calling a corresponding function in the OpenSSL library.
-\end{abstract}
-
-\tableofcontents
-
-
-\section{Introduction \label{intro}}
-
-The reason pyOpenSSL was created is that the SSL support in the socket module
-in Python 2.1 (the contemporary version of Python when the pyOpenSSL project
-was begun) was severely limited.  Other OpenSSL wrappers for Python at the time
-were also limited, though in different ways.  Unfortunately, Python's standard
-library SSL support has remained weak, although other packages (such as
-M2Crypto\footnote{See \url{http://chandlerproject.org/Projects/MeTooCrypto}})
-have made great advances and now equal or exceed pyOpenSSL's functionality.
-
-The reason pyOpenSSL continues to be maintained is that there is a significant
-user community around it, as well as a large amount of software which depends
-on it.  It is a great benefit to many people for pyOpenSSL to continue to exist
-and advance.
-
-\section{Building and Installing \label{building}}
-
-These instructions can also be found in the file \verb|INSTALL|.
-
-I have tested this on Debian Linux systems (woody and sid), Solaris 2.6 and
-2.7. Others have successfully compiled it on Windows and NT.
-
-\subsection{Building the Module on a Unix System \label{building-unix}}
-
-pyOpenSSL uses distutils, so there really shouldn't be any problems. To build
-the library:
-\begin{verbatim}
-python setup.py build
-\end{verbatim}
-
-If your OpenSSL header files aren't in \verb|/usr/include|, you may need to
-supply the \verb|-I| flag to let the setup script know where to look. The same
-goes for the libraries of course, use the \verb|-L| flag. Note that
-\verb|build| won't accept these flags, so you have to run first
-\verb|build_ext| and then \verb|build|! Example:
-\begin{verbatim}
-python setup.py build_ext -I/usr/local/ssl/include -L/usr/local/ssl/lib
-python setup.py build
-\end{verbatim}
-
-Now you should have a directory called \verb|OpenSSL| that contains e.g.
-\verb|SSL.so| and \verb|__init__.py| somewhere in the build dicrectory,
-so just:
-\begin{verbatim}
-python setup.py install
-\end{verbatim}
-
-If you, for some arcane reason, don't want the module to appear in the
-\verb|site-packages| directory, use the \verb|--prefix| option.
-
-You can, of course, do
-\begin{verbatim}
-python setup.py --help
-\end{verbatim}
-
-to find out more about how to use the script.
-
-\subsection{Building the Module on a Windows System \label{building-windows}}
-
-Big thanks to Itamar Shtull-Trauring and Oleg Orlov for their help with
-Windows build instructions.  Same as for Unix systems, we have to separate
-the \verb|build_ext| and the \verb|build|.
-
-Building the library:
-
-\begin{verbatim}
-setup.py build_ext -I ...\openssl\inc32 -L ...\openssl\out32dll
-setup.py build
-\end{verbatim}
-
-Where \verb|...\openssl| is of course the location of your OpenSSL installation.
-
-Installation is the same as for Unix systems:
-\begin{verbatim}
-setup.py install
-\end{verbatim}
-
-And similarily, you can do
-\begin{verbatim}
-setup.py --help
-\end{verbatim}
-
-to get more information.
-
-
-\section{\module{OpenSSL} --- Python interface to OpenSSL \label{openssl}}
-
-\declaremodule{extension}{OpenSSL}
-\modulesynopsis{Python interface to OpenSSL}
-
-This package provides a high-level interface to the functions in the
-OpenSSL library. The following modules are defined:
-
-\begin{datadesc}{crypto}
-Generic cryptographic module. Note that if anything is incomplete, this module is!
-\end{datadesc}
-
-\begin{datadesc}{rand}
-An interface to the OpenSSL pseudo random number generator.
-\end{datadesc}
-
-\begin{datadesc}{SSL}
-An interface to the SSL-specific parts of OpenSSL.
-\end{datadesc}
-
-
-% % % crypto moduleOpenSSL
-
-\subsection{\module{crypto} --- Generic cryptographic module \label{openssl-crypto}}
-
-\declaremodule{extension}{crypto}
-\modulesynopsis{Generic cryptographic module}
-
-\begin{datadesc}{X509Type}
-See \class{X509}.
-\end{datadesc}
-
-\begin{classdesc}{X509}{}
-A class representing X.509 certificates.
-\end{classdesc}
-
-\begin{datadesc}{X509NameType}
-See \class{X509Name}.
-\end{datadesc}
-
-\begin{classdesc}{X509Name}{x509name}
-A class representing X.509 Distinguished Names.
-
-This constructor creates a copy of \var{x509name} which should be an
-instance of \class{X509Name}.
-\end{classdesc}
-
-\begin{datadesc}{X509ReqType}
-See \class{X509Req}.
-\end{datadesc}
-
-\begin{classdesc}{X509Req}{}
-A class representing X.509 certificate requests.
-\end{classdesc}
-
-\begin{datadesc}{X509StoreType}
-A Python type object representing the X509Store object type.
-\end{datadesc}
-
-\begin{datadesc}{PKeyType}
-See \class{PKey}.
-\end{datadesc}
-
-\begin{classdesc}{PKey}{}
-A class representing DSA or RSA keys.
-\end{classdesc}
-
-\begin{datadesc}{PKCS7Type}
-A Python type object representing the PKCS7 object type.
-\end{datadesc}
-
-\begin{datadesc}{PKCS12Type}
-A Python type object representing the PKCS12 object type.
-\end{datadesc}
-
-\begin{datadesc}{X509ExtensionType}
-See \class{X509Extension}.
-\end{datadesc}
-
-\begin{classdesc}{X509Extension}{typename, critical, value\optional{, subject}\optional{, issuer}}
-A class representing an X.509 v3 certificate extensions.
-See \url{http://openssl.org/docs/apps/x509v3_config.html\#STANDARD_EXTENSIONS}
-for \var{typename} strings and their options.
-Optional parameters \var{subject} and \var{issuer} must be X509 objects.
-\end{classdesc}
-
-\begin{datadesc}{NetscapeSPKIType}
-See \class{NetscapeSPKI}.
-\end{datadesc}
-
-\begin{classdesc}{NetscapeSPKI}{\optional{enc}}
-A class representing Netscape SPKI objects.
-
-If the \var{enc} argument is present, it should be a base64-encoded string
-representing a NetscapeSPKI object, as returned by the \method{b64_encode}
-method.
-\end{classdesc}
-
-\begin{classdesc}{CRL}{}
-A class representing Certifcate Revocation List objects.
-\end{classdesc}
-
-\begin{classdesc}{Revoked}{}
-A class representing Revocation objects of CRL.
-\end{classdesc}
-
-\begin{datadesc}{FILETYPE_PEM}
-\dataline{FILETYPE_ASN1}
-File type constants.
-\end{datadesc}
-
-\begin{datadesc}{TYPE_RSA}
-\dataline{TYPE_DSA}
-Key type constants.
-\end{datadesc}
-
-\begin{excdesc}{Error}
-Generic exception used in the \module{crypto} module.
-\end{excdesc}
-
-\begin{funcdesc}{dump_certificate}{type, cert}
-Dump the certificate \var{cert} into a buffer string encoded with the type
-\var{type}.
-\end{funcdesc}
-
-\begin{funcdesc}{dump_certificate_request}{type, req}
-Dump the certificate request \var{req} into a buffer string encoded with the
-type \var{type}.
-\end{funcdesc}
-
-\begin{funcdesc}{dump_privatekey}{type, pkey\optional{, cipher, passphrase}}
-Dump the private key \var{pkey} into a buffer string encoded with the type
-\var{type}, optionally (if \var{type} is \constant{FILETYPE_PEM}) encrypting it
-using \var{cipher} and \var{passphrase}.
-
-\var{passphrase} must be either a string or a callback for providing the
-pass phrase.
-\end{funcdesc}
-
-\begin{funcdesc}{load_certificate}{type, buffer}
-Load a certificate (X509) from the string \var{buffer} encoded with the
-type \var{type}.
-\end{funcdesc}
-
-\begin{funcdesc}{load_certificate_request}{type, buffer}
-Load a certificate request (X509Req) from the string \var{buffer} encoded with
-the type \var{type}.
-\end{funcdesc}
-
-\begin{funcdesc}{load_privatekey}{type, buffer\optional{, passphrase}}
-Load a private key (PKey) from the string \var{buffer} encoded with
-the type \var{type} (must be one of \constant{FILETYPE_PEM} and
-\constant{FILETYPE_ASN1}).
-
-\var{passphrase} must be either a string or a callback for providing the
-pass phrase.
-\end{funcdesc}
-
-\begin{funcdesc}{load_crl}{type, buffer}
-Load Certificate Revocation List (CRL) data from a string \var{buffer}.
-\var{buffer} encoded with the type \var{type}.  The type \var{type}
-must either \constant{FILETYPE_PEM} or \constant{FILETYPE_ASN1}).
-\end{funcdesc}
-
-\begin{funcdesc}{load_pkcs7_data}{type, buffer}
-Load pkcs7 data from the string \var{buffer} encoded with the type \var{type}.
-\end{funcdesc}
-
-\begin{funcdesc}{load_pkcs12}{buffer\optional{, passphrase}}
-Load pkcs12 data from the string \var{buffer}. If the pkcs12 structure is
-encrypted, a \var{passphrase} must be included.  The MAC is always
-checked and thus required.
-
-See also the man page for the C function \function{PKCS12_parse}.
-\end{funcdesc}
-
-\begin{funcdesc}{sign}{key, data, digest}
-Sign a data string using the given key and message digest.
-
-\var{key} is a \code{PKey} instance.  \var{data} is a \code{str} instance.
-\var{digest} is a \code{str} naming a supported message digest type, for example
-\code{``sha1''}.
-\versionadded{0.11}
-\end{funcdesc}
-
-\begin{funcdesc}{verify}{certificate, signature, data, digest}
-Verify the signature for a data string.
-
-\var{certificate} is a \code{X509} instance corresponding to the private key
-which generated the signature.  \var{signature} is a \var{str} instance giving
-the signature itself.  \var{data} is a \var{str} instance giving the data to
-which the signature applies.  \var{digest} is a \var{str} instance naming the
-message digest type of the signature, for example \code{``sha1''}.
-\versionadded{0.11}
-\end{funcdesc}
-
-\subsubsection{X509 objects \label{openssl-x509}}
-
-X509 objects have the following methods:
-
-\begin{methoddesc}[X509]{get_issuer}{}
-Return an X509Name object representing the issuer of the certificate.
-\end{methoddesc}
-
-\begin{methoddesc}[X509]{get_pubkey}{}
-Return a PKey object representing the public key of the certificate.
-\end{methoddesc}
-
-\begin{methoddesc}[X509]{get_serial_number}{}
-Return the certificate serial number.
-\end{methoddesc}
-
-\begin{methoddesc}[X509]{get_signature_algorithm}{}
-Return the signature algorithm used in the certificate.  If the algorithm is
-undefined, raise \code{ValueError}.
-\end{methoddesc}
-
-\begin{methoddesc}[X509]{get_subject}{}
-Return an X509Name object representing the subject of the certificate.
-\end{methoddesc}
-
-\begin{methoddesc}[X509]{get_version}{}
-Return the certificate version.
-\end{methoddesc}
-
-\begin{methoddesc}[X509]{get_notBefore}{}
-Return a string giving the time before which the certificate is not valid.  The
-string is formatted as an ASN1 GENERALIZEDTIME:
-\begin{verbatim}
-                 YYYYMMDDhhmmssZ
-                 YYYYMMDDhhmmss+hhmm
-                 YYYYMMDDhhmmss-hhmm
-\end{verbatim}
-If no value exists for this field, \code{None} is returned.
-\end{methoddesc}
-
-\begin{methoddesc}[X509]{get_notAfter}{}
-Return a string giving the time after which the certificate is not valid.  The
-string is formatted as an ASN1 GENERALIZEDTIME:
-\begin{verbatim}
-                 YYYYMMDDhhmmssZ
-                 YYYYMMDDhhmmss+hhmm
-                 YYYYMMDDhhmmss-hhmm
-\end{verbatim}
-If no value exists for this field, \code{None} is returned.
-\end{methoddesc}
-
-\begin{methoddesc}[X509]{set_notBefore}{when}
-Change the time before which the certificate is not valid.  \var{when} is a
-string formatted as an ASN1 GENERALIZEDTIME:
-\begin{verbatim}
-                 YYYYMMDDhhmmssZ
-                 YYYYMMDDhhmmss+hhmm
-                 YYYYMMDDhhmmss-hhmm
-\end{verbatim}
-\end{methoddesc}
-
-\begin{methoddesc}[X509]{set_notAfter}{when}
-Change the time after which the certificate is not valid.  \var{when} is a
-string formatted as an ASN1 GENERALIZEDTIME:
-\begin{verbatim}
-                 YYYYMMDDhhmmssZ
-                 YYYYMMDDhhmmss+hhmm
-                 YYYYMMDDhhmmss-hhmm
-\end{verbatim}
-\end{methoddesc}
-
-\begin{methoddesc}[X509]{gmtime_adj_notBefore}{time}
-Adjust the timestamp (in GMT) when the certificate starts being valid.
-\end{methoddesc}
-
-\begin{methoddesc}[X509]{gmtime_adj_notAfter}{time}
-Adjust the timestamp (in GMT) when the certificate stops being valid.
-\end{methoddesc}
-
-\begin{methoddesc}[X509]{has_expired}{}
-Checks the certificate's time stamp against current time. Returns true if the
-certificate has expired and false otherwise.
-\end{methoddesc}
-
-\begin{methoddesc}[X509]{set_issuer}{issuer}
-Set the issuer of the certificate to \var{issuer}.
-\end{methoddesc}
-
-\begin{methoddesc}[X509]{set_pubkey}{pkey}
-Set the public key of the certificate to \var{pkey}.
-\end{methoddesc}
-
-\begin{methoddesc}[X509]{set_serial_number}{serialno}
-Set the serial number of the certificate to \var{serialno}.
-\end{methoddesc}
-
-\begin{methoddesc}[X509]{set_subject}{subject}
-Set the subject of the certificate to \var{subject}.
-\end{methoddesc}
-
-\begin{methoddesc}[X509]{set_version}{version}
-Set the certificate version to \var{version}.
-\end{methoddesc}
-
-\begin{methoddesc}[X509]{sign}{pkey, digest}
-Sign the certificate, using the key \var{pkey} and the message digest algorithm
-identified by the string \var{digest}.
-\end{methoddesc}
-
-\begin{methoddesc}[X509]{subject_name_hash}{}
-Return the hash of the certificate subject.
-\end{methoddesc}
-
-\begin{methoddesc}[X509]{digest}{digest_name}
-Return a digest of the certificate, using the \var{digest_name} method.
-\var{digest_name} must be a string describing a digest algorithm supported
-by OpenSSL (by EVP_get_digestbyname, specifically).  For example,
-\constant{"md5"} or \constant{"sha1"}.
-\end{methoddesc}
-
-\begin{methoddesc}[X509]{add_extensions}{extensions}
-Add the extensions in the sequence \var{extensions} to the certificate.
-\end{methoddesc}
-
-\begin{methoddesc}[X509]{get_extension_count}{}
-Return the number of extensions on this certificate.
-\versionadded{0.12}
-\end{methoddesc}
-
-\begin{methoddesc}[X509]{get_extension}{index}
-Retrieve the extension on this certificate at the given index.
-
-Extensions on a certificate are kept in order.  The index parameter selects
-which extension will be returned.  The returned object will be an X509Extension
-instance.
-\versionadded{0.12}
-\end{methoddesc}
-
-\subsubsection{X509Name objects \label{openssl-x509name}}
-
-X509Name objects have the following methods:
-
-\begin{methoddesc}[X509Name]{hash}{}
-Return an integer giving the first four bytes of the MD5 digest of the DER
-representation of the name.
-\end{methoddesc}
-
-\begin{methoddesc}[X509Name]{der}{}
-Return a string giving the DER representation of the name.
-\end{methoddesc}
-
-\begin{methoddesc}[X509Name]{get_components}{}
-Return a list of two-tuples of strings giving the components of the name.
-\end{methoddesc}
-
-X509Name objects have the following members:
-
-\begin{memberdesc}[X509Name]{countryName}
-The country of the entity. \code{C} may be used as an alias for
-\code{countryName}.
-\end{memberdesc}
-
-\begin{memberdesc}[X509Name]{stateOrProvinceName}
-The state or province of the entity. \code{ST} may be used as an alias for
-\code{stateOrProvinceName}·
-\end{memberdesc}
-
-\begin{memberdesc}[X509Name]{localityName}
-The locality of the entity. \code{L} may be used as an alias for
-\code{localityName}.
-\end{memberdesc}
-
-\begin{memberdesc}[X509Name]{organizationName}
-The organization name of the entity. \code{O} may be used as an alias for
-\code{organizationName}.
-\end{memberdesc}
-
-\begin{memberdesc}[X509Name]{organizationalUnitName}
-The organizational unit of the entity. \code{OU} may be used as an alias for
-\code{organizationalUnitName}.
-\end{memberdesc}
-
-\begin{memberdesc}[X509Name]{commonName}
-The common name of the entity. \code{CN} may be used as an alias for
-\code{commonName}.
-\end{memberdesc}
-
-\begin{memberdesc}[X509Name]{emailAddress}
-The e-mail address of the entity.
-\end{memberdesc}
-
-\subsubsection{X509Req objects \label{openssl-x509req}}
-
-X509Req objects have the following methods:
-
-\begin{methoddesc}[X509Req]{get_pubkey}{}
-Return a PKey object representing the public key of the certificate request.
-\end{methoddesc}
-
-\begin{methoddesc}[X509Req]{get_subject}{}
-Return an X509Name object representing the subject of the certificate.
-\end{methoddesc}
-
-\begin{methoddesc}[X509Req]{set_pubkey}{pkey}
-Set the public key of the certificate request to \var{pkey}.
-\end{methoddesc}
-
-\begin{methoddesc}[X509Req]{sign}{pkey, digest}
-Sign the certificate request, using the key \var{pkey} and the message digest
-algorithm identified by the string \var{digest}.
-\end{methoddesc}
-
-\begin{methoddesc}[X509Req]{verify}{pkey}
-Verify a certificate request using the public key \var{pkey}.
-\end{methoddesc}
-
-\begin{methoddesc}[X509Req]{set_version}{version}
-Set the version (RFC 2459, 4.1.2.1) of the certificate request to
-\var{version}.
-\end{methoddesc}
-
-\begin{methoddesc}[X509Req]{get_version}{}
-Get the version (RFC 2459, 4.1.2.1) of the certificate request.
-\end{methoddesc}
-
-\subsubsection{X509Store objects \label{openssl-x509store}}
-
-The X509Store object has currently just one method:
-
-\begin{methoddesc}[X509Store]{add_cert}{cert}
-Add the certificate \var{cert} to the certificate store.
-\end{methoddesc}
-
-\subsubsection{PKey objects \label{openssl-pkey}}
-
-The PKey object has the following methods:
-
-\begin{methoddesc}[PKey]{bits}{}
-Return the number of bits of the key.
-\end{methoddesc}
-
-\begin{methoddesc}[PKey]{generate_key}{type, bits}
-Generate a public/private key pair of the type \var{type} (one of
-\constant{TYPE_RSA} and \constant{TYPE_DSA}) with the size \var{bits}.
-\end{methoddesc}
-
-\begin{methoddesc}[PKey]{type}{}
-Return the type of the key.
-\end{methoddesc}
-
-\begin{methoddesc}[PKey]{check}{}
-Check the consistency of this key, returning True if it is consistent and
-raising an exception otherwise.  This is only valid for RSA keys.  See the
-OpenSSL RSA_check_key man page for further limitations.
-\end{methoddesc}
-
-\subsubsection{PKCS7 objects \label{openssl-pkcs7}}
-
-PKCS7 objects have the following methods:
-
-\begin{methoddesc}[PKCS7]{type_is_signed}{}
-FIXME
-\end{methoddesc}
-
-\begin{methoddesc}[PKCS7]{type_is_enveloped}{}
-FIXME
-\end{methoddesc}
-
-\begin{methoddesc}[PKCS7]{type_is_signedAndEnveloped}{}
-FIXME
-\end{methoddesc}
-
-\begin{methoddesc}[PKCS7]{type_is_data}{}
-FIXME
-\end{methoddesc}
-
-\begin{methoddesc}[PKCS7]{get_type_name}{}
-Get the type name of the PKCS7.
-\end{methoddesc}
-
-\subsubsection{PKCS12 objects \label{openssl-pkcs12}}
-
-PKCS12 objects have the following methods:
-
-\begin{methoddesc}[PKCS12]{export}{\optional{passphrase=None}\optional{, iter=2048}\optional{, maciter=1}}
-Returns a PKCS12 object as a string.
-
-The optional \var{passphrase} must be a string not a callback.
-
-See also the man page for the C function \function{PKCS12_create}.
-\end{methoddesc}
-
-\begin{methoddesc}[PKCS12]{get_ca_certificates}{}
-Return CA certificates within the PKCS12 object as a tuple. Returns
-\constant{None} if no CA certificates are present.
-\end{methoddesc}
-
-\begin{methoddesc}[PKCS12]{get_certificate}{}
-Return certificate portion of the PKCS12 structure.
-\end{methoddesc}
-
-\begin{methoddesc}[PKCS12]{get_friendlyname}{}
-Return friendlyName portion of the PKCS12 structure.
-\end{methoddesc}
-
-\begin{methoddesc}[PKCS12]{get_privatekey}{}
-Return private key portion of the PKCS12 structure
-\end{methoddesc}
-
-\begin{methoddesc}[PKCS12]{set_ca_certificates}{cacerts}
-Replace or set the CA certificates within the PKCS12 object with the sequence \var{cacerts}.
-
-Set \var{cacerts} to \constant{None} to remove all CA certificates.
-\end{methoddesc}
-
-\begin{methoddesc}[PKCS12]{set_certificate}{cert}
-Replace or set the certificate portion of the PKCS12 structure.
-\end{methoddesc}
-
-\begin{methoddesc}[PKCS12]{set_friendlyname}{name}
-Replace or set the friendlyName portion of the PKCS12 structure.
-\end{methoddesc}
-
-\begin{methoddesc}[PKCS12]{set_privatekey}{pkey}
-Replace or set private key portion of the PKCS12 structure
-\end{methoddesc}
-
-\subsubsection{X509Extension objects \label{openssl-509ext}}
-
-X509Extension objects have several methods:
-
-\begin{methoddesc}[X509Extension]{get_critical}{}
-Return the critical field of the extension object.
-\end{methoddesc}
-
-\begin{methoddesc}[X509Extension]{get_short_name}{}
-Retrieve the short descriptive name for this extension.
-
-The result is a byte string like \code{``basicConstraints''}.
-\versionadded{0.12}
-\end{methoddesc}
-
-\begin{methoddesc}[X509Extension]{get_data}{}
-Retrieve the data for this extension.
-
-The result is the ASN.1 encoded form of the extension data as a byte string.
-\versionadded{0.12}
-\end{methoddesc}
-
-\subsubsection{NetscapeSPKI objects \label{openssl-netscape-spki}}
-
-NetscapeSPKI objects have the following methods:
-
-\begin{methoddesc}[NetscapeSPKI]{b64_encode}{}
-Return a base64-encoded string representation of the object.
-\end{methoddesc}
-
-\begin{methoddesc}[NetscapeSPKI]{get_pubkey}{}
-Return the public key of object.
-\end{methoddesc}
-
-\begin{methoddesc}[NetscapeSPKI]{set_pubkey}{key}
-Set the public key of the object to \var{key}.
-\end{methoddesc}
-
-\begin{methoddesc}[NetscapeSPKI]{sign}{key, digest_name}
-Sign the NetscapeSPKI object using the given \var{key} and
-\var{digest_name}.  \var{digest_name} must be a string describing a digest
-algorithm supported by OpenSSL (by EVP_get_digestbyname, specifically).  For
-example, \constant{"md5"} or \constant{"sha1"}.
-\end{methoddesc}
-
-\begin{methoddesc}[NetscapeSPKI]{verify}{key}
-Verify the NetscapeSPKI object using the given \var{key}.
-\end{methoddesc}
-
-\subsubsection{CRL objects \label{crl}}
-
-CRL objects have the following methods:
-
-\begin{methoddesc}[CRL]{add_revoked}{revoked}
-Add a Revoked object to the CRL, by value not reference.
-\end{methoddesc}
-
-\begin{methoddesc}[CRL]{export}{cert, key\optional{, type=FILETYPE_PEM}\optional{, days=100}}
-Use \var{cert} and \var{key} to sign the CRL and return the CRL as a string.
-\var{days} is the number of days before the next CRL is due.
-\end{methoddesc}
-
-\begin{methoddesc}[CRL]{get_revoked}{}
-Return a tuple of Revoked objects, by value not reference.
-\end{methoddesc}
-
-\subsubsection{Revoked objects \label{revoked}}
-
-Revoked objects have the following methods:
-
-\begin{methoddesc}[Revoked]{all_reasons}{}
-Return a list of all supported reasons.
-\end{methoddesc}
-
-\begin{methoddesc}[Revoked]{get_reason}{}
-Return the revocation reason as a str.  Can be
-None, which differs from "Unspecified".
-\end{methoddesc}
-
-\begin{methoddesc}[Revoked]{get_rev_date}{}
-Return the revocation date as a str.
-The string is formatted as an ASN1 GENERALIZEDTIME.
-\end{methoddesc}
-
-\begin{methoddesc}[Revoked]{get_serial}{}
-Return a str containing a hex number of the serial of the revoked certificate.
-\end{methoddesc}
-
-\begin{methoddesc}[Revoked]{set_reason}{reason}
-Set the revocation reason.  \var{reason} must
-be None or a string, but the values are limited.  
-Spaces and case are ignored.  See \method{all_reasons}.
-\end{methoddesc}
-
-\begin{methoddesc}[Revoked]{set_rev_date}{date}
-Set the revocation date.
-The string is formatted as an ASN1 GENERALIZEDTIME.
-\end{methoddesc}
-
-\begin{methoddesc}[Revoked]{set_serial}{serial}
-\var{serial} is a string containing a hex number of the serial of the revoked certificate.
-\end{methoddesc}
-
-
-% % % rand module
-
-\subsection{\module{rand} --- An interface to the OpenSSL pseudo random number generator \label{openssl-rand}}
-
-\declaremodule{extension}{rand}
-\modulesynopsis{An interface to the OpenSSL pseudo random number generator}
-
-This module handles the OpenSSL pseudo random number generator (PRNG) and
-declares the following:
-
-\begin{funcdesc}{add}{string, entropy}
-Mix bytes from \var{string} into the PRNG state. The \var{entropy} argument is
-(the lower bound of) an estimate of how much randomness is contained in
-\var{string}, measured in bytes. For more information, see e.g. \rfc{1750}.
-\end{funcdesc}
-
-\begin{funcdesc}{bytes}{num_bytes}
-Get some random bytes from the PRNG as a string.
-
-This is a wrapper for the C function \function{RAND_bytes}.
-\end{funcdesc}
-
-\begin{funcdesc}{cleanup}{}
-Erase the memory used by the PRNG.
-
-This is a wrapper for the C function \function{RAND_cleanup}.
-\end{funcdesc}
-
-\begin{funcdesc}{egd}{path\optional{, bytes}}
-Query the Entropy Gathering Daemon\footnote{See
-\url{http://www.lothar.com/tech/crypto/}} on socket \var{path} for \var{bytes}
-bytes of random data and and uses \function{add} to seed the PRNG. The default
-value of \var{bytes} is 255.
-\end{funcdesc}
-
-\begin{funcdesc}{load_file}{path\optional{, bytes}}
-Read \var{bytes} bytes (or all of it, if \var{bytes} is negative) of data from
-the file \var{path} to seed the PRNG. The default value of \var{bytes} is -1.
-\end{funcdesc}
-
-\begin{funcdesc}{screen}{}
-Add the current contents of the screen to the PRNG state.
-Availability: Windows.
-\end{funcdesc}
-
-\begin{funcdesc}{seed}{string}
-This is equivalent to calling \function{add} with \var{entropy} as the length
-of the string.
-\end{funcdesc}
-
-\begin{funcdesc}{status}{}
-Returns true if the PRNG has been seeded with enough data, and false otherwise.
-\end{funcdesc}
-
-\begin{funcdesc}{write_file}{path}
-Write a number of random bytes (currently 1024) to the file \var{path}. This
-file can then be used with \function{load_file} to seed the PRNG again.
-\end{funcdesc}
-
-\begin{excdesc}{Error}
-If the current RAND method supports any errors, this is raised when needed.
-The default method does not raise this when the entropy pool is depleted.
-
-Whenever this exception is raised directly, it has a list of error messages
-from the OpenSSL error queue, where each item is a tuple \code{(\var{lib},
-\var{function}, \var{reason})}. Here \var{lib}, \var{function} and \var{reason}
-are all strings, describing where and what the problem is. See \manpage{err}{3}
-for more information.
-\end{excdesc}
-
-
-% % % SSL module
-
-\subsection{\module{SSL} --- An interface to the SSL-specific parts of OpenSSL \label{openssl-ssl}}
-
-\declaremodule{extension}{SSL}
-\modulesynopsis{An interface to the SSL-specific parts of OpenSSL}
-
-This module handles things specific to SSL. There are two objects defined:
-Context, Connection.
-
-\begin{datadesc}{SSLv2_METHOD}
-\dataline{SSLv3_METHOD}
-\dataline{SSLv23_METHOD}
-\dataline{TLSv1_METHOD}
-These constants represent the different SSL methods to use when creating a
-context object.
-\end{datadesc}
-
-\begin{datadesc}{VERIFY_NONE}
-\dataline{VERIFY_PEER}
-\dataline{VERIFY_FAIL_IF_NO_PEER_CERT}
-These constants represent the verification mode used by the Context
-object's \method{set_verify} method.
-\end{datadesc}
-
-\begin{datadesc}{FILETYPE_PEM}
-\dataline{FILETYPE_ASN1}
-File type constants used with the \method{use_certificate_file} and
-\method{use_privatekey_file} methods of Context objects.
-\end{datadesc}
-
-\begin{datadesc}{OP_SINGLE_DH_USE}
-\dataline{OP_EPHEMERAL_RSA}
-\dataline{OP_NO_SSLv2}
-\dataline{OP_NO_SSLv3}
-\dataline{OP_NO_TLSv1}
-Constants used with \method{set_options} of Context objects.
-\constant{OP_SINGLE_DH_USE} means to always create a new key when using ephemeral
-Diffie-Hellman. \constant{OP_EPHEMERAL_RSA} means to always use ephemeral RSA keys
-when doing RSA operations. \constant{OP_NO_SSLv2}, \constant{OP_NO_SSLv3} and
-\constant{OP_NO_TLSv1} means to disable those specific protocols. This is
-interesting if you're using e.g. \constant{SSLv23_METHOD} to get an SSLv2-compatible
-handshake, but don't want to use SSLv2.
-\end{datadesc}
-
-\begin{datadesc}{SSLEAY_VERSION}
-\dataline{SSLEAY_CFLAGS}
-\dataline{SSLEAY_BUILT_ON}
-\dataline{SSLEAY_PLATFORM}
-\dataline{SSLEAY_DIR}
-Constants used with \method{SSLeay_version} to specify what OpenSSL version
-information to retrieve.  See the man page for the \function{SSLeay_version} C
-API for details.
-\end{datadesc}
-
-\begin{datadesc}{OPENSSL_VERSION_NUMBER}
-An integer giving the version number of the OpenSSL library used to build this
-version of pyOpenSSL.  See the man page for the \function{SSLeay_version} C API
-for details.
-\end{datadesc}
-
-\begin{funcdesc}{SSLeay_version}{type}
-Retrieve a string describing some aspect of the underlying OpenSSL version.  The
-type passed in should be one of the \constant{SSLEAY_*} constants defined in
-this module.
-\end{funcdesc}
-
-\begin{datadesc}{ContextType}
-See \class{Context}.
-\end{datadesc}
-
-\begin{classdesc}{Context}{method}
-A class representing SSL contexts.  Contexts define the parameters of one or
-more SSL connections.
-
-\var{method} should be \constant{SSLv2_METHOD}, \constant{SSLv3_METHOD},
-\constant{SSLv23_METHOD} or \constant{TLSv1_METHOD}.
-\end{classdesc}
-
-\begin{datadesc}{ConnectionType}
-See \class{Connection}.
-\end{datadesc}
-
-\begin{classdesc}{Connection}{context, socket}
-A class representing SSL connections.
-
-\var{context} should be an instance of \class{Context} and \var{socket}
-should be a socket \footnote{Actually, all that is required is an object
-that \emph{behaves} like a socket, you could even use files, even though
-it'd be tricky to get the handshakes right!} object.  \var{socket} may be
-\var{None}; in this case, the Connection is created with a memory BIO: see
-the \method{bio_read}, \method{bio_write}, and \method{bio_shutdown}
-methods.
-\end{classdesc}
-
-\begin{excdesc}{Error}
-This exception is used as a base class for the other SSL-related
-exceptions, but may also be raised directly.
-
-Whenever this exception is raised directly, it has a list of error messages
-from the OpenSSL error queue, where each item is a tuple \code{(\var{lib},
-\var{function}, \var{reason})}. Here \var{lib}, \var{function} and \var{reason}
-are all strings, describing where and what the problem is. See \manpage{err}{3}
-for more information.
-\end{excdesc}
-
-\begin{excdesc}{ZeroReturnError}
-This exception matches the error return code \code{SSL_ERROR_ZERO_RETURN}, and
-is raised when the SSL Connection has been closed. In SSL 3.0 and TLS 1.0, this
-only occurs if a closure alert has occurred in the protocol, i.e. the
-connection has been closed cleanly. Note that this does not necessarily
-mean that the transport layer (e.g. a socket) has been closed.
-
-It may seem a little strange that this is an exception, but it does match an
-\code{SSL_ERROR} code, and is very convenient.
-\end{excdesc}
-
-\begin{excdesc}{WantReadError}
-The operation did not complete; the same I/O method should be called again
-later, with the same arguments. Any I/O method can lead to this since new
-handshakes can occur at any time.
-
-The wanted read is for \emph{dirty} data sent over the network, not the
-\emph{clean} data inside the tunnel.  For a socket based SSL connection,
-\emph{read} means data coming at us over the network.  Until that read
-succeeds, the attempted \method{OpenSSL.SSL.Connection.recv},
-\method{OpenSSL.SSL.Connection.send}, or
-\method{OpenSSL.SSL.Connection.do_handshake} is prevented or incomplete. You
-probably want to \method{select()} on the socket before trying again.
-\end{excdesc}
-
-\begin{excdesc}{WantWriteError}
-See \exception{WantReadError}.  The socket send buffer may be too full to
-write more data.
-\end{excdesc}
-
-\begin{excdesc}{WantX509LookupError}
-The operation did not complete because an application callback has asked to be
-called again. The I/O method should be called again later, with the same
-arguments. Note: This won't occur in this version, as there are no such
-callbacks in this version.
-\end{excdesc}
-
-\begin{excdesc}{SysCallError}
-The \exception{SysCallError} occurs when there's an I/O error and OpenSSL's
-error queue does not contain any information. This can mean two things: An
-error in the transport protocol, or an end of file that violates the protocol.
-The parameter to the exception is always a pair \code{(\var{errnum},
-\var{errstr})}.
-\end{excdesc}
-
-
-\subsubsection{Context objects \label{openssl-context}}
-
-Context objects have the following methods:
-
-\begin{methoddesc}[Context]{check_privatekey}{}
-Check if the private key (loaded with \method{use_privatekey\optional{_file}})
-matches the certificate (loaded with \method{use_certificate\optional{_file}}).
-Returns \code{None} if they match, raises \exception{Error} otherwise.
-\end{methoddesc}
-
-\begin{methoddesc}[Context]{get_app_data}{}
-Retrieve application data as set by \method{set_app_data}.
-\end{methoddesc}
-
-\begin{methoddesc}[Context]{get_cert_store}{}
-Retrieve the certificate store (a X509Store object) that the context uses.
-This can be used to add "trusted" certificates without using the.
-\method{load_verify_locations()} method.
-\end{methoddesc}
-
-\begin{methoddesc}[Context]{get_timeout}{}
-Retrieve session timeout, as set by \method{set_timeout}. The default is 300
-seconds.
-\end{methoddesc}
-
-\begin{methoddesc}[Context]{get_verify_depth}{}
-Retrieve the Context object's verify depth, as set by
-\method{set_verify_depth}.
-\end{methoddesc}
-
-\begin{methoddesc}[Context]{get_verify_mode}{}
-Retrieve the Context object's verify mode, as set by \method{set_verify}.
-\end{methoddesc}
-
-\begin{methoddesc}[Context]{load_client_ca}{pemfile}
-Read a file with PEM-formatted certificates that will be sent to the client
-when requesting a client certificate.
-\end{methoddesc}
-
-\begin{methoddesc}[Context]{set_client_ca_list}{certificate_authorities}
-Replace the current list of preferred certificate signers that would be
-sent to the client when requesting a client certificate with the
-\var{certificate_authorities} sequence of \class{OpenSSL.crypto.X509Name}s.
-
-\versionadded{0.10}
-\end{methoddesc}
-
-\begin{methoddesc}[Context]{add_client_ca}{certificate_authority}
-Extract a \class{OpenSSL.crypto.X509Name} from the \var{certificate_authority}
-\class{OpenSSL.crypto.X509} certificate and add it to the list of preferred
-certificate signers sent to the client when requesting a client certificate.
-
-\versionadded{0.10}
-\end{methoddesc}
-
-\begin{methoddesc}[Context]{load_verify_locations}{pemfile, capath}
-Specify where CA certificates for verification purposes are located. These
-are trusted certificates. Note that the certificates have to be in PEM
-format.  If capath is passed, it must be a directory prepared using the
-\code{c_rehash} tool included with OpenSSL.  Either, but not both, of
-\var{pemfile} or \var{capath} may be \code{None}.
-\end{methoddesc}
-
-\begin{methoddesc}[Context]{set_default_verify_paths}{}
-Specify that the platform provided CA certificates are to be used for
-verification purposes.  This method may not work properly on OS X.
-\end{methoddesc}
-
-\begin{methoddesc}[Context]{load_tmp_dh}{dhfile}
-Load parameters for Ephemeral Diffie-Hellman from \var{dhfile}.
-\end{methoddesc}
-
-\begin{methoddesc}[Context]{set_app_data}{data}
-Associate \var{data} with this Context object. \var{data} can be retrieved
-later using the \method{get_app_data} method.
-\end{methoddesc}
-
-\begin{methoddesc}[Context]{set_cipher_list}{ciphers}
-Set the list of ciphers to be used in this context. See the OpenSSL manual for
-more information (e.g. ciphers(1))
-\end{methoddesc}
-
-\begin{methoddesc}[Context]{set_info_callback}{callback}
-Set the information callback to \var{callback}. This function will be called
-from time to time during SSL handshakes.
-\var{callback} should take three arguments: a Connection object and two
-integers. The first integer specifies where in the SSL handshake the function
-was called, and the other the return code from a (possibly failed) internal
-function call.
-\end{methoddesc}
-
-\begin{methoddesc}[Context]{set_options}{options}
-Add SSL options. Options you have set before are not cleared!
-This method should be used with the \constant{OP_*} constants.
-\end{methoddesc}
-
-\begin{methoddesc}[Context]{set_passwd_cb}{callback\optional{, userdata}}
-Set the passphrase callback to \var{callback}. This function will be called
-when a private key with a passphrase is loaded. \var{callback} must accept
-three positional arguments.  First, an integer giving the maximum length of
-the passphrase it may return.  If the returned passphrase is longer than
-this, it will be truncated.  Second, a boolean value which will be true if
-the user should be prompted for the passphrase twice and the callback should
-verify that the two values supplied are equal. Third, the value given as the
-\var{userdata} parameter to \method{set_passwd_cb}.  If an error occurs,
-\var{callback} should return a false value (e.g. an empty string).
-\end{methoddesc}
-
-\begin{methoddesc}[Context]{set_session_id}{name}
-Set the context \var{name} within which a session can be reused for this
-Context object. This is needed when doing session resumption, because there is
-no way for a stored session to know which Context object it is associated with.
-\var{name} may be any binary data.
-\end{methoddesc}
-
-\begin{methoddesc}[Context]{set_timeout}{timeout}
-Set the timeout for newly created sessions for this Context object to
-\var{timeout}. \var{timeout} must be given in (whole) seconds. The default
-value is 300 seconds. See the OpenSSL manual for more information (e.g.
-SSL_CTX_set_timeout(3)).
-\end{methoddesc}
-
-\begin{methoddesc}[Context]{set_verify}{mode, callback}
-Set the verification flags for this Context object to \var{mode} and specify
-that \var{callback} should be used for verification callbacks. \var{mode}
-should be one of \constant{VERIFY_NONE} and \constant{VERIFY_PEER}. If
-\constant{VERIFY_PEER} is used, \var{mode} can be OR:ed with
-\constant{VERIFY_FAIL_IF_NO_PEER_CERT} and \constant{VERIFY_CLIENT_ONCE} to
-further control the behaviour.
-\var{callback} should take five arguments: A Connection object, an X509 object,
-and three integer variables, which are in turn potential error number, error
-depth and return code. \var{callback} should return true if verification passes
-and false otherwise.
-\end{methoddesc}
-
-\begin{methoddesc}[Context]{set_verify_depth}{depth}
-Set the maximum depth for the certificate chain verification that shall be
-allowed for this Context object.
-\end{methoddesc}
-
-\begin{methoddesc}[Context]{use_certificate}{cert}
-Use the certificate \var{cert} which has to be a X509 object.
-\end{methoddesc}
-
-\begin{methoddesc}[Context]{add_extra_chain_cert}{cert}
-Adds the certificate \var{cert}, which has to be a X509 object, to the
-certificate chain presented together with the certificate.
-\end{methoddesc}
-
-\begin{methoddesc}[Context]{use_certificate_chain_file}{file}
-Load a certificate chain from \var{file} which must be PEM encoded.
-\end{methoddesc}
-
-\begin{methoddesc}[Context]{use_privatekey}{pkey}
-Use the private key \var{pkey} which has to be a PKey object.
-\end{methoddesc}
-
-\begin{methoddesc}[Context]{use_certificate_file}{file\optional{, format}}
-Load the first certificate found in \var{file}. The certificate must be in the
-format specified by \var{format}, which is either \constant{FILETYPE_PEM} or
-\constant{FILETYPE_ASN1}. The default is \constant{FILETYPE_PEM}.
-\end{methoddesc}
-
-\begin{methoddesc}[Context]{use_privatekey_file}{file\optional{, format}}
-Load the first private key found in \var{file}. The private key must be in the
-format specified by \var{format}, which is either \constant{FILETYPE_PEM} or
-\constant{FILETYPE_ASN1}. The default is \constant{FILETYPE_PEM}.
-\end{methoddesc}
-
-\begin{methoddesc}[Context]{set_tlsext_servername_callback}{callback}
-Specify a one-argument callable to use as the TLS extension server name
-callback.  When a connection using the server name extension is made using this
-context, the callback will be invoked with the \code{Connection} instance.
-\versionadded{0.13}
-\end{methoddesc}
-
-\subsubsection{Connection objects \label{openssl-connection}}
-
-Connection objects have the following methods:
-
-\begin{methoddesc}[Connection]{accept}{}
-Call the \method{accept} method of the underlying socket and set up SSL on the
-returned socket, using the Context object supplied to this Connection object at
-creation. Returns a pair \code{(\var{conn}, \var{address})}. where \var{conn}
-is the new Connection object created, and \var{address} is as returned by the
-socket's \method{accept}.
-\end{methoddesc}
-
-\begin{methoddesc}[Connection]{bind}{address}
-Call the \method{bind} method of the underlying socket.
-\end{methoddesc}
-
-\begin{methoddesc}[Connection]{close}{}
-Call the \method{close} method of the underlying socket. Note: If you want
-correct SSL closure, you need to call the \method{shutdown} method first.
-\end{methoddesc}
-
-\begin{methoddesc}[Connection]{connect}{address}
-Call the \method{connect} method of the underlying socket and set up SSL on the
-socket, using the Context object supplied to this Connection object at
-creation.
-\end{methoddesc}
-
-\begin{methoddesc}[Connection]{connect_ex}{address}
-Call the \method{connect_ex} method of the underlying socket and set up SSL on
-the socket, using the Context object supplied to this Connection object at
-creation. Note that if the \method{connect_ex} method of the socket doesn't
-return 0, SSL won't be initialized.
-\end{methoddesc}
-
-\begin{methoddesc}[Connection]{do_handshake}{}
-Perform an SSL handshake (usually called after \method{renegotiate} or one of
-\method{set_accept_state} or \method{set_accept_state}). This can raise the
-same exceptions as \method{send} and \method{recv}.
-\end{methoddesc}
-
-\begin{methoddesc}[Connection]{fileno}{}
-Retrieve the file descriptor number for the underlying socket.
-\end{methoddesc}
-
-\begin{methoddesc}[Connection]{listen}{backlog}
-Call the \method{listen} method of the underlying socket.
-\end{methoddesc}
-
-\begin{methoddesc}[Connection]{get_app_data}{}
-Retrieve application data as set by \method{set_app_data}.
-\end{methoddesc}
-
-\begin{methoddesc}[Connection]{get_cipher_list}{}
-Retrieve the list of ciphers used by the Connection object. WARNING: This API
-has changed. It used to take an optional parameter and just return a string,
-but not it returns the entire list in one go.
-\end{methoddesc}
-
-\begin{methoddesc}[Connection]{get_client_ca_list}{}
-Retrieve the list of preferred client certificate issuers sent by the server
-as \class{OpenSSL.crypto.X509Name} objects.
-
-If this is a client \class{Connection}, the list will be empty until the
-connection with the server is established.
-
-If this is a server \class{Connection}, return the list of certificate
-authorities that will be sent or has been sent to the client, as controlled
-by this \class{Connection}'s \class{Context}.
-
-\versionadded{0.10}
-\end{methoddesc}
-
-\begin{methoddesc}[Connection]{get_context}{}
-Retrieve the Context object associated with this Connection.
-\end{methoddesc}
-
-\begin{methoddesc}[Connection]{set_context}{context}
-Specify a replacement Context object for this Connection.
-\end{methoddesc}
-
-\begin{methoddesc}[Connection]{get_peer_certificate}{}
-Retrieve the other side's certificate (if any)
-\end{methoddesc}
-
-\begin{methoddesc}[Connection]{get_peer_cert_chain}{}
-Retrieve the tuple of the other side's certificate chain (if any)
-\end{methoddesc}
-
-\begin{methoddesc}[Connection]{getpeername}{}
-Call the \method{getpeername} method of the underlying socket.
-\end{methoddesc}
-
-\begin{methoddesc}[Connection]{getsockname}{}
-Call the \method{getsockname} method of the underlying socket.
-\end{methoddesc}
-
-\begin{methoddesc}[Connection]{getsockopt}{level, optname\optional{, buflen}}
-Call the \method{getsockopt} method of the underlying socket.
-\end{methoddesc}
-
-\begin{methoddesc}[Connection]{pending}{}
-Retrieve the number of bytes that can be safely read from the SSL buffer
-(\emph{not} the underlying transport buffer).
-\end{methoddesc}
-
-\begin{methoddesc}[Connection]{recv}{bufsize}
-Receive data from the Connection. The return value is a string representing the
-data received. The maximum amount of data to be received at once, is specified
-by \var{bufsize}.
-\end{methoddesc}
-
-\begin{methoddesc}[Connection]{bio_write}{bytes}
-If the Connection was created with a memory BIO, this method can be used to add
-bytes to the read end of that memory BIO.  The Connection can then read the
-bytes (for example, in response to a call to \method{recv}).
-\end{methoddesc}
-
-\begin{methoddesc}[Connection]{renegotiate}{}
-Renegotiate the SSL session. Call this if you wish to change cipher suites or
-anything like that.
-\end{methoddesc}
-
-\begin{methoddesc}[Connection]{send}{string}
-Send the \var{string} data to the Connection.
-\end{methoddesc}
-
-\begin{methoddesc}[Connection]{bio_read}{bufsize}
-If the Connection was created with a memory BIO, this method can be used to
-read bytes from the write end of that memory BIO.  Many Connection methods will
-add bytes which must be read in this manner or the buffer will eventually fill
-up and the Connection will be able to take no further actions.
-\end{methoddesc}
-
-\begin{methoddesc}[Connection]{sendall}{string}
-Send all of the \var{string} data to the Connection. This calls \method{send}
-repeatedly until all data is sent. If an error occurs, it's impossible to tell
-how much data has been sent.
-\end{methoddesc}
-
-\begin{methoddesc}[Connection]{set_accept_state}{}
-Set the connection to work in server mode. The handshake will be handled
-automatically by read/write.
-\end{methoddesc}
-
-\begin{methoddesc}[Connection]{set_app_data}{data}
-Associate \var{data} with this Connection object. \var{data} can be retrieved
-later using the \method{get_app_data} method.
-\end{methoddesc}
-
-\begin{methoddesc}[Connection]{set_connect_state}{}
-Set the connection to work in client mode. The handshake will be handled
-automatically by read/write.
-\end{methoddesc}
-
-\begin{methoddesc}[Connection]{setblocking}{flag}
-Call the \method{setblocking} method of the underlying socket.
-\end{methoddesc}
-
-\begin{methoddesc}[Connection]{setsockopt}{level, optname, value}
-Call the \method{setsockopt} method of the underlying socket.
-\end{methoddesc}
-
-\begin{methoddesc}[Connection]{shutdown}{}
-Send the shutdown message to the Connection. Returns true if the shutdown
-message exchange is completed and false otherwise (in which case you call
-\method{recv()} or \method{send()} when the connection becomes
-readable/writeable.
-\end{methoddesc}
-
-\begin{methoddesc}[Connection]{get_shutdown}{}
-Get the shutdown state of the Connection.  Returns a bitvector of either or
-both of \var{SENT_SHUTDOWN} and \var{RECEIVED_SHUTDOWN}.
-\end{methoddesc}
-
-\begin{methoddesc}[Connection]{set_shutdown}{state}
-Set the shutdown state of the Connection.  \var{state} is a bitvector of
-either or both of \var{SENT_SHUTDOWN} and \var{RECEIVED_SHUTDOWN}.
-\end{methoddesc}
-
-\begin{methoddesc}[Connection]{sock_shutdown}{how}
-Call the \method{shutdown} method of the underlying socket.
-\end{methoddesc}
-
-\begin{methoddesc}[Connection]{bio_shutdown}{}
-If the Connection was created with a memory BIO, this method can be used to
-indicate that ``end of file'' has been reached on the read end of that memory
-BIO.
-\end{methoddesc}
-
-\begin{methoddesc}[Connection]{state_string}{}
-Retrieve a verbose string detailing the state of the Connection.
-\end{methoddesc}
-
-\begin{methoddesc}[Connection]{client_random}{}
-Retrieve the random value used with the client hello message.
-\end{methoddesc}
-
-\begin{methoddesc}[Connection]{server_random}{}
-Retrieve the random value used with the server hello message.
-\end{methoddesc}
-
-\begin{methoddesc}[Connection]{master_key}{}
-Retrieve the value of the master key for this session.
-\end{methoddesc}
-
-\begin{methoddesc}[Connection]{want_read}{}
-Checks if more data has to be read from the transport layer to complete an
-operation.
-\end{methoddesc}
-
-\begin{methoddesc}[Connection]{want_write}{}
-Checks if there is data to write to the transport layer to complete an
-operation.
-\end{methoddesc}
-
-\begin{methoddesc}[Connection]{set_tlsext_host_name}{name}
-Specify the byte string to send as the server name in the client hello message.
-\versionadded{0.13}
-\end{methoddesc}
-
-\begin{methoddesc}[Connection]{get_servername}{}
-Get the value of the server name received in the client hello message.
-\versionadded{0.13}
-\end{methoddesc}
-
-
-
-\section{Internals \label{internals}}
-
-We ran into three main problems developing this: Exceptions, callbacks and
-accessing socket methods. This is what this chapter is about.
-
-\subsection{Exceptions \label{exceptions}}
-
-We realized early that most of the exceptions would be raised by the I/O
-functions of OpenSSL, so it felt natural to mimic OpenSSL's error code system,
-translating them into Python exceptions. This naturally gives us the exceptions
-\exception{SSL.ZeroReturnError}, \exception{SSL.WantReadError},
-\exception{SSL.WantWriteError}, \exception{SSL.WantX509LookupError} and
-\exception{SSL.SysCallError}.
-
-For more information about this, see section \ref{openssl-ssl}.
-
-
-\subsection{Callbacks \label{callbacks}}
-
-There are a number of problems with callbacks. First of all, OpenSSL is written
-as a C library, it's not meant to have Python callbacks, so a way around that
-is needed. Another problem is thread support. A lot of the OpenSSL I/O
-functions can block if the socket is in blocking mode, and then you want other
-Python threads to be able to do other things. The real trouble is if you've
-released the global CPython interpreter lock to do a potentially blocking
-operation, and the operation calls a callback. Then we must take the GIL back,
-since calling Python APIs without holding it is not allowed.
-
-There are two solutions to the first problem, both of which are necessary. The
-first solution to use is if the C callback allows ''userdata'' to be passed to
-it (an arbitrary pointer normally). This is great! We can set our Python
-function object as the real userdata and emulate userdata for the Python
-function in another way. The other solution can be used if an object with an
-''app_data'' system always is passed to the callback. For example, the SSL
-object in OpenSSL has app_data functions and in e.g. the verification
-callbacks, you can retrieve the related SSL object. What we do is to set our
-wrapper \class{Connection} object as app_data for the SSL object, and we can
-easily find the Python callback.
-
-The other problem is solved using thread local variables.  Whenever the GIL is
-released before calling into an OpenSSL API, the PyThreadState pointer returned
-by \cfunction{PyEval_SaveState} is stored in a global thread local variable
-(using Python's own TLS API, \cfunction{PyThread_set_key_value}).  When it is
-necessary to re-acquire the GIL, either after the OpenSSL API returns or in a C
-callback invoked by that OpenSSL API, the value of the thread local variable is
-retrieved (\cfunction{PyThread_get_key_value}) and used to re-acquire the GIL.
-This allows Python threads to execute while OpenSSL APIs are running and allows
-use of any particular pyOpenSSL object from any Python thread, since there is
-no per-thread state associated with any of these objects and since OpenSSL is
-threadsafe (as long as properly initialized, as pyOpenSSL initializes it).
-
-
-\subsection{Acessing Socket Methods \label{socket-methods}}
-
-We quickly saw the benefit of wrapping socket methods in the
-\class{SSL.Connection} class, for an easy transition into using SSL. The
-problem here is that the \module{socket} module lacks a C API, and all the
-methods are declared static. One approach would be to have \module{OpenSSL} as
-a submodule to the \module{socket} module, placing all the code in
-\file{socketmodule.c}, but this is obviously not a good solution, since you
-might not want to import tonnes of extra stuff you're not going to use when
-importing the \module{socket} module. The other approach is to somehow get a
-pointer to the method to be called, either the C function, or a callable Python
-object. This is not really a good solution either, since there's a lot of
-lookups involved.
-
-The way it works is that you have to supply a ``\class{socket}-like'' transport
-object to the \class{SSL.Connection}. The only requirement of this object is
-that it has a \method{fileno()} method that returns a file descriptor that's
-valid at the C level (i.e. you can use the system calls read and write). If you
-want to use the \method{connect()} or \method{accept()} methods of the
-\class{SSL.Connection} object, the transport object has to supply such
-methods too. Apart from them, any method lookups in the \class{SSL.Connection}
-object that fail are passed on to the underlying transport object.
-
-Future changes might be to allow Python-level transport objects, that instead
-of having \method{fileno()} methods, have \method{read()} and \method{write()}
-methods, so more advanced features of Python can be used. This would probably
-entail some sort of OpenSSL ``BIOs'', but converting Python strings back and
-forth is expensive, so this shouldn't be used unless necessary. Other nice
-things would be to be able to pass in different transport objects for reading
-and writing, but then the \method{fileno()} method of \class{SSL.Connection}
-becomes virtually useless. Also, should the method resolution be used on the
-read-transport or the write-transport?
-
-
-\end{document}
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/Quotes hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/Quotes
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/Quotes	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/Quotes	2014-01-10 11:06:42.000000000 +0100
@@ -0,0 +1,2 @@
+< Screwtape> I like how developing against OpenSSL is like a text adventure game with a maze of twisty passages, all alike.
+%
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/README hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/README
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/README	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/README	2014-01-10 11:06:42.000000000 +0100
@@ -0,0 +1,4 @@
+This is the pyOpenSSL documentation source.  It uses Sphinx.  To build the
+documentation, install Sphinx 1.0 and run:
+
+    $ make html
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/anno-api.py hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/anno-api.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/anno-api.py	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/anno-api.py	1970-01-01 01:00:00.000000000 +0100
@@ -1,71 +0,0 @@
-#! /usr/bin/env python
-"""Add reference count annotations to the Python/C API Reference."""
-__version__ = '$Revision: 1.1.1.1 $'
-
-import getopt
-import os
-import sys
-
-import refcounts
-
-
-PREFIX_1 = r"\begin{cfuncdesc}{PyObject*}{"
-PREFIX_2 = r"\begin{cfuncdesc}{PyVarObject*}{"
-
-
-def main():
-    rcfile = os.path.join(os.path.dirname(refcounts.__file__), os.pardir,
-                          "api", "refcounts.dat")
-    outfile = "-"
-    opts, args = getopt.getopt(sys.argv[1:], "o:r:", ["output=", "refcounts="])
-    for opt, arg in opts:
-        if opt in ("-o", "--output"):
-            outfile = arg
-        elif opt in ("-r", "--refcounts"):
-            rcfile = arg
-    rcdict = refcounts.load(rcfile)
-    if outfile == "-":
-        output = sys.stdout
-    else:
-        output = open(outfile, "w")
-    if not args:
-        args = ["-"]
-    for infile in args:
-        if infile == "-":
-            input = sys.stdin
-        else:
-            input = open(infile)
-        while 1:
-            line = input.readline()
-            if not line:
-                break
-            prefix = None
-            if line.startswith(PREFIX_1):
-                prefix = PREFIX_1
-            elif line.startswith(PREFIX_2):
-                prefix = PREFIX_2
-            if prefix:
-                s = line[len(prefix):].split('}', 1)[0]
-                try:
-                    info = rcdict[s]
-                except KeyError:
-                    sys.stderr.write("No refcount data for %s\n" % s)
-                else:
-                    if info.result_type in ("PyObject*", "PyVarObject*"):
-                        if info.result_refs is None:
-                            rc = "Always \NULL{}"
-                        else:
-                            rc = info.result_refs and "New" or "Borrowed"
-                            rc = rc + " reference"
-                        line = (r"\begin{cfuncdesc}[%s]{%s}{"
-                                % (rc, info.result_type)) \
-                                + line[len(prefix):]
-            output.write(line)
-        if infile != "-":
-            input.close()
-    if outfile != "-":
-        output.close()
-
-
-if __name__ == "__main__":
-    main()
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/buildindex.py hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/buildindex.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/buildindex.py	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/buildindex.py	1970-01-01 01:00:00.000000000 +0100
@@ -1,353 +0,0 @@
-#! /usr/bin/env python
-
-__version__ = '$Revision: 1.1.1.1 $'
-
-import os
-import re
-import string
-import sys
-
-
-class Node:
-    __rmjunk = re.compile("<#\d+#>")
-
-    continuation = 0
-
-    def __init__(self, link, str, seqno):
-        self.links = [link]
-        self.seqno = seqno
-        # remove <#\d+#> left in by moving the data out of LaTeX2HTML
-        str = self.__rmjunk.sub('', str)
-        # build up the text
-        self.text = split_entry_text(str)
-        self.key = split_entry_key(str)
-
-    def __cmp__(self, other):
-        """Comparison operator includes sequence number, for use with
-        list.sort()."""
-        return self.cmp_entry(other) or cmp(self.seqno, other.seqno)
-
-    def cmp_entry(self, other):
-        """Comparison 'operator' that ignores sequence number."""
-        c = 0
-        for i in range(min(len(self.key), len(other.key))):
-            c = (cmp_part(self.key[i], other.key[i])
-                 or cmp_part(self.text[i], other.text[i]))
-            if c:
-                break
-        return c or cmp(self.key, other.key) or cmp(self.text, other.text)
-
-    def __repr__(self):
-        return "<Node for %s (%s)>" % (string.join(self.text, '!'), self.seqno)
-
-    def __str__(self):
-        return string.join(self.key, '!')
-
-    def dump(self):
-        return "%s\1%s###%s\n" \
-               % (string.join(self.links, "\1"),
-                  string.join(self.text, '!'),
-                  self.seqno)
-
-
-def cmp_part(s1, s2):
-    result = cmp(s1, s2)
-    if result == 0:
-        return 0
-    l1 = string.lower(s1)
-    l2 = string.lower(s2)
-    minlen = min(len(s1), len(s2))
-    if len(s1) < len(s2) and l1 == l2[:len(s1)]:
-        result = -1
-    elif len(s2) < len(s1) and l2 == l1[:len(s2)]:
-        result = 1
-    else:
-        result = cmp(l1, l2) or cmp(s1, s2)
-    return result
-
-
-def split_entry(str, which):
-    stuff = []
-    parts = string.split(str, '!')
-    parts = map(string.split, parts, ['@'] * len(parts))
-    for entry in parts:
-        if len(entry) != 1:
-            key = entry[which]
-        else:
-            key = entry[0]
-        stuff.append(key)
-    return stuff
-
-
-_rmtt = re.compile(r"""(.*)<tt(?: class=['"][a-z0-9]+["'])?>(.*)</tt>(.*)$""",
-                   re.IGNORECASE)
-_rmparens = re.compile(r"\(\)")
-
-def split_entry_key(str):
-    parts = split_entry(str, 1)
-    for i in range(len(parts)):
-        m = _rmtt.match(parts[i])
-        if m:
-            parts[i] = string.join(m.group(1, 2, 3), '')
-        else:
-            parts[i] = string.lower(parts[i])
-        # remove '()' from the key:
-        parts[i] = _rmparens.sub('', parts[i])
-    return map(trim_ignored_letters, parts)
-
-
-def split_entry_text(str):
-    if '<' in str:
-        m = _rmtt.match(str)
-        if m:
-            str = string.join(m.group(1, 2, 3), '')
-    return split_entry(str, 1)
-
-
-def load(fp):
-    nodes = []
-    rx = re.compile("(.*)\1(.*)###(.*)$")
-    while 1:
-        line = fp.readline()
-        if not line:
-            break
-        m = rx.match(line)
-        if m:
-            link, str, seqno = m.group(1, 2, 3)
-            nodes.append(Node(link, str, seqno))
-    return nodes
-
-
-def trim_ignored_letters(s):
-    # ignore $ to keep environment variables with the
-    # leading letter from the name
-    s = string.lower(s)
-    if s[0] == "$":
-        return s[1:]
-    else:
-        return s
-
-def get_first_letter(s):
-    return string.lower(trim_ignored_letters(s)[0])
-
-
-def split_letters(nodes):
-    letter_groups = []
-    if nodes:
-        group = []
-        append = group.append
-        letter = get_first_letter(nodes[0].text[0])
-        letter_groups.append((letter, group))
-        for node in nodes:
-            nletter = get_first_letter(node.text[0])
-            if letter != nletter:
-                letter = nletter
-                group = []
-                letter_groups.append((letter, group))
-                append = group.append
-            append(node)
-    return letter_groups
-
-
-# need a function to separate the nodes into columns...
-def split_columns(nodes, columns=1):
-    if columns <= 1:
-        return [nodes]
-    # This is a rough height; we may have to increase to avoid breaks before
-    # a subitem.
-    colheight = len(nodes) / columns
-    numlong = len(nodes) % columns
-    if numlong:
-        colheight = colheight + 1
-    else:
-        numlong = columns
-    cols = []
-    for i in range(numlong):
-        start = i * colheight
-        end = start + colheight
-        cols.append(nodes[start:end])
-    del nodes[:end]
-    colheight = colheight - 1
-    try:
-        numshort = len(nodes) / colheight
-    except ZeroDivisionError:
-        cols = cols + (columns - len(cols)) * [[]]
-    else:
-        for i in range(numshort):
-            start = i * colheight
-            end = start + colheight
-            cols.append(nodes[start:end])
-    #
-    # If items continue across columns, make sure they are marked
-    # as continuations so the user knows to look at the previous column.
-    #
-    for i in range(len(cols) - 1):
-        try:
-            prev = cols[i][-1]
-            next = cols[i + 1][0]
-        except IndexError:
-            return cols
-        else:
-            n = min(len(prev.key), len(next.key))
-            for j in range(n):
-                if prev.key[j] != next.key[j]:
-                    break
-                next.continuation = j + 1
-    return cols
-
-
-DL_LEVEL_INDENT = "  "
-
-def format_column(nodes):
-    strings = ["<dl compact>"]
-    append = strings.append
-    level = 0
-    previous = []
-    for node in nodes:
-        current = node.text
-        count = 0
-        for i in range(min(len(current), len(previous))):
-            if previous[i] != current[i]:
-                break
-            count = i + 1
-        if count > level:
-            append("<dl compact>" * (count - level) + "\n")
-            level = count
-        elif level > count:
-            append("\n")
-            append(level * DL_LEVEL_INDENT)
-            append("</dl>" * (level - count))
-            level = count
-        # else: level == count
-        for i in range(count, len(current) - 1):
-            term = node.text[i]
-            level = level + 1
-            if node.continuation > i:
-                extra = " (continued)"
-            else:
-                extra = ""
-            append("\n<dt>%s%s\n<dd>\n%s<dl compact>"
-                   % (term, extra, level * DL_LEVEL_INDENT))
-        append("\n%s<dt>%s%s</a>"
-               % (level * DL_LEVEL_INDENT, node.links[0], node.text[-1]))
-        for link in node.links[1:]:
-            append(",\n%s    %s[Link]</a>" % (level * DL_LEVEL_INDENT, link))
-        previous = current
-    append("\n")
-    append("</dl>" * (level + 1))
-    return string.join(strings, '')
-
-
-def format_nodes(nodes, columns=1):
-    strings = []
-    append = strings.append
-    if columns > 1:
-        colnos = range(columns)
-        colheight = len(nodes) / columns
-        if len(nodes) % columns:
-            colheight = colheight + 1
-        colwidth = 100 / columns
-        append('<table width="100%"><tr valign="top">')
-        for col in split_columns(nodes, columns):
-            append('<td width="%d%%">\n' % colwidth)
-            append(format_column(col))
-            append("\n</td>")
-        append("\n</tr></table>")
-    else:
-        append(format_column(nodes))
-    append("\n<p>\n")
-    return string.join(strings, '')
-
-
-def format_letter(letter):
-    if letter == '.':
-        lettername = ". (dot)"
-    elif letter == '_':
-        lettername = "_ (underscore)"
-    else:
-        lettername = string.upper(letter)
-    return "\n<hr>\n<h2><a name=\"letter-%s\">%s</a></h2>\n\n" \
-           % (letter, lettername)
-
-
-def format_html_letters(nodes, columns=1):
-    letter_groups = split_letters(nodes)
-    items = []
-    for letter, nodes in letter_groups:
-        s = "<b><a href=\"#letter-%s\">%s</a></b>" % (letter, letter)
-        items.append(s)
-    s = ["<hr><center>\n%s</center>\n" % string.join(items, " |\n")]
-    for letter, nodes in letter_groups:
-        s.append(format_letter(letter))
-        s.append(format_nodes(nodes, columns))
-    return string.join(s, '')
-
-def format_html(nodes, columns):
-    return format_nodes(nodes, columns)
-
-
-def collapse(nodes):
-    """Collapse sequences of nodes with matching keys into a single node.
-    Destructive."""
-    if len(nodes) < 2:
-        return
-    prev = nodes[0]
-    i = 1
-    while i < len(nodes):
-        node = nodes[i]
-        if not node.cmp_entry(prev):
-            prev.links.append(node.links[0])
-            del nodes[i]
-        else:
-            i = i + 1
-            prev = node
-
-
-def dump(nodes, fp):
-    for node in nodes:
-        fp.write(node.dump())
-
-
-def process_nodes(nodes, columns, letters):
-    nodes.sort()
-    collapse(nodes)
-    if letters:
-        return format_html_letters(nodes, columns)
-    else:
-        return format_html(nodes, columns)
-
-
-def main():
-    import getopt
-    ifn = "-"
-    ofn = "-"
-    columns = 1
-    letters = 0
-    opts, args = getopt.getopt(sys.argv[1:], "c:lo:",
-                               ["columns=", "letters", "output="])
-    for opt, val in opts:
-        if opt in ("-o", "--output"):
-            ofn = val
-        elif opt in ("-c", "--columns"):
-            columns = string.atoi(val)
-        elif opt in ("-l", "--letters"):
-            letters = 1
-    if not args:
-        args = [ifn]
-    nodes = []
-    for fn in args:
-        nodes = nodes + load(open(fn))
-    num_nodes = len(nodes)
-    html = process_nodes(nodes, columns, letters)
-    program = os.path.basename(sys.argv[0])
-    if ofn == "-":
-        sys.stdout.write(html)
-        sys.stderr.write("\n%s: %d index nodes" % (program, num_nodes))
-    else:
-        open(ofn, "w").write(html)
-        print
-        print "%s: %d index nodes" % (program, num_nodes)
-
-
-if __name__ == "__main__":
-    main()
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/checkargs.pm hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/checkargs.pm
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/checkargs.pm	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/checkargs.pm	1970-01-01 01:00:00.000000000 +0100
@@ -1,112 +0,0 @@
-#!/uns/bin/perl
-
-package checkargs;
-require 5.004;			# uses "for my $var"
-require Exporter;
-@ISA = qw(Exporter);
-@EXPORT = qw(check_args check_args_range check_args_at_least);
-use strict;
-use Carp;
-
-=head1 NAME
-
-checkargs -- Provide rudimentary argument checking for perl5 functions
-
-=head1 SYNOPSIS
-
-  check_args(cArgsExpected, @_)
-  check_args_range(cArgsMin, cArgsMax, @_)
-  check_args_at_least(cArgsMin, @_)
-where "@_" should be supplied literally.
-
-=head1 DESCRIPTION
-
-As the first line of user-written subroutine foo, do one of the following:
-
-  my ($arg1, $arg2) = check_args(2, @_);
-  my ($arg1, @rest) = check_args_range(1, 4, @_);
-  my ($arg1, @rest) = check_args_at_least(1, @_);
-  my @args = check_args_at_least(0, @_);
-
-These functions may also be called for side effect (put a call to one
-of the functions near the beginning of the subroutine), but using the
-argument checkers to set the argument list is the recommended usage.
-
-The number of arguments and their definedness are checked; if the wrong
-number are received, the program exits with an error message.
-
-=head1 AUTHOR
-
-Michael D. Ernst <F<mernst@cs.washington.edu>>
-
-=cut
-
-## Need to check that use of caller(1) really gives desired results.
-## Need to give input chunk information.
-## Is this obviated by Perl 5.003's declarations?  Not entirely, I think.
-
-sub check_args ( $@ )
-{
-  my ($num_formals, @args) = @_;
-  my ($pack, $file_arg, $line_arg, $subname, $hasargs, $wantarr) = caller(1);
-  if (@_ < 1) { croak "check_args needs at least 7 args, got ", scalar(@_), ": @_\n "; }
-  if ((!wantarray) && ($num_formals != 0))
-    { croak "check_args called in scalar context"; }
-  # Can't use croak below here: it would only go out to caller, not its caller
-  my $num_actuals = @args;
-  if ($num_actuals != $num_formals)
-    { die "$file_arg:$line_arg: function $subname expected $num_formals argument",
-      (($num_formals == 1) ? "" : "s"),
-      ", got $num_actuals",
-      (($num_actuals == 0) ? "" : ": @args"),
-      "\n"; }
-  for my $index (0..$#args)
-    { if (!defined($args[$index]))
-	{ die "$file_arg:$line_arg: function $subname undefined argument ", $index+1, ": @args[0..$index-1]\n"; } }
-  return @args;
-}
-
-sub check_args_range ( $$@ )
-{
-  my ($min_formals, $max_formals, @args) = @_;
-  my ($pack, $file_arg, $line_arg, $subname, $hasargs, $wantarr) = caller(1);
-  if (@_ < 2) { croak "check_args_range needs at least 8 args, got ", scalar(@_), ": @_"; }
-  if ((!wantarray) && ($max_formals != 0) && ($min_formals !=0) )
-    { croak "check_args_range called in scalar context"; }
-  # Can't use croak below here: it would only go out to caller, not its caller
-  my $num_actuals = @args;
-  if (($num_actuals < $min_formals) || ($num_actuals > $max_formals))
-    { die "$file_arg:$line_arg: function $subname expected $min_formals-$max_formals arguments, got $num_actuals",
-      ($num_actuals == 0) ? "" : ": @args", "\n"; }
-  for my $index (0..$#args)
-    { if (!defined($args[$index]))
-	{ die "$file_arg:$line_arg: function $subname undefined argument ", $index+1, ": @args[0..$index-1]\n"; } }
-  return @args;
-}
-
-sub check_args_at_least ( $@ )
-{
-  my ($min_formals, @args) = @_;
-  my ($pack, $file_arg, $line_arg, $subname, $hasargs, $wantarr) = caller(1);
-  # Don't do this, because we want every sub to start with a call to check_args*
-  # if ($min_formals == 0)
-  #   { die "Isn't it pointless to check for at least zero args to $subname?\n"; }
-  if (scalar(@_) < 1)
-    { croak "check_args_at_least needs at least 1 arg, got ", scalar(@_), ": @_"; }
-  if ((!wantarray) && ($min_formals != 0))
-    { croak "check_args_at_least called in scalar context"; }
-  # Can't use croak below here: it would only go out to caller, not its caller
-  my $num_actuals = @args;
-  if ($num_actuals < $min_formals)
-    { die "$file_arg:$line_arg: function $subname expected at least $min_formals argument",
-      ($min_formals == 1) ? "" : "s",
-      ", got $num_actuals",
-      ($num_actuals == 0) ? "" : ": @args", "\n"; }
-  for my $index (0..$#args)
-    { if (!defined($args[$index]))
-	{ warn "$file_arg:$line_arg: function $subname undefined argument ", $index+1, ": @args[0..$index-1]\n"; last; } }
-  return @args;
-}
-
-1;				# successful import
-__END__
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/cklatex hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/cklatex
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/cklatex	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/cklatex	1970-01-01 01:00:00.000000000 +0100
@@ -1,26 +0,0 @@
-#! /bin/sh
-#  -*- ksh -*-
-
-# This script *helps* locate lines of normal content that end in '}';
-# this is useful since LaTeX2HTML (at least the old version that we
-# use) breaks on many lines that end that way.
-#
-# Usage: cklatex files... | less
-#
-# *Read* the output looking for suspicious lines!
-
-grep -n "[^ 	]}\$" $@ | \
- grep -v '\\begin{' | \
- grep -v '\\end{' | \
- grep -v '\\input{' | \
- grep -v '\\documentclass{' | \
- grep -v '\\title{' | \
- grep -v '\\chapter{' | \
- grep -v '\\chapter\*{' | \
- grep -v '\\section{' | \
- grep -v '\\subsection{' | \
- grep -v '\\subsubsection{' | \
- grep -v '\\sectionauthor{' | \
- grep -v '\\moduleauthor{'
-
-exit $?
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/custlib.py hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/custlib.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/custlib.py	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/custlib.py	1970-01-01 01:00:00.000000000 +0100
@@ -1,73 +0,0 @@
-# Generate custlib.tex, which is a site-specific library document.
-
-# Phase I: list all the things that can be imported
-
-import glob, os, sys, string
-modules={}
-
-for modname in sys.builtin_module_names:
-    modules[modname]=modname
-    
-for dir in sys.path:
-    # Look for *.py files
-    filelist=glob.glob(os.path.join(dir, '*.py'))
-    for file in filelist: 
-        path, file = os.path.split(file)
-        base, ext=os.path.splitext(file)
-        modules[string.lower(base)]=base
-
-    # Look for shared library files
-    filelist=(glob.glob(os.path.join(dir, '*.so')) + 
-              glob.glob(os.path.join(dir, '*.sl')) +
-              glob.glob(os.path.join(dir, '*.o')) )
-    for file in filelist: 
-        path, file = os.path.split(file)
-        base, ext=os.path.splitext(file)
-        if base[-6:]=='module': base=base[:-6]
-        modules[string.lower(base)]=base
-
-# Minor oddity: the types module is documented in libtypes2.tex
-if modules.has_key('types'):
-    del modules['types'] ; modules['types2']=None
-
-# Phase II: find all documentation files (lib*.tex)
-#           and eliminate modules that don't have one.
-
-docs={}
-filelist=glob.glob('lib*.tex')
-for file in filelist:
-    modname=file[3:-4]
-    docs[modname]=modname
-
-mlist=modules.keys()
-mlist=filter(lambda x, docs=docs: docs.has_key(x), mlist)
-mlist.sort()
-mlist=map(lambda x, docs=docs: docs[x], mlist)
-
-modules=mlist
-
-# Phase III: write custlib.tex
-
-# Write the boilerplate
-# XXX should be fancied up.  
-print """\documentstyle[twoside,11pt,myformat]{report}
-\\title{Python Library Reference}
-\\input{boilerplate}
-\\makeindex                     % tell \\index to actually write the .idx file
-\\begin{document}
-\\pagenumbering{roman}
-\\maketitle
-\\input{copyright}
-\\begin{abstract}
-\\noindent This is a customized version of the Python Library Reference.
-\\end{abstract}
-\\pagebreak
-{\\parskip = 0mm \\tableofcontents}
-\\pagebreak\\pagenumbering{arabic}"""
-    
-for modname in mlist: 
-    print "\\input{lib%s}" % (modname,)
-    
-# Write the end
-print """\\input{custlib.ind}                   % Index
-\\end{document}"""
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/cvsinfo.py hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/cvsinfo.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/cvsinfo.py	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/cvsinfo.py	1970-01-01 01:00:00.000000000 +0100
@@ -1,81 +0,0 @@
-"""Utility class and function to get information about the CVS repository
-based on checked-out files.
-"""
-
-import os
-
-
-def get_repository_list(paths):
-    d = {}
-    for name in paths:
-        if os.path.isfile(name):
-            dir = os.path.dirname(name)
-        else:
-            dir = name
-        rootfile = os.path.join(name, "CVS", "Root")
-        root = open(rootfile).readline().strip()
-        if not d.has_key(root):
-            d[root] = RepositoryInfo(dir), [name]
-        else:
-            d[root][1].append(name)
-    return d.values()
-
-
-class RepositoryInfo:
-    """Record holding information about the repository we want to talk to."""
-    cvsroot_path = None
-    branch = None
-
-    # type is '', ':ext', or ':pserver:'
-    type = ""
-
-    def __init__(self, dir=None):
-        if dir is None:
-            dir = os.getcwd()
-        dir = os.path.join(dir, "CVS")
-        root = open(os.path.join(dir, "Root")).readline().strip()
-        if root.startswith(":pserver:"):
-            self.type = ":pserver:"
-            root = root[len(":pserver:"):]
-        elif ":" in root:
-            if root.startswith(":ext:"):
-                root = root[len(":ext:"):]
-            self.type = ":ext:"
-        self.repository = root
-        if ":" in root:
-            host, path = root.split(":", 1)
-            self.cvsroot_path = path
-        else:
-            self.cvsroot_path = root
-        fn = os.path.join(dir, "Tag")
-        if os.path.isfile(fn):
-            self.branch = open(fn).readline().strip()[1:]
-
-    def get_cvsroot(self):
-        return self.type + self.repository
-
-    _repository_dir_cache = {}
-
-    def get_repository_file(self, path):
-        filename = os.path.abspath(path)
-        if os.path.isdir(path):
-            dir = path
-            join = 0
-        else:
-            dir = os.path.dirname(path)
-            join = 1
-        try:
-            repodir = self._repository_dir_cache[dir]
-        except KeyError:
-            repofn = os.path.join(dir, "CVS", "Repository")
-            repodir = open(repofn).readline().strip()
-            repodir = os.path.join(self.cvsroot_path, repodir)
-            self._repository_dir_cache[dir] = repodir
-        if join:
-            fn = os.path.join(repodir, os.path.basename(path))
-        else:
-            fn = repodir
-        return fn[len(self.cvsroot_path)+1:]
-
-    def __repr__(self):
-        return "<RepositoryInfo for %s>" % `self.get_cvsroot()`
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/findacks hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/findacks
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/findacks	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/findacks	1970-01-01 01:00:00.000000000 +0100
@@ -1,161 +0,0 @@
-#!/usr/bin/env python
-"""Script to locate email addresses in the CVS logs."""
-__version__ = '$Revision: 1.1.1.1 $'
-
-import os
-import re
-import sys
-import UserDict
-
-import cvsinfo
-
-
-class Acknowledgements(UserDict.UserDict):
-    def add(self, email, name, path):
-        d = self.data
-        d.setdefault(email, {})[path] = name
-
-
-def open_cvs_log(info, paths=None):
-    cvsroot = info.get_cvsroot()
-    cmd = "cvs -q -d%s log " % cvsroot
-    if paths:
-        cmd += " ".join(paths)
-    return os.popen(cmd, "r")
-
-
-email_rx = re.compile("<([a-z][-a-z0-9._]*@[-a-z0-9.]+)>", re.IGNORECASE)
-
-def find_acks(f, acks):
-    prev = ''
-    filename = None
-    MAGIC_WORDS = ('van', 'von')
-    while 1:
-        line = f.readline()
-        if not line:
-            break
-        if line.startswith("Working file: "):
-            filename = line.split(None, 2)[2].strip()
-            prev = line
-            continue
-        m = email_rx.search(line)
-        if m:
-            words = prev.split() + line[:m.start()].split()
-            L = []
-            while words \
-                  and (words[-1][0].isupper() or words[-1] in MAGIC_WORDS):
-                L.insert(0, words.pop())
-            name = " ".join(L)
-            email = m.group(1).lower()
-            acks.add(email, name, filename)
-        prev = line
-
-
-def load_cvs_log_acks(acks, args):
-    repolist = cvsinfo.get_repository_list(args or [""])
-    for info, paths in repolist:
-        print >>sys.stderr, "Repository:", info.get_cvsroot()
-        f = open_cvs_log(info, paths)
-        find_acks(f, acks)
-        f.close()
-
-
-def load_tex_source_acks(acks, args):
-    for path in args:
-        path = path or os.curdir
-        if os.path.isfile(path):
-            read_acks_from_tex_file(acks, path)
-        else:
-            read_acks_from_tex_dir(acks, path)
-
-
-def read_acks_from_tex_file(acks, path):
-    f = open(path)
-    while 1:
-        line = f.readline()
-        if not line:
-            break
-        if line.startswith(r"\sectionauthor{"):
-            line = line[len(r"\sectionauthor"):]
-            name, line = extract_tex_group(line)
-            email, line = extract_tex_group(line)
-            acks.add(email, name, path)
-
-
-def read_acks_from_tex_dir(acks, path):
-    stack = [path]
-    while stack:
-        p = stack.pop()
-        for n in os.listdir(p):
-            n = os.path.join(p, n)
-            if os.path.isdir(n):
-                stack.insert(0, n)
-            elif os.path.normpath(n).endswith(".tex"):
-                read_acks_from_tex_file(acks, n)
-
-
-def extract_tex_group(s):
-    c = 0
-    for i in range(len(s)):
-        if s[i] == '{':
-            c += 1
-        elif s[i] == '}':
-            c -= 1
-            if c == 0:
-                return s[1:i], s[i+1:]
-
-
-def print_acks(acks):
-    first = 1
-    for email, D in acks.items():
-        if first:
-            first = 0
-        else:
-            print
-        L = D.items()
-        L.sort()
-        prefname = L[0][1]
-        for file, name in L[1:]:
-            if name != prefname:
-                prefname = ""
-                break
-        if prefname:
-            print prefname, "<%s>:" % email
-        else:
-            print email + ":"
-        for file, name in L:
-            if name == prefname:
-                print "    " + file
-            else:
-                print "    %s (as %s)" % (file, name)
-
-
-def print_ack_names(acks):
-    names = []
-    for email, D in acks.items():
-        L = D.items()
-        L.sort()
-        prefname = L[0][1]
-        for file, name in L[1:]:
-            prefname = prefname or name
-        names.append(prefname or email)
-    def f(s1, s2):
-        s1 = s1.lower()
-        s2 = s2.lower()
-        return cmp((s1.split()[-1], s1),
-                   (s2.split()[-1], s2))
-    names.sort(f)
-    for name in names:
-        print name
-
-
-def main():
-    args = sys.argv[1:]
-    acks = Acknowledgements()
-    load_cvs_log_acks(acks, args)
-    load_tex_source_acks(acks, args)
-    print_ack_names(acks)
-
-
-if __name__ == "__main__":
-    main()
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/findmodrefs hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/findmodrefs
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/findmodrefs	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/findmodrefs	1970-01-01 01:00:00.000000000 +0100
@@ -1,63 +0,0 @@
-#! /usr/bin/env python
-#  -*- Python -*-
-
-import fileinput
-import getopt
-import glob
-import os
-import re
-import sys
-
-
-declare_rx = re.compile(
-    r"\\declaremodule(?:\[[a-zA-Z0-9]*\]*)?{[a-zA-Z_0-9]+}{([a-zA-Z_0-9]+)}")
-
-module_rx = re.compile(r"\\module{([a-zA-Z_0-9]+)}")
-
-def main():
-    try:
-        just_list = 0
-        print_lineno = 0
-        opts, args = getopt.getopt(sys.argv[1:], "ln", ["list", "number"])
-        for opt, arg in opts:
-            if opt in ("-l", "--list"):
-                just_list = 1
-            elif opt in ("-n", "--number"):
-                print_lineno = 1
-        files = args
-        if not files:
-            files = glob.glob("*.tex")
-            files.sort()
-        modulename = None
-        for line in fileinput.input(files):
-            if line[:9] == r"\section{":
-                modulename = None
-                continue
-            if line[:16] == r"\modulesynopsys{":
-                continue
-            m = declare_rx.match(line)
-            if m:
-                modulename = m.group(1)
-                continue
-            if not modulename:
-                continue
-            m = module_rx.search(line)
-            if m:
-                name = m.group(1)
-                if name != modulename:
-                    filename = fileinput.filename()
-                    if just_list:
-                        print filename
-                        fileinput.nextfile()
-                        modulename = None
-                    elif print_lineno:
-                        print "%s(%d):%s" \
-                              % (filename, fileinput.filelineno(), line[:-1])
-                    else:
-                        print "%s:%s" % (filename, line[:-1])
-    except KeyboardInterrupt:
-        sys.exit(1)
-
-
-if __name__ == "__main__":
-    main()
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/fix_hack hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/fix_hack
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/fix_hack	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/fix_hack	1970-01-01 01:00:00.000000000 +0100
@@ -1,2 +0,0 @@
-#!/bin/sh
-sed -e 's/{\\ptt[ 	]*\\char[ 	]*'"'"'137}/_/g' <"$1" > "@$1" && mv "@$1" $1
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/fixinfo.el hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/fixinfo.el
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/fixinfo.el	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/fixinfo.el	1970-01-01 01:00:00.000000000 +0100
@@ -1,15 +0,0 @@
-(defun fix-python-texinfo ()
-  (goto-char (point-min))
-  (replace-regexp "\\(@setfilename \\)\\([-a-z]*\\)$"
-		  "\\1python-\\2.info")
-  (replace-string "@node Front Matter\n@chapter Abstract\n"
-		  "@node Abstract\n@section Abstract\n")
-  (mark-whole-buffer)
-  (texinfo-master-menu 'update-all-nodes)
-  (save-buffer)
-  )	;; fix-python-texinfo
-
-;; now really do it:
-(find-file (car command-line-args-left))
-(fix-python-texinfo)
-(kill-emacs)
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/fix_libaux.sed hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/fix_libaux.sed
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/fix_libaux.sed	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/fix_libaux.sed	1970-01-01 01:00:00.000000000 +0100
@@ -1,3 +0,0 @@
-#! /bin/sed -f
-s/{\\tt  \\hackscore  {}\\hackscore  {}/\\sectcode{__/
-s/\\hackscore  {}\\hackscore  {}/__/
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/getpagecounts hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/getpagecounts
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/getpagecounts	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/getpagecounts	1970-01-01 01:00:00.000000000 +0100
@@ -1,88 +0,0 @@
-#! /usr/bin/env python
-#  -*- Python -*-
-
-"""Generate a page count report of the PostScript version of the manuals."""
-
-__version__ = '$Revision: 1.1.1.1 $'
-
-
-class PageCounter:
-    def __init__(self):
-        self.doclist = []
-        self.total = 0
-        self.title_width = 0
-
-    def add_document(self, prefix, title):
-        count = count_pages(prefix + ".ps")
-        self.doclist.append((title, prefix, count))
-        self.title_width = max(self.title_width, len(title))
-        self.total = self.total + count
-
-    def dump(self):
-        fmt = "%%-%ds  (%%s.ps, %%d pages)" % self.title_width
-        for item in self.doclist:
-            print fmt % item
-        print
-        print "  Total page count:  %d" % self.total
-
-    def run(self):
-        for prefix, title in [
-            ("api", "Python/C API"),
-            ("ext", "Extending and Embedding the Python Interpreter"),
-            ("lib", "Python Library Reference"),
-            ("mac", "Macintosh Module Reference"),
-            ("ref", "Python Reference Manual"),
-            ("tut", "Python Tutorial"),
-            ("doc", "Documenting Python"),
-            ("inst", "Installing Python Modules"),
-            ("dist", "Distributing Python Modules"),
-            ]:
-            self.add_document(prefix, title)
-        print self.PREFIX
-        self.dump()
-        print self.SUFFIX
-
-    PREFIX = """\
-This is the PostScript version of the standard Python documentation.
-If you plan to print this, be aware that some of the documents are
-long.  It is formatted for printing on two-sided paper; if you do plan
-to print this, *please* print two-sided if you have a printer capable
-of it!  To locate published copies of the larger manuals, or other
-Python reference material, consult the PSA Online Bookstore at:
-
-             http://www.python.org/psa/bookstore/
-
-The following manuals are included:
-"""
-    SUFFIX = """\
-
-
-If you have any questions, comments, or suggestions regarding these
-documents, please send them via email to python-docs@python.org.
-
-If you would like to support the development and maintenance of
-documentation for Python, please consider joining the Python Software
-Activity (PSA; see http://www.python.org/psa/), or urging your
-organization to join the PSA or the Python Consortium (see
-http://www.python.org/consortium/).
-"""
-
-def count_pages(filename):
-    fp = open(filename)
-    count = 0
-    while 1:
-        lines = fp.readlines(1024*40)
-        if not lines:
-            break
-        for line in lines:
-            if line[:7] == "%%Page:":
-                count = count + 1
-    fp.close()
-    return count
-
-
-def main():
-    PageCounter().run()
-
-if __name__ == "__main__":
-    main()
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/html/about.dat hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/html/about.dat
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/html/about.dat	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/html/about.dat	1970-01-01 01:00:00.000000000 +0100
@@ -1,24 +0,0 @@
-<p> This document was generated using the <a
-    href="http://saftsack.fs.uni-bayreuth.de/;SPMtilde;latex2ht/">
-    <strong>LaTeX</strong>2<tt>HTML</tt></a> translator.
-</p>
-
-<p> <a
-    href="http://saftsack.fs.uni-bayreuth.de/;SPMtilde;latex2ht/">
-    <strong>LaTeX</strong>2<tt>HTML</tt></a> is Copyright &copy;
-  1993, 1994, 1995, 1996, 1997, <a
-    href="http://cbl.leeds.ac.uk/nikos/personal.html">Nikos
-    Drakos</a>, Computer Based Learning Unit, University of
-  Leeds, and Copyright &copy; 1997, 1998, <a
-    href="http://www.maths.mq.edu.au/;SPMtilde;ross/">Ross
-    Moore</a>, Mathematics Department, Macquarie University,
-  Sydney.
-</p>
-
-<p> The application of <a
-    href="http://saftsack.fs.uni-bayreuth.de/;SPMtilde;latex2ht/">
-    <strong>LaTeX</strong>2<tt>HTML</tt></a> to the Python
-  documentation has been heavily tailored by Fred L. Drake,
-  Jr.  Original navigation icons were contributed by Christopher
-  Petrilli.
-</p>
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/html/about.html hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/html/about.html
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/html/about.html	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/html/about.html	1970-01-01 01:00:00.000000000 +0100
@@ -1,74 +0,0 @@
-<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
-<html>
-  <head>
-    <title>About the Python Documentation</title>
-    <meta name="description"
-      content="Overview information about the Python documentation">
-    <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
-    <link rel="STYLESHEET" href="lib/lib.css">
-  </head>
-  <body>
-    <div class="navigation">
-      <table width="100%" cellpadding="0" cellspacing="2">
-          <tr>
-            <td><img width="32" height="32" align="bottom" border="0" alt=""
-                src="icons/blank.gif"></td>
-            <td><a href="./"
-                title="Python Documentation Index"><img width="32" height="32"
-                  align="bottom" border="0" alt="up"
-                  src="icons/up.gif"></a></td>
-            <td><img width="32" height="32" align="bottom" border="0" alt=""
-                src="icons/blank.gif"></td>
-            <td align="center" width="100%">About the Python Documentation</td>
-            <td><img width="32" height="32" align="bottom" border="0" alt=""
-                src="icons/blank.gif"></td>
-            <td><img width="32" height="32" align="bottom" border="0" alt=""
-                src="icons/blank.gif"></td>
-            <td><img width="32" height="32" align="bottom" border="0" alt=""
-                src="icons/blank.gif"></td>
-          </tr>
-      </table>
-      <b class="navlabel">Up:</b>
-      <span class="sectref">
-        <a href="./" title="Python Documentation Index">
-          Python Documentation Index</A></span>
-      <br>
-    </div>
-    <hr>
-
-    <h2>About the Python Documentation</h2>
-
-    <p>The Python documentation was originally written by Guido van
-      Rossum, but has increasingly become a community effort over the
-      past several years.  This growing collection of documents is
-      available in several formats, including typeset versions in PDF
-      and PostScript for printing, from the <a
-        href="http://www.python.org/">Python Web site</a>.
-
-    <p>A <a href="acks.html">list of contributors</a> is available.
-
-    <h2>Comments and Questions</h2>
-
-    <p> General comments and questions regarding this document should
-      be sent by email to <a href="mailto:python-docs@python.org"
-        >python-docs@python.org</a>.  If you find specific errors in
-      this document, please report the bug at the <a
-        href="http://sourceforge.net/bugs/?group_id=5470">Python Bug
-        Tracker</a> at <a href="http://sourceforge.net/">SourceForge</a>.
-    </p>
-
-    <p> Questions regarding how to use the information in this
-      document should be sent to the Python news group, <a
-        href="news:comp.lang.python">comp.lang.python</a>, or the <a
-        href="http://www.python.org/mailman/listinfo/python-list"
-        >Python mailing list</a> (which is gated to the newsgroup and
-      carries the same content).
-    </p>
-
-    <p> For any of these channels, please be sure not to send HTML email.
-      Thanks.
-    </p>
-
-    <hr>
-  </body>
-</html>
BinÃ¤rdateien hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/html/icons/blank.gif und hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/html/icons/blank.gif sind verschieden.
BinÃ¤rdateien hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/html/icons/blank.png und hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/html/icons/blank.png sind verschieden.
BinÃ¤rdateien hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/html/icons/contents.gif und hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/html/icons/contents.gif sind verschieden.
BinÃ¤rdateien hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/html/icons/contents.png und hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/html/icons/contents.png sind verschieden.
BinÃ¤rdateien hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/html/icons/index.gif und hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/html/icons/index.gif sind verschieden.
BinÃ¤rdateien hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/html/icons/index.png und hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/html/icons/index.png sind verschieden.
BinÃ¤rdateien hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/html/icons/modules.gif und hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/html/icons/modules.gif sind verschieden.
BinÃ¤rdateien hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/html/icons/modules.png und hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/html/icons/modules.png sind verschieden.
BinÃ¤rdateien hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/html/icons/next.gif und hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/html/icons/next.gif sind verschieden.
BinÃ¤rdateien hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/html/icons/next.png und hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/html/icons/next.png sind verschieden.
BinÃ¤rdateien hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/html/icons/previous.gif und hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/html/icons/previous.gif sind verschieden.
BinÃ¤rdateien hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/html/icons/previous.png und hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/html/icons/previous.png sind verschieden.
BinÃ¤rdateien hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/html/icons/up.gif und hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/html/icons/up.gif sind verschieden.
BinÃ¤rdateien hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/html/icons/up.png und hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/html/icons/up.png sind verschieden.
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/html/index.html.in hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/html/index.html.in
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/html/index.html.in	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/html/index.html.in	1970-01-01 01:00:00.000000000 +0100
@@ -1,117 +0,0 @@
-<html>
-  <head>
-    <title>Python @RELEASE@ Documentation - @DATE@</title>
-    <link rel="STYLESHEET" href="lib/lib.css" type="text/css">
-    <meta name="description"
-          content="Top-level index to the standard documentation for
-                   Python @RELEASE@.">
-    <style type="text/css">
-      a.title { font-weight: bold; font-size: 110%; }
-      ul { margin-left: 1em; padding: 0pt; border: 0pt; }
-    </style>
-  </head>
-  <body>
-	<div class="navigation">
-	<table align="center" width="100%" cellpadding="0" cellspacing="2">
-	<tr>
-	  <td><img width="32" height="32" align="bottom" border="0" alt=""
-	      src="icons/blank.gif"></td>
-	  <td><img width="32" height="32" align="bottom" border="0" alt=""
-	      src="icons/blank.gif"></td>
-	  <td><img width="32" height="32" align="bottom" border="0" alt=""
-	      src="icons/blank.gif"></td>
-	  <td align="center" width="100%">
-	    <b class="title">Python Documentation</b></td>
-	  <td><img width="32" height="32" align="bottom" border="0" alt=""
-	      src="icons/blank.gif"></td>
-	  <td><a href="modindex.html"><img width="32" height="32"
-		align="bottom" border="0" alt="Module Index"
-		src="icons/modules.gif"></a></td>
-	  <td><img width="32" height="32" align="bottom" border="0" alt=""
-	      src="icons/blank.gif"></A></td>
-	</tr>
-	</table>
-        <hr>
-	</div>
-    <div align="center" class="titlepage">
-      <h1>Python Documentation</h1>
-
-      <p>
-	<strong>Release @RELEASE@</strong>
-	<br>
-	<strong>@DATE@</strong>
-      </p>
-    </div>
-
-    <table align="center">
-      <tbody>
-      <tr><td>
-	  <ul>
-	    <li> <a href="tut/tut.html" class="title">Tutorial</a>
-	      <br>(start here)
-
-	    <li> <a href="modindex.html" class="title">Global Module Index</a>
-	      <br>(for quick access to all documentation)
-
-	    <li> <a href="lib/lib.html" class="title">Library Reference</a>
-	      <br>(keep this under your pillow)
-
-	    <li> <a href="mac/mac.html" class="title">Macintosh Module
-		Reference</a>
-	      <br>(this too, if you use a Macintosh)
-
-	    <li> <a href="inst/inst.html" class="title">Installing
-		Python Modules</a>
-	      <br>(for administrators)
-	  </ul>
-	  </td>
-	  <td>
-	  <ul>
-	    <li> <a href="ref/ref.html" class="title">Language Reference</a>
-	      <br>(for language lawyers)
-
-	    <li> <a href="ext/ext.html" class="title">Extending and
-		Embedding</a>
-	      <br>(tutorial for C/C++ programmers)
-
-	    <li> <a href="api/api.html" class="title">Python/C API</a>
-	      <br>(reference for C/C++ programmers)
-
-	    <li> <a href="doc/doc.html" class="title">Documenting Python</a>
-	      <br>(information for documentation authors)
-
-	    <li> <a href="dist/dist.html" class="title">Distributing
-		Python Modules</a>
-	      <br>(for developers and packagers)
-	  </ul>
-	  </td>
-	</tr>
-        <tr>
-          <td>
-          &nbsp;
-          <ul>
-            <li> <a href="http://www.python.org/doc/" class="title"
-                >Documentation Central</a>
-              <br>(for everyone)
-          </ul>
-          </td>
-          <td>
-          &nbsp;
-          <ul>
-            <li> <a href="http://www.python.org/doc/howto/" class="title"
-                >Python How-To Guides</a>
-              <br>(special topics)
-          </ul>
-          </td>
-        </tr>
-      </tbody>
-    </table>
-    <p>
-
-    <address>
-      <hr>
-      See <i><a href="about.html">About the Python Documentation</a></i>
-      for information on suggesting changes.
-    </address>
-  </body>
-</html>
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/html/stdabout.dat hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/html/stdabout.dat
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/html/stdabout.dat	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/html/stdabout.dat	1970-01-01 01:00:00.000000000 +0100
@@ -1,48 +0,0 @@
-<p> This document was generated using the <a
-    href="http://saftsack.fs.uni-bayreuth.de/;SPMtilde;latex2ht/">
-    <strong>LaTeX</strong>2<tt>HTML</tt></a> translator.
-</p>
-
-<p> <a
-    href="http://saftsack.fs.uni-bayreuth.de/;SPMtilde;latex2ht/">
-    <strong>LaTeX</strong>2<tt>HTML</tt></a> is Copyright &copy;
-  1993, 1994, 1995, 1996, 1997, <a
-    href="http://cbl.leeds.ac.uk/nikos/personal.html">Nikos
-    Drakos</a>, Computer Based Learning Unit, University of
-  Leeds, and Copyright &copy; 1997, 1998, <a
-    href="http://www.maths.mq.edu.au/;SPMtilde;ross/">Ross
-    Moore</a>, Mathematics Department, Macquarie University,
-  Sydney.
-</p>
-
-<p> The application of <a
-    href="http://saftsack.fs.uni-bayreuth.de/;SPMtilde;latex2ht/">
-    <strong>LaTeX</strong>2<tt>HTML</tt></a> to the Python
-  documentation has been heavily tailored by Fred L. Drake,
-  Jr.  Original navigation icons were contributed by Christopher
-  Petrilli.
-</p>
-
-<hr>
-
-<h2>Comments and Questions</h2>
-
-<p> General comments and questions regarding this document should
-  be sent by email to <a href="mailto:python-docs@python.org"
-    >python-docs@python.org</a>.  If you find specific errors in
-  this document, please report the bug at the <a
-    href="http://sourceforge.net/bugs/?group_id=5470">Python Bug
-    Tracker</a> at <a href="http://sourceforge.net/">SourceForge</a>.
-</p>
-
-<p> Questions regarding how to use the information in this
-  document should be sent to the Python news group, <a
-    href="news:comp.lang.python">comp.lang.python</a>, or the <a
-    href="http://www.python.org/mailman/listinfo/python-list"
-    >Python mailing list</a> (which is gated to the newsgroup and
-  carries the same content).
-</p>
-
-<p> For any of these channels, please be sure not to send HTML email.
-  Thanks.
-</p>
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/html/style.css hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/html/style.css
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/html/style.css	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/html/style.css	1970-01-01 01:00:00.000000000 +0100
@@ -1,88 +0,0 @@
-/*
- * The first part of this is the standard CSS generated by LaTeX2HTML,
- * with the "empty" declarations removed.
- */
-
-/* Century Schoolbook font is very similar to Computer Modern Math: cmmi */
-.math                   { font-family: "Century Schoolbook", serif; }
-.math i                 { font-family: "Century Schoolbook", serif;
-                          font-weight: bold }
-.boldmath               { font-family: "Century Schoolbook", serif;
-                          font-weight: bold }
-
-/* Implement both fixed-size and relative sizes: */
-small.xtiny             { font-size : xx-small }
-small.tiny              { font-size : x-small }
-small.scriptsize        { font-size : smaller }
-small.footnotesize      { font-size : small }
-big.xlarge              { font-size : large }
-big.xxlarge             { font-size : x-large }
-big.huge                { font-size : larger }
-big.xhuge               { font-size : xx-large }
-
-/*
- * Document-specific styles come next;
- * these are added for the Python documentation.
- *
- * Note that the size specifications for the H* elements are because
- * Netscape on Solaris otherwise doesn't get it right; they all end up
- * the normal text size.
- */
-
-body                    { color: #000000;
-                          background-color: #ffffff; }
-
-a:active                { color: #ff0000; }
-a:visited               { color: #551a8b; }
-a:link                  { color: #0000bb; }
-
-h1, h2, h3, h4, h5, h6  { font-family: avantgarde, sans-serif;
-                          font-weight: bold }
-h1                      { font-size: 180% }
-h2                      { font-size: 150% }
-h3, h4                  { font-size: 120% }
-code, tt                { font-family: monospace }
-var                     { font-family: times, serif;
-                          font-style: italic;
-                          font-weight: normal }
-
-.navigation td          { background-color: #99ccff;
-                          font-weight: bold;
-                          font-family: avantgarde, sans-serif;
-                          font-size: 110% }
-
-.release-info           { font-style: italic; }
-
-.titlegraphic           { vertical-align: top; }
-
-.verbatim               { color: #00008b }
-
-.email                  { font-family: avantgarde, sans-serif }
-.mimetype               { font-family: avantgarde, sans-serif }
-.newsgroup              { font-family: avantgarde, sans-serif }
-.url                    { font-family: avantgarde, sans-serif }
-.file                   { font-family: avantgarde, sans-serif }
-
-.tableheader            { background-color: #99ccff;
-                          font-family: avantgarde, sans-serif; }
-
-.refcount-info          { font-style: italic }
-.refcount-info .value   { font-weight: bold;
-                          color: #006600 }
-
-/*
- * Some decoration for the "See also:" blocks, in part inspired by some of
- * the styling on Lars Marius Garshol's XSA pages.
- * (The blue in the navigation bars is #99CCFF.)
- */
-.seealso                { background-color: #fffaf0;
-                          border: thin solid black;
-                          padding: 4pt }
-
-.seealso .heading       { font-size: 110% }
-
-/*
- * Class 'availability' is used for module availability statements at
- * the top of modules.
- */
-.availability .platform { font-weight: bold }
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/html2texi.pl hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/html2texi.pl
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/html2texi.pl	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/html2texi.pl	1970-01-01 01:00:00.000000000 +0100
@@ -1,1750 +0,0 @@
-#! /usr/bin/env perl
-# html2texi.pl -- Convert HTML documentation to Texinfo format
-# Michael Ernst <mernst@cs.washington.edu>
-# Time-stamp: <1999-01-12 21:34:27 mernst>
-
-# This program converts HTML documentation trees into Texinfo format.
-# Given the name of a main (or contents) HTML file, it processes that file,
-# and other files (transitively) referenced by it, into a Texinfo file
-# (whose name is chosen from the file or directory name of the argument).
-# For instance:
-#   html2texi.pl api/index.html
-# produces file "api.texi".
-
-# Texinfo format can be easily converted to Info format (for browsing in
-# Emacs or the standalone Info browser), to a printed manual, or to HTML.
-# Thus, html2texi.pl permits conversion of HTML files to Info format, and
-# secondarily enables producing printed versions of Web page hierarchies.
-
-# Unlike HTML, Info format is searchable.  Since Info is integrated into
-# Emacs, one can read documentation without starting a separate Web
-# browser.  Additionally, Info browsers (including Emacs) contain
-# convenient features missing from Web browsers, such as easy index lookup
-# and mouse-free browsing.
-
-# Limitations:
-# html2texi.pl is currently tuned to latex2html output (and it corrects
-# several latex2html bugs), but should be extensible to arbitrary HTML
-# documents.  It will be most useful for HTML with a hierarchical structure
-# and an index, and it recognizes those features as created by latex2html
-# (and possibly by some other tools).  The HTML tree to be traversed must
-# be on local disk, rather than being accessed via HTTP.
-# This script requires the use of "checkargs.pm".  To eliminate that
-# dependence, replace calls to check_args* by @_ (which is always the last
-# argument to those functions).
-# Also see the "to do" section, below.
-# Comments, suggestions, bug fixes, and enhancements are welcome.
-
-# Troubleshooting:
-# Malformed HTML can cause this program to abort, so
-# you should check your HTML files to make sure they are legal.
-
-
-###
-### Typical usage for the Python documentation:
-###
-
-# (Actually, most of this is in a Makefile instead.)
-# The resulting Info format Python documentation is currently available at
-# ftp://ftp.cs.washington.edu/homes/mernst/python-info.tar.gz
-
-# Fix up HTML problems, eg <DT><DL COMPACT><DD> should be <DT><DL COMPACT><DD>.
-
-# html2texi.pl /homes/fish/mernst/tmp/python-doc/html/api/index.html
-# html2texi.pl /homes/fish/mernst/tmp/python-doc/html/ext/index.html
-# html2texi.pl /homes/fish/mernst/tmp/python-doc/html/lib/index.html
-# html2texi.pl /homes/fish/mernst/tmp/python-doc/html/mac/index.html
-# html2texi.pl /homes/fish/mernst/tmp/python-doc/html/ref/index.html
-# html2texi.pl /homes/fish/mernst/tmp/python-doc/html/tut/index.html
-
-# Edit the generated .texi files:
-#   * change @setfilename to prefix "python-"
-#   * fix up any sectioning, such as for Abstract
-#   * make Texinfo menus
-#   * perhaps remove the @detailmenu ... @end detailmenu
-# In Emacs, to do all this:
-#   (progn (goto-char (point-min)) (replace-regexp "\\(@setfilename \\)\\([-a-z]*\\)$" "\\1python-\\2.info") (replace-string "@node Front Matter\n@chapter Abstract\n" "@node Abstract\n@section Abstract\n") (progn (mark-whole-buffer) (texinfo-master-menu 'update-all-nodes)) (save-buffer))
-
-# makeinfo api.texi
-# makeinfo ext.texi
-# makeinfo lib.texi
-# makeinfo mac.texi
-# makeinfo ref.texi
-# makeinfo tut.texi
-
-
-###
-### Structure of the code
-###
-
-# To be written...
-
-
-###
-### Design decisions
-###
-
-# Source and destination languages
-# --------------------------------
-# 
-# The goal is Info files; I create Texinfo, so I don't have to worry about
-# the finer details of Info file creation.  (I'm not even sure of its exact
-# format.)
-# 
-# Why not start from LaTeX rather than HTML?
-# I could hack latex2html itself to produce Texinfo instead, or fix up
-# partparse.py (which already translates LaTeX to Teinfo).
-#  Pros:
-#   * has high-level information such as index entries, original formatting
-#  Cons:
-#   * those programs are complicated to read and understand
-#   * those programs try to handle arbitrary LaTeX input, track catcodes,
-#     and more:  I don't want to go to that effort.  HTML isn't as powerful
-#     as LaTeX, so there are fewer subtleties.
-#   * the result wouldn't work for arbitrary HTML documents; it would be
-#     nice to eventually extend this program to HTML produced from Docbook,
-#     Frame, and more.
-
-# Parsing
-# -------
-# 
-# I don't want to view the text as a linear stream; I'd rather parse the
-# whole thing and then do pattern matching over the parsed representation (to
-# find idioms such as indices, lists of child nodes, etc.).
-#  * Perl provides HTML::TreeBuilder, which does just what I want.
-#     * libwww-perl: http://www.linpro.no/lwp/
-#     * TreeBuilder: HTML-Tree-0.51.tar.gz
-#  * Python Parsers, Formatters, and Writers don't really provide the right
-#    interface (and the version in Grail doesn't correspond to another
-#    distributed version, so I'm confused about which to be using).  I could
-#    write something in Python that creates a parse tree, but why bother?
-
-# Other implementation language issues:
-#  * Python lacks variable declarations, reasonable scoping, and static
-#    checking tools.  I've written some of the latter for myself that make
-#    my Perl programming a lot safer than my Python programming will be until
-#    I have a similar suite for that language.
-
-
-###########################################################################
-### To do
-###
-
-# Section names:
-#   Fix the problem with multiple sections in a single file (eg, Abstract in
-#     Front Matter section).
-#   Deal with cross-references, as in /homes/fish/mernst/tmp/python-doc/html/ref/types.html:310
-# Index:
-#   Perhaps double-check that every tag mentioned in the index is found
-#     in the text.
-# Python:  email to python-docs@python.org, to get their feedback.
-#   Compare to existing lib/ Info manual
-#   Write the hooks into info-look; replace pyliblookup1-1.tar.gz.
-#   Postpass to remove extra quotation marks around typography already in
-#     a different font (to avoid double delimiters as in "`code'"); or
-#     perhaps consider using only font-based markup so that we don't get
-#     the extra *bold* and `code' markup in Info.
-
-## Perhaps don't rely on automatic means for adding up, next, prev; I have
-## all that info available to me already, so it's not so much trouble to
-## add it.  (Right?)  But it is *so* easy to use Emacs instead...
-
-
-###########################################################################
-### Strictures
-###
-
-# man HTML::TreeBuilder
-# man HTML::Parser
-# man HTML::Element
-
-# require HTML::ParserWComment;
-require HTML::Parser;
-require HTML::TreeBuilder;
-require HTML::Element;
-
-use File::Basename;
-
-use strict;
-# use Carp;
-
-use checkargs;
-
-
-###########################################################################
-### Variables
-###
-
-my @section_stack = ();		# elements are chapter/section/subsec nodetitles (I think)
-my $current_ref_tdf;		# for the file currently being processed;
-				#  used in error messages
-my $html_directory;
-my %footnotes;
-
-# First element should not be used.
-my @sectionmarker = ("manual", "chapter", "section", "subsection", "subsubsection");
-
-my %inline_markup = ("b" => "strong",
-		     "code" => "code",
-		     "i" => "emph",
-		     "kbd" => "kbd",
-		     "samp" => "samp",
-		     "strong" => "strong",
-		     "tt" => "code",
-		     "var" => "var");
-
-my @deferred_index_entries = ();
-
-my @index_titles = ();		# list of (filename, type) lists
-my %index_info = ("Index" => ["\@blindex", "bl"],
-		  "Concept Index" => ["\@cindex", "cp"],
-		  "Module Index" => ["\@mdindex", "md"]);
-
-
-###########################################################################
-### Main/contents page
-###
-
-# Process first-level page on its own, or just a contents page?  Well, I do
-# want the title, author, etc., and the front matter...  For now, just add
-# that by hand at the end.
-
-
-# data structure possibilities:
-#  * tree-like (need some kind of stack when processing (or parent pointers))
-#  * list of name and depth; remember old and new depths.
-
-# Each element is a reference to a list of (nodetitle, depth, filename).
-my @contents_list = ();
-
-# The problem with doing fixups on the fly is that some sections may have
-# already been processed (and no longer available) by the time we notice
-# others with the same name.  It's probably better to fully construct the
-# contents list (reading in all files of interest) upfront; that will also
-# let me do a better job with cross-references, because again, all files
-# will already be read in.
-my %contents_hash = ();
-my %contents_fixups = ();
-
-my @current_contents_list = ();
-
-# Merge @current_contents_list into @contents_list,
-# and set @current_contents_list to be empty.
-sub merge_contents_lists ( )
-{ check_args(0, @_);
-
-  # Three possibilities:
-  #  * @contents_list is empty: replace it by @current_contents_list.
-  #  * prefixes of the two lists are identical: do nothing
-  #  * @current_contents_list is all at lower level than $contents_list[0];
-  #    prefix @contents_list by @current_contents_list
-
-  if (scalar(@current_contents_list) == 0)
-    { die "empty current_contents_list"; }
-
-  #   if (scalar(@contents_list) == 0)
-  #     { @contents_list = @current_contents_list;
-  #       @current_contents_list = ();
-  #       return; }
-
-  #   if (($ {$contents_list[0]}[1]) < ($ {$current_contents_list[0]}[1]))
-  #     { unshift @contents_list, @current_contents_list;
-  #       @current_contents_list = ();
-  #       return; }
-
-  for (my $i=0; $i<scalar(@current_contents_list); $i++)
-    { my $ref_c_tdf = $current_contents_list[$i];
-      if ($i >= scalar(@contents_list))
-	{ push @contents_list, $ref_c_tdf;
-	  my $title = $ {$ref_c_tdf}[0];
-	  if (defined $contents_hash{$title})
-	    { $contents_fixups{$title} = 1; }
-	  else
-	    { $contents_hash{$title} = 1; }
-	  next; }
-      my $ref_tdf = $contents_list[$i];
-      my ($title, $depth, $file) = @{$ref_tdf};
-      my ($c_title, $c_depth, $c_file) = @{$ref_c_tdf};
-
-      if (($title ne $c_title)
-	  && ($depth < $c_depth)
-	  && ($file ne $c_file))
-	{ splice @contents_list, $i, 0, $ref_c_tdf;
-	  if (defined $contents_hash{$c_title})
-	    { $contents_fixups{$c_title} = 1; }
-	  else
-	    { $contents_hash{$c_title} = 1; }
-	  next; }
-
-      if (($title ne $c_title)
-	  || ($depth != $c_depth)
-	  || ($file ne $c_file))
-	{ die ("while processing $ {$current_ref_tdf}[2] at depth $ {$current_ref_tdf}[1], mismatch at index $i:",
-	       "\n  main:  <<<$title>>> $depth $file",
-	       "\n  curr:  <<<$c_title>>> $c_depth $c_file"); }
-    }
-  @current_contents_list = ();
-}
-
-
-
-# Set @current_contents_list to a list of (title, href, sectionlevel);
-#  then merge that list into @contents_list.
-# Maybe this function should also produce a map
-#  from title (or href) to sectionlevel (eg "chapter"?).
-sub process_child_links ( $ )
-{ my ($he) = check_args(1, @_);
-
-  # $he->dump();
-  if (scalar(@current_contents_list) != 0)
-    { die "current_contents_list nonempty: @current_contents_list"; }
-  $he->traverse(\&increment_current_contents_list, 'ignore text');
-
-  # Normalize the depths; for instance, convert 1,3,5 into 0,1,2.
-  my %depths = ();
-  for my $ref_tdf (@current_contents_list)
-    { $depths{$ {$ref_tdf}[1]} = 1; }
-  my @sorted_depths = sort keys %depths;
-  my $current_depth = scalar(@section_stack)-1;
-  my $current_depth_2 = $ {$current_ref_tdf}[1];
-  if ($current_depth != $current_depth_2)
-    { die "mismatch in current depths: $current_depth $current_depth_2; ", join(", ", @section_stack); }
-  for (my $i=0; $i<scalar(@sorted_depths); $i++)
-    { $depths{$sorted_depths[$i]} = $i + $current_depth+1; }
-  for my $ref_tdf (@current_contents_list)
-    { $ {$ref_tdf}[1] = $depths{$ {$ref_tdf}[1]}; }
-
-  # Eliminate uninteresting sections.  Hard-coded hack for now.
-  if ($ {$current_contents_list[-1]}[0] eq "About this document ...")
-    { pop @current_contents_list; }
-  if ((scalar(@current_contents_list) > 1)
-      && ($ {$current_contents_list[1]}[0] eq "Contents"))
-    { my $ref_first_tdf = shift @current_contents_list;
-      $current_contents_list[0] = $ref_first_tdf; }
-
-  for (my $i=0; $i<scalar(@current_contents_list); $i++)
-    { my $ref_tdf = $current_contents_list[$i];
-      my $title = $ {$ref_tdf}[0];
-      if (exists $index_info{$title})
-	{ my $index_file = $ {$ref_tdf}[2];
-	  my ($indexing_command, $suffix) = @{$index_info{$title}};
-	  process_index_file($index_file, $indexing_command);
-	  print TEXI "\n\@defindex $suffix\n";
-	  push @index_titles, $title;
-	  splice @current_contents_list, $i, 1;
-	  $i--; }
-      elsif ($title =~ /\bIndex$/)
-	{ print STDERR "Warning: \"$title\" might be an index; if so, edit \%index_info.\n"; } }
-
-  merge_contents_lists();
-
-  # print_contents_list();
-  # print_index_info();
-}
-
-
-sub increment_current_contents_list ( $$$ )
-{ my ($he, $startflag, $depth) = check_args(3, @_);
-  if (!$startflag)
-    { return; }
-
-  if ($he->tag eq "li")
-    { my @li_content = @{$he->content};
-      if ($li_content[0]->tag ne "a")
-	{ die "first element of <LI> should be <A>"; }
-      my ($name, $href, @content) = anchor_info($li_content[0]);
-      # unused $name
-      my $title = join("", collect_texts($li_content[0]));
-      $title = texi_remove_punctuation($title);
-      # The problem with these is that they are formatted differently in
-      # @menu and @node!
-      $title =~ s/``/\"/g;
-      $title =~ s/''/\"/g;
-      $title =~ s/ -- / /g;
-      push @current_contents_list, [ $title, $depth, $href ]; }
-  return 1;
-}
-
-# Simple version for section titles
-sub html_to_texi ( $ )
-{ my ($he) = check_args(1, @_);
-  if (!ref $he)
-    { return $he; }
-
-  my $tag = $he->tag;
-  if (exists $inline_markup{$tag})
-    { my $result = "\@$inline_markup{$tag}\{";
-      for my $elt (@{$he->content})
-	{ $result .= html_to_texi($elt); }
-      $result .= "\}";
-      return $result; }
-  else
-    { $he->dump();
-      die "html_to_texi confused by <$tag>"; }
-}
-
-
-
-sub print_contents_list ()
-{ check_args(0, @_);
-  print STDERR "Contents list:\n";
-  for my $ref_tdf (@contents_list)
-    { my ($title, $depth, $file) = @{$ref_tdf};
-      print STDERR "$title $depth $file\n"; }
-}
-
-
-
-###########################################################################
-### Index
-###
-
-my $l2h_broken_link_name = "l2h-";
-
-
-# map from file to (map from anchor name to (list of index texts))
-# (The list is needed when a single LaTeX command like \envvar
-# expands to multiple \index commands.)
-my %file_index_entries = ();
-my %this_index_entries;		# map from anchor name to (list of index texts)
-
-my %file_index_entries_broken = (); # map from file to (list of index texts)
-my @this_index_entries_broken;
-
-my $index_prefix = "";
-my @index_prefixes = ();
-
-my $this_indexing_command;
-
-sub print_index_info ()
-{ check_args(0, @_);
-  my ($key, $val);
-  for my $file (sort keys %file_index_entries)
-    { my %index_entries = %{$file_index_entries{$file}};
-      print STDERR "file: $file\n";
-      for my $aname (sort keys %index_entries)
-	{ my @entries = @{$index_entries{$aname}};
-	  if (scalar(@entries) == 1)
-	    { print STDERR "  $aname : $entries[0]\n"; }
-	  else
-	    { print STDERR "  $aname : ", join("\n     " . (" " x length($aname)), @entries), "\n"; } } }
-  for my $file (sort keys %file_index_entries_broken)
-    { my @entries = @{$file_index_entries_broken{$file}};
-      print STDERR "file: $file\n";
-      for my $entry (@entries)
-	{ print STDERR "  $entry\n"; }
-    }
-}
-
-
-sub process_index_file ( $$ )
-{ my ($file, $indexing_command) = check_args(2, @_);
-  # print "process_index_file $file $indexing_command\n";
-
-  my $he = file_to_tree($html_directory . $file);
-  # $he->dump();
-
-  $this_indexing_command = $indexing_command;
-  $he->traverse(\&process_if_index_dl_compact, 'ignore text');
-  undef $this_indexing_command;
-  # print "process_index_file done\n";
-}
-
-
-sub process_if_index_dl_compact ( $$$ )
-{ my ($he, $startflag) = (check_args(3, @_))[0,1]; #  ignore depth argument
-  if (!$startflag)
-    { return; }
-
-  if (($he->tag() eq "dl") && (defined $he->attr('compact')))
-    { process_index_dl_compact($he);
-      return 0; }
-  else
-    { return 1; }
-}
-
-
-# The elements of a <DL COMPACT> list from a LaTeX2HTML index:
-#  * a single space: text to be ignored
-#  * <DT> elements with an optional <DD> element following each one
-#    Two types of <DT> elements:
-#     * Followed by a <DD> element:  the <DT> contains a single
-#       string, and the <DD> contains a whitespace string to be ignored, a
-#       <DL COMPACT> to be recursively processed (with the <DT> string as a
-#       prefix), and a whitespace string to be ignored.
-#     * Not followed by a <DD> element:  contains a list of anchors
-#       and texts (ignore the texts, which are only whitespace and commas).
-#       Optionally contains a <DL COMPACT> to be recursively processed (with
-#       the <DT> string as a prefix)
-sub process_index_dl_compact ( $ )
-{ my ($h) = check_args(1, @_);
-  my @content = @{$h->content()};
-  for (my $i = 0; $i < scalar(@content); $i++)
-    { my $this_he = $content[$i];
-      if ($this_he->tag ne "dt")
-	{ $this_he->dump();
-	  die "Expected <DT> tag: " . $this_he->tag; }
-      if (($i < scalar(@content) - 1) && ($content[$i+1]->tag eq "dd"))
-	{ process_index_dt_and_dd($this_he, $content[$i+1]);
-	  $i++;	}
-      else
-	{ process_index_lone_dt($this_he); } } }
-
-
-
-# Argument is a <DT> element.  If it contains more than one anchor, then
-# the texts of all subsequent ones are "[Link]".  Example:
-#       <DT>
-#         <A HREF="embedding.html#l2h-201">
-#           "$PATH"
-#         ", "
-#         <A HREF="embedding.html#l2h-205">
-#           "[Link]"
-# Optionally contains a <DL COMPACT> as well.  Example:
-# <DT>
-#   <A HREF="types.html#l2h-616">
-#     "attribute"
-#   <DL COMPACT>
-#     <DT>
-#       <A HREF="assignment.html#l2h-3074">
-#         "assignment"
-#       ", "
-#       <A HREF="assignment.html#l2h-3099">
-#         "[Link]"
-#     <DT>
-#       <A HREF="types.html#l2h-">
-#         "assignment, class"
-
-sub process_index_lone_dt ( $ )
-{ my ($dt) = check_args(1, @_);
-  my @dtcontent = @{$dt->content()};
-  my $acontent;
-  my $acontent_suffix;
-  for my $a (@dtcontent)
-    { if ($a eq ", ")
-	{ next; }
-      if (!ref $a)
-	{ $dt->dump;
-	  die "Unexpected <DT> string element: $a"; }
-
-      if ($a->tag eq "dl")
-	{ push @index_prefixes, $index_prefix;
-	  if (!defined $acontent_suffix)
-	    { die "acontent_suffix not yet defined"; }
-	  $index_prefix .= $acontent_suffix . ", ";
-	  process_index_dl_compact($a);
-	  $index_prefix = pop(@index_prefixes);
-	  return; }
-
-      if ($a->tag ne "a")
-	{ $dt->dump;
-	  $a->dump;
-	  die "Expected anchor in lone <DT>"; }
-
-      my ($aname, $ahref, @acontent) = anchor_info($a);
-      # unused $aname
-      if (scalar(@acontent) != 1)
-	{ die "Expected just one content of <A> in <DT>: @acontent"; }
-      if (ref $acontent[0])
-	{ $acontent[0]->dump;
-	  die "Expected string content of <A> in <DT>: $acontent[0]"; }
-      if (!defined($acontent))
-	{ $acontent = $index_prefix . $acontent[0];
-	  $acontent_suffix = $acontent[0]; }
-      elsif (($acontent[0] ne "[Link]") && ($acontent ne ($index_prefix . $acontent[0])))
-	{ die "Differing content: <<<$acontent>>>, <<<$acontent[0]>>>"; }
-
-      if (!defined $ahref)
-	{ $dt->dump;
-	  die "no HREF in nachor in <DT>"; }
-      my ($ahref_file, $ahref_name) = split(/\#/, $ahref);
-      if (!defined $ahref_name)
-	{ # Reference to entire file
-	  $ahref_name = ""; }
-
-      if ($ahref_name eq $l2h_broken_link_name)
-	{ if (!exists $file_index_entries_broken{$ahref_file})
-	    { $file_index_entries_broken{$ahref_file} = []; }
-	  push @{$file_index_entries_broken{$ahref_file}}, "$this_indexing_command $acontent";
-	  next; }
-
-      if (!exists $file_index_entries{$ahref_file})
-	{ $file_index_entries{$ahref_file} = {}; }
-      # Don't do this!  It appears to make a copy, which is not desired.
-      # my %index_entries = %{$file_index_entries{$ahref_file}};
-      if (!exists $ {$file_index_entries{$ahref_file}}{$ahref_name})
-	{ $ {$file_index_entries{$ahref_file}}{$ahref_name} = []; }
-      # 	{ my $oldcontent = $ {$file_index_entries{$ahref_file}}{$ahref_name};
-      # 	  if ($acontent eq $oldcontent)
-      # 	    { die "Multiple identical index entries?"; }
-      # 	  die "Trying to add $acontent, but already have index entry pointing at $ahref_file\#$ahref_name: ${$file_index_entries{$ahref_file}}{$ahref_name}"; }
-
-      push @{$ {$file_index_entries{$ahref_file}}{$ahref_name}}, "$this_indexing_command $acontent";
-      # print STDERR "keys: ", keys %{$file_index_entries{$ahref_file}}, "\n";
-    }
-}
-
-sub process_index_dt_and_dd ( $$ )
-{ my ($dt, $dd) = check_args(2, @_);
-  my $dtcontent;
-  { my @dtcontent = @{$dt->content()};
-    if ((scalar(@dtcontent) != 1) || (ref $dtcontent[0]))
-      { $dd->dump;
-	$dt->dump;
-	die "Expected single string (actual size = " . scalar(@dtcontent) . ") in content of <DT>: @dtcontent"; }
-    $dtcontent = $dtcontent[0];
-    $dtcontent =~ s/ +$//; }
-  my $ddcontent;
-  { my @ddcontent = @{$dd->content()};
-    if (scalar(@ddcontent) != 1)
-      { die "Expected single <DD> content, got ", scalar(@ddcontent), " elements:\n", join("\n", @ddcontent), "\n "; }
-    $ddcontent = $ddcontent[0]; }
-  if ($ddcontent->tag ne "dl")
-    { die "Expected <DL> as content of <DD>, but saw: $ddcontent"; }
-
-  push @index_prefixes, $index_prefix;
-  $index_prefix .= $dtcontent . ", ";
-  process_index_dl_compact($ddcontent);
-  $index_prefix = pop(@index_prefixes);
-}
-
-
-###########################################################################
-### Ordinary sections
-###
-
-sub process_section_file ( $$$ )
-{ my ($file, $depth, $nodetitle) = check_args(3, @_);
-  my $he = file_to_tree(($file =~ /^\//) ? $file : $html_directory . $file);
-
-  # print STDERR "process_section_file: $file $depth $nodetitle\n";
-
-  # Equivalently:
-  #   while ($depth >= scalar(@section_stack)) { pop(@section_stack); }
-  @section_stack = @section_stack[0..$depth-1];
-
-  # Not a great nodename fixup scheme; need a more global view
-  if ((defined $contents_fixups{$nodetitle})
-      && (scalar(@section_stack) > 0))
-    { my $up_title = $section_stack[$#section_stack];
-      # hack for Python Standard Library
-      $up_title =~ s/^(Built-in|Standard) Module //g;
-      my ($up_first_word) = split(/ /, $up_title);
-      $nodetitle = "$up_first_word $nodetitle";
-    }
-
-  push @section_stack, $nodetitle;
-  # print STDERR "new section_stack: ", join(", ", @section_stack), "\n";
-
-  $he->traverse(\&process_if_child_links, 'ignore text');
-  %footnotes = ();
-  # $he->dump;
-  $he->traverse(\&process_if_footnotes, 'ignore text');
-
-  # $he->dump;
-
-  if (exists $file_index_entries{$file})
-    { %this_index_entries = %{$file_index_entries{$file}};
-      # print STDERR "this_index_entries:\n ", join("\n ", keys %this_index_entries), "\n";
-    }
-  else
-    { # print STDERR "Warning: no index entries for file $file\n";
-      %this_index_entries = (); }
-
-  if (exists $file_index_entries_broken{$file})
-    { @this_index_entries_broken = @{$file_index_entries_broken{$file}}; }
-  else
-    { # print STDERR "Warning: no index entries for file $file\n";
-      @this_index_entries_broken = (); }
-
-
-  if ($he->tag() ne "html")
-    { die "Expected <HTML> at top level"; }
-  my @content = @{$he->content()};
-  if ((!ref $content[0]) or ($content[0]->tag ne "head"))
-    { $he->dump;
-      die "<HEAD> not first element of <HTML>"; }
-  if ((!ref $content[1]) or ($content[1]->tag ne "body"))
-    { $he->dump;
-      die "<BODY> not second element of <HTML>"; }
-
-  $content[1]->traverse(\&output_body);
-}
-
-# stack of things we're inside that are preventing indexing from occurring now.
-# These are "h1", "h2", "h3", "h4", "h5", "h6", "dt" (and possibly others?)
-my @index_deferrers = ();
-
-sub push_or_pop_index_deferrers ( $$ )
-{ my ($tag, $startflag) = check_args(2, @_);
-  if ($startflag)
-    { push @index_deferrers, $tag; }
-  else
-    { my $old_deferrer = pop @index_deferrers;
-      if ($tag ne $old_deferrer)
-	{ die "Expected $tag at top of index_deferrers but saw $old_deferrer; remainder = ", join(" ", @index_deferrers); }
-      do_deferred_index_entries(); }
-}
-
-
-sub label_add_index_entries ( $;$ )
-{ my ($label, $he) = check_args_range(1, 2, @_);
-  # print ((exists $this_index_entries{$label}) ? "*" : " "), " label_add_index_entries $label\n";
-  # $he is the anchor element
-  if (exists $this_index_entries{$label})
-    { push @deferred_index_entries, @{$this_index_entries{$label}};
-      return; }
-
-  if ($label eq $l2h_broken_link_name)
-    { # Try to find some text to use in guessing which links should point here
-      # I should probably only look at the previous element, or if that is
-      # all punctuation, the one before it; collecting all the previous texts
-      # is a bit of overkill.
-      my @anchor_texts = collect_texts($he);
-      my @previous_texts = collect_texts($he->parent, $he);
-      # 4 elements is arbitrary; ought to filter out punctuation and small words
-      # first, then perhaps keep fewer.  Perhaps also filter out formatting so
-      # that we can see a larger chunk of text?  (Probably not.)
-      # Also perhaps should do further chunking into words, in case the
-      # index term isn't a chunk of its own (eg, was in <tt>...</tt>.
-      my @candidate_texts = (@anchor_texts, (reverse(@previous_texts))[0..min(3,$#previous_texts)]);
-
-      my $guessed = 0;
-      for my $text (@candidate_texts)
-	{ # my $orig_text = $text;
-	  if ($text =~ /^[\"\`\'().?! ]*$/)
-	    { next; }
-	  if (length($text) <= 2)
-	    { next; }
-	  # hack for Python manual; maybe defer until failure first time around?
-	  $text =~ s/^sys\.//g;
-	  for my $iterm (@this_index_entries_broken)
-	    { # I could test for zero:  LaTeX2HTML's failures in the Python
-	      # documentation are only for items of the form "... (built-in...)"
-	      if (index($iterm, $text) != -1)
-		{ push @deferred_index_entries, $iterm;
-		  # print STDERR "Guessing index term `$iterm' for text `$orig_text'\n";
-		  $guessed = 1;
-		} } }
-      if (!$guessed)
-	{ # print STDERR "No guess in `", join("'; `", @this_index_entries_broken), "' for texts:\n `", join("'\n `", @candidate_texts), "'\n";
-	}
-    }
-}
-
-
-# Need to add calls to this at various places.
-# Perhaps add HTML::Element argument and do the check for appropriateness
-# here (ie, no action if inside <H1>, etc.).
-sub do_deferred_index_entries ()
-{ check_args(0, @_);
-  if ((scalar(@deferred_index_entries) > 0)
-      && (scalar(@index_deferrers) == 0))
-    { print TEXI "\n", join("\n", @deferred_index_entries), "\n";
-      @deferred_index_entries = (); }
-}
-
-my $table_columns;		# undefined if not in a table
-my $table_first_column;		# boolean
-
-sub output_body ( $$$ )
-{ my ($he, $startflag) = (check_args(3, @_))[0,1]; #  ignore depth argument
-
-  if (!ref $he)
-    { my $space_index = index($he, " ");
-      if ($space_index != -1)
-	{ # Why does
-	  #   print TEXI texi_quote(substr($he, 0, $space_index+1));
-	  # give:  Can't locate object method "TEXI" via package "texi_quote"
-	  # (Because the definition texi_quote hasn't been seen yet.)
-	  print TEXI &texi_quote(substr($he, 0, $space_index+1));
-	  do_deferred_index_entries();
-	  print TEXI &texi_quote(substr($he, $space_index+1)); }
-      else
-	{ print TEXI &texi_quote($he); }
-      return; }
-
-  my $tag = $he->tag();
-
-  # Ordinary text markup first
-  if (exists $inline_markup{$tag})
-    { if ($startflag)
-	{ print TEXI "\@$inline_markup{$tag}\{"; }
-      else
-	{ print TEXI "\}"; } }
-  elsif ($tag eq "a")
-    { my ($name, $href, @content) = anchor_info($he);
-      if (!$href)
-	{ # This anchor is only here for indexing/cross referencing purposes.
-	  if ($startflag)
-	    { label_add_index_entries($name, $he); }
-	}
-      elsif ($href =~ "^(ftp|http|news):")
-	{ if ($startflag)
-	    { # Should avoid second argument if it's identical to the URL.
-	      print TEXI "\@uref\{$href, "; }
-	  else
-	    { print TEXI "\}"; }
-	}
-      elsif ($href =~ /^\#(foot[0-9]+)$/)
-	{ # Footnote
-	  if ($startflag)
-	    { # Could double-check name and content, but I'm not
-	      # currently storing that information.
-	      print TEXI "\@footnote\{";
-	      $footnotes{$1}->traverse(\&output_body);
-	      print TEXI "\}";
-	      return 0; } }
-      else
-	{ if ($startflag)
-	    { # cross-references are not active Info links, but no text is lost
-	      print STDERR "Can't deal with internal HREF anchors yet:\n";
-	      $he->dump; }
-	}
-    }
-  elsif ($tag eq "br")
-    { print TEXI "\@\n"; }
-  elsif ($tag eq "body")
-    { }
-  elsif ($tag eq "center")
-    { if (has_single_content_string($he)
-	  && ($ {$he->content}[0] =~ /^ *$/))
-	{ return 0; }
-      if ($startflag)
-	{ print TEXI "\n\@center\n"; }
-      else
-	{ print TEXI "\n\@end center\n"; }
-    }
-  elsif ($tag eq "div")
-    { my $align = $he->attr('align');
-      if (defined($align) && ($align eq "center"))
-	{ if (has_single_content_string($he)
-	      && ($ {$he->content}[0] =~ /^ *$/))
-	    { return 0; }
-	  if ($startflag)
-	    { print TEXI "\n\@center\n"; }
-	  else
-	    { print TEXI "\n\@end center\n"; } }
-    }
-  elsif ($tag eq "dl")
-    { # Recognize "<dl><dd><pre> ... </pre></dl>" paradigm for "@example"
-      if (has_single_content_with_tag($he, "dd"))
-	{ my $he_dd = $ {$he->content}[0];
-	  if (has_single_content_with_tag($he_dd, "pre"))
-	    { my $he_pre = $ {$he_dd->content}[0];
-	      print_pre($he_pre);
-	      return 0; } }
-      if ($startflag)
-	{ # Could examine the elements, to be cleverer about formatting.
-	  # (Also to use ftable, vtable...)
-	  print TEXI "\n\@table \@asis\n"; }
-      else
-	{ print TEXI "\n\@end table\n"; }
-    }
-  elsif ($tag eq "dt")
-    { push_or_pop_index_deferrers($tag, $startflag);
-      if ($startflag)
-	{ print TEXI "\n\@item "; }
-      else
-	{ } }
-  elsif ($tag eq "dd")
-    { if ($startflag)
-	{ print TEXI "\n"; }
-      else
-	{ }
-      if (scalar(@index_deferrers) != 0)
-	{ $he->dump;
-	  die "Unexpected <$tag> while inside: (" . join(" ", @index_deferrers) . "); bad HTML?"; }
-      do_deferred_index_entries();
-    }
-  elsif ($tag =~ /^(font|big|small)$/)
-    { # Do nothing for now.
-    }
-  elsif ($tag =~ /^h[1-6]$/)
-    { # We don't need this because we never recursively enter the heading content.
-      # push_or_pop_index_deferrers($tag, $startflag);
-      my $secname = "";
-      my @seclabels = ();
-      for my $elt (@{$he->content})
-	{ if (!ref $elt)
-	    { $secname .= $elt; }
-	  elsif ($elt->tag eq "br")
-	    { }
-	  elsif ($elt->tag eq "a")
-	    { my ($name, $href, @acontent) = anchor_info($elt);
-              if ($href)
-                { $he->dump;
-                  $elt->dump;
-                  die "Nonsimple anchor in <$tag>"; }
-	      if (!defined $name)
-		{ die "No NAME for anchor in $tag"; }
-	      push @seclabels, $name;
-	      for my $subelt (@acontent)
-		{ $secname .= html_to_texi($subelt); } }
-	  else
-	    { $secname .= html_to_texi($elt); } }
-      if ($secname eq "")
-	{ die "No section name in <$tag>"; }
-      if (scalar(@section_stack) == 1)
-	{ if ($section_stack[-1] ne "Top")
-	    { die "Not top? $section_stack[-1]"; }
-	  print TEXI "\@settitle $secname\n";
-	  print TEXI "\@c %**end of header\n";
-	  print TEXI "\n";
-	  print TEXI "\@node Top\n";
-	  print TEXI "\n"; }
-      else
-	{ print TEXI "\n\@node $section_stack[-1]\n";
-	  print TEXI "\@$sectionmarker[scalar(@section_stack)-1] ", texi_remove_punctuation($secname), "\n"; }
-      for my $seclabel (@seclabels)
-	{ label_add_index_entries($seclabel); }
-      # This should only happen once per file.
-      label_add_index_entries("");
-      if (scalar(@index_deferrers) != 0)
-	{ $he->dump;
-	  die "Unexpected <$tag> while inside: (" . join(" ", @index_deferrers) . "); bad HTML?"; }
-      do_deferred_index_entries();
-      return 0;
-    }
-  elsif ($tag eq "hr")
-    { }
-  elsif ($tag eq "ignore")
-    { # Hack for ignored elements
-      return 0;
-    }
-  elsif ($tag eq "li")
-    { if ($startflag)
-	{ print TEXI "\n\n\@item\n";
-	  do_deferred_index_entries(); } }
-  elsif ($tag eq "ol")
-    { if ($startflag)
-	{ print TEXI "\n\@enumerate \@bullet\n"; }
-      else
-	{ print TEXI "\n\@end enumerate\n"; } }
-  elsif ($tag eq "p")
-    { if ($startflag)
-	{ print TEXI "\n\n"; }
-      if (scalar(@index_deferrers) != 0)
-	{ $he->dump;
-	  die "Unexpected <$tag> while inside: (" . join(" ", @index_deferrers) . "); bad HTML?"; }
-      do_deferred_index_entries(); }
-  elsif ($tag eq "pre")
-    { print_pre($he);
-      return 0; }
-  elsif ($tag eq "table")
-    { # Could also indicate common formatting for first column, or
-      # determine relative widths for columns (or determine a prototype row)
-      if ($startflag)
-	{ if (defined $table_columns)
-	    { $he->dump;
-	      die "Can't deal with table nested inside $table_columns-column table"; }
-	  $table_columns = table_columns($he);
-	  if ($table_columns < 2)
-	    { $he->dump;
-	      die "Column with $table_columns columns?"; }
-	  elsif ($table_columns == 2)
-	    { print TEXI "\n\@table \@asis\n"; }
-	  else
-	    { print TEXI "\n\@multitable \@columnfractions";
-	      for (my $i=0; $i<$table_columns; $i++)
-		{ print TEXI " ", 1.0/$table_columns; }
-	      print TEXI "\n"; } }
-      else
-	{ if ($table_columns == 2)
-	    { print TEXI "\n\@end table\n"; }
-	  else
-	    { print TEXI "\n\@end multitable\n"; }
-	  undef $table_columns; } }
-  elsif (($tag eq "td") || ($tag eq "th"))
-    { if ($startflag)
-	{ if ($table_first_column)
-	    { print TEXI "\n\@item ";
-	      $table_first_column = 0; }
-	  elsif ($table_columns > 2)
-	    { print TEXI "\n\@tab "; } }
-      else
-	{ print TEXI "\n"; } }
-  elsif ($tag eq "tr")
-    { if ($startflag)
-	{ $table_first_column = 1; } }
-  elsif ($tag eq "ul")
-    { if ($startflag)
-	{ print TEXI "\n\@itemize \@bullet\n"; }
-      else
-	{ print TEXI "\n\@end itemize\n"; } }
-  else
-    { # I used to have a newline before "output_body" here.
-      print STDERR "output_body: ignoring <$tag> tag\n";
-      $he->dump;
-      return 0; }
-
-  return 1;
-}
-
-sub print_pre ( $ )
-{ my ($he_pre) = check_args(1, @_);
-  if (!has_single_content_string($he_pre))
-    { die "Multiple or non-string content for <PRE>: ", @{$he_pre->content}; }
-  my $pre_content = $ {$he_pre->content}[0];
-  print TEXI "\n\@example";
-  print TEXI &texi_quote($pre_content);
-  print TEXI "\@end example\n";
-}
-
-sub table_columns ( $ )
-{ my ($table) = check_args(1, @_);
-  my $result = 0;
-  for my $row (@{$table->content})
-    { if ($row->tag ne "tr")
-	{ $table->dump;
-	  $row->dump;
-	  die "Expected <TR> as table row."; }
-      $result = max($result, scalar(@{$row->content})); }
-  return $result;
-}
-
-
-###########################################################################
-### Utilities
-###
-
-sub min ( $$ )
-{ my ($x, $y) = check_args(2, @_);
-  return ($x < $y) ? $x : $y;
-}
-
-sub max ( $$ )
-{ my ($x, $y) = check_args(2, @_);
-  return ($x > $y) ? $x : $y;
-}
-
-sub file_to_tree ( $ )
-{ my ($file) = check_args(1, @_);
-
-  my $tree = new HTML::TreeBuilder;
-  $tree->ignore_unknown(1);
-  # $tree->warn(1);
-  $tree->parse_file($file);
-  cleanup_parse_tree($tree);
-  return $tree
-}
-
-
-sub has_single_content ( $ )
-{ my ($he) = check_args(1, @_);
-  if (!ref $he)
-    { # return 0;
-      die "Non-reference argument: $he"; }
-  my $ref_content = $he->content;
-  if (!defined $ref_content)
-    { return 0; }
-  my @content = @{$ref_content};
-  if (scalar(@content) != 1)
-    { return 0; }
-  return 1;
-}
-
-
-# Return true if the content of the element contains only one element itself,
-# and that inner element has the specified tag.
-sub has_single_content_with_tag ( $$ )
-{ my ($he, $tag) = check_args(2, @_);
-  if (!has_single_content($he))
-    { return 0; }
-  my $content = $ {$he->content}[0];
-  if (!ref $content)
-    { return 0; }
-  my $content_tag = $content->tag;
-  if (!defined $content_tag)
-    { return 0; }
-  return $content_tag eq $tag;
-}
-
-sub has_single_content_string ( $ )
-{ my ($he) = check_args(1, @_);
-  if (!has_single_content($he))
-    { return 0; }
-  my $content = $ {$he->content}[0];
-  if (ref $content)
-    { return 0; }
-  return 1;
-}
-
-
-# Return name, href, content.  First two may be undefined; third is an array.
-# I don't see how to determine if there are more attributes.
-sub anchor_info ( $ )
-{ my ($he) = check_args(1, @_);
-  if ($he->tag ne "a")
-    { $he->dump;
-      die "passed non-anchor to anchor_info"; }
-  my $name = $he->attr('name');
-  my $href = $he->attr('href');
-  my @content = ();
-  { my $ref_content = $he->content;
-    if (defined $ref_content)
-      { @content = @{$ref_content}; } }
-  return ($name, $href, @content);
-}
-
-
-sub texi_quote ( $ )
-{ my ($text) = check_args(1, @_);
-  $text =~ s/([\@\{\}])/\@$1/g;
-  $text =~ s/ -- / --- /g;
-  return $text;
-}
-
-# Eliminate bad punctuation (that confuses Makeinfo or Info) for section titles.
-sub texi_remove_punctuation ( $ )
-{ my ($text) = check_args(1, @_);
-
-  $text =~ s/^ +//g;
-  $text =~ s/[ :]+$//g;
-  $text =~ s/^[1-9][0-9.]* +//g;
-  $text =~ s/,//g;
-  # Both embedded colons and " -- " confuse makeinfo.  (Perhaps " -- "
-  # gets converted into " - ", just as "---" would be converted into " -- ",
-  # so the names end up differing.)
-  # $text =~ s/:/ -- /g;
-  $text =~ s/://g;
-  return $text;
-}
-
-
-## Do not use this inside `traverse':  it throws off the traversal.  Use
-## html_replace_by_ignore or html_replace_by_meta instead.
-# Returns 1 if success, 0 if failure.
-sub html_remove ( $;$ )
-{ my ($he, $parent) = check_args_range(1, 2, @_);
-  if (!defined $parent)
-    { $parent = $he->parent; }
-  my $ref_pcontent = $parent->content;
-  my @pcontent = @{$ref_pcontent};
-  for (my $i=0; $i<scalar(@pcontent); $i++)
-    { if ($pcontent[$i] eq $he)
-	{ splice @{$ref_pcontent}, $i, 1;
-	  $he->parent(undef);
-	  return 1; } }
-  die "Didn't find $he in $parent";
-}
-
-
-sub html_replace ( $$;$ )
-{ my ($orig, $new, $parent) = check_args_range(2, 3, @_);
-  if (!defined $parent)
-    { $parent = $orig->parent; }
-  my $ref_pcontent = $parent->content;
-  my @pcontent = @{$ref_pcontent};
-  for (my $i=0; $i<scalar(@pcontent); $i++)
-    { if ($pcontent[$i] eq $orig)
-	{ $ {$ref_pcontent}[$i] = $new;
-	  $new->parent($parent);
-	  $orig->parent(undef);
-	  return 1; } }
-  die "Didn't find $orig in $parent";
-}
-
-sub html_replace_by_meta ( $;$ )
-{ my ($orig, $parent) = check_args_range(1, 2, @_);
-  my $meta = new HTML::Element "meta";
-  if (!defined $parent)
-    { $parent = $orig->parent; }
-  return html_replace($orig, $meta, $parent);
-}
-
-sub html_replace_by_ignore ( $;$ )
-{ my ($orig, $parent) = check_args_range(1, 2, @_);
-  my $ignore = new HTML::Element "ignore";
-  if (!defined $parent)
-    { $parent = $orig->parent; }
-  return html_replace($orig, $ignore, $parent);
-}
-
-
-
-###
-### Collect text elements
-###
-
-my @collected_texts;
-my $collect_texts_stoppoint;
-my $done_collecting;
-
-sub collect_texts ( $;$ )
-{ my ($root, $stop) = check_args_range(1, 2, @_);
-  # print STDERR "collect_texts: $root $stop\n";
-  $collect_texts_stoppoint = $stop;
-  $done_collecting = 0;
-  @collected_texts = ();
-  $root->traverse(\&collect_if_text); # process texts
-  # print STDERR "collect_texts => ", join(";;;", @collected_texts), "\n";
-  return @collected_texts;
-}
-
-sub collect_if_text ( $$$ )
-{ my $he = (check_args(3, @_))[0]; #  ignore depth and startflag arguments
-  if ($done_collecting)
-    { return 0; }
-  if (!defined $he)
-    { return 0; }
-  if (!ref $he)
-    { push @collected_texts, $he;
-      return 0; }
-  if ((defined $collect_texts_stoppoint) && ($he eq $collect_texts_stoppoint))
-    { $done_collecting = 1;
-      return 0; }
-  return 1;
-}
-
-
-###########################################################################
-### Clean up parse tree
-###
-
-sub cleanup_parse_tree ( $ )
-{ my ($he) = check_args(1, @_);
-  $he->traverse(\&delete_if_navigation, 'ignore text');
-  $he->traverse(\&delete_extra_spaces, 'ignore text');
-  $he->traverse(\&merge_dl, 'ignore text');
-  $he->traverse(\&reorder_dt_and_dl, 'ignore text');
-  return $he;
-}
-
-
-## Simpler version that deletes contents but not the element itself.
-# sub delete_if_navigation ( $$$ )
-# { my $he = (check_args(3, @_))[0]; # ignore startflag and depth
-#   if (($he->tag() eq "div") && ($he->attr('class') eq 'navigation'))
-#     { $he->delete();
-#       return 0; }
-#   else
-#     { return 1; }
-# }
-
-sub delete_if_navigation ( $$$ )
-{ my ($he, $startflag) = (check_args(3, @_))[0,1]; #  ignore depth argument
-  if (!$startflag)
-    { return; }
-
-  if (($he->tag() eq "div") && (defined $he->attr('class')) && ($he->attr('class') eq 'navigation'))
-    { my $ref_pcontent = $he->parent()->content();
-      # Don't try to modify @pcontent, which appears to be a COPY.
-      # my @pcontent = @{$ref_pcontent};
-      for (my $i = 0; $i<scalar(@{$ref_pcontent}); $i++)
-	{ if (${$ref_pcontent}[$i] eq $he)
-	    { splice(@{$ref_pcontent}, $i, 1);
-	      last; } }
-      $he->delete();
-      return 0; }
-  else
-    { return 1; }
-}
-
-sub delete_extra_spaces ( $$$ )
-{ my ($he, $startflag) = (check_args(3, @_))[0,1]; #  ignore depth argument
-  if (!$startflag)
-    { return; }
-
-  my $tag = $he->tag;
-  if ($tag =~ /^(head|html|table|tr|ul)$/)
-    { delete_child_spaces($he); }
-  delete_trailing_spaces($he);
-  return 1;
-}
-
-
-sub delete_child_spaces ( $ )
-{ my ($he) = check_args(1, @_);
-  my $ref_content = $he->content();
-  for (my $i = 0; $i<scalar(@{$ref_content}); $i++)
-    { if ($ {$ref_content}[$i] =~ /^ *$/)
-	{ splice(@{$ref_content}, $i, 1);
-	  $i--; } }
-}
-
-sub delete_trailing_spaces ( $ )
-{ my ($he) = check_args(1, @_);
-  my $ref_content = $he->content();
-  if (! defined $ref_content)
-    { return; }
-  # Could also check for previous element = /^h[1-6]$/.
-  for (my $i = 0; $i<scalar(@{$ref_content})-1; $i++)
-    { if ($ {$ref_content}[$i] =~ /^ *$/)
-	{ my $next_elt = $ {$ref_content}[$i+1];
-	  if ((ref $next_elt) && ($next_elt->tag =~ /^(br|dd|dl|dt|hr|p|ul)$/))
-	    { splice(@{$ref_content}, $i, 1);
-	      $i--; } } }
-  if ($he->tag =~ /^(dd|dt|^h[1-6]|li|p)$/)
-    { my $last_elt = $ {$ref_content}[$#{$ref_content}];
-      if ((defined $last_elt) && ($last_elt =~ /^ *$/))
-	{ pop @{$ref_content}; } }
-}
-
-
-# LaTeX2HTML sometimes creates
-#   <DT>text
-#   <DL COMPACT><DD>text
-# which should actually be:
-#   <DL COMPACT>
-#   <DT>text
-#   <DD>text
-# Since a <DL> gets added, this ends up looking like
-# <P>
-#   <DL>
-#     <DT>
-#       text1...
-#       <DL COMPACT>
-#         <DD>
-#           text2...
-#         dt_or_dd1...
-#     dt_or_dd2...
-# which should become
-# <P>
-#   <DL COMPACT>
-#     <DT>
-#       text1...
-#     <DD>
-#       text2...
-#     dt_or_dd1...
-#     dt_or_dd2...
-
-sub reorder_dt_and_dl ( $$$ )
-{ my ($he, $startflag) = (check_args(3, @_))[0,1]; #  ignore depth argument
-  if (!$startflag)
-    { return; }
-
-  if ($he->tag() eq "p")
-    { my $ref_pcontent = $he->content();
-      if (defined $ref_pcontent)
-	{ my @pcontent = @{$ref_pcontent};
-	  # print "reorder_dt_and_dl found a <p>\n"; $he->dump();
-	  if ((scalar(@pcontent) >= 1)
-	      && (ref $pcontent[0]) && ($pcontent[0]->tag() eq "dl")
-	      && $pcontent[0]->implicit())
-	    { my $ref_dlcontent = $pcontent[0]->content();
-	      # print "reorder_dt_and_dl found a <p> and implicit <dl>\n";
-	      if (defined $ref_dlcontent)
-		{ my @dlcontent = @{$ref_dlcontent};
-		  if ((scalar(@dlcontent) >= 1)
-		      && (ref $dlcontent[0]) && ($dlcontent[0]->tag() eq "dt"))
-		    { my $ref_dtcontent = $dlcontent[0]->content();
-		      # print "reorder_dt_and_dl found a <p>, implicit <dl>, and <dt>\n";
-		      if (defined $ref_dtcontent)
-			{ my @dtcontent = @{$ref_dtcontent};
-			  if ((scalar(@dtcontent) > 0)
-			      && (ref $dtcontent[$#dtcontent])
-			      && ($dtcontent[$#dtcontent]->tag() eq "dl"))
-			    { my $ref_dl2content = $dtcontent[$#dtcontent]->content();
-			      # print "reorder_dt_and_dl found a <p>, implicit <dl>, <dt>, and <dl>\n";
-			      if (defined $ref_dl2content)
-				{ my @dl2content = @{$ref_dl2content};
-				  if ((scalar(@dl2content) > 0)
-				      && (ref ($dl2content[0]))
-				      && ($dl2content[0]->tag() eq "dd"))
-			    {
-			      # print "reorder_dt_and_dl found a <p>, implicit <dl>, <dt>, <dl>, and <dd>\n";
-			      # print STDERR "CHANGING\n"; $he->dump();
-			      html_replace_by_ignore($dtcontent[$#dtcontent]);
-			      splice(@{$ref_dlcontent}, 1, 0, @dl2content);
-			      # print STDERR "CHANGED TO:\n"; $he->dump();
-			      return 0; # don't traverse children
-			    } } } } } } } } }
-  return 1;
-}
-
-
-# If we find a paragraph that looks like
-# <P>
-#   <HR>
-#   <UL>
-# then accumulate its links into a contents_list and delete the paragraph.
-sub process_if_child_links ( $$$ )
-{ my ($he, $startflag) = (check_args(3, @_))[0,1]; #  ignore depth argument
-  if (!$startflag)
-    { return; }
-
-  if ($he->tag() eq "p")
-    { my $ref_content = $he->content();
-      if (defined $ref_content)
-	{ my @content = @{$ref_content};
-	  if ((scalar(@content) == 2)
-	      && (ref $content[0]) && $content[0]->tag() eq "hr"
-	      && (ref $content[1]) && $content[1]->tag() eq "ul")
-	    { process_child_links($he);
-	      $he->delete();
-	      return 0; } } }
-  return 1;
-}
-
-
-# If we find
-#     <H4>
-#       "Footnotes"
-#     <DL>
-#       <DT>
-#         <A NAME="foot560">
-#           "...borrow"
-#         <A HREF="refcountsInPython.html#tex2html2" NAME="foot560">
-#           "1.2"
-#       <DD>
-#         "The metaphor of ``borrowing'' a reference is not completely correct: the owner still has a copy of the reference. "
-#       ...
-# then record the footnote information and delete the section and list.
-
-my $process_if_footnotes_expect_dl_next = 0;
-
-sub process_if_footnotes ( $$$ )
-{ my ($he, $startflag) = (check_args(3, @_))[0,1]; #  ignore depth argument
-  if (!$startflag)
-    { return; }
-
-  if (($he->tag() eq "h4")
-      && has_single_content_string($he)
-      && ($ {$he->content}[0] eq "Footnotes"))
-    { html_replace_by_ignore($he);
-      $process_if_footnotes_expect_dl_next = 1;
-      return 0; }
-
-  if ($process_if_footnotes_expect_dl_next && ($he->tag() eq "dl"))
-    { my $ref_content = $he->content();
-      if (defined $ref_content)
-	{ $process_if_footnotes_expect_dl_next = 0;
-	  my @content = @{$ref_content};
-	  for (my $i=0; $i<$#content; $i+=2)
-	    { my $he_dt = $content[$i];
-	      my $he_dd = $content[$i+1];
-	      if (($he_dt->tag ne "dt") || ($he_dd->tag ne "dd"))
-		{ $he->dump;
-		  die "expected <DT> and <DD> at positions $i and ", $i+1; }
-	      my @dt_content = @{$he_dt->content()};
-	      if ((scalar(@dt_content) != 2)
-		  || ($dt_content[0]->tag ne "a")
-		  || ($dt_content[1]->tag ne "a"))
-		{ $he_dt->dump;
-		  die "Expected 2 anchors as content of <DT>"; }
-	      my ($dt1_name, $dt1_href, $dt1_content) = anchor_info($dt_content[0]);
-	      my ($dt2_name, $dt2_href, $dt2_content) = anchor_info($dt_content[0]);
-	      # unused: $dt1_href, $dt1_content, $dt2_href, $dt2_content
-	      if ($dt1_name ne $dt2_name)
-		{ $he_dt->dump;
-		  die "Expected identical names for anchors"; }
-	      html_replace_by_ignore($he_dd);
-	      $he_dd->tag("div"); # has no effect
-	      $footnotes{$dt1_name} = $he_dd; }
-	  html_replace_by_ignore($he);
-	  return 0; } }
-
-  if ($process_if_footnotes_expect_dl_next)
-    { $he->dump;
-      die "Expected <DL> for footnotes next"; }
-
-  return 1;
-}
-
-
-
-## Merge two adjacent paragraphs containing <DL> items, such as:
-#     <P>
-#       <DL>
-#         <DT>
-#           ...
-#         <DD>
-#           ...
-#     <P>
-#       <DL>
-#         <DT>
-#           ...
-#         <DD>
-#           ...
-
-sub merge_dl ( $$$ )
-{ my ($he, $startflag) = (check_args(3, @_))[0,1]; #  ignore depth argument
-  if (!$startflag)
-    { return; }
-
-  my $ref_content = $he->content;
-  if (!defined $ref_content)
-    { return; }
-  my $i = 0;
-  while ($i < scalar(@{$ref_content})-1)
-    { my $p1 = $ {$ref_content}[$i];
-      if ((ref $p1) && ($p1->tag eq "p")
-	  && has_single_content_with_tag($p1, "dl"))
-	{ my $dl1 = $ {$p1->content}[0];
-	  # In this loop, rhs, not lhs, of < comparison changes,
-	  # because we are removing elements from the content of $he.
-	  while ($i < scalar(@{$ref_content})-1)
-	    { my $p2 = $ {$ref_content}[$i+1];
-	      if (!((ref $p2) && ($p2->tag eq "p")
-		    && has_single_content_with_tag($p2, "dl")))
-		{ last; }
-	      # Merge these two elements.
-	      splice(@{$ref_content}, $i+1, 1); # remove $p2
-	      my $dl2 = $ {$p2->content}[0];
-	      $dl1->push_content(@{$dl2->content}); # put $dl2's content in $dl1
-	    }
-	  # extra increment because next element isn't a candidate for $p1
-	  $i++; }
-      $i++; }
-  return 1;
-}
-
-
-
-###########################################################################
-### Testing
-###
-
-sub test ( $$ )
-{ my ($action, $file) = check_args(2, @_);
-
-  # General testing
-  if (($action eq "view") || ($action eq ""))
-    { # # $file = "/homes/gws/mernst/www/links.html";
-      # # $file = "/homes/gws/mernst/www/index.html";
-      # # $file = "/homes/fish/mernst/java/gud/doc/manual.html";
-      # # $file = "/projects/cecil/cecil/doc/manuals/stdlib-man/stdlib/stdlib.html";
-      # # $file = "/homes/fish/mernst/tmp/python-doc/html/index.html";
-      # $file = "/homes/fish/mernst/tmp/python-doc/html/api/complexObjects.html";
-      my $tree = file_to_tree($file);
-
-      ## Testing
-      # print STDERR $tree->as_HTML;
-      $tree->dump();
-
-      # print STDERR $tree->tag(), "\n";
-      # print STDERR @{$tree->content()}, "\n";
-      # 
-      # for (@{ $tree->extract_links(qw(a img)) }) {
-      #   my ($link, $linkelem) = @$_;
-      #   print STDERR "$link ", $linkelem->as_HTML;
-      #   }
-      # 
-      # print STDERR @{$tree->extract_links()}, "\n";
-
-      # my @top_level_elts = @{$tree->content()};
-
-      # if scalar(@{$tree->content()})
-      return;
-    }
-
-  elsif ($action eq "raw")
-    { my $tree = new HTML::TreeBuilder;
-      $tree->ignore_unknown(1);
-      # $tree->warn(1);
-      $tree->parse_file($file);
-
-      $tree->dump();
-
-      # cleanup_parse_tree($tree);
-      # $tree->dump();
-      return;
-    }
-
-  # Test dealing with a section.
-  elsif ($action eq "section")
-    { # my $file;
-      # $file = "/homes/fish/mernst/tmp/python-doc/html/api/intro.html";
-      # $file = "/homes/fish/mernst/tmp/python-doc/html/api/includes.html";
-      # $file = "/homes/fish/mernst/tmp/python-doc/html/api/complexObjects.html";
-      process_section_file($file, 0, "Title");
-    }
-
-  # Test dealing with many sections
-  elsif (0)
-    { my @files = ("/homes/fish/mernst/tmp/python-doc/html/api/about.html",
-		   "/homes/fish/mernst/tmp/python-doc/html/api/abstract.html",
-		   "/homes/fish/mernst/tmp/python-doc/html/api/api.html",
-		   "/homes/fish/mernst/tmp/python-doc/html/api/cObjects.html",
-		   "/homes/fish/mernst/tmp/python-doc/html/api/complexObjects.html",
-		   "/homes/fish/mernst/tmp/python-doc/html/api/concrete.html",
-		   # "/homes/fish/mernst/tmp/python-doc/html/api/contents.html",
-		   "/homes/fish/mernst/tmp/python-doc/html/api/countingRefs.html",
-		   "/homes/fish/mernst/tmp/python-doc/html/api/debugging.html",
-		   "/homes/fish/mernst/tmp/python-doc/html/api/dictObjects.html",
-		   "/homes/fish/mernst/tmp/python-doc/html/api/embedding.html",
-		   "/homes/fish/mernst/tmp/python-doc/html/api/exceptionHandling.html",
-		   "/homes/fish/mernst/tmp/python-doc/html/api/exceptions.html",
-		   "/homes/fish/mernst/tmp/python-doc/html/api/fileObjects.html",
-		   "/homes/fish/mernst/tmp/python-doc/html/api/floatObjects.html",
-		   "/homes/fish/mernst/tmp/python-doc/html/api/front.html",
-		   "/homes/fish/mernst/tmp/python-doc/html/api/fundamental.html",
-		   # "/homes/fish/mernst/tmp/python-doc/html/api/genindex.html",
-		   "/homes/fish/mernst/tmp/python-doc/html/api/importing.html",
-		   "/homes/fish/mernst/tmp/python-doc/html/api/includes.html",
-		   "/homes/fish/mernst/tmp/python-doc/html/api/index.html",
-		   "/homes/fish/mernst/tmp/python-doc/html/api/initialization.html",
-		   "/homes/fish/mernst/tmp/python-doc/html/api/intObjects.html",
-		   "/homes/fish/mernst/tmp/python-doc/html/api/intro.html",
-		   "/homes/fish/mernst/tmp/python-doc/html/api/listObjects.html",
-		   "/homes/fish/mernst/tmp/python-doc/html/api/longObjects.html",
-		   "/homes/fish/mernst/tmp/python-doc/html/api/mapObjects.html",
-		   "/homes/fish/mernst/tmp/python-doc/html/api/mapping.html",
-		   "/homes/fish/mernst/tmp/python-doc/html/api/newTypes.html",
-		   "/homes/fish/mernst/tmp/python-doc/html/api/node24.html",
-		   "/homes/fish/mernst/tmp/python-doc/html/api/noneObject.html",
-		   "/homes/fish/mernst/tmp/python-doc/html/api/number.html",
-		   "/homes/fish/mernst/tmp/python-doc/html/api/numericObjects.html",
-		   "/homes/fish/mernst/tmp/python-doc/html/api/object.html",
-		   "/homes/fish/mernst/tmp/python-doc/html/api/objects.html",
-		   "/homes/fish/mernst/tmp/python-doc/html/api/os.html",
-		   "/homes/fish/mernst/tmp/python-doc/html/api/otherObjects.html",
-		   "/homes/fish/mernst/tmp/python-doc/html/api/processControl.html",
-		   "/homes/fish/mernst/tmp/python-doc/html/api/refcountDetails.html",
-		   "/homes/fish/mernst/tmp/python-doc/html/api/refcounts.html",
-		   "/homes/fish/mernst/tmp/python-doc/html/api/sequence.html",
-		   "/homes/fish/mernst/tmp/python-doc/html/api/sequenceObjects.html",
-		   "/homes/fish/mernst/tmp/python-doc/html/api/standardExceptions.html",
-		   "/homes/fish/mernst/tmp/python-doc/html/api/stringObjects.html",
-		   "/homes/fish/mernst/tmp/python-doc/html/api/threads.html",
-		   "/homes/fish/mernst/tmp/python-doc/html/api/tupleObjects.html",
-		   "/homes/fish/mernst/tmp/python-doc/html/api/typeObjects.html",
-		   "/homes/fish/mernst/tmp/python-doc/html/api/types.html",
-		   "/homes/fish/mernst/tmp/python-doc/html/api/utilities.html",
-		   "/homes/fish/mernst/tmp/python-doc/html/api/veryhigh.html");
-      for my $file (@files)
-	{ print STDERR "\n", "=" x 75, "\n", "$file:\n";
-	  process_section_file($file, 0, "Title");
-	}
-    }
-
-  # Test dealing with index.
-  elsif ($action eq "index")
-    { # my $file;
-      # $file = "/homes/fish/mernst/tmp/python-doc/html/api/genindex.html";
-
-      process_index_file($file, "\@cindex");
-      print_index_info();
-    }
-
-  else
-    { die "Unrecognized action `$action'"; }
-}
-
-
-###########################################################################
-### Main loop
-###
-
-sub process_contents_file ( $ )
-{ my ($file) = check_args(1, @_);
-
-  # could also use File::Basename
-  my $info_file = $file;
-  $info_file =~ s/(\/?index)?\.html$//;
-  if ($info_file eq "")
-    { chomp($info_file = `pwd`); }
-  $info_file =~ s/^.*\///;	# not the most efficient way to remove dirs
-
-  $html_directory = $file;
-  $html_directory =~ s/(\/|^)[^\/]+$/$1/;
-
-  my $texi_file = "$info_file.texi";
-  open(TEXI, ">$texi_file");
-
-  print TEXI "\\input texinfo   \@c -*-texinfo-*-\n";
-  print TEXI "\@c %**start of header\n";
-  print TEXI "\@setfilename $info_file\n";
-
-  # 2. Summary Description and Copyright
-  #      The "Summary Description and Copyright" segment describes the
-  #      document and contains the copyright notice and copying permissions
-  #      for the Info file.  The segment must be enclosed between `@ifinfo'
-  #      and `@end ifinfo' commands so that the formatters place it only in
-  #      the Info file.
-  # 
-  # The summary description and copyright segment does not appear in the
-  # printed document.
-  # 
-  #      @ifinfo
-  #      This is a short example of a complete Texinfo file.
-  #      
-  #      Copyright @copyright{} 1990 Free Software Foundation, Inc.
-  #      @end ifinfo
-
-
-  # 3. Title and Copyright
-  #      The "Title and Copyright" segment contains the title and copyright
-  #      pages and copying permissions for the printed manual.  The segment
-  #      must be enclosed between `@titlepage' and `@end titlepage'
-  #      commands.  The title and copyright page appear only in the printed
-  #      manual.
-  # 
-  # The titlepage segment does not appear in the Info file.
-  # 
-  #      @titlepage
-  #      @sp 10
-  #      @comment The title is printed in a large font.
-  #      @center @titlefont{Sample Title}
-  #      
-  #      @c The following two commands start the copyright page.
-  #      @page
-  #      @vskip 0pt plus 1filll
-  #      Copyright @copyright{} 1990 Free Software Foundation, Inc.
-  #      @end titlepage
-
-
-  # 4. `Top' Node and Master Menu
-  #      The "Master Menu" contains a complete menu of all the nodes in the
-  #      whole Info file.  It appears only in the Info file, in the `Top'
-  #      node.
-  # 
-  # The `Top' node contains the master menu for the Info file.  Since a
-  # printed manual uses a table of contents rather than a menu, the master
-  # menu appears only in the Info file.
-  # 
-  #      @node    Top,       First Chapter, ,         (dir)
-  #      @comment node-name, next,          previous, up
-  # 
-  #      @menu
-  #      * First Chapter::    The first chapter is the
-  #                           only chapter in this sample.
-  #      * Concept Index::    This index has two entries.
-  #      @end menu
-
-
-
-  $current_ref_tdf = [ "Top", 0, $ARGV[0] ];
-  process_section_file($file, 0, "Top");
-  while (scalar(@contents_list))
-  { $current_ref_tdf = shift @contents_list;
-    process_section_file($ {$current_ref_tdf}[2], $ {$current_ref_tdf}[1], $ {$current_ref_tdf}[0]);
-  }
-
-  print TEXI "\n";
-  for my $indextitle (@index_titles)
-    { print TEXI "\@node $indextitle\n";
-      print TEXI "\@unnumbered $indextitle\n";
-      print TEXI "\@printindex $ {$index_info{$indextitle}}[1]\n";
-      print TEXI "\n"; }
-
-  print TEXI "\@contents\n";
-  print TEXI "\@bye\n";
-  close(TEXI);
-}
-
-# This needs to be last so global variable initializations are reached.
-
-if (scalar(@ARGV) == 0)
-{ die "No arguments supplied to html2texi.pl"; }
-
-if ($ARGV[0] eq "-test")
-{ my @test_args = @ARGV[1..$#ARGV];
-  if (scalar(@test_args) == 0)
-    { test("", "index.html"); }
-  elsif (scalar(@test_args) == 1)
-    { test("", $test_args[0]); }
-  elsif (scalar(@test_args) == 2)
-    { test($test_args[0], $test_args[1]); }
-  else
-    { die "Too many test arguments passed to html2texi: ", join(" ", @ARGV); }
-  exit();
-}
-
-if (scalar(@ARGV) != 1)
-{ die "Pass one argument, the main/contents page"; }
-
-process_contents_file($ARGV[0]);
-
-# end of html2texi.pl
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/indfix.py hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/indfix.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/indfix.py	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/indfix.py	1970-01-01 01:00:00.000000000 +0100
@@ -1,101 +0,0 @@
-#! /usr/bin/env python
-
-"""Combine similar index entries into an entry and subentries.
-
-For example:
-
-    \item {foobar} (in module flotz), 23
-    \item {foobar} (in module whackit), 4323
-
-becomes
-
-    \item {foobar}
-      \subitem in module flotz, 23
-      \subitem in module whackit, 4323
-
-Note that an item which matches the format of a collapsable item but which
-isn't part of a group of similar items is not modified.
-"""
-__version__ = '$Revision: 1.1.1.1 $'
-
-import re
-import string
-import StringIO
-import sys
-
-
-def cmp_entries(e1, e2, lower=string.lower):
-    return cmp(lower(e1[1]), lower(e2[1])) or cmp(e1, e2)
-
-
-def dump_entries(write, entries):
-    if len(entries) == 1:
-        write("  \\item %s (%s)%s\n" % entries[0])
-        return
-    write("  \item %s\n" % entries[0][0])
-    # now sort these in a case insensitive manner:
-    if len(entries) > 0:
-        entries.sort(cmp_entries)
-    for xxx, subitem, pages in entries:
-        write("    \subitem %s%s\n" % (subitem, pages))
-
-
-breakable_re = re.compile(
-    r"  \\item (.*) [(](.*)[)]((?:(?:, \d+)|(?:, \\[a-z]*\{\d+\}))+)")
-
-
-def process(ifn, ofn=None):
-    if ifn == "-":
-        ifp = sys.stdin
-    else:
-        ifp = open(ifn)
-    if ofn is None:
-        ofn = ifn
-    ofp = StringIO.StringIO()
-    entries = []
-    match = breakable_re.match
-    write = ofp.write
-    while 1:
-        line = ifp.readline()
-        if not line:
-            break
-        m = match(line)
-        if m:
-            entry = m.group(1, 2, 3)
-            if entries and entries[-1][0] != entry[0]:
-                dump_entries(write, entries)
-                entries = []
-            entries.append(entry)
-        elif entries:
-            dump_entries(write, entries)
-            entries = []
-            write(line)
-        else:
-            write(line)
-    del write
-    del match
-    ifp.close()
-    data = ofp.getvalue()
-    ofp.close()
-    if ofn == "-":
-        ofp = sys.stdout
-    else:
-        ofp = open(ofn, "w")
-    ofp.write(data)
-    ofp.close()
-
-
-def main():
-    import getopt
-    outfile = None
-    opts, args = getopt.getopt(sys.argv[1:], "o:")
-    for opt, val in opts:
-        if opt in ("-o", "--output"):
-            outfile = val
-    filename = args[0]
-    outfile = outfile or filename
-    process(filename, outfile)
-
-
-if __name__ == "__main__":
-    main()
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/info/Makefile hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/info/Makefile
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/info/Makefile	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/info/Makefile	1970-01-01 01:00:00.000000000 +0100
@@ -1,73 +0,0 @@
-# Generate the Python "info" documentation.
-
-TOPDIR=..
-TOOLSDIR=$(TOPDIR)/tools
-HTMLDIR=$(TOPDIR)/html
-
-MKINFO=$(TOOLSDIR)/mkinfo
-SCRIPTS=$(TOOLSDIR)/html2texi.pl $(TOOLSDIR)/checkargs.pm $(TOOLSDIR)/mkinfo \
-	$(TOOLSDIR)/fixinfo.el
-
-all:	python-api.info python-ext.info python-lib.info \
-	python-ref.info python-tut.info \
-	python-dist.info python-inst.info
-
-
-python-api.info:	$(HTMLDIR)/api/api.html $(SCRIPTS)
-	$(MKINFO) $<
-
-python-ext.info:	$(HTMLDIR)/ext/ext.html $(SCRIPTS)
-	$(MKINFO) $<
-
-python-lib.info:	$(HTMLDIR)/lib/lib.html $(SCRIPTS)
-	$(MKINFO) $<
-
-# Not built by default; the conversion doesn't really handle it well.
-python-mac.info:	$(HTMLDIR)/mac/mac.html $(SCRIPTS)
-	$(MKINFO) $<
-
-python-ref.info:	$(HTMLDIR)/ref/ref.html $(SCRIPTS)
-	$(MKINFO) $<
-
-python-tut.info:	$(HTMLDIR)/tut/tut.html $(SCRIPTS)
-	$(MKINFO) $<
-
-python-dist.info:	$(HTMLDIR)/dist/dist.html $(SCRIPTS)
-	$(MKINFO) $<
-
-python-inst.info:	$(HTMLDIR)/inst/inst.html $(SCRIPTS)
-	$(MKINFO) $<
-
-clean:
-	rm -f *.texi~ *.texi
-
-clobber: clean
-	rm -f *.texi python-*.info python-*.info-[0-9]*
-
-
-# This makes sure we can build info files from a "clean" tree,
-# in case we haven't already built the HTML:
-
-$(HTMLDIR)/api/api.html:
-	(cd $(HTMLDIR); $(MAKE) api)
-
-$(HTMLDIR)/ext/ext.html:
-	(cd $(HTMLDIR); $(MAKE) ext)
-
-$(HTMLDIR)/lib/lib.html:
-	(cd $(HTMLDIR); $(MAKE) lib)
-
-$(HTMLDIR)/mac/mac.html:
-	(cd $(HTMLDIR); $(MAKE) mac)
-
-$(HTMLDIR)/ref/ref.html:
-	(cd $(HTMLDIR); $(MAKE) ref)
-
-$(HTMLDIR)/tut/tut.html:
-	(cd $(HTMLDIR); $(MAKE) tut)
-
-$(HTMLDIR)/dist/dist.html:
-	(cd $(HTMLDIR); $(MAKE) dist)
-
-$(HTMLDIR)/inst/inst.html:
-	(cd $(HTMLDIR); $(MAKE) inst)
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/info/python.dir hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/info/python.dir
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/info/python.dir	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/info/python.dir	1970-01-01 01:00:00.000000000 +0100
@@ -1,9 +0,0 @@
-
-Python Standard Documentation
-
-* Python Library: (python-lib).		Python Library Reference
-* Python Mac Modules: (python-mac).	Python Macintosh Modules
-* Python Reference: (python-ref).	Python Reference Manual
-* Python API: (python-api).		Python/C API Reference Manual
-* Python Extending: (python-ext).	Extending & Embedding Python
-* Python Tutorial: (python-tut).	Python Tutorial
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/info/README hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/info/README
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/info/README	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/info/README	1970-01-01 01:00:00.000000000 +0100
@@ -1,21 +0,0 @@
-This archive contains the standard Python documentation in GNU info
-format.  Five manuals are included:
-
-    python-ref.info*	Python Reference Manual
-    python-mac.info*	Python Macintosh Modules
-    python-lib.info*	Python Library Reference
-    python-ext.info*	Extending and Embedding the Python Interpreter
-    python-api.info*	Python/C API Reference
-    python-tut.info*	Python Tutorial
-
-The file python.dir is a fragment of a "dir" file that can be used to
-incorporate these documents into an existing GNU info installation:
-insert the contents of this file into the "dir" or "localdir" file at
-an appropriate point and copy the python-*.info* files to the same
-directory.
-
-Thanks go to Milan Zamazal <pdm@freesoft.cz> for providing this
-conversion to the info format.
-
-Questions and comments on these documents should be directed to
-python-docs@python.org.
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/keywords.py hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/keywords.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/keywords.py	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/keywords.py	1970-01-01 01:00:00.000000000 +0100
@@ -1,20 +0,0 @@
-#! /usr/bin/env python
-
-# This Python program sorts and reformats the table of keywords in ref2.tex
-
-import string
-l = []
-try:
-	while 1:
-		l = l + string.split(raw_input())
-except EOFError:
-	pass
-l.sort()
-for x in l[:]:
-	while l.count(x) > 1: l.remove(x)
-ncols = 5
-nrows = (len(l)+ncols-1)/ncols
-for i in range(nrows):
-	for j in range(i, len(l), nrows):
-		print string.ljust(l[j], 10),
-	print
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/listmodules hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/listmodules
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/listmodules	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/listmodules	1970-01-01 01:00:00.000000000 +0100
@@ -1,183 +0,0 @@
-#! /usr/bin/env python
-#  -*- Python -*-
-#
-#  This script can be used to identify undocumented modules in the Python
-#  standard library.  Use it like this:
-#
-#  .../Doc/tools/listmodules --ignore-from .../Doc/paper-<paper>/modlib.idx
-
-"""%(program)s - list modules in the Python standard library
-
--a, --annotate	  Annotate the module names with the subdirectory they
-                  live in
--c, --categorize  Group the modules by subdirectory
--i <file>,
-
---ignore-from <file>	Ignore the modules listed in <file>.  <file> may
-                  contain a list of module names or a module index file
-                  as produced when formatting the Python documentation
-                  (.idx or .html flavor).
-
-If neither -a nor -c are given, the modules are listed in alphabetical
-order.
-
-Note that -a and -c are mutually exclusive.
-
-Limitation: Modules loadable as shared objects may not be listed,
-though this script attempts to locate such modules.
-
-"""
-
-__version__ = '$Revision: 1.1.1.1 $'
-
-import getopt
-import glob
-import os
-import re
-import string
-import sys
-
-
-REMOVE_DIRS = ["dos-8x3", "encodings", "distutils",
-               "lib-old", "lib-stdwin", "test"]
-
-
-def main():
-    args = sys.argv[1:]
-    annotate = 0
-    builtin = 0
-    categorize = 0
-    ignore_dict = {}
-    ignore = ignore_dict.has_key
-    try:
-        opts, args = getopt.getopt(
-            args, "abchi:",
-            ["annotate", "built-in", "categorize", "help", "ignore-from="])
-    except getopt.error, msg:
-        sys.stdout = sys.stderr
-        print msg
-        print
-        usage()
-        sys.exit(2)
-    for opt, arg in opts:
-        if opt in ("-a", "--annotate"):
-            annotate = 1
-        elif opt in ("-b", "--built-in"):
-            builtin = 1
-        elif opt in ("-c", "--categorize"):
-            categorize = 1
-        elif opt in ("-h", "--help"):
-            usage()
-            sys.exit()
-        elif opt in ("-i", "--ignore-from"):
-            data = open(arg).read()
-            if data[:1] == "\\":
-                ignore_from_idx(data, ignore_dict)
-            else:
-                ignore_from_modulelist(data, ignore_dict)
-    if args or (annotate and categorize):
-        usage()
-        sys.exit(2)
-    #
-    # Populate the database:
-    #
-    srcdir = os.path.normpath(os.path.join(
-        os.path.dirname(sys.argv[0]), os.pardir, os.pardir))
-    os.chdir(srcdir)
-    modules_by_name = {}
-    modules_by_dir = {}
-    if builtin:
-        l = []
-        modules_by_dir["<builtin>"] = l
-        for name in sys.builtin_module_names:
-            if not ignore(name):
-                modules_by_name[name] = "<built-in>"
-                l.append(name)
-    rx = re.compile("Lib/plat-[a-zA-Z0-9]*/")
-    fp = os.popen("find Lib -name \*.py -print", "r")
-    while 1:
-        line = fp.readline()
-        if not line:
-            break
-        m = rx.match(line)
-        if m:
-            line = "Lib/plat-*/" + line[m.end():]
-        line = line[4:-4]                # strip off 'Lib/' and '.py\n'
-        dir, name = os.path.split(line)
-        dir = dir or "<standard>"
-        if ignore(name):
-            continue
-        if dir not in REMOVE_DIRS:
-            modules_by_name[name] = dir
-            l = modules_by_dir.get(dir, [])
-            modules_by_dir[dir] = l
-            if name not in l:
-                l.append(name)
-    # load up extension modules:
-    pwd = os.getcwd()
-    try:
-        os.chdir("Modules")
-        dir = "<extension>"
-        for line in glob.glob("*module.c"):
-            name = line[:-8]
-            if ignore(name) or modules_by_name.has_key(name) or name == "xx":
-                continue
-            modules_by_name[name] = dir
-            l = modules_by_dir.get(dir, [])
-            modules_by_dir[dir] = l
-            if name not in l:
-                l.append(name)
-    finally:
-        os.chdir(pwd)
-    #
-    # Dump the results:
-    #
-    if annotate:
-        modules = modules_by_name.items()
-        modules.sort()
-        width = max(map(len, modules_by_name.keys()))
-        format = "%%-%ds  %%s" % width
-        for name, dir in modules:
-            if dir and dir[0] != "<":
-                print format % (name, dir)
-            else:
-                print name
-    elif categorize:
-        modules = modules_by_dir.items()
-        modules.sort()
-        width = max(map(len, modules_by_dir.keys()))
-        format = "%%-%ds  %%s" % width
-        for dir, names in modules:
-            names.sort()
-            print format % (dir, names[0])
-            for name in names[1:]:
-                print format % ('', name)
-            print
-    else:
-        modules = modules_by_name.keys()
-        modules.sort()
-        print string.join(modules, "\n")
-
-
-def ignore_from_modulelist(data, ignore_dict):
-    for name in string.split(data):
-        ignore_dict[name] = name
-
-def ignore_from_idx(data, ignore_dict):
-    data = string.replace(data, r"\hackscore  {}", "_")
-    rx = re.compile(r"\\indexentry\s*{([^@]*)@")
-    for line in string.split(data, "\n"):
-        m = rx.match(line)
-        if m:
-            name = m.group(1)
-            ignore_dict[name] = name
-
-
-def usage():
-    vars = {}
-    vars["program"] = os.path.basename(sys.argv[0])
-    print __doc__ % vars
-
-
-if __name__ == "__main__":
-    main()
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/mkackshtml hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/mkackshtml
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/mkackshtml	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/mkackshtml	1970-01-01 01:00:00.000000000 +0100
@@ -1,65 +0,0 @@
-#! /usr/bin/env python
-#  -*- Python -*-
-
-import string
-import support
-import sys
-
-
-def collect(fp):
-    names = []
-    while 1:
-        line = fp.readline()
-        if not line:
-            break
-        line = string.strip(line)
-        if line:
-            names.append(line)
-        else:
-            names = []
-    return names
-
-
-def main():
-    options = support.Options()
-    options.columns = 4
-    options.variables["title"] = "Acknowledgements"
-    options.parse(sys.argv[1:])
-    names = collect(sys.stdin)
-    percol = (len(names) + options.columns - 1) / options.columns
-    colnums = []
-    for i in range(options.columns):
-        colnums.append(percol*i)
-    fp = options.get_output_file()
-    fp.write(string.rstrip(options.get_header()) + "\n")
-    fp.write(THANKS + "\n")
-    fp.write('<table width="100%" align="center">\n')
-    for i in range(percol):
-        fp.write("  <tr>\n")
-        for j in colnums:
-            try:
-                fp.write("    <td>%s</td>\n" % names[i + j])
-            except IndexError:
-                pass
-        fp.write("  </tr>\n")
-    fp.write("</table>\n")
-    fp.write(string.rstrip(options.get_footer()) + "\n")
-    fp.close()
-
-THANKS = '''\
-
-<p>These people have contributed in some way to the Python
-documentation.  This list is probably not complete -- if you feel that
-you or anyone else should be on this list, please let us know (send
-email to <a
-href="mailto:python-docs@python.org">python-docs@python.org</a>), and
-we will be glad to correct the problem.</p>
-
-<p>It is only with the input and contributions of the Python community
-that Python has such wonderful documentation -- <b>Thank You!</b></p>
-
-'''
-
-
-if __name__ == "__main__":
-    main()
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/mkhowto hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/mkhowto
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/mkhowto	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/mkhowto	1970-01-01 01:00:00.000000000 +0100
@@ -1,597 +0,0 @@
-#! /usr/bin/env python
-#  -*- Python -*-
-"""usage: %(program)s [options...] file ...
-
-Options specifying formats to build:
-    --html		HyperText Markup Language (default)
-    --pdf		Portable Document Format
-    --ps		PostScript
-    --dvi		'DeVice Indepentent' format from TeX
-    --text		ASCII text (requires lynx)
-
-    More than one output format may be specified, or --all.
-
-HTML options:
-    --address, -a	Specify an address for page footers.
-    --link		Specify the number of levels to include on each page.
-    --split, -s		Specify a section level for page splitting, default: %(max_split_depth)s.
-    --iconserver, -i	Specify location of icons (default: ../).
-    --image-type	Specify the image type to use in HTML output;
-                        values: gif (default), png.
-    --numeric           Don't rename the HTML files; just keep node#.html for
-                        the filenames.
-    --style             Specify the CSS file to use for the output (filename,
-                        not a URL).
-    --up-link           URL to a parent document.
-    --up-title          Title of a parent document.
-
-Other options:
-    --a4		Format for A4 paper.
-    --letter		Format for US letter paper (the default).
-    --help, -H		Show this text.
-    --logging, -l	Log stdout and stderr to a file (*.how).
-    --debugging, -D	Echo commands as they are executed.
-    --keep, -k		Keep temporary files around.
-    --quiet, -q		Do not print command output to stdout.
-			(stderr is also lost,  sorry; see *.how for errors)
-"""
-
-import getopt
-import glob
-import os
-import re
-import shutil
-import string
-import sys
-import tempfile
-
-
-MYDIR = os.path.abspath(sys.path[0])
-
-ISTFILE = os.path.join(MYDIR, "texinputs", "python.ist")
-NODE2LABEL_SCRIPT = os.path.join(MYDIR, "node2label.pl")
-L2H_INIT_FILE = os.path.join(MYDIR, "perl", "l2hinit.perl")
-
-BIBTEX_BINARY = "bibtex"
-DVIPS_BINARY = "dvips"
-LATEX_BINARY = "latex"
-LATEX2HTML_BINARY = "latex2html"
-LYNX_BINARY = "lynx"
-MAKEINDEX_BINARY = "makeindex"
-PDFLATEX_BINARY = "pdflatex"
-PERL_BINARY = "perl"
-PYTHON_BINARY = "python"
-
-
-def usage(options):
-    print __doc__ % options
-
-def error(options, message, err=2):
-    sys.stdout = sys.stderr
-    print message
-    print
-    usage(options)
-    sys.exit(2)
-
-
-class Options:
-    program = os.path.basename(sys.argv[0])
-    #
-    address = ''
-    builddir = None
-    debugging = 0
-    discard_temps = 1
-    have_temps = 0
-    icon_server = None
-    image_type = "gif"
-    logging = 0
-    max_link_depth = 3
-    max_split_depth = 6
-    paper = "letter"
-    quiet = 0
-    runs = 0
-    numeric = 0
-    global_module_index = None
-    style_file = os.path.join(MYDIR, "html", "style.css")
-    about_file = os.path.join(MYDIR, "html", "about.dat")
-    up_link = None
-    up_title = None
-    #
-    DEFAULT_FORMATS = ("html",)
-    ALL_FORMATS = ("dvi", "html", "pdf", "ps", "text")
-
-    def __init__(self):
-        self.formats = []
-        self.l2h_init_files = []
-
-    def __getitem__(self, key):
-        # This is used when formatting the usage message.
-        try:
-            return getattr(self, key)
-        except AttributeError:
-            raise KeyError, key
-
-    def parse(self, args):
-        opts, args = getopt.getopt(args, "Hi:a:s:lDkqr:",
-                                   ["all", "postscript", "help", "iconserver=",
-                                    "address=", "a4", "letter", "l2h-init=",
-                                    "link=", "split=", "logging", "debugging",
-                                    "keep", "quiet", "runs=", "image-type=",
-                                    "about=", "numeric", "style=", "paper=",
-                                    "up-link=", "up-title=", "dir=",
-                                    "global-module-index="]
-                                   + list(self.ALL_FORMATS))
-        for opt, arg in opts:
-            if opt == "--all":
-                self.formats = list(self.ALL_FORMATS)
-            elif opt in ("-H", "--help"):
-                usage(self)
-                sys.exit()
-            elif opt == "--iconserver":
-                self.icon_server = arg
-            elif opt in ("-a", "--address"):
-                self.address = arg
-            elif opt == "--a4":
-                self.paper = "a4"
-            elif opt == "--letter":
-                self.paper = "letter"
-            elif opt == "--link":
-                self.max_link_depth = int(arg)
-            elif opt in ("-s", "--split"):
-                self.max_split_depth = int(arg)
-            elif opt in ("-l", "--logging"):
-                self.logging = self.logging + 1
-            elif opt in ("-D", "--debugging"):
-                self.debugging = self.debugging + 1
-            elif opt in ("-k", "--keep"):
-                self.discard_temps = 0
-            elif opt in ("-q", "--quiet"):
-                self.quiet = 1
-            elif opt in ("-r", "--runs"):
-                self.runs = int(arg)
-            elif opt == "--image-type":
-                self.image_type = arg
-            elif opt == "--about":
-                # always make this absolute:
-                self.about_file = os.path.normpath(
-                    os.path.abspath(arg))
-            elif opt == "--numeric":
-                self.numeric = 1
-            elif opt == "--style":
-                self.style_file = os.path.abspath(arg)
-            elif opt == "--l2h-init":
-                self.l2h_init_files.append(os.path.abspath(arg))
-            elif opt == "--up-link":
-                self.up_link = arg
-            elif opt == "--up-title":
-                self.up_title = arg
-            elif opt == "--global-module-index":
-                self.global_module_index = arg
-            elif opt == "--dir":
-                self.builddir = arg
-            elif opt == "--paper":
-                self.paper = arg
-            #
-            # Format specifiers:
-            #
-            elif opt[2:] in self.ALL_FORMATS:
-                self.add_format(opt[2:])
-            elif opt == "--postscript":
-                # synonym for --ps
-                self.add_format("ps")
-        self.initialize()
-        #
-        # return the args to allow the caller access:
-        #
-        return args
-
-    def add_format(self, format):
-        """Add a format to the formats list if not present."""
-        if not format in self.formats:
-            self.formats.append(format)
-
-    def initialize(self):
-        """Complete initialization.  This is needed if parse() isn't used."""
-        # add the default format if no formats were specified:
-        if not self.formats:
-            self.formats = self.DEFAULT_FORMATS
-        # determine the base set of texinputs directories:
-        texinputs = string.split(os.environ.get("TEXINPUTS", ""), os.pathsep)
-        if not texinputs:
-            texinputs = ['']
-        self.base_texinputs = [
-            os.path.join(MYDIR, "paper-" + self.paper),
-            os.path.join(MYDIR, "texinputs"),
-            ] + texinputs
-
-
-class Job:
-    latex_runs = 0
-
-    def __init__(self, options, path):
-        self.options = options
-        self.doctype = get_doctype(path)
-        self.filedir, self.doc = split_pathname(path)
-        self.log_filename = self.doc + ".how"
-        if os.path.exists(self.log_filename):
-            os.unlink(self.log_filename)
-        if os.path.exists(self.doc + ".l2h"):
-            self.l2h_aux_init_file = tempfile.mktemp()
-        else:
-            self.l2h_aux_init_file = self.doc + ".l2h"
-        self.write_l2h_aux_init_file()
-
-    def build(self):
-        self.setup_texinputs()
-        formats = self.options.formats
-        if "dvi" in formats or "ps" in formats:
-            self.build_dvi()
-        if "pdf" in formats:
-            self.build_pdf()
-        if "ps" in formats:
-            self.build_ps()
-        if "html" in formats:
-            self.require_temps()
-            self.build_html(self.options.builddir or self.doc)
-            if self.options.icon_server == ".":
-                pattern = os.path.join(MYDIR, "html", "icons",
-                                       "*." + self.options.image_type)
-                imgs = glob.glob(pattern)
-                if not imgs:
-                    self.warning(
-                        "Could not locate support images of type %s."
-                        % `self.options.image_type`)
-                for fn in imgs:
-                    new_fn = os.path.join(self.doc, os.path.basename(fn))
-                    shutil.copyfile(fn, new_fn)
-        if "text" in formats:
-            self.require_temps()
-            tempdir = self.doc
-            need_html = "html" not in formats
-            if self.options.max_split_depth != 1:
-                fp = open(self.l2h_aux_init_file, "a")
-                fp.write("# re-hack this file for --text:\n")
-                l2hoption(fp, "MAX_SPLIT_DEPTH", "1")
-                fp.write("1;\n")
-                fp.close()
-                tempdir = self.doc + "-temp-html"
-                need_html = 1
-            if need_html:
-                self.build_html(tempdir, max_split_depth=1)
-            self.build_text(tempdir)
-        if self.options.discard_temps:
-            self.cleanup()
-
-    def setup_texinputs(self):
-        texinputs = [self.filedir] + list(self.options.base_texinputs)
-        os.environ["TEXINPUTS"] = string.join(['.']+texinputs, os.pathsep)
-        self.message("TEXINPUTS=" + os.environ["TEXINPUTS"])
-
-    def build_aux(self, binary=None):
-        if binary is None:
-            binary = LATEX_BINARY
-        new_index(   "%s.ind" % self.doc, "genindex")
-        new_index("mod%s.ind" % self.doc, "modindex")
-        self.run("%s %s" % (binary, self.doc))
-        self.use_bibtex = check_for_bibtex(self.doc + ".aux")
-        self.latex_runs = 1
-
-    def build_dvi(self):
-        self.use_latex(LATEX_BINARY)
-
-    def build_pdf(self):
-        self.use_latex(PDFLATEX_BINARY)
-
-    def use_latex(self, binary):
-        self.require_temps(binary=binary)
-        if self.latex_runs < 2:
-            if os.path.isfile("mod%s.idx" % self.doc):
-                self.run("%s mod%s.idx" % (MAKEINDEX_BINARY, self.doc))
-            use_indfix = 0
-            if os.path.isfile(self.doc + ".idx"):
-                use_indfix = 1
-                # call to Doc/tools/fix_hack omitted; doesn't appear necessary
-                self.run("%s %s.idx" % (MAKEINDEX_BINARY, self.doc))
-                import indfix
-                indfix.process(self.doc + ".ind")
-            if self.use_bibtex:
-                self.run("%s %s" % (BIBTEX_BINARY, self.doc))
-            self.process_synopsis_files()
-            #
-            # let the doctype-specific handler do some intermediate work:
-            #
-            self.run("%s %s" % (binary, self.doc))
-            self.latex_runs = self.latex_runs + 1
-            if os.path.isfile("mod%s.idx" % self.doc):
-                self.run("%s -s %s mod%s.idx"
-                         % (MAKEINDEX_BINARY, ISTFILE, self.doc))
-            if use_indfix:
-                self.run("%s -s %s %s.idx"
-                         % (MAKEINDEX_BINARY, ISTFILE, self.doc))
-                indfix.process(self.doc + ".ind")
-            self.process_synopsis_files()
-        #
-        # and now finish it off:
-        #
-        if os.path.isfile(self.doc + ".toc") and binary == PDFLATEX_BINARY:
-            import toc2bkm
-            if self.doctype == "manual":
-                bigpart = "chapter"
-            else:
-                bigpart = "section"
-            toc2bkm.process(self.doc + ".toc", self.doc + ".bkm", bigpart)
-        if self.use_bibtex:
-            self.run("%s %s" % (BIBTEX_BINARY, self.doc))
-        self.run("%s %s" % (binary, self.doc))
-        self.latex_runs = self.latex_runs + 1
-
-    def process_synopsis_files(self):
-        synopsis_files = glob.glob(self.doc + "*.syn")
-        for path in synopsis_files:
-            uniqify_module_table(path)
-
-    def build_ps(self):
-        self.run("%s -N0 -o %s.ps %s" % (DVIPS_BINARY, self.doc, self.doc))
-
-    def build_html(self, builddir=None, max_split_depth=None):
-        if builddir is None:
-            builddir = self.doc
-        if max_split_depth is None:
-            max_split_depth = self.options.max_split_depth
-        texfile = None
-        for p in string.split(os.environ["TEXINPUTS"], os.pathsep):
-            fn = os.path.join(p, self.doc + ".tex")
-            if os.path.isfile(fn):
-                texfile = fn
-                break
-        if not texfile:
-            self.warning("Could not locate %s.tex; aborting." % self.doc)
-            sys.exit(1)
-        # remove leading ./ (or equiv.); might avoid problems w/ dvips
-        if texfile[:2] == os.curdir + os.sep:
-            texfile = texfile[2:]
-        # build the command line and run LaTeX2HTML:
-        if not os.path.isdir(builddir):
-            os.mkdir(builddir)
-        else:
-            for fname in glob.glob(os.path.join(builddir, "*.html")):
-                os.unlink(fname)
-        args = [LATEX2HTML_BINARY,
-                "-init_file", self.l2h_aux_init_file,
-                "-dir", builddir,
-                texfile
-                ]
-        self.run(string.join(args))     # XXX need quoting!
-        # ... postprocess
-        shutil.copyfile(self.options.style_file,
-                        os.path.join(builddir, self.doc + ".css"))
-        shutil.copyfile(os.path.join(builddir, self.doc + ".html"),
-                        os.path.join(builddir, "index.html"))
-        if max_split_depth != 1:
-            if self.options.numeric:
-                label_file = os.path.join(builddir, "labels.pl")
-                fp = open(label_file)
-                about_node = None
-                target = " = q/about/;\n"
-                x = len(target)
-                while 1:
-                    line = fp.readline()
-                    if not line:
-                        break
-                    if line[-x:] == target:
-                        line = fp.readline()
-                        m = re.search(r"\|(node\d+\.[a-z]+)\|", line)
-                        about_node = m.group(1)
-                        shutil.copyfile(os.path.join(builddir, about_node),
-                                        os.path.join(builddir, "about.html"))
-                        break
-            else:
-                pwd = os.getcwd()
-                try:
-                    os.chdir(builddir)
-                    self.run("%s %s *.html" % (PERL_BINARY, NODE2LABEL_SCRIPT))
-                finally:
-                    os.chdir(pwd)
-
-    def build_text(self, tempdir=None):
-        if tempdir is None:
-            tempdir = self.doc
-        indexfile = os.path.join(tempdir, "index.html")
-        self.run("%s -nolist -dump %s >%s.txt"
-                 % (LYNX_BINARY, indexfile, self.doc))
-
-    def require_temps(self, binary=None):
-        if not self.latex_runs:
-            self.build_aux(binary=binary)
-
-    def write_l2h_aux_init_file(self):
-        options = self.options
-        fp = open(self.l2h_aux_init_file, "w")
-        d = string_to_perl(os.path.dirname(L2H_INIT_FILE))
-        fp.write("package main;\n"
-                 "push (@INC, '%s');\n"
-                 "$mydir = '%s';\n"
-                 % (d, d))
-        fp.write(open(L2H_INIT_FILE).read())
-        for filename in options.l2h_init_files:
-            fp.write("\n# initialization code incorporated from:\n# ")
-            fp.write(filename)
-            fp.write("\n")
-            fp.write(open(filename).read())
-        fp.write("\n"
-                 "# auxillary init file for latex2html\n"
-                 "# generated by mkhowto\n"
-                 "$NO_AUTO_LINK = 1;\n"
-                 )
-        l2hoption(fp, "ABOUT_FILE", options.about_file)
-        l2hoption(fp, "ICONSERVER", options.icon_server)
-        l2hoption(fp, "IMAGE_TYPE", options.image_type)
-        l2hoption(fp, "ADDRESS", options.address)
-        l2hoption(fp, "MAX_LINK_DEPTH", options.max_link_depth)
-        l2hoption(fp, "MAX_SPLIT_DEPTH", options.max_split_depth)
-        l2hoption(fp, "EXTERNAL_UP_LINK", options.up_link)
-        l2hoption(fp, "EXTERNAL_UP_TITLE", options.up_title)
-        l2hoption(fp, "GLOBAL_MODULE_INDEX", options.global_module_index)
-        fp.write("1;\n")
-        fp.close()
-
-    def cleanup(self):
-        self.__have_temps = 0
-        for pattern in ("%s.aux", "%s.log", "%s.out", "%s.toc", "%s.bkm",
-                        "%s.idx", "%s.ilg", "%s.ind", "%s.pla",
-                        "%s.bbl", "%s.blg",
-                        "mod%s.idx", "mod%s.ind", "mod%s.ilg",
-                        ):
-            safe_unlink(pattern % self.doc)
-        map(safe_unlink, glob.glob(self.doc + "*.syn"))
-        for spec in ("IMG*", "*.pl", "WARNINGS", "index.dat", "modindex.dat"):
-            pattern = os.path.join(self.doc, spec)
-            map(safe_unlink, glob.glob(pattern))
-        if "dvi" not in self.options.formats:
-            safe_unlink(self.doc + ".dvi")
-        if os.path.isdir(self.doc + "-temp-html"):
-            shutil.rmtree(self.doc + "-temp-html", ignore_errors=1)
-        if not self.options.logging:
-            os.unlink(self.log_filename)
-        if not self.options.debugging:
-            os.unlink(self.l2h_aux_init_file)
-
-    def run(self, command):
-        self.message(command)
-        rc = os.system("(%s) </dev/null >>%s 2>&1"
-                       % (command, self.log_filename))
-        if rc:
-            self.warning(
-                "Session transcript and error messages are in %s."
-                % self.log_filename)
-            sys.stderr.write("The relevant lines from the transcript are:\n")
-            sys.stderr.write("-" * 72 + "\n")
-            sys.stderr.writelines(get_run_transcript(self.log_filename))
-            sys.exit(rc)
-
-    def message(self, msg):
-        msg = "+++ " + msg
-        if not self.options.quiet:
-            print msg
-        self.log(msg + "\n")
-
-    def warning(self, msg):
-        msg = "*** %s\n" % msg
-        sys.stderr.write(msg)
-        self.log(msg)
-
-    def log(self, msg):
-        fp = open(self.log_filename, "a")
-        fp.write(msg)
-        fp.close()
-
-
-def get_run_transcript(filename):
-    """Return lines from the transcript file for the most recent run() call."""
-    fp = open(filename)
-    lines = fp.readlines()
-    fp.close()
-    lines.reverse()
-    L = []
-    for line in lines:
-        L.append(line)
-        if line[:4] == "+++ ":
-            break
-    L.reverse()
-    return L
-
-
-def safe_unlink(path):
-    """Unlink a file without raising an error if it doesn't exist."""
-    try:
-        os.unlink(path)
-    except os.error:
-        pass
-
-
-def split_pathname(path):
-    path = os.path.normpath(os.path.join(os.getcwd(), path))
-    dirname, basename = os.path.split(path)
-    if basename[-4:] == ".tex":
-        basename = basename[:-4]
-    return dirname, basename
-
-
-_doctype_rx = re.compile(r"\\documentclass(?:\[[^]]*\])?{([a-zA-Z]*)}")
-def get_doctype(path):
-    fp = open(path)
-    doctype = None
-    while 1:
-        line = fp.readline()
-        if not line:
-            break
-        m = _doctype_rx.match(line)
-        if m:
-            doctype = m.group(1)
-            break
-    fp.close()
-    return doctype
-
-
-def main():
-    options = Options()
-    try:
-        args = options.parse(sys.argv[1:])
-    except getopt.error, msg:
-        error(options, msg)
-    if not args:
-        # attempt to locate single .tex file in current directory:
-        args = glob.glob("*.tex")
-        if not args:
-            error(options, "No file to process.")
-        if len(args) > 1:
-            error(options, "Could not deduce which files should be processed.")
-    #
-    # parameters are processed, let's go!
-    #
-    for path in args:
-        Job(options, path).build()
-
-
-def l2hoption(fp, option, value):
-    if value:
-        fp.write('$%s = "%s";\n' % (option, string_to_perl(str(value))))
-
-
-_to_perl = {}
-for c in map(chr, range(1, 256)):
-    _to_perl[c] = c
-_to_perl["@"] = "\\@"
-_to_perl["$"] = "\\$"
-_to_perl['"'] = '\\"'
-
-def string_to_perl(s):
-    return string.join(map(_to_perl.get, s), '')
-
-
-def check_for_bibtex(filename):
-    fp = open(filename)
-    pos = string.find(fp.read(), r"\bibdata{")
-    fp.close()
-    return pos >= 0
-
-def uniqify_module_table(filename):
-    lines = open(filename).readlines()
-    if len(lines) > 1:
-        if lines[-1] == lines[-2]:
-            del lines[-1]
-    open(filename, "w").writelines(lines)
-
-
-def new_index(filename, label="genindex"):
-    fp = open(filename, "w")
-    fp.write(r"""\
-\begin{theindex}
-\label{%s}
-\end{theindex}
-""" % label)
-    fp.close()
-
-
-if __name__ == "__main__":
-    main()
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/mkinfo hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/mkinfo
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/mkinfo	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/mkinfo	1970-01-01 01:00:00.000000000 +0100
@@ -1,48 +0,0 @@
-#! /bin/sh
-#  -*- Ksh -*-
-
-#  Script to drive the HTML-info conversion process.
-#  Pass in a single parameter: the name of the top-level HTML file
-#  generated by LaTeX2HTML.
-#
-#  Written by Fred L. Drake, Jr. <fdrake@acm.org>
-
-PERL=${PERL:-perl}
-EMACS=${EMACS:-emacs}
-MAKEINFO=${MAKEINFO:-makeinfo}
-
-
-# Normalize file name since something called by html2texi.pl seems to
-# screw up with relative path names.
-FILENAME="$1"
-DOCDIR=`dirname "$FILENAME"`
-DOCFILE=`basename "$FILENAME"`
-DOCNAME=`basename "$FILENAME" .html`
-
-# Now build the real directory names, and locate our support stuff:
-WORKDIR=`pwd`
-cd `dirname $0`
-TOOLSDIR=`pwd`
-cd $DOCDIR
-DOCDIR=`pwd`
-cd $WORKDIR
-
-
-run() {
-    # show what we're doing, like make does:
-    echo "$*"
-    $* || exit $?
-}
-
-
-# generate the Texinfo file:
-
-run $PERL -I$TOOLSDIR $TOOLSDIR/html2texi.pl $DOCDIR/$DOCFILE
-run $EMACS -batch -l $TOOLSDIR/fixinfo.el $DOCNAME.texi
-rm -f $DOCNAME.texi~
-
-
-# generate the .info files:
-
-run $MAKEINFO --footnote-style end --fill-column 72 \
-	      --paragraph-indent 0 $DOCNAME.texi
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/mkmodindex hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/mkmodindex
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/mkmodindex	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/mkmodindex	1970-01-01 01:00:00.000000000 +0100
@@ -1,136 +0,0 @@
-#! /usr/bin/env python
-#  -*- Python -*-
-
-"""usage: %(program)s [options] file...
-
-Supported options:
-
-    --address addr
-    -a addr         Set the address text to include at the end of the generated
-                    HTML; this should be used for contact information.
-    --columns cols
-    -c cols         Set the number of columns each index section should be
-                    displayed in.  The default is 1.
-    --help
-    -h              Display this help message.
-    --letters
-    -l              Split the output into sections by letter.
-    --output file
-    -o file         Write output to 'file' instead of standard out.
-    --iconserver is Use 'is' as the directory containing icons for the
-                    navigation bar.  The default is 'icons'.
-    --title str     Set the page title to 'str'.  The default is 'Global
-                    Module Index'.
-    --uplink url    Set the upward link URL.  The default is './'.
-    --uptitle str   Set the upward link title.  The default is 'Python
-                    Documentation Index'.
-"""
-import buildindex
-import os
-import re
-import string
-import support
-import sys
-
-
-class IndexOptions(support.Options):
-    def __init__(self):
-        support.Options.__init__(self)
-        self.add_args("l", ["letters"])
-        self.letters = 0
-
-    def handle_option(self, opt, val):
-        if opt in ("-l", "--letters"):
-            self.letters = 1
-
-    def usage(self):
-        program = os.path.basename(sys.argv[0])
-        print __doc__ % {"program": program}
-
-
-class Node(buildindex.Node):
-    annotation = ""
-
-    def __init__(self, link, str, seqno):
-        parts = string.split(str, None, 1)
-        if parts[0][-5:] == "</tt>":
-            self.modname = parts[0][:-5]
-        else:
-            self.modname = parts[0]
-        if len(parts) == 2:
-            self.annotation = parts[1]
-        buildindex.Node.__init__(self, link, self.modname, seqno)
-
-    def __str__(self):
-        return '<tt class="module">%s</tt> %s' \
-               % (self.modname, self.annotation)
-
-_rx = re.compile(
-    "<dt><a href='(module-.*\.html)#l2h-\d+'><tt class='module'>"
-    "([a-zA-Z_][a-zA-Z0-9_.]*</tt>(\s*<em>"
-    "\(<span class='platform'>.*</span>\)</em>)?)</a>")
-
-def main():
-    options = IndexOptions()
-    options.variables["title"] = "Global Module Index"
-    options.parse(sys.argv[1:])
-    args = options.args
-    if not args:
-        args = ["-"]
-    #
-    # Collect the input data:
-    #
-    nodes = []
-    seqno = 0
-    has_plat_flag = 0
-    for ifn in args:
-        if ifn == "-":
-            ifp = sys.stdin
-            dirname = ''
-        else:
-            ifp = open(ifn)
-            dirname = os.path.dirname(ifn)
-        while 1:
-            line = ifp.readline()
-            if not line:
-                break
-            m = _rx.match(line)
-            if m:
-                # This line specifies a module!
-                basename, modname = m.group(1, 2)
-                has_plat_flag = has_plat_flag or m.group(3)
-                linkfile = os.path.join(dirname, basename)
-                nodes.append(Node('<a href="%s">' % linkfile, modname, seqno))
-                seqno = seqno + 1
-        ifp.close()
-    #
-    # Generate all output:
-    #
-    num_nodes = len(nodes)
-    # Here's the HTML generation:
-    parts = [options.get_header(),
-             buildindex.process_nodes(nodes, options.columns, options.letters),
-             options.get_footer(),
-             ]
-    if has_plat_flag:
-        parts.insert(1, PLAT_DISCUSS)
-    html = string.join(parts, '')
-    program = os.path.basename(sys.argv[0])
-    fp = options.get_output_file()
-    fp.write(string.rstrip(html) + "\n")
-    if options.outputfile == "-":
-        sys.stderr.write("%s: %d index nodes\n" % (program, num_nodes))
-    else:
-        print
-        print "%s: %d index nodes" % (program, num_nodes)
-
-
-PLAT_DISCUSS = """
-<p> Some module names are followed by an annotation indicating what
-platform they are available on.</p>
-
-"""
-
-
-if __name__ == "__main__":
-    main()
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/mksourcepkg hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/mksourcepkg
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/mksourcepkg	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/mksourcepkg	1970-01-01 01:00:00.000000000 +0100
@@ -1,163 +0,0 @@
-#! /usr/bin/env python
-#  -*- Python -*-
-
-"""%(program)s - script to create the latex source distribution
-
-usage:
-     %(program)s [-t|--tools] release [tag]
-
-with -t|--tools:  doesn't include the documents, only the framework
-
-without [tag]:  generate from the current version that's checked in
-     	   (*NOT* what's in the current directory!)
-
-with [tag]:  generate from the named tag
-"""
-#* should be modified to get the Python version number automatically
-#  from the Makefile or someplace.
-
-import getopt
-import glob
-import os
-import re
-import shutil
-import sys
-import tempfile
-
-import cvsinfo
-
-
-quiet = 0
-rx = re.compile(r":ext:(?:[a-zA-Z0-9]+)@cvs\.([a-zA-Z0-9]+).sourceforge.net:"
-                r"/cvsroot/\1")
-
-
-def main():
-     global quiet
-     try:
-          opts, args = getopt.getopt(sys.argv[1:], "abgtzq",
-                                     ["all", "bzip2", "gzip", "tools", "zip",
-                                      "quiet"])
-     except getopt.error, e:
-          usage(warning=str(e))
-          sys.exit(2)
-     if len(args) not in (1, 2):
-          usage(warning="wrong number of parameters")
-          sys.exit(2)
-     tools = 0
-     formats = {}
-     for opt, arg in opts:
-          if opt in ("-t", "--tools"):
-               tools = 1
-          elif opt in ("-q", "--quiet"):
-               quiet = quiet + 1
-          elif opt in ("-b", "--bzip2"):
-               formats["bzip2"] = 1
-          elif opt in ("-g", "--gzip"):
-               formats["gzip"] = 1
-          elif opt in ("-z", "--zip"):
-               formats["zip"] = 1
-          elif opt in ("-a", "--all"):
-               formats["bzip2"] = 1
-               formats["gzip"] = 1
-               formats["zip"] = 1
-     if formats:
-          # make order human-predictable
-          formats = formats.keys()
-          formats.sort()
-     else:
-          formats = ["gzip"]
-     release = args[0]
-     cvstag = None
-     if len(args) > 1:
-          cvstag = args[1]
-     tempdir = tempfile.mktemp()
-     os.mkdir(tempdir)
-     pkgdir = os.path.join(tempdir, "Python-" + release)
-     os.mkdir(pkgdir)
-     pwd = os.getcwd()
-     mydir = os.path.abspath(os.path.dirname(sys.argv[0]))
-     info = cvsinfo.RepositoryInfo(mydir)
-     cvsroot = info.get_cvsroot()
-     m = rx.match(cvsroot)
-     if m:
-          # If this is an authenticated SourceForge repository, convert to
-          # anonymous usage for the export/checkout, since that avoids the
-          # SSH overhead.
-          group = m.group(1)
-          cvsroot = ":pserver:anonymous@cvs.%s.sourceforge.net:/cvsroot/%s" \
-                    % (group, group)
-          # For some reason, SourceForge/CVS doesn't seem to care that we
-          # might not have done a "cvs login" to the anonymous server.
-          # That avoids a lot of painful gunk here.
-     os.chdir(pkgdir)
-     if not quiet:
-          print "--- current directory is:", pkgdir
-     if cvstag:
-          run("cvs -d%s export -r %s -d Doc python/dist/src/Doc"
-              % (cvsroot, cvstag))
-     else:
-          run("cvs -Q -d%s checkout -d Doc python/dist/src/Doc" % cvsroot)
-          # remove CVS directories
-          for p in ('*/CVS', '*/*/CVS', '*/*/*/CVS'):
-               map(shutil.rmtree, glob.glob(p))
-          for f in ('.cvsignore', '*/.cvsignore'):
-               map(os.unlink, glob.glob(f))
-     LICENSE = os.path.normpath(
-          os.path.join(mydir, os.pardir, os.pardir, "LICENSE"))
-     shutil.copyfile(LICENSE, "Doc/LICENSE")
-     if tools:
-          archive = "doctools-" + release
-          # we don't want the actual documents in this case:
-          for d in ("api", "dist", "doc", "ext", "inst",
-                    "lib", "mac", "ref", "tut"):
-               shutil.rmtree(os.path.join(os.path.join(pkgdir, "Doc"), d))
-     else:
-          archive = "latex-" + release
-
-     # XXX should also remove the .cvsignore files at this point
-
-     os.chdir(tempdir)
-     archive = os.path.join(pwd, archive)
-     for format in formats:
-          if format == "bzip2":
-               run("tar cf - Python-%s | bzip2 -9 >%s.tar.bz2"
-                   % (release, archive))
-          elif format == "gzip":
-               run("tar cf - Python-%s | gzip -9 >%s.tgz"
-                   % (release, archive))
-          elif format == "zip":
-               if os.path.exists(archive + ".zip"):
-                    os.unlink(archive + ".zip")
-               run("zip -q -r9 %s.zip Python-%s"
-                   % (archive, release))
-
-     # clean up the work area:
-     os.chdir(pwd)
-     shutil.rmtree(tempdir)
-
-
-def run(cmd):
-     if quiet < 2:
-          print "+++", cmd
-     if quiet:
-          cmd = "%s >/dev/null" % cmd
-     rc = os.system(cmd)
-     if rc:
-          sys.exit(rc)
-
-
-def usage(warning=None):
-     stdout = sys.stdout
-     sys.stdout = sys.stderr
-     program = os.path.basename(sys.argv[0])
-     try:
-          if warning:
-               print "%s: %s\n" % (program, warning)
-          print __doc__ % {"program": program}
-     finally:
-          sys.stdout = stdout
-
-
-if __name__ == "__main__":
-     main()
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/node2label.pl hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/node2label.pl
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/node2label.pl	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/node2label.pl	1970-01-01 01:00:00.000000000 +0100
@@ -1,55 +0,0 @@
-#! /usr/bin/env perl
-
-use English;
-$INPLACE_EDIT = '';
-
-# read the labels, then reverse the mappings
-require "labels.pl";
-
-%nodes = ();
-my $key;
-# sort so that we get a consistent assignment for nodes with multiple labels 
-foreach $label (sort keys %external_labels) {
-  $key = $external_labels{$label};
-  $key =~ s|^/||;
-  $nodes{$key} = $label;
-}
-
-# This adds the "internal" labels added for indexing.  These labels will not
-# be used for file names.
-require "internals.pl";
-foreach $label (keys %internal_labels) {
-  $key = $internal_labels{$label};
-  $key =~ s|^/||;
-  if (defined($nodes{$key})) {
-    $nodes{$label} = $nodes{$key};
-  }
-}
-
-# collect labels that have been used
-%newnames = ();
-
-while (<>) {
-  # don't want to do one s/// per line per node
-  # so look for lines with hrefs, then do s/// on nodes present
-  if (/(HREF|href)=[\"\']([^\#\"\']*)html[\#\"\']/) {
-    @parts = split(/(HREF|href)\=[\"\']/);
-    shift @parts;
-    for $node (@parts) {
-      $node =~ s/[\#\"\'].*$//g;
-      chop($node);
-      if (defined($nodes{$node})) {
-	$label = $nodes{$node};
-	if (s/(HREF|href)=([\"\'])$node([\#\"\'])/href=$2$label.html$3/g) {
-	  s/(HREF|href)=([\"\'])$label.html/href=$2$label.html/g;
-	  $newnames{$node} = "$label.html";
-	}
-      }
-    }
-  }
-  print;
-}
-
-foreach $oldname (keys %newnames) {
-  rename($oldname, $newnames{$oldname});
-}
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/paper-a4/pypaper.sty hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/paper-a4/pypaper.sty
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/paper-a4/pypaper.sty	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/paper-a4/pypaper.sty	1970-01-01 01:00:00.000000000 +0100
@@ -1,5 +0,0 @@
-%
-%  Change this to say a4paper instead of letterpaper if you want A4.
-%
-\newcommand{\py@paper}{a4paper}
-\newcommand{\py@ptsize}{10pt}
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/perl/distutils.perl hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/perl/distutils.perl
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/perl/distutils.perl	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/perl/distutils.perl	1970-01-01 01:00:00.000000000 +0100
@@ -1,21 +0,0 @@
-# LaTeX2HTML support for distutils.sty.
-
-package main;
-
-sub do_cmd_command {
-    return use_wrappers(@_[0], '<code>', '</code>');
-}
-
-sub do_cmd_option {
-    return use_wrappers(@_[0], '<font face="sans-serif">', '</font>');
-}
-
-sub do_cmd_filevar {
-    return use_wrappers(@_[0], '<font face="sans-serif"></i>', '</i></font>');
-}
-
-sub do_cmd_XXX {
-    return use_wrappers(@_[0], '<b>** ', ' **</b>');
-}
-
-1;
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/perl/howto.perl hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/perl/howto.perl
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/perl/howto.perl	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/perl/howto.perl	1970-01-01 01:00:00.000000000 +0100
@@ -1,12 +0,0 @@
-# -*- perl -*-
-#
-# This implements the Python howto class.  All it really needs to do it
-# load the "python" style.
-
-package main;
-
-do_require_package("article");
-do_require_package("alltt");
-do_require_package("python");
-
-1;				# sheesh....
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/perl/l2hinit.perl hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/perl/l2hinit.perl
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/perl/l2hinit.perl	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/perl/l2hinit.perl	1970-01-01 01:00:00.000000000 +0100
@@ -1,594 +0,0 @@
-# LaTeX2HTML support base for use with Python documentation.
-
-package main;
-
-use L2hos;
-
-$HTML_VERSION = 4.0;
-
-$MAX_LINK_DEPTH = 2;
-$ADDRESS = '';
-
-$NO_FOOTNODE = 1;
-$NUMBERED_FOOTNOTES = 1;
-
-# Python documentation uses section numbers to support references to match
-# in the printed and online versions.
-#
-$SHOW_SECTION_NUMBERS = 1;
-
-$ICONSERVER = '../icons';
-$IMAGE_TYPE = 'gif';
-
-# Control where the navigation bars should show up:
-$TOP_NAVIGATION = 1;
-$BOTTOM_NAVIGATION = 1;
-$AUTO_NAVIGATION = 0;
-
-$BODYTEXT = '';
-$CHILDLINE = "\n<p><hr>\n";
-$VERBOSITY = 0;
-
-# default # of columns for the indexes
-$INDEX_COLUMNS = 2;
-$MODULE_INDEX_COLUMNS = 4;
-
-
-# A little painful, but lets us clean up the top level directory a little,
-# and not be tied to the current directory (as far as I can tell).  Testing
-# an existing definition of $mydir is needed since it cannot be computed when
-# run under mkhowto with recent versions of LaTeX2HTML, since this file is
-# not read directly by LaTeX2HTML any more.  mkhowto is required to prepend
-# the required definition at the top of the actual input file.
-#
-if (!defined $mydir) {
-    use Cwd;
-    use File::Basename;
-    ($myname, $mydir, $myext) = fileparse(__FILE__, '\..*');
-    chop $mydir;			# remove trailing '/'
-    $mydir = getcwd() . "$dd$mydir"
-        unless $mydir =~ s|^/|/|;
-}
-$LATEX2HTMLSTYLES = "$mydir$envkey$LATEX2HTMLSTYLES";
-push (@INC, $mydir);
-
-($myrootname, $myrootdir, $myext) = fileparse($mydir, '\..*');
-chop $myrootdir;
-
-
-# Hackish way to get the appropriate paper-*/ directory into $TEXINPUTS;
-# pass in the paper size (a4 or letter) as the environment variable PAPER
-# to add the right directory.  If not given, the current directory is
-# added instead for use with HOWTO processing.
-#
-if (defined $ENV{'PAPER'}) {
-    $mytexinputs = "$myrootdir${dd}paper-$ENV{'PAPER'}$envkey";
-}
-else {
-    $mytexinputs = getcwd() . $envkey;
-}
-$mytexinputs .= "$myrootdir${dd}texinputs";
-
-
-# Change this variable to change the text added in "About this document...";
-# this should be an absolute pathname to get it right.
-#
-$ABOUT_FILE = "$myrootdir${dd}html${dd}stdabout.dat";
-
-
-sub custom_driver_hook {
-    #
-    # This adds the directory of the main input file to $TEXINPUTS; it
-    # seems to be sufficiently general that it should be fine for HOWTO
-    # processing.
-    #
-    my $file = @_[0];
-    my($jobname, $dir, $ext) = fileparse($file, '\..*');
-    $dir = L2hos->Make_directory_absolute($dir);
-    $dir =~ s/$dd$//;
-    $TEXINPUTS = "$dir$envkey$mytexinputs";
-    print "\nAdding $dir to \$TEXINPUTS\n";
-}
-
-
-$CUSTOM_BUTTONS = '';
-
-sub make_nav_sectref {
-    my($label,$title) = @_;
-    if ($title) {
-        if ($title =~ /\<[aA] /) {
-            $title =~ s/\<[aA] /<a class="sectref" /;
-        }
-        else {
-            $title = "<span class=\"sectref\">$title</span>";
-        }
-        return "<b class=\"navlabel\">$label:</b> $title\n";
-    }
-    return '';
-}
-
-@my_icon_tags = ();
-$my_icon_tags{'next'} = 'Next Page';
-$my_icon_tags{'next_page'} = 'Next Page';
-$my_icon_tags{'previous'} = 'Previous Page';
-$my_icon_tags{'previous_page'} = 'Previous Page';
-$my_icon_tags{'up'} = 'Up One Level';
-$my_icon_tags{'contents'} = 'Contents';
-$my_icon_tags{'index'} = 'Index';
-$my_icon_tags{'modules'} = 'Module Index';
-
-@my_icon_names = ();
-$my_icon_names{'previous_page'} = 'previous';
-$my_icon_names{'next_page'} = 'next';
-
-sub get_my_icon {
-    my $name = @_[0];
-    my $text = $my_icon_tags{$name};
-    if ($my_icon_names{$name}) {
-        $name = $my_icon_names{$name};
-    }
-    if ($text eq '') {
-        $name = 'blank';
-    }
-    my $iconserver = ($ICONSERVER eq '.') ? '' : "$ICONSERVER/";
-    return "<img src=\"$iconserver$name.$IMAGE_TYPE\"\n  border=\"0\""
-           . " height=\"32\"\n  alt=\"$text\" width=\"32\">";
-}
-
-sub use_my_icon {
-    my $s = @_[0];
-    if ($s =~ /\<tex2html_([a-z_]+)_visible_mark\>/) {
-        my $r = get_my_icon($1);
-        $s =~ s/\<tex2html_[a-z_]+_visible_mark\>/$r/;
-    }
-    return $s;
-}
-
-sub make_nav_panel {
-    my $s;
-    my $BLANK_ICON = get_my_icon('blank');
-    $NEXT = $NEXT_TITLE ? use_my_icon("$NEXT") : $BLANK_ICON;
-    $UP = $UP_TITLE ? use_my_icon("$UP") : $BLANK_ICON;
-    $PREVIOUS = $PREVIOUS_TITLE ? use_my_icon("$PREVIOUS") : $BLANK_ICON;
-    $CONTENTS = use_my_icon("$CONTENTS");
-    $INDEX = $INDEX ? use_my_icon("$INDEX") : $BLANK_ICON;
-    if (!$CUSTOM_BUTTONS) {
-        $CUSTOM_BUTTONS = $BLANK_ICON;
-    }
-    $s = ('<table align="center" width="100%" cellpadding="0" cellspacing="2">'
-          . "\n<tr>"
-          # left-hand side
-          . "\n<td>$PREVIOUS</td>"
-          . "\n<td>$UP</td>"
-          . "\n<td>$NEXT</td>"
-          # title box
-          . "\n<td align=\"center\" width=\"100%\">$t_title</td>"
-          # right-hand side
-          . "\n<td>$CONTENTS</td>"
-          . "\n<td>$CUSTOM_BUTTONS</td>" # module index
-          . "\n<td>$INDEX</td>"
-          . "\n</tr></table>\n"
-          # textual navigation
-          . make_nav_sectref("Previous", $PREVIOUS_TITLE)
-          . make_nav_sectref("Up", $UP_TITLE)
-          . make_nav_sectref("Next", $NEXT_TITLE)
-          );
-    # remove these; they are unnecessary and cause errors from validation
-    $s =~ s/ NAME="tex2html\d+"\n */ /g;
-    return $s;
-}
-
-sub get_version_text {
-    if ($PACKAGE_VERSION ne '' && $t_date) {
-        return ("<span class=\"release-info\">"
-                . "Release $PACKAGE_VERSION,"
-                . " documentation updated on $t_date.</span>");
-    }
-    if ($PACKAGE_VERSION ne '') {
-        return ("<span class=\"release-info\">"
-                . "Release $PACKAGE_VERSION.</span>");
-    }
-    if ($t_date) {
-        return ("<span class=\"release-info\">Documentation released on "
-                . "$t_date.</span>");
-    }
-    return '';
-}
-
-
-sub top_navigation_panel {
-    return "\n"
-           . make_nav_panel()
-           . "<br><hr>\n";
-}
-
-sub bot_navigation_panel {
-    return "\n<p><hr>\n"
-           . make_nav_panel()
-           . "<hr>\n"
-           . get_version_text()
-           . "\n";
-}
-
-sub add_link {
-    # Returns a pair (iconic link, textual link)
-    my($icon, $current_file, @link) = @_;
-    my($dummy, $file, $title) = split($delim,
-				      $section_info{join(' ',@link)});
-    if ($icon =~ /\<tex2html_([_a-z]+)_visible_mark\>/) {
-        my $r = get_my_icon($1);
-        $icon =~ s/\<tex2html_[_a-z]+_visible_mark\>/$r/;
-    }
-    if ($title && ($file ne $current_file)) {
-        $title = purify($title);
-	$title = get_first_words($title, $WORDS_IN_NAVIGATION_PANEL_TITLES);
-	return (make_href($file, $icon), make_href($file, "$title"))
-	}
-    elsif ($icon eq get_my_icon('up') && $EXTERNAL_UP_LINK) {
- 	return (make_href($EXTERNAL_UP_LINK, $icon),
-		make_href($EXTERNAL_UP_LINK, "$EXTERNAL_UP_TITLE"))
-	}
-    elsif ($icon eq get_my_icon('previous')
-	   && $EXTERNAL_PREV_LINK && $EXTERNAL_PREV_TITLE) {
-	return (make_href($EXTERNAL_PREV_LINK, $icon),
-		make_href($EXTERNAL_PREV_LINK, "$EXTERNAL_PREV_TITLE"))
-	}
-    elsif ($icon eq get_my_icon('next')
-	   && $EXTERNAL_DOWN_LINK && $EXTERNAL_DOWN_TITLE) {
-	return (make_href($EXTERNAL_DOWN_LINK, $icon),
-		make_href($EXTERNAL_DOWN_LINK, "$EXTERNAL_DOWN_TITLE"))
-	}
-    return (&inactive_img($icon), "");
-}
-
-sub add_special_link {
-    my($icon, $file, $current_file) = @_;
-    if ($icon =~ /\<tex2html_([_a-z]+)_visible_mark\>/) {
-        my $r = get_my_icon($1);
-        $icon =~ s/\<tex2html_[_a-z]+_visible_mark\>/$r/;
-    }
-    return (($file && ($file ne $current_file))
-            ? make_href($file, $icon)
-            : undef)
-}
-
-# The img_tag() function seems only to be called with the parameter
-# 'anchor_invisible_mark', which we want to turn into ''.  Since
-# replace_icon_marks() is the only interesting caller, and all it really
-# does is call img_tag(), we can just define the hook alternative to be
-# a no-op instead.
-#
-sub replace_icons_hook {}
-
-sub do_cmd_arabic {
-    # get rid of that nasty <SPAN CLASS="arabic">...</SPAN>
-    my($ctr, $val, $id, $text) = &read_counter_value(@_[0]);
-    return ($val ? farabic($val) : "0") . $text;
-}
-
-
-sub gen_index_id {
-    # this is used to ensure common index key generation and a stable sort
-    my($str,$extra) = @_;
-    sprintf('%s###%s%010d', $str, $extra, ++$global{'max_id'});
-}
-
-sub insert_index {
-    my($mark,$datafile,$columns,$letters,$prefix) = @_;
-    my $prog = "$myrootdir/tools/buildindex.py";
-    my $index;
-    if ($letters) {
-	$index = `$prog --columns $columns --letters $datafile`;
-    }
-    else {
-	$index = `$prog --columns $columns $datafile`;
-    }
-    if (!s/$mark/$prefix$index/) {
-        print "\nCould not locate index mark: $mark";
-    }
-}
-
-sub add_idx {
-    print "\nBuilding HTML for the index ...";
-    close(IDXFILE);
-    insert_index($idx_mark, 'index.dat', $INDEX_COLUMNS, 1, '');
-}
-
-
-$idx_module_mark = '<tex2html_idx_module_mark>';
-$idx_module_title = 'Module Index';
-
-sub add_module_idx {
-    print "\nBuilding HTML for the module index ...";
-    my $key;
-    my $first = 1;
-    my $prevplat = '';
-    my $allthesame = 1;
-    my $prefix = '';
-    foreach $key (keys %Modules) {
-	$key =~ s/<tt>([a-zA-Z0-9._]*)<\/tt>/\1/;
-	my $plat = "$ModulePlatforms{$key}";
-	$plat = ''
-	  if ($plat eq $IGNORE_PLATFORM_ANNOTATION);
-	if (!$first) {
-	    $allthesame = 0
-	      if ($prevplat ne $plat);
-	}
-	else { $first = 0; }
-	$prevplat = $plat;
-    }
-    open(MODIDXFILE, '>modindex.dat') || die "\n$!\n";
-    foreach $key (keys %Modules) {
-	# dump the line in the data file; just use a dummy seqno field
-	my $nkey = $1;
-	my $moditem = "$Modules{$key}";
-	my $plat = '';
-	$key =~ s/<tt>([a-zA-Z0-9._]*)<\/tt>/\1/;
-	if ($ModulePlatforms{$key} && !$allthesame) {
-	    $plat = (" <em>(<span class='platform'>$ModulePlatforms{$key}"
-		     . '</span>)</em>');
-	}
-	print MODIDXFILE $moditem . $IDXFILE_FIELD_SEP
-              . "<tt class='module'>$key</tt>$plat###\n";
-    }
-    close(MODIDXFILE);
-
-    if ($GLOBAL_MODULE_INDEX) {
-        $prefix = <<MODULE_INDEX_PREFIX;
-
-<p> This index only lists modules documented in this manual.
-  The <em class="citetitle"><a href="$GLOBAL_MODULE_INDEX">Global Module
-     Index</a></em> lists all modules that are documented in this set
-  of manuals.</p>
-MODULE_INDEX_PREFIX
-    }
-    if (!$allthesame) {
-	$prefix .= <<PLAT_DISCUSS;
-
-<p> Some module names are followed by an annotation indicating what
-platform they are available on.</p>
-
-PLAT_DISCUSS
-    }
-    insert_index($idx_module_mark, 'modindex.dat', $MODULE_INDEX_COLUMNS, 0,
-		 $prefix);
-}
-
-# replace both indexes as needed:
-sub add_idx_hook {
-    add_idx() if (/$idx_mark/);
-    process_python_state();
-    if ($MODULE_INDEX_FILE) {
-        local ($_);
-        open(MYFILE, "<$MODULE_INDEX_FILE");
-        sysread(MYFILE, $_, 1024*1024);
-        close(MYFILE);
-        add_module_idx();
-        open(MYFILE,">$MODULE_INDEX_FILE");
-        print MYFILE $_;
-        close(MYFILE);
-    }
-}
-
-
-# In addition to the standard stuff, add label to allow named node files and
-# support suppression of the page complete (for HTML Help use).
-sub do_cmd_tableofcontents {
-    local($_) = @_;
-    $TITLE = $toc_title;
-    $tocfile = $CURRENT_FILE;
-    my($closures,$reopens) = preserve_open_tags();
-    anchor_label('contents', $CURRENT_FILE, $_);	# this is added
-    join('', "<BR>\n\\tableofchildlinks[off]", $closures
-	 , make_section_heading($toc_title, 'H2'), $toc_mark
-	 , $reopens, $_);
-}
-# In addition to the standard stuff, add label to allow named node files.
-sub do_cmd_listoffigures {
-    local($_) = @_;
-    $TITLE = $lof_title;
-    $loffile = $CURRENT_FILE;
-    my($closures,$reopens) = preserve_open_tags();
-    anchor_label('lof', $CURRENT_FILE, $_);		# this is added
-    join('', "<BR>\n", $closures
-	 , make_section_heading($lof_title, 'H2'), $lof_mark
-	 , $reopens, $_);
-}
-# In addition to the standard stuff, add label to allow named node files.
-sub do_cmd_listoftables {
-    local($_) = @_;
-    $TITLE = $lot_title;
-    $lotfile = $CURRENT_FILE;
-    my($closures,$reopens) = preserve_open_tags();
-    anchor_label('lot', $CURRENT_FILE, $_);		# this is added
-    join('', "<BR>\n", $closures
-	 , make_section_heading($lot_title, 'H2'), $lot_mark
-	 , $reopens, $_);
-}
-# In addition to the standard stuff, add label to allow named node files.
-sub do_cmd_textohtmlinfopage {
-    local($_) = @_;
-    if ($INFO) {					# 
-	anchor_label("about",$CURRENT_FILE,$_);		# this is added
-    }							#
-    my $the_version = '';				# and the rest is
-    if ($t_date) {					# mostly ours
-	$the_version = ",\n$t_date";
-	if ($PACKAGE_VERSION) {
-	    $the_version .= ", Release $PACKAGE_VERSION";
-	}
-    }
-    $_ = (($INFO == 1)
-          ? join('',
-                 $close_all,
-                 "<strong>$t_title</strong>$the_version\n",
-                 `cat $ABOUT_FILE`,
-                 $open_all, $_)
-          : join('', $close_all, $INFO,"\n", $open_all, $_));
-    $_;
-}
-
-# $idx_mark will be replaced with the real index at the end
-sub do_cmd_textohtmlindex {
-    local($_) = @_;
-    $TITLE = $idx_title;
-    $idxfile = $CURRENT_FILE;
-    if (%index_labels) { make_index_labels(); }
-    if (($SHORT_INDEX) && (%index_segment)) { make_preindex(); }
-    else { $preindex = ''; }
-    my $heading = make_section_heading($idx_title, 'h2') . $idx_mark;
-    my($pre,$post) = minimize_open_tags($heading);
-    anchor_label('genindex',$CURRENT_FILE,$_);		# this is added
-    return "<br>\n" . $pre . $_;
-}
-
-$MODULE_INDEX_FILE = '';
-
-# $idx_module_mark will be replaced with the real index at the end
-sub do_cmd_textohtmlmoduleindex {
-    local($_) = @_;
-    $TITLE = $idx_module_title;
-    anchor_label('modindex', $CURRENT_FILE, $_);
-    $MODULE_INDEX_FILE = "$CURRENT_FILE";
-    $_ = ('<p>' . make_section_heading($idx_module_title, 'h2')
-          . $idx_module_mark . $_);
-    return $_;
-}
-
-# The bibliography and the index should be treated as separate
-# sections in their own HTML files. The \bibliography{} command acts
-# as a sectioning command that has the desired effect. But when the
-# bibliography is constructed manually using the thebibliography
-# environment, or when using the theindex environment it is not
-# possible to use the normal sectioning mechanism. This subroutine
-# inserts a \bibliography{} or a dummy \textohtmlindex command just
-# before the appropriate environments to force sectioning.
-
-# XXX	This *assumes* that if there are two {theindex} environments,
-#	the first is the module index and the second is the standard
-#	index.  This is sufficient for the current Python documentation,
-#	but that's about it.
-
-sub add_bbl_and_idx_dummy_commands {
-    my $id = $global{'max_id'};
-
-    s/([\\]begin\s*$O\d+$C\s*thebibliography)/$bbl_cnt++; $1/eg;
-    s/([\\]begin\s*$O\d+$C\s*thebibliography)/$id++; "\\bibliography$O$id$C$O$id$C $1"/geo;
-    my(@parts) = split(/\\begin\s*$O\d+$C\s*theindex/);
-    if (scalar(@parts) == 3) {
-        # Be careful to re-write the string in place, since $_ is *not*
-        # returned explicity;  *** nasty side-effect dependency! ***
-        print "\nadd_bbl_and_idx_dummy_commands ==> adding module index";
-        my $rx = "([\\\\]begin\\s*$O\\d+$C\\s*theindex[\\s\\S]*)"
-          . "([\\\\]begin\\s*$O\\d+$C\\s*theindex)";
-        s/$rx/\\textohtmlmoduleindex \1 \\textohtmlindex \2/o;
-        # Add a button to the navigation areas:
-        $CUSTOM_BUTTONS .= ('<a href="modindex.html" title="Module Index">'
-                            . get_my_icon('modules')
-                            . '</a>');
-    }
-    else {
-        $CUSTOM_BUTTONS .= get_my_icon('blank');
-        $global{'max_id'} = $id; # not sure why....
-        s/([\\]begin\s*$O\d+$C\s*theindex)/\\textohtmlindex $1/o;
-	    s/[\\]printindex/\\textohtmlindex /o;
-	}
-    #----------------------------------------------------------------------
-    lib_add_bbl_and_idx_dummy_commands()
-        if defined(&lib_add_bbl_and_idx_dummy_commands);
-}
-
-# The bibliographic references, the appendices, the lists of figures
-# and tables etc. must appear in the contents table at the same level
-# as the outermost sectioning command. This subroutine finds what is
-# the outermost level and sets the above to the same level;
-
-sub set_depth_levels {
-    # Sets $outermost_level
-    my $level;
-    #RRM:  do not alter user-set value for  $MAX_SPLIT_DEPTH
-    foreach $level ("part", "chapter", "section", "subsection",
-		    "subsubsection", "paragraph") {
-	last if (($outermost_level) = /\\($level)$delimiter_rx/);
-    }
-    $level = ($outermost_level ? $section_commands{$outermost_level} :
-	      do {$outermost_level = 'section'; 3;});
-
-    #RRM:  but calculate value for $MAX_SPLIT_DEPTH when a $REL_DEPTH was given
-    if ($REL_DEPTH && $MAX_SPLIT_DEPTH) { 
-	$MAX_SPLIT_DEPTH = $level + $MAX_SPLIT_DEPTH;
-    } elsif (!($MAX_SPLIT_DEPTH)) { $MAX_SPLIT_DEPTH = 1 };
-
-    %unnumbered_section_commands = ('tableofcontents' => $level,
-				    'listoffigures' => $level,
-				    'listoftables' => $level,
-				    'bibliography' => $level,
-				    'textohtmlindex' => $level,
-				    'textohtmlmoduleindex' => $level);
-    $section_headings{'textohtmlmoduleindex'} = 'h1';
-
-    %section_commands = (%unnumbered_section_commands,
-			 %section_commands);
-
-    make_sections_rx();
-}
-
-
-# This changes the markup used for {verbatim} environments, and is the
-# best way I've found that ensures the <dl> goes on the outside of the
-# <pre>...</pre>.
-#
-# Note that this *must* be done in the init file, not the python.perl
-# style support file.  The %declarations must be set before
-# initialize() is called in the main LaTeX2HTML script (which happens
-# before style files are loaded).
-#
-%declarations = ('preform' => '<dl><dd><pre class="verbatim"></pre></dl>',
-		 %declarations);
-
-
-# This is added to get rid of the long comment that follows the
-# doctype declaration; MSIE5 on NT4 SP4 barfs on it and drops the
-# content of the page.
-sub make_head_and_body {
-    my($title, $body) = @_;
-    $body = " $body" unless ($body eq '');
-    my $DTDcomment = '';
-    my($version, $isolanguage) = ($HTML_VERSION, 'EN');
-    my %isolanguages = (  'english',  'EN'   , 'USenglish', 'EN.US'
-                        , 'original', 'EN'   , 'german'   , 'DE'
-                        , 'austrian', 'DE.AT', 'french'   , 'FR'
-                        , 'spanish',  'ES');
-    $isolanguage = $isolanguages{$default_language};
-    $isolanguage = 'EN' unless $isolanguage;
-    $title = &purify($title,1);
-    eval("\$title = ". $default_title ) unless ($title);
-
-    # allow user-modification of the <TITLE> tag; thanks Dan Young
-    if (defined &custom_TITLE_hook) {
-	$title = &custom_TITLE_hook($title, $toc_sec_title);
-    }
-
-    if ($DOCTYPE =~ /\/\/[\w\.]+\s*$/) { # language spec included
-	$DTDcomment = "<!DOCTYPE html PUBLIC \"$DOCTYPE\">\n";
-    } else {
-	$DTDcomment = "<!DOCTYPE html PUBLIC \"$DOCTYPE//"
-	    . ($ISO_LANGUAGE ? $ISO_LANGUAGE : $isolanguage) . "\">\n";
-    }
-
-    $STYLESHEET = $FILE.".css" unless $STYLESHEET;
-    if (!$charset && $CHARSET) { $charset = $CHARSET; $charset =~ s/_/\-/go; }
-
-    join('', ($DOCTYPE ? $DTDcomment : '' )
-	,"<html>\n<head>\n<title>", $title, "</title>\n"
-	, &meta_information($title)
-	, ($CHARSET && $HTML_VERSION ge "2.1" ?
-           "<meta http-equiv=\"Content-Type\" content=\"text/html; charset=$charset\">\n"
-           : "" )
-	, ($BASE ? "<base href=\"$BASE\">\n" : "" )
-	, "<link rel=\"STYLESHEET\" href=\"$STYLESHEET\">"
-	, $more_links_mark
-	, "\n</head>\n<body$body>");
-}
-
-1;	# This must be the last line
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/perl/ltxmarkup.perl hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/perl/ltxmarkup.perl
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/perl/ltxmarkup.perl	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/perl/ltxmarkup.perl	1970-01-01 01:00:00.000000000 +0100
@@ -1,67 +0,0 @@
-# LaTeX2HTML support for the ltxmarkup package.  Doesn't do indexing.
-
-package main;
-
-
-sub ltx_next_argument{
-    my $param;
-    $param = missing_braces()
-      unless ((s/$next_pair_pr_rx/$param=$2;''/eo)
-	      ||(s/$next_pair_rx/$param=$2;''/eo));
-    return $param;
-}
-
-
-sub do_cmd_macro{
-    local($_) = @_;
-    my $macro = ltx_next_argument();
-    return "<tt class='macro'>&#92;$macro</tt>" . $_;
-}
-
-sub do_cmd_env{
-    local($_) = @_;
-    my $env = ltx_next_argument();
-    return "<tt class='environment'>&#92;$env</tt>" . $_;
-}
-
-sub ltx_process_params{
-    # Handle processing of \p and \op for parameter specifications for
-    # envdesc and macrodesc.  It's done this way to avoid defining do_cmd_p()
-    # and do_cmd_op() functions, which would be interpreted outside the context
-    # in which these commands are legal, and cause LaTeX2HTML to think they're
-    # defined.  This way, other uses of \p and \op are properly flagged as
-    # unknown macros.
-    my $s = @_[0];
-    $s =~ s%\\op<<(\d+)>>(.+)<<\1>>%<tt>[</tt><var>$2</var><tt>]</tt>%;
-    while ($s =~ /\\p<<(\d+)>>(.+)<<\1>>/) {
-	$s =~ s%\\p<<(\d+)>>(.+)<<\1>>%<tt>{</tt><var>$2</var><tt>}</tt>%;
-    }
-    return $s;
-}
-
-sub do_env_macrodesc{
-    local($_) = @_;
-    my $macro = ltx_next_argument();
-    my $params = ltx_process_params(ltx_next_argument());
-    return "\n<dl class='macrodesc'>"
-         . "\n<dt><b><tt class='macro'>&#92;$macro</tt></b>"
-         . "\n    $params"
-	 . "\n<dd>"
-	 . $_
-	 . "</dl>";
-}
-
-sub do_env_envdesc{
-    local($_) = @_;
-    my $env = ltx_next_argument();
-    my $params = ltx_process_params(ltx_next_argument());
-    return "\n<dl class='envdesc'>"
-         . "\n<dt><tt>&#92;begin{<b class='environment'>$env</b>}</tt>"
-         . "\n    $params"
-         . "\n<br /><tt>&#92;end{<b class='environment'>$env</b>}</tt>"
-	 . "\n<dd>"
-	 . $_
-	 . "</dl>";
-}
-
-1;				# Must end with this, because Perl is bogus.
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/perl/manual.perl hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/perl/manual.perl
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/perl/manual.perl	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/perl/manual.perl	1970-01-01 01:00:00.000000000 +0100
@@ -1,15 +0,0 @@
-# -*- perl -*-
-#
-# This implements the Python manual class.  All it really needs to do it
-# load the "python" style.  The style code is not moved into the class code
-# at this time, since we expect additional document class to be developed
-# for the Python documentation in the future.  Appropriate relocations will
-# be made at that time.
-
-package main;
-
-do_require_package("report");
-do_require_package("alltt");
-do_require_package("python");
-
-1;				# sheesh....
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/perl/python.perl hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/perl/python.perl
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/perl/python.perl	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/perl/python.perl	1970-01-01 01:00:00.000000000 +0100
@@ -1,1651 +0,0 @@
-# python.perl by Fred L. Drake, Jr. <fdrake@acm.org>		-*- perl -*-
-#
-# Heavily based on Guido van Rossum's myformat.perl (now obsolete).
-#
-# Extension to LaTeX2HTML for documents using myformat.sty.
-# Subroutines of the form do_cmd_<name> here define translations
-# for LaTeX commands \<name> defined in the corresponding .sty file.
-
-package main;
-
-use File::Basename;
-
-
-sub next_argument{
-    my $param;
-    $param = missing_braces()
-      unless ((s/$next_pair_pr_rx/$param=$2;''/eo)
-	      ||(s/$next_pair_rx/$param=$2;''/eo));
-    return $param;
-}
-
-sub next_optional_argument{
-    my($param,$rx) = ('', "^\\s*(\\[([^]]*)\\])?");
-    s/$rx/$param=$2;''/eo;
-    return $param;
-}
-
-sub make_icon_filename($){
-    my($myname, $mydir, $myext) = fileparse(@_[0], '\..*');
-    chop $mydir;
-    if ($mydir eq '.') {
-        $mydir = $ICONSERVER;
-    }
-    $myext = ".$IMAGE_TYPE"
-      unless $myext;
-    return "$mydir$dd$myname$myext";
-}
-
-sub get_link_icon($){
-    my $url = @_[0];
-    if ($OFF_SITE_LINK_ICON && ($url =~ /^[-a-zA-Z0-9.]+:/)) {
-        # absolute URL; assume it points off-site
-        my $icon = make_icon_filename($OFF_SITE_LINK_ICON);
-        return (" <img src='$icon'\n"
-                . "  border='0' class='offsitelink'"
-                . ($OFF_SITE_LINK_ICON_HEIGHT
-                   ? " height='$OFF_SITE_LINK_ICON_HEIGHT'"
-                   : '')
-                . ($OFF_SITE_LINK_ICON_WIDTH
-                   ? " width='$OFF_SITE_LINK_ICON_WIDTH'"
-                   : '')
-                . " alt='[off-site link]'\n"
-                . "  >");
-    }
-    return '';
-}
-
-# This is a fairly simple hack; it supports \let when it is used to create
-# (or redefine) a macro to exactly be some other macro: \let\newname=\oldname.
-# Many possible uses of \let aren't supported or aren't supported correctly.
-#
-sub do_cmd_let{
-    local($_) = @_;
-    my $matched = 0;
-    s/[\\]([a-zA-Z]+)\s*(=\s*)?[\\]([a-zA-Z]*)/$matched=1; ''/e;
-    if ($matched) {
-	my($new, $old) = ($1, $3);
-	eval "sub do_cmd_$new { do_cmd_$old" . '(@_); }';
-	print "\ndefining handler for \\$new using \\$old\n";
-    }
-    else {
-	s/[\\]([a-zA-Z]+)\s*(=\s*)?([^\\])/$matched=1; ''/es;
-	if ($matched) {
-	    my($new, $char) = ($1, $3);
-	    eval "sub do_cmd_$new { \"\\$char\" . \@_[0]; }";
-	    print "\ndefining handler for \\$new to insert '$char'\n";
-	}
-	else {
-	    write_warnings("Could not interpret \\let construct...");
-	}
-    }
-    return $_;
-}
-
-
-# the older version of LaTeX2HTML we use doesn't support this, but we use it:
-
-sub do_cmd_textasciitilde{ '~' . @_[0]; }
-
-
-# words typeset in a special way (not in HTML though)
-
-sub do_cmd_ABC{ 'ABC' . @_[0]; }
-sub do_cmd_UNIX{ 'Unix'. @_[0]; }
-sub do_cmd_ASCII{ 'ASCII' . @_[0]; }
-sub do_cmd_POSIX{ 'POSIX' . @_[0]; }
-sub do_cmd_C{ 'C' . @_[0]; }
-sub do_cmd_Cpp{ 'C++' . @_[0]; }
-sub do_cmd_EOF{ 'EOF' . @_[0]; }
-sub do_cmd_NULL{ '<tt class="constant">NULL</tt>' . @_[0]; }
-
-sub do_cmd_e{ '&#92;' . @_[0]; }
-
-$DEVELOPER_ADDRESS = '';
-$SHORT_VERSION = '';
-$PACKAGE_VERSION = '';
-
-sub do_cmd_version{ $PACKAGE_VERSION . @_[0]; }
-sub do_cmd_shortversion{ $SHORT_VERSION . @_[0]; }
-sub do_cmd_release{
-    local($_) = @_;
-    $PACKAGE_VERSION = next_argument();
-    return $_;
-}
-
-sub do_cmd_setshortversion{
-    local($_) = @_;
-    $SHORT_VERSION = next_argument();
-    return $_;
-}
-
-sub do_cmd_authoraddress{
-    local($_) = @_;
-    $DEVELOPER_ADDRESS = next_argument();
-    return $_;
-}
-
-#sub do_cmd_developer{ do_cmd_author(@_[0]); }
-#sub do_cmd_developers{ do_cmd_author(@_[0]); }
-#sub do_cmd_developersaddress{ do_cmd_authoraddress(@_[0]); }
-
-sub do_cmd_hackscore{
-    local($_) = @_;
-    next_argument();
-    return '_' . $_;
-}
-
-sub use_wrappers{
-    local($_,$before,$after) = @_;
-    my $stuff = next_argument();
-    return $before . $stuff . $after . $_;
-}
-
-$IN_DESC_HANDLER = 0;
-sub do_cmd_optional{
-    if ($IN_DESC_HANDLER) {
-        return use_wrappers(@_[0], "</var><big>\[</big><var>",
-                            "</var><big>\]</big><var>");
-    }
-    else {
-        return use_wrappers(@_[0], "<big>\[</big>", "<big>\]</big>");
-    }
-}
-
-# Logical formatting (some based on texinfo), needs to be converted to
-# minimalist HTML.  The "minimalist" is primarily to reduce the size of
-# output files for users that read them over the network rather than
-# from local repositories.
-
-# \file and \samp are at the end of this file since they screw up fontlock.
-
-sub do_cmd_pytype{ return @_[0]; }
-sub do_cmd_makevar{
-    return use_wrappers(@_[0], '<span class="makevar">', '</span>'); }
-sub do_cmd_code{
-    return use_wrappers(@_[0], '<code>', '</code>'); }
-sub do_cmd_module{
-    return use_wrappers(@_[0], '<tt class="module">', '</tt>'); }
-sub do_cmd_keyword{
-    return use_wrappers(@_[0], '<tt class="keyword">', '</tt>'); }
-sub do_cmd_exception{
-    return use_wrappers(@_[0], '<tt class="exception">', '</tt>'); }
-sub do_cmd_class{
-    return use_wrappers(@_[0], '<tt class="class">', '</tt>'); }
-sub do_cmd_function{
-    return use_wrappers(@_[0], '<tt class="function">', '</tt>'); }
-sub do_cmd_constant{
-    return use_wrappers(@_[0], '<tt class="constant">', '</tt>'); }
-sub do_cmd_member{
-    return use_wrappers(@_[0], '<tt class="member">', '</tt>'); }
-sub do_cmd_method{
-    return use_wrappers(@_[0], '<tt class="method">', '</tt>'); }
-sub do_cmd_cfunction{
-    return use_wrappers(@_[0], '<tt class="cfunction">', '</tt>'); }
-sub do_cmd_cdata{
-    return use_wrappers(@_[0], '<tt class="cdata">', '</tt>'); }
-sub do_cmd_ctype{
-    return use_wrappers(@_[0], '<tt class="ctype">', '</tt>'); }
-sub do_cmd_regexp{
-    return use_wrappers(@_[0], '<tt class="regexp">', '</tt>'); }
-sub do_cmd_character{
-    return use_wrappers(@_[0], '"<tt class="character">', '</tt>"'); }
-sub do_cmd_program{
-    return use_wrappers(@_[0], '<b class="program">', '</b>'); }
-sub do_cmd_programopt{
-    return use_wrappers(@_[0], '<b class="programopt">', '</b>'); }
-sub do_cmd_longprogramopt{
-    # note that the --- will be later converted to -- by LaTeX2HTML
-    return use_wrappers(@_[0], '<b class="programopt">---', '</b>'); }
-sub do_cmd_email{
-    return use_wrappers(@_[0], '<span class="email">', '</span>'); }
-sub do_cmd_mimetype{
-    return use_wrappers(@_[0], '<span class="mimetype">', '</span>'); }
-sub do_cmd_var{
-    return use_wrappers(@_[0], "<var>", "</var>"); }
-sub do_cmd_dfn{
-    return use_wrappers(@_[0], '<i class="dfn">', '</i>'); }
-sub do_cmd_emph{
-    return use_wrappers(@_[0], '<i>', '</i>'); }
-sub do_cmd_file{
-    return use_wrappers(@_[0], '<span class="file">', '</span>'); }
-sub do_cmd_filenq{
-    return do_cmd_file(@_[0]); }
-sub do_cmd_samp{
-    return use_wrappers(@_[0], '"<tt class="samp">', '</tt>"'); }
-sub do_cmd_kbd{
-    return use_wrappers(@_[0], '<kbd>', '</kbd>'); }
-sub do_cmd_strong{
-    return use_wrappers(@_[0], '<b>', '</b>'); }
-sub do_cmd_textbf{
-    return use_wrappers(@_[0], '<b>', '</b>'); }
-sub do_cmd_textit{
-    return use_wrappers(@_[0], '<i>', '</i>'); }
-
-sub do_cmd_moreargs{
-    return '...' . @_[0]; }
-sub do_cmd_unspecified{
-    return '...' . @_[0]; }
-
-
-sub do_cmd_refmodule{
-    # Insert the right magic to jump to the module definition.
-    local($_) = @_;
-    my $key = next_optional_argument();
-    my $module = next_argument();
-    $key = $module
-        unless $key;
-    return "<tt class='module'><a href='module-$key.html'>$module</a></tt>"
-      . $_;
-}
-
-sub do_cmd_newsgroup{
-    local($_) = @_;
-    my $newsgroup = next_argument();
-    my $icon = get_link_icon("news:$newsgroup");
-    my $stuff = "<a class='newsgroup' href='news:$newsgroup'>"
-      . "$newsgroup$icon</a>";
-    return $stuff . $_;
-}
-
-sub do_cmd_envvar{
-    local($_) = @_;
-    my $envvar = next_argument();
-    my($name,$aname,$ahref) = new_link_info();
-    # The <tt> here is really to keep buildindex.py from making
-    # the variable name case-insensitive.
-    add_index_entry("environment variables!$envvar@<tt>$envvar</tt>",
-		    $ahref);
-    add_index_entry("$envvar (environment variable)", $ahref);
-    $aname =~ s/<a/<a class="envvar"/;
-    return "$aname$envvar</a>" . $_;
-}
-
-sub do_cmd_url{
-    # use the URL as both text and hyperlink
-    local($_) = @_;
-    my $url = next_argument();
-    my $icon = get_link_icon($url);
-    $url =~ s/~/&#126;/g;
-    return "<a class=\"url\" href=\"$url\">$url$icon</a>" . $_;
-}
-
-sub do_cmd_manpage{
-    # two parameters:  \manpage{name}{section}
-    local($_) = @_;
-    my $page = next_argument();
-    my $section = next_argument();
-    return "<span class='manpage'><i>$page</i>($section)</span>" . $_;
-}
-
-$PEP_FORMAT = "http://python.sourceforge.net/peps/pep-XXXX.html";
-$RFC_FORMAT = "http://www.ietf.org/rfc/rfcXXXX.txt";
-
-sub get_rfc_url($$){
-    my($rfcnum, $format) = @_;
-    $rfcnum = sprintf("%04d", $rfcnum);
-    $format = "$format";
-    $format =~ s/XXXX/$rfcnum/;
-    return $format;
-}
-
-sub do_cmd_pep{
-    local($_) = @_;
-    my $rfcnumber = next_argument();
-    my $id = "rfcref-" . ++$global{'max_id'};
-    my $href = get_rfc_url($rfcnumber, $PEP_FORMAT);
-    my $icon = get_link_icon($href);
-    # Save the reference
-    my $nstr = gen_index_id("Python Enhancement Proposals!PEP $rfcnumber", '');
-    $index{$nstr} .= make_half_href("$CURRENT_FILE#$id");
-    return ("<a class=\"rfc\" name=\"$id\"\nhref=\"$href\">PEP $rfcnumber"
-            . "$icon</a>" . $_);
-}
-
-sub do_cmd_rfc{
-    local($_) = @_;
-    my $rfcnumber = next_argument();
-    my $id = "rfcref-" . ++$global{'max_id'};
-    my $href = get_rfc_url($rfcnumber, $RFC_FORMAT);
-    my $icon = get_link_icon($href);
-    # Save the reference
-    my $nstr = gen_index_id("RFC!RFC $rfcnumber", '');
-    $index{$nstr} .= make_half_href("$CURRENT_FILE#$id");
-    return ("<a class=\"rfc\" name=\"$id\"\nhref=\"$href\">RFC $rfcnumber"
-            . "$icon</a>" . $_);
-}
-
-sub do_cmd_citetitle{
-    local($_) = @_;
-    my $url = next_optional_argument();
-    my $title = next_argument();
-    my $icon = get_link_icon($url);
-    my $repl = '';
-    if ($url) {
-        $repl = ("<em class='citetitle'><a\n"
-                 . " href='$url'\n"
-                 . " title='$title'\n"
-                 . " >$title$icon</a></em>");
-    }
-    else {
-        $repl = "<em class='citetitle'\n >$title</em>";
-    }
-    return $repl . $_;
-}
-
-sub do_cmd_deprecated{
-    # two parameters:  \deprecated{version}{whattodo}
-    local($_) = @_;
-    my $release = next_argument();
-    my $reason = next_argument();
-    return ('<div class="versionnote">'
-            . "<b>Deprecated since release $release.</b>"
-            . "\n$reason</div><p>"
-            . $_);
-}
-
-sub do_cmd_versionadded{
-    # one parameter:  \versionadded{version}
-    local($_) = @_;
-    my $release = next_argument();
-    return ("\n<span class='versionnote'>New in version $release.</span>\n"
-            . $_);
-}
-
-sub do_cmd_versionchanged{
-    # one parameter:  \versionchanged{version}
-    local($_) = @_;
-    my $explanation = next_optional_argument();
-    my $release = next_argument();
-    my $text = "Changed in version $release.";
-    if ($explanation) {
-        $text = "Changed in version $release:\n$explanation.";
-    }
-    return "\n<span class='versionnote'>$text</span>\n" . $_;
-}
-
-#
-# These function handle platform dependency tracking.
-#
-sub do_cmd_platform{
-    local($_) = @_;
-    my $platform = next_argument();
-    $ModulePlatforms{"<tt class='module'>$THIS_MODULE</tt>"} = $platform;
-    $platform = "Macintosh"
-      if $platform eq 'Mac';
-    return "\n<p class='availability'>Availability: <span"
-      . "\n class='platform'>$platform</span>.</p>\n" . $_;
-}
-
-$IGNORE_PLATFORM_ANNOTATION = '';
-sub do_cmd_ignorePlatformAnnotation{
-    local($_) = @_;
-    $IGNORE_PLATFORM_ANNOTATION = next_argument();
-    return $_;
-}
-
-
-# index commands
-
-$INDEX_SUBITEM = "";
-
-sub get_indexsubitem{
-    return $INDEX_SUBITEM ? " $INDEX_SUBITEM" : '';
-}
-
-sub do_cmd_setindexsubitem{
-    local($_) = @_;
-    $INDEX_SUBITEM = next_argument();
-    return $_;
-}
-
-sub do_cmd_withsubitem{
-    # We can't really do the right thing, because LaTeX2HTML doesn't
-    # do things in the right order, but we need to at least strip this stuff
-    # out, and leave anything that the second argument expanded out to.
-    #
-    local($_) = @_;
-    my $oldsubitem = $INDEX_SUBITEM;
-    $INDEX_SUBITEM = next_argument();
-    my $stuff = next_argument();
-    my $br_id = ++$globals{'max_id'};
-    my $marker = "$O$br_id$C";
-    return
-      $stuff
-      . "\\setindexsubitem$marker$oldsubitem$marker"
-      . $_;
-}
-
-# This is the prologue macro which is required to start writing the
-# mod\jobname.idx file; we can just ignore it.  (Defining this suppresses
-# a warning that \makemodindex is unknown.)
-#
-sub do_cmd_makemodindex{ return @_[0]; }
-
-# We're in the document subdirectory when this happens!
-#
-open(IDXFILE, '>index.dat') || die "\n$!\n";
-open(INTLABELS, '>intlabels.pl') || die "\n$!\n";
-print INTLABELS "%internal_labels = ();\n";
-print INTLABELS "1;		# hack in case there are no entries\n\n";
-
-# Using \0 for this is bad because we can't use common tools to work with the
-# resulting files.  Things like grep can be useful with this stuff!
-#
-$IDXFILE_FIELD_SEP = "\1";
-
-sub write_idxfile{
-    my ($ahref, $str) = @_;
-    print IDXFILE $ahref, $IDXFILE_FIELD_SEP, $str, "\n";
-}
-
-
-sub gen_link{
-    my($node,$target) = @_;
-    print INTLABELS "\$internal_labels{\"$target\"} = \"$URL/$node\";\n";
-    return "<a href='$node#$target'>";
-}
-
-sub add_index_entry{
-    # add an entry to the index structures; ignore the return value
-    my($str,$ahref) = @_;
-    $str = gen_index_id($str, '');
-    $index{$str} .= $ahref;
-    write_idxfile($ahref, $str);
-}
-
-sub new_link_info{
-    my $name = "l2h-" . ++$globals{'max_id'};
-    my $aname = "<a name='$name'>";
-    my $ahref = gen_link($CURRENT_FILE, $name);
-    return ($name, $aname, $ahref);
-}
-
-$IndexMacroPattern = '';
-sub define_indexing_macro{
-    my $count = @_;
-    my $i = 0;
-    for (; $i < $count; ++$i) {
-	my $name = @_[$i];
-	my $cmd = "idx_cmd_$name";
-	die "\nNo function $cmd() defined!\n"
-	  if (!defined &$cmd);
-	eval ("sub do_cmd_$name { return process_index_macros("
-	      . "\@_[0], '$name'); }");
-	if (length($IndexMacroPattern) == 0) {
-	    $IndexMacroPattern = "$name";
-	}
-	else {
-	    $IndexMacroPattern .= "|$name";
-	}
-    }
-}
-
-$DEBUG_INDEXING = 0;
-sub process_index_macros{
-    local($_) = @_;
-    my $cmdname = @_[1];	# This is what triggered us in the first place;
-				# we know it's real, so just process it.
-    my($name,$aname,$ahref) = new_link_info();
-    my $cmd = "idx_cmd_$cmdname";
-    print "\nIndexing: \\$cmdname"
-      if $DEBUG_INDEXING;
-    &$cmd($ahref);		# modifies $_ and adds index entries
-    while (/^[\s\n]*\\($IndexMacroPattern)</) {
-	$cmdname = "$1";
-	print " \\$cmdname"
-	  if $DEBUG_INDEXING;
-	$cmd = "idx_cmd_$cmdname";
-	if (!defined &$cmd) {
-	    last;
-	}
-	else {
-	    s/^[\s\n]*\\$cmdname//;
-	    &$cmd($ahref);
-	}
-    }
-    if (/^[ \t\r\n]/) {
-        $_ = substr($_, 1);
-    }
-    return "$aname$anchor_invisible_mark</a>" . $_;
-}
-
-define_indexing_macro('index');
-sub idx_cmd_index{
-    my $str = next_argument();
-    add_index_entry("$str", @_[0]);
-}
-
-define_indexing_macro('kwindex');
-sub idx_cmd_kwindex{
-    my $str = next_argument();
-    add_index_entry("<tt>$str</tt>!keyword", @_[0]);
-    add_index_entry("keyword!<tt>$str</tt>", @_[0]);
-}
-
-define_indexing_macro('indexii');
-sub idx_cmd_indexii{
-    my $str1 = next_argument();
-    my $str2 = next_argument();
-    add_index_entry("$str1!$str2", @_[0]);
-    add_index_entry("$str2!$str1", @_[0]);
-}
-
-define_indexing_macro('indexiii');
-sub idx_cmd_indexiii{
-    my $str1 = next_argument();
-    my $str2 = next_argument();
-    my $str3 = next_argument();
-    add_index_entry("$str1!$str2 $str3", @_[0]);
-    add_index_entry("$str2!$str3, $str1", @_[0]);
-    add_index_entry("$str3!$str1 $str2", @_[0]);
-}
-
-define_indexing_macro('indexiv');
-sub idx_cmd_indexiv{
-    my $str1 = next_argument();
-    my $str2 = next_argument();
-    my $str3 = next_argument();
-    my $str4 = next_argument();
-    add_index_entry("$str1!$str2 $str3 $str4", @_[0]);
-    add_index_entry("$str2!$str3 $str4, $str1", @_[0]);
-    add_index_entry("$str3!$str4, $str1 $str2", @_[0]);
-    add_index_entry("$str4!$$str1 $str2 $str3", @_[0]);
-}
-
-define_indexing_macro('ttindex');
-sub idx_cmd_ttindex{
-    my $str = next_argument();
-    my $entry = $str . get_indexsubitem();
-    add_index_entry($entry, @_[0]);
-}
-
-sub my_typed_index_helper{
-    my($word,$ahref) = @_;
-    my $str = next_argument();
-    add_index_entry("$str $word", $ahref);
-    add_index_entry("$word!$str", $ahref);
-}
-
-define_indexing_macro('stindex', 'opindex', 'exindex', 'obindex');
-sub idx_cmd_stindex{ my_typed_index_helper('statement', @_[0]); }
-sub idx_cmd_opindex{ my_typed_index_helper('operator', @_[0]); }
-sub idx_cmd_exindex{ my_typed_index_helper('exception', @_[0]); }
-sub idx_cmd_obindex{ my_typed_index_helper('object', @_[0]); }
-
-define_indexing_macro('bifuncindex');
-sub idx_cmd_bifuncindex{
-    my $str = next_argument();
-    add_index_entry("<tt class='function'>$str()</tt> (built-in function)",
-                    @_[0]);
-}
-
-
-sub make_mod_index_entry{
-    my($str,$define) = @_;
-    my($name,$aname,$ahref) = new_link_info();
-    # equivalent of add_index_entry() using $define instead of ''
-    $ahref =~ s/\#[-_a-zA-Z0-9]*\"/\"/
-      if ($define eq 'DEF');
-    $str = gen_index_id($str, $define);
-    $index{$str} .= $ahref;
-    write_idxfile($ahref, $str);
-
-    if ($define eq 'DEF') {
-	# add to the module index
-        $str =~ /(<tt.*<\/tt>)/;
-        my $nstr = $1;
-	$Modules{$nstr} .= $ahref;
-    }
-    return "$aname$anchor_invisible_mark2</a>";
-}
-
-
-$THIS_MODULE = '';
-$THIS_CLASS = '';
-
-sub define_module{
-    my($word,$name) = @_;
-    my $section_tag = join('', @curr_sec_id);
-    if ($word ne "built-in" && $word ne "extension"
-	&& $word ne "standard" && $word ne "") {
-	write_warnings("Bad module type '$word'"
-		       . " for \\declaremodule (module $name)");
-	$word = "";
-    }
-    $word = "$word " if $word;
-    $THIS_MODULE = "$name";
-    $INDEX_SUBITEM = "(in module $name)";
-    print "[$name]";
-    return make_mod_index_entry(
-        "<tt class='module'>$name</tt> (${word}module)", 'DEF');
-}
-
-sub my_module_index_helper{
-    local($word, $_) = @_;
-    my $name = next_argument();
-    return define_module($word, $name) . $_;
-}
-
-sub do_cmd_modindex{ return my_module_index_helper('', @_); }
-sub do_cmd_bimodindex{ return my_module_index_helper('built-in', @_); }
-sub do_cmd_exmodindex{ return my_module_index_helper('extension', @_); }
-sub do_cmd_stmodindex{ return my_module_index_helper('standard', @_); }
-
-sub ref_module_index_helper{
-    my($word, $ahref) = @_;
-    my $str = next_argument();
-    $word = "$word " if $word;
-    $str = "<tt class='module'>$str</tt> (${word}module)";
-    # can't use add_index_entry() since the 2nd arg to gen_index_id() is used;
-    # just inline it all here
-    $str = gen_index_id($str, 'REF');
-    $index{$str} .= $ahref;
-    write_idxfile($ahref, $str);
-}
-
-# these should be adjusted a bit....
-define_indexing_macro('refmodindex', 'refbimodindex',
-		      'refexmodindex', 'refstmodindex');
-sub idx_cmd_refmodindex{ return ref_module_index_helper('', @_); }
-sub idx_cmd_refbimodindex{ return ref_module_index_helper('built-in', @_); }
-sub idx_cmd_refexmodindex{ return ref_module_index_helper('extension', @_); }
-sub idx_cmd_refstmodindex{ return ref_module_index_helper('standard', @_); }
-
-sub do_cmd_nodename{ return do_cmd_label(@_); }
-
-sub init_myformat{
-    $anchor_invisible_mark = '&nbsp;';
-    $anchor_invisible_mark2 = '';
-    $anchor_mark = '';
-    $icons{'anchor_mark'} = '';
-}
-init_myformat();
-
-# Create an index entry, but include the string in the target anchor
-# instead of the dummy filler.
-#
-sub make_str_index_entry{
-    my($str) = @_;
-    my($name,$aname,$ahref) = new_link_info();
-    add_index_entry($str, $ahref);
-    return "$aname$str</a>";
-}
-
-$REFCOUNTS_LOADED = 0;
-
-sub load_refcounts{
-    $REFCOUNTS_LOADED = 1;
-
-    my $myname, $mydir, $myext;
-    ($myname, $mydir, $myext) = fileparse(__FILE__, '\..*');
-    chop $mydir;			# remove trailing '/'
-    ($myname, $mydir, $myext) = fileparse($mydir, '\..*');
-    chop $mydir;			# remove trailing '/'
-    $mydir = getcwd() . "$dd$mydir"
-      unless $mydir =~ s|^/|/|;
-    local $_;
-    my $filename = "$mydir${dd}api${dd}refcounts.dat";
-    open(REFCOUNT_FILE, "<$filename") || die "\n$!\n";
-    print "[loading API refcount data]";
-    while (<REFCOUNT_FILE>) {
-        if (/([a-zA-Z0-9_]+):PyObject\*:([a-zA-Z0-9_]*):(0|[-+]1|null):(.*)$/) {
-            my($func, $param, $count, $comment) = ($1, $2, $3, $4);
-            #print "\n$func($param) --> $count";
-            $REFCOUNTS{"$func:$param"} = $count;
-        }
-    }
-}
-
-sub get_refcount{
-    my ($func, $param) = @_;
-    load_refcounts()
-        unless $REFCOUNTS_LOADED;
-    return $REFCOUNTS{"$func:$param"};
-}
-
-sub do_env_cfuncdesc{
-    local($_) = @_;
-    my $return_type = next_argument();
-    my $function_name = next_argument();
-    my $arg_list = next_argument();
-    my $idx = make_str_index_entry(
-        "<tt class='cfunction'>$function_name()</tt>" . get_indexsubitem());
-    $idx =~ s/ \(.*\)//;
-    $idx =~ s/\(\)//;		# ???? - why both of these?
-    my $result_rc = get_refcount($function_name, '');
-    my $rcinfo = '';
-    if ($result_rc eq '+1') {
-        $rcinfo = 'New reference';
-    }
-    elsif ($result_rc eq '0') {
-        $rcinfo = 'Borrowed reference';
-    }
-    elsif ($result_rc eq 'null') {
-        $rcinfo = 'Always <tt class="constant">NULL</tt>';
-    }
-    if ($rcinfo ne '') {
-        $rcinfo = (  "\n<div class=\"refcount-info\">"
-                   . "\n  <span class=\"label\">Return value:</span>"
-                   . "\n  <span class=\"value\">$rcinfo.</span>"
-                   . "\n</div>");
-    }
-    return "<dl><dt>$return_type <b>$idx</b>(<var>$arg_list</var>)\n<dd>"
-           . $rcinfo
-           . $_
-           . '</dl>';
-}
-
-sub do_env_csimplemacrodesc{
-    local($_) = @_;
-    my $name = next_argument();
-    my $idx = make_str_index_entry("<tt class='macro'>$name</tt>");
-    return "<dl><dt><b>$idx</b>\n<dd>"
-           . $_
-           . '</dl>'
-}
-
-sub do_env_ctypedesc{
-    local($_) = @_;
-    my $index_name = next_optional_argument();
-    my $type_name = next_argument();
-    $index_name = $type_name
-      unless $index_name;
-    my($name,$aname,$ahref) = new_link_info();
-    add_index_entry("<tt class='ctype'>$index_name</tt> (C type)", $ahref);
-    return "<dl><dt><b><tt class='ctype'>$aname$type_name</a></tt></b>\n<dd>"
-           . $_
-           . '</dl>'
-}
-
-sub do_env_cvardesc{
-    local($_) = @_;
-    my $var_type = next_argument();
-    my $var_name = next_argument();
-    my $idx = make_str_index_entry("<tt class='cdata'>$var_name</tt>"
-				   . get_indexsubitem());
-    $idx =~ s/ \(.*\)//;
-    return "<dl><dt>$var_type <b>$idx</b>\n"
-           . '<dd>'
-           . $_
-           . '</dl>';
-}
-
-sub convert_args($){
-    local($IN_DESC_HANDLER) = 1;
-    local($_) = @_;
-    return translate_commands($_);
-}
-
-sub do_env_funcdesc{
-    local($_) = @_;
-    my $function_name = next_argument();
-    my $arg_list = convert_args(next_argument());
-    my $idx = make_str_index_entry("<tt class='function'>$function_name()</tt>"
-				   . get_indexsubitem());
-    $idx =~ s/ \(.*\)//;
-    $idx =~ s/\(\)<\/tt>/<\/tt>/;
-    return "<dl><dt><b>$idx</b>(<var>$arg_list</var>)\n<dd>" . $_ . '</dl>';
-}
-
-sub do_env_funcdescni{
-    local($_) = @_;
-    my $function_name = next_argument();
-    my $arg_list = convert_args(next_argument());
-    return "<dl><dt><b><tt class='function'>$function_name</tt></b>"
-      . "(<var>$arg_list</var>)\n"
-      . '<dd>'
-      . $_
-      . '</dl>';
-}
-
-sub do_cmd_funcline{
-    local($_) = @_;
-    my $function_name = next_argument();
-    my $arg_list = convert_args(next_argument());
-    my $prefix = "<tt class='function'>$function_name()</tt>";
-    my $idx = make_str_index_entry($prefix . get_indexsubitem());
-    $prefix =~ s/\(\)//;
-
-    return "<dt><b>$prefix</b>(<var>$arg_list</var>)\n<dd>" . $_;
-}
-
-sub do_cmd_funclineni{
-    local($_) = @_;
-    my $function_name = next_argument();
-    my $arg_list = convert_args(next_argument());
-    my $prefix = "<tt class='function'>$function_name</tt>";
-
-    return "<dt><b>$prefix</b>(<var>$arg_list</var>)\n<dd>" . $_;
-}
-
-# Change this flag to index the opcode entries.  I don't think it's very
-# useful to index them, since they're only presented to describe the dis
-# module.
-#
-$INDEX_OPCODES = 0;
-
-sub do_env_opcodedesc{
-    local($_) = @_;
-    my $opcode_name = next_argument();
-    my $arg_list = next_argument();
-    my $idx;
-    if ($INDEX_OPCODES) {
-	$idx = make_str_index_entry("<tt class='opcode'>$opcode_name</tt>"
-                                    . " (byte code instruction)");
-	$idx =~ s/ \(byte code instruction\)//;
-    }
-    else {
-	$idx = "<tt class='opcode'>$opcode_name</tt>";
-    }
-    my $stuff = "<dl><dt><b>$idx</b>";
-    if ($arg_list) {
-	$stuff .= "&nbsp;&nbsp;&nbsp;&nbsp;<var>$arg_list</var>";
-    }
-    return $stuff . "\n<dd>" . $_ . '</dl>';
-}
-
-sub do_env_datadesc{
-    local($_) = @_;
-    my $dataname = next_argument();
-    my $idx = make_str_index_entry("<tt>$dataname</tt>" . get_indexsubitem());
-    $idx =~ s/ \(.*\)//;
-    return "<dl><dt><b>$idx</b>\n<dd>"
-           . $_
-	   . '</dl>';
-}
-
-sub do_env_datadescni{
-    local($_) = @_;
-    my $idx = next_argument();
-    if (! $STRING_INDEX_TT) {
-	$idx = "<tt>$idx</tt>";
-    }
-    return "<dl><dt><b>$idx</b>\n<dd>" . $_ . '</dl>';
-}
-
-sub do_cmd_dataline{
-    local($_) = @_;
-    my $data_name = next_argument();
-    my $idx = make_str_index_entry("<tt>$data_name</tt>" . get_indexsubitem());
-    $idx =~ s/ \(.*\)//;
-    return "<dt><b>$idx</b><dd>" . $_;
-}
-
-sub do_cmd_datalineni{
-    local($_) = @_;
-    my $data_name = next_argument();
-    return "<dt><b><tt>$data_name</tt></b><dd>" . $_;
-}
-
-sub do_env_excdesc{
-    local($_) = @_;
-    my $excname = next_argument();
-    my $idx = make_str_index_entry("<tt class='exception'>$excname</tt>");
-    return "<dl><dt><b>exception $idx</b>\n<dd>" . $_ . '</dl>'
-}
-
-sub do_env_fulllineitems{ return do_env_itemize(@_); }
-
-
-sub handle_classlike_descriptor{
-    local($_, $what) = @_;
-    $THIS_CLASS = next_argument();
-    my $arg_list = convert_args(next_argument());
-    $idx = make_str_index_entry(
-		"<tt class='$what'>$THIS_CLASS</tt> ($what in $THIS_MODULE)" );
-    $idx =~ s/ \(.*\)//;
-    return ("<dl><dt><b>$what $idx</b>(<var>$arg_list</var>)\n<dd>"
-            . $_
-            . '</dl>');
-}
-
-sub do_env_classdesc{
-    return handle_classlike_descriptor(@_[0], "class");
-}
-
-sub do_env_excclassdesc{
-    return handle_classlike_descriptor(@_[0], "exception");
-}
-
-
-sub do_env_methoddesc{
-    local($_) = @_;
-    my $class_name = next_optional_argument();
-    $class_name = $THIS_CLASS
-        unless $class_name;
-    my $method = next_argument();
-    my $arg_list = convert_args(next_argument());
-    my $extra = '';
-    if ($class_name) {
-	$extra = " ($class_name method)";
-    }
-    my $idx = make_str_index_entry("<tt class='method'>$method()</tt>$extra");
-    $idx =~ s/ \(.*\)//;
-    $idx =~ s/\(\)//;
-    return "<dl><dt><b>$idx</b>(<var>$arg_list</var>)\n<dd>" . $_ . '</dl>';
-}
-
-
-sub do_cmd_methodline{
-    local($_) = @_;
-    my $class_name = next_optional_argument();
-    $class_name = $THIS_CLASS
-        unless $class_name;
-    my $method = next_argument();
-    my $arg_list = convert_args(next_argument());
-    my $extra = '';
-    if ($class_name) {
-	$extra = " ($class_name method)";
-    }
-    my $idx = make_str_index_entry("<tt class='method'>$method()</tt>$extra");
-    $idx =~ s/ \(.*\)//;
-    $idx =~ s/\(\)//;
-    return "<dt><b>$idx</b>(<var>$arg_list</var>)\n<dd>"
-           . $_;
-}
-
-
-sub do_cmd_methodlineni{
-    local($_) = @_;
-    next_optional_argument();
-    my $method = next_argument();
-    my $arg_list = convert_args(next_argument());
-    return "<dt><b>$method</b>(<var>$arg_list</var>)\n<dd>"
-           . $_;
-}
-
-sub do_env_methoddescni{
-    local($_) = @_;
-    next_optional_argument();
-    my $method = next_argument();
-    my $arg_list = convert_args(next_argument());
-    return "<dl><dt><b>$method</b>(<var>$arg_list</var>)\n<dd>"
-           . $_
-	   . '</dl>';
-}
-
-
-sub do_env_memberdesc{
-    local($_) = @_;
-    my $class = next_optional_argument();
-    my $member = next_argument();
-    $class = $THIS_CLASS
-        unless $class;
-    my $extra = '';
-    $extra = " ($class attribute)"
-        if ($class ne '');
-    my $idx = make_str_index_entry("<tt class='member'>$member</tt>$extra");
-    $idx =~ s/ \(.*\)//;
-    $idx =~ s/\(\)//;
-    return "<dl><dt><b>$idx</b>\n<dd>" . $_ . '</dl>';
-}
-
-
-sub do_cmd_memberline{
-    local($_) = @_;
-    my $class = next_optional_argument();
-    my $member = next_argument();
-    $class = $THIS_CLASS
-        unless $class;
-    my $extra = '';
-    $extra = " ($class attribute)"
-        if ($class ne '');
-    my $idx = make_str_index_entry("<tt class='member'>$member</tt>$extra");
-    $idx =~ s/ \(.*\)//;
-    $idx =~ s/\(\)//;
-    return "<dt><b>$idx</b><dd>" . $_;
-}
-
-sub do_env_memberdescni{
-    local($_) = @_;
-    next_optional_argument();
-    my $member = next_argument();
-    return "<dl><dt><b><tt class='member'>$member</tt></b>\n<dd>"
-           . $_
-           . '</dl>';
-}
-
-
-sub do_cmd_memberlineni{
-    local($_) = @_;
-    next_optional_argument();
-    my $member = next_argument();
-    return "<dt><b><tt class='member'>$member</tt></b><dd>" . $_;
-}
-
-@col_aligns = ('<td>', '<td>', '<td>', '<td>');
-
-sub fix_font{
-    # do a little magic on a font name to get the right behavior in the first
-    # column of the output table
-    my $font = @_[0];
-    if ($font eq 'textrm') {
-	$font = '';
-    }
-    elsif ($font eq 'file' || $font eq 'filenq') {
-	$font = 'tt class="file"';
-    }
-    elsif ($font eq 'member') {
-        $font = 'tt class="member"';
-    }
-    elsif ($font eq 'class') {
-        $font = 'tt class="class"';
-    }
-    elsif ($font eq 'constant') {
-        $font = 'tt class="constant"';
-    }
-    elsif ($font eq 'kbd') {
-        $font = 'kbd';
-    }
-    elsif ($font eq 'programopt') {
-        $font = 'b';
-    }
-    elsif ($font eq 'exception') {
-        $font = 'tt class="exception"';
-    }
-    return $font;
-}
-
-sub figure_column_alignment{
-    my $a = @_[0];
-    my $mark = substr($a, 0, 1);
-    my $r = '';
-    if ($mark eq 'c')
-      { $r = ' align="center"'; }
-    elsif ($mark eq 'r')
-      { $r = ' align="right"'; }
-    elsif ($mark eq 'l')
-      { $r = ' align="left"'; }
-    elsif ($mark eq 'p')
-      { $r = ' align="left"'; }
-    return $r;
-}
-
-sub setup_column_alignments{
-    local($_) = @_;
-    my($s1,$s2,$s3,$s4) = split(/[|]/,$_);
-    my $a1 = figure_column_alignment($s1);
-    my $a2 = figure_column_alignment($s2);
-    my $a3 = figure_column_alignment($s3);
-    my $a4 = figure_column_alignment($s4);
-    $col_aligns[0] = "<td$a1 valign=\"baseline\">";
-    $col_aligns[1] = "<td$a2>";
-    $col_aligns[2] = "<td$a3>";
-    $col_aligns[3] = "<td$a4>";
-    # return the aligned header start tags
-    return ("<th$a1>", "<th$a2>", "<th$a3>", "<th$a4>");
-}
-
-sub get_table_col1_fonts{
-    my $font = $globals{'lineifont'};
-    my ($sfont,$efont) = ('', '');
-    if ($font) {
-        $sfont = "<$font>";
-        $efont = "</$font>";
-        $efont =~ s/ .*>/>/;
-    }
-    return ($sfont, $efont);
-}
-
-sub do_env_tableii{
-    local($_) = @_;
-    my($th1,$th2,$th3,$th4) = setup_column_alignments(next_argument());
-    my $font = fix_font(next_argument());
-    my $h1 = next_argument();
-    my $h2 = next_argument();
-    s/[\s\n]+//;
-    $globals{'lineifont'} = $font;
-    my $a1 = $col_aligns[0];
-    my $a2 = $col_aligns[1];
-    s/\\lineii</\\lineii[$a1|$a2]</g;
-    return '<table border align="center" style="border-collapse: collapse">'
-	   . "\n  <thead>"
-	   . "\n    <tr class=\"tableheader\">"
-	   . "\n      $th1<b>$h1</b>\&nbsp;</th>"
-	   . "\n      $th2<b>$h2</b>\&nbsp;</th>"
-	   . "\n      </tr>"
-	   . "\n    </thead>"
-	   . "\n  <tbody valign='baseline'>"
-	   . $_
-	   . "\n    </tbody>"
-	   . "\n</table>";
-}
-
-sub do_env_longtableii{
-    return do_env_tableii(@_);
-}
-
-sub do_cmd_lineii{
-    local($_) = @_;
-    my $aligns = next_optional_argument();
-    my $c1 = next_argument();
-    my $c2 = next_argument();
-    s/[\s\n]+//;
-    my($sfont,$efont) = get_table_col1_fonts();
-    $c2 = '&nbsp;' if ($c2 eq '');
-    my($c1align,$c2align) = split('\|', $aligns);
-    my $padding = '';
-    if ($c1align =~ /align="right"/ || $c1 eq '') {
-        $padding = '&nbsp;';
-    }
-    return "\n    <tr>$c1align$sfont$c1$efont$padding</td>\n"
-           . "        $c2align$c2</td>"
-	   . $_;
-}
-
-sub do_env_tableiii{
-    local($_) = @_;
-    my($th1,$th2,$th3,$th4) = setup_column_alignments(next_argument());
-    my $font = fix_font(next_argument());
-    my $h1 = next_argument();
-    my $h2 = next_argument();
-    my $h3 = next_argument();
-    s/[\s\n]+//;
-    $globals{'lineifont'} = $font;
-    my $a1 = $col_aligns[0];
-    my $a2 = $col_aligns[1];
-    my $a3 = $col_aligns[2];
-    s/\\lineiii</\\lineiii[$a1|$a2|$a3]</g;
-    return '<table border align="center" style="border-collapse: collapse">'
-	   . "\n  <thead>"
-	   . "\n    <tr class=\"tableheader\">"
-	   . "\n      $th1<b>$h1</b>\&nbsp;</th>"
-	   . "\n      $th2<b>$h2</b>\&nbsp;</th>"
-	   . "\n      $th3<b>$h3</b>\&nbsp;</th>"
-	   . "\n      </tr>"
-	   . "\n    </thead>"
-	   . "\n  <tbody valign='baseline'>"
-	   . $_
-	   . "\n    </tbody>"
-	   . "\n</table>";
-}
-
-sub do_env_longtableiii{
-    return do_env_tableiii(@_);
-}
-
-sub do_cmd_lineiii{
-    local($_) = @_;
-    my $aligns = next_optional_argument();
-    my $c1 = next_argument();
-    my $c2 = next_argument(); 
-    my $c3 = next_argument();
-    s/[\s\n]+//;
-    my($sfont,$efont) = get_table_col1_fonts();
-    $c3 = '&nbsp;' if ($c3 eq '');
-    my($c1align,$c2align,$c3align) = split('\|', $aligns);
-    my $padding = '';
-    if ($c1align =~ /align="right"/ || $c1 eq '') {
-        $padding = '&nbsp;';
-    }
-    return "\n    <tr>$c1align$sfont$c1$efont$padding</td>\n"
-           . "        $c2align$c2</td>\n"
-	   . "        $c3align$c3</td>"
-	   . $_;
-}
-
-sub do_env_tableiv{
-    local($_) = @_;
-    my($th1,$th2,$th3,$th4) = setup_column_alignments(next_argument());
-    my $font = fix_font(next_argument());
-    my $h1 = next_argument();
-    my $h2 = next_argument();
-    my $h3 = next_argument();
-    my $h4 = next_argument();
-    s/[\s\n]+//;
-    $globals{'lineifont'} = $font;
-    my $a1 = $col_aligns[0];
-    my $a2 = $col_aligns[1];
-    my $a3 = $col_aligns[2];
-    my $a4 = $col_aligns[3];
-    s/\\lineiv</\\lineiv[$a1|$a2|$a3|$a4]</g;
-    return '<table border align="center" style="border-collapse: collapse">'
-	   . "\n  <thead>"
-	   . "\n    <tr class=\"tableheader\">"
-	   . "\n      $th1<b>$h1</b>\&nbsp;</th>"
-	   . "\n      $th2<b>$h2</b>\&nbsp;</th>"
-	   . "\n      $th3<b>$h3</b>\&nbsp;</th>"
-	   . "\n      $th4<b>$h4</b>\&nbsp;</th>"
-	   . "\n      </tr>"
-	   . "\n    </thead>"
-	   . "\n  <tbody valign='baseline'>"
-	   . $_
-	   . "\n    </tbody>"
-	   . "\n</table>";
-}
-
-sub do_env_longtableiv{
-    return do_env_tableiv(@_);
-}
-
-sub do_cmd_lineiv{
-    local($_) = @_;
-    my $aligns = next_optional_argument();
-    my $c1 = next_argument();
-    my $c2 = next_argument(); 
-    my $c3 = next_argument();
-    my $c4 = next_argument();
-    s/[\s\n]+//;
-    my($sfont,$efont) = get_table_col1_fonts();
-    $c4 = '&nbsp;' if ($c4 eq '');
-    my($c1align,$c2align,$c3align,$c4align) = split('\|', $aligns);
-    my $padding = '';
-    if ($c1align =~ /align="right"/ || $c1 eq '') {
-        $padding = '&nbsp;';
-    }
-    return "\n    <tr>$c1align$sfont$c1$efont$padding</td>\n"
-           . "        $c2align$c2</td>\n"
-	   . "        $c3align$c3</td>\n"
-	   . "        $c4align$c4</td>"
-	   . $_;
-}
-
-
-# These can be used to control the title page appearance;
-# they need a little bit of documentation.
-#
-# If $TITLE_PAGE_GRAPHIC is set, it should be the name of a file in the
-# $ICONSERVER directory, or include path information (other than "./").  The
-# default image type will be assumed if an extension is not provided.
-#
-# If specified, the "title page" will contain two colums: one containing the
-# title/author/etc., and the other containing the graphic.  Use the other
-# four variables listed here to control specific details of the layout; all
-# are optional.
-#
-# $TITLE_PAGE_GRAPHIC = "my-company-logo";
-# $TITLE_PAGE_GRAPHIC_COLWIDTH = "30%";
-# $TITLE_PAGE_GRAPHIC_WIDTH = 150;
-# $TITLE_PAGE_GRAPHIC_HEIGHT = 150;
-# $TITLE_PAGE_GRAPHIC_ON_RIGHT = 0;
-
-sub make_my_titlepage() {
-    my $the_title = "";
-    if ($t_title) {
-	$the_title .= "\n<h1>$t_title</h1>";
-    }
-    else {
-        write_warnings("\nThis document has no title.");
-    }
-    if ($t_author) {
-	if ($t_authorURL) {
-	    my $href = translate_commands($t_authorURL);
-	    $href = make_named_href('author', $href,
-				    "<b><font size='+2'>$t_author</font></b>");
-	    $the_title .= "\n<p>$href</p>";
-	}
-        else {
-	    $the_title .= ("\n<p><b><font size='+2'>$t_author</font></b></p>");
-	}
-    }
-    else {
-        write_warnings("\nThere is no author for this document.");
-    }
-    if ($t_institute) {
-        $the_title .= "\n<p>$t_institute</p>";
-    }
-    if ($DEVELOPER_ADDRESS) {
-        $the_title .= "\n<p>$DEVELOPER_ADDRESS</p>";
-    }
-    if ($t_affil) {
-	$the_title .= "\n<p><i>$t_affil</i></p>";
-    }
-    if ($t_date) {
-	$the_title .= "\n<p>";
-	if ($PACKAGE_VERSION) {
-	    $the_title .= "<strong>Release $PACKAGE_VERSION</strong><br>\n";
-        }
-	$the_title .= "<strong>$t_date</strong></p>"
-    }
-    if ($t_address) {
-	$the_title .= "\n<p>$t_address</p>";
-    }
-    else {
-        $the_title .= "\n<p>";
-    }
-    if ($t_email) {
-	$the_title .= "\n<p>$t_email</p>";
-    }
-    return $the_title;
-}
-
-sub make_my_titlegraphic() {
-    my $filename = make_icon_filename($TITLE_PAGE_GRAPHIC);
-    my $graphic = "<td class=\"titlegraphic\"";
-    $graphic .= " width=\"$TITLE_PAGE_GRAPHIC_COLWIDTH\""
-      if ($TITLE_PAGE_GRAPHIC_COLWIDTH);
-    $graphic .= "><img";
-    $graphic .= " width=\"$TITLE_PAGE_GRAPHIC_WIDTH\""
-      if ($TITLE_PAGE_GRAPHIC_WIDTH);
-    $graphic .= " height=\"$TITLE_PAGE_GRAPHIC_HEIGHT\""
-      if ($TITLE_PAGE_GRAPHIC_HEIGHT);
-    $graphic .= "\n  src=\"$filename\"></td>\n";
-    return $graphic;
-}
-
-sub do_cmd_maketitle {
-    local($_) = @_;
-    my $the_title = "\n<div class=\"titlepage\">";
-    if ($TITLE_PAGE_GRAPHIC) {
-        if ($TITLE_PAGE_GRAPHIC_ON_RIGHT) {
-            $the_title .= ("\n<table border=\"0\" width=\"100%\">"
-                           . "<tr align=\"right\">\n<td>"
-                           . make_my_titlepage()
-                           . "</td>\n"
-                           . make_my_titlegraphic()
-                           . "</tr>\n</table>");
-        }
-        else {
-            $the_title .= ("\n<table border=\"0\" width=\"100%\"><tr>\n"
-                           . make_my_titlegraphic()
-                           . "<td>"
-                           . make_my_titlepage()
-                           . "</td></tr>\n</table>");
-        }
-    }
-    else {
-        $the_title .= ("\n<center>"
-                       . make_my_titlepage()
-                       . "\n</center>");
-    }
-    $the_title .= "\n</div>";
-    return $the_title . $_;
-    $the_title .= "\n</center></div>";
-    return $the_title . $_ ;
-}
-
-
-#
-#  Module synopsis support
-#
-
-require SynopsisTable;
-
-sub get_chapter_id(){
-    my $id = do_cmd_thechapter('');
-    $id =~ s/<SPAN CLASS="arabic">(\d+)<\/SPAN>/\1/;
-    $id =~ s/\.//;
-    return $id;
-}
-
-# 'chapter' => 'SynopsisTable instance'
-%ModuleSynopses = ();
-
-sub get_synopsis_table($){
-    my($chap) = @_;
-    my $key;
-    foreach $key (keys %ModuleSynopses) {
-	if ($key eq $chap) {
-	    return $ModuleSynopses{$chap};
-	}
-    }
-    my $st = SynopsisTable->new();
-    $ModuleSynopses{$chap} = $st;
-    return $st;
-}
-
-sub do_cmd_moduleauthor{
-    local($_) = @_;
-    next_argument();
-    next_argument();
-    return $_;
-}
-
-sub do_cmd_sectionauthor{
-    local($_) = @_;
-    next_argument();
-    next_argument();
-    return $_;
-}
-
-sub do_cmd_declaremodule{
-    local($_) = @_;
-    my $key = next_optional_argument();
-    my $type = next_argument();
-    my $name = next_argument();
-    my $st = get_synopsis_table(get_chapter_id());
-    #
-    $key = $name unless $key;
-    $type = 'built-in' if $type eq 'builtin';
-    $st->declare($name, $key, $type);
-    define_module($type, $name);
-    return anchor_label("module-$key",$CURRENT_FILE,$_)
-}
-
-sub do_cmd_modulesynopsis{
-    local($_) = @_;
-    my $st = get_synopsis_table(get_chapter_id());
-    $st->set_synopsis($THIS_MODULE, translate_commands(next_argument()));
-    return $_;
-}
-
-sub do_cmd_localmoduletable{
-    local($_) = @_;
-    my $chap = get_chapter_id();
-    my $st = get_synopsis_table($chap);
-    $st->set_file("$CURRENT_FILE");
-    return "<tex2html-localmoduletable><$chap>\\tableofchildlinks[off]" . $_;
-}
-
-sub process_all_localmoduletables{
-    my $key;
-    my $st, $file;
-    foreach $key (keys %ModuleSynopses) {
-        $st = $ModuleSynopses{$key};
-        $file = $st->get_file();
-        if ($file) {
-            process_localmoduletables_in_file($file);
-        }
-        else {
-            print "\nsynopsis table $key has no file association";
-        }
-    }
-}
-
-sub process_localmoduletables_in_file{
-    my $file = @_[0];
-    open(MYFILE, "<$file");
-    local($_);
-    sysread(MYFILE, $_, 1024*1024);
-    close(MYFILE);
-    # need to get contents of file in $_
-    while (/<tex2html-localmoduletable><(\d+)>/) {
-	my $match = $&;
-	my $chap = $1;
-	my $st = get_synopsis_table($chap);
-	my $data = $st->tohtml();
-	s/$match/$data/;
-    }
-    open(MYFILE,">$file");
-    print MYFILE $_;
-    close(MYFILE);
-}
-sub process_python_state{
-    process_all_localmoduletables();
-}
-
-
-#
-#  "See also:" -- references placed at the end of a \section
-#
-
-sub do_env_seealso{
-    return "<div class='seealso'>\n  "
-      . "<p class='heading'><b>See Also:</b></p>\n"
-      . @_[0]
-      . '</div>';
-}
-
-sub do_cmd_seemodule{
-    # Insert the right magic to jump to the module definition.  This should
-    # work most of the time, at least for repeat builds....
-    local($_) = @_;
-    my $key = next_optional_argument();
-    my $module = next_argument();
-    my $text = next_argument();
-    my $period = '.';
-    $key = $module
-        unless $key;
-    if ($text =~ /\.$/) {
-	$period = '';
-    }
-    return '<dl compact class="seemodule">'
-      . "\n    <dt>Module <b><tt class='module'><a href='module-$key.html'>"
-      . "$module</a></tt>:</b>"
-      . "\n    <dd>$text$period\n  </dl>"
-      . $_;
-}
-
-sub strip_html_markup($){
-    my $str = @_[0];
-    my $s = "$str";
-    $s =~ s/<[a-zA-Z0-9]+(\s+[a-zA-Z0-9]+(\s*=\s*(\'[^\']*\'|\"[^\"]*\"|[a-zA-Z0-9]+))?)*\s*>//g;
-    $s =~ s/<\/[a-zA-Z0-9]+>//g;
-    return $s;
-}
-
-sub handle_rfclike_reference{
-    local($_, $what, $format) = @_;
-    my $rfcnum = next_argument();
-    my $title = next_argument();
-    my $text = next_argument();
-    my $url = get_rfc_url($rfcnum, $format);
-    my $icon = get_link_icon($url);
-    my $attrtitle = strip_html_markup($title);
-    return '<dl compact class="seerfc">'
-      . "\n    <dt><a href=\"$url\""
-      . "\n        title=\"$attrtitle\""
-      . "\n        >$what $rfcnum, <em>$title</em>$icon</a>"
-      . "\n    <dd>$text\n  </dl>"
-      . $_;
-}
-
-sub do_cmd_seepep{
-    return handle_rfclike_reference(@_[0], "PEP", $PEP_FORMAT);
-}
-
-sub do_cmd_seerfc{
-    return handle_rfclike_reference(@_[0], "RFC", $RFC_FORMAT);
-}
-
-sub do_cmd_seetitle{
-    local($_) = @_;
-    my $url = next_optional_argument();
-    my $title = next_argument();
-    my $text = next_argument();
-    if ($url) {
-        my $icon = get_link_icon($url);
-        return '<dl compact class="seetitle">'
-          . "\n    <dt><em class=\"citetitle\"><a href=\"$url\""
-          . "\n        >$title$icon</a></em>"
-          . "\n    <dd>$text\n  </dl>"
-          . $_;
-    }
-    return '<dl compact class="seetitle">'
-      . "\n    <dt><em class=\"citetitle\""
-      . "\n        >$title</em>"
-      . "\n    <dd>$text\n  </dl>"
-      . $_;
-}
-
-sub do_cmd_seeurl{
-    local($_) = @_;
-    my $url = next_argument();
-    my $text = next_argument();
-    my $icon = get_link_icon($url);
-    return '<dl compact class="seeurl">'
-      . "\n    <dt><a href=\"$url\""
-      . "\n        class=\"url\">$url$icon</a>"
-      . "\n    <dd>$text\n  </dl>"
-      . $_;
-}
-
-sub do_cmd_seetext{
-    local($_) = @_;
-    my $content = next_argument();
-    return '<div class="seetext"><p>' . $content . '</div>' . $_;
-}
-
-
-#
-#  Definition list support.
-#
-
-sub do_env_definitions{
-    return "<dl class='definitions'>" . @_[0] . "</dl>\n";
-}
-
-sub do_cmd_term{
-    local($_) = @_;
-    my $term = next_argument();
-    my($name,$aname,$ahref) = new_link_info();
-    # could easily add an index entry here...
-    return "<dt><b>$aname" . $term . "</a></b>\n<dd>" . $_;
-}
-
-
-# I don't recall exactly why this was needed, but it was very much needed.
-# We'll see if anything breaks when I move the "code" line out -- some
-# things broke with it in.
-
-#code # {}
-process_commands_wrap_deferred(<<_RAW_ARG_DEFERRED_CMDS_);
-declaremodule # [] # {} # {}
-memberline # [] # {}
-methodline # [] # {} # {}
-modulesynopsis # {}
-platform # {}
-samp # {}
-setindexsubitem # {}
-withsubitem # {} # {}
-_RAW_ARG_DEFERRED_CMDS_
-
-
-$alltt_start = '<dl><dd><pre class="verbatim">';
-$alltt_end = '</pre></dl>';
-
-sub do_env_alltt {
-    local ($_) = @_;
-    local($closures,$reopens,@open_block_tags);
-
-    # get the tag-strings for all open tags
-    local(@keep_open_tags) = @$open_tags_R;
-    ($closures,$reopens) = &preserve_open_tags() if (@$open_tags_R);
-
-    # get the tags for text-level tags only
-    $open_tags_R = [ @keep_open_tags ];
-    local($local_closures, $local_reopens);
-    ($local_closures, $local_reopens,@open_block_tags)
-      = &preserve_open_block_tags
-	if (@$open_tags_R);
-
-    $open_tags_R = [ @open_block_tags ];
-
-    do {
-	local($open_tags_R) = [ @open_block_tags ];
-	local(@save_open_tags) = ();
-
-	local($cnt) = ++$global{'max_id'};
-	$_ = join('',"$O$cnt$C\\tt$O", ++$global{'max_id'}, $C
-		, $_ , $O, $global{'max_id'}, "$C$O$cnt$C");
-
-	$_ = &translate_environments($_);
-	$_ = &translate_commands($_) if (/\\/);
-
-	# preserve space-runs, using &nbsp;
-	while (s/(\S) ( +)/$1$2;SPMnbsp;/g){};
-	s/(<BR>) /$1;SPMnbsp;/g;
-
-	$_ = join('', $closures, $alltt_start, $local_reopens
-		, $_
-		, &balance_tags() #, $local_closures
-		, $alltt_end, $reopens);
-	undef $open_tags_R; undef @save_open_tags;
-    };
-    $open_tags_R = [ @keep_open_tags ];
-    $_;
-}
-
-
-1;				# This must be the last line
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/perl/SynopsisTable.pm hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/perl/SynopsisTable.pm
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/perl/SynopsisTable.pm	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/perl/SynopsisTable.pm	1970-01-01 01:00:00.000000000 +0100
@@ -1,89 +0,0 @@
-package SynopsisTable;
-
-sub new{
-    return bless {names=>'', info=>{}, file=>''};
-}
-
-sub declare{
-    my($self,$name,$key,$type) = @_;
-    if ($self->{names}) {
-	$self->{names} .= ",$name";
-    }
-    else {
-	$self->{names} .= "$name";
-    }
-    $self->{info}{$name} = "$key,$type,";
-}
-
-# The 'file' attribute is used to store the filename of the node in which
-# the table will be presented; this assumes that each table will be presented
-# only once, which works for the current use of this object.
-
-sub set_file{
-    my($self, $filename) = @_;
-    $self->{file} = "$filename";
-}
-
-sub get_file{
-    my $self = shift;
-    return $self->{file};
-}
-
-sub set_synopsis{
-    my($self,$name,$synopsis) = @_;
-    my($key,$type,$unused) = split ',', $self->{info}{$name}, 3;
-    $self->{info}{$name} = "$key,$type,$synopsis";
-}
-
-sub get{
-    my($self,$name) = @_;
-    return split /,/, $self->{info}{$name}, 3;
-}
-
-sub show{
-    my $self = shift;
-    my $name;
-    print "names: ", $self->{names}, "\n\n";
-    foreach $name (split /,/, $self->{names}) {
-	my($key,$type,$synopsis) = $self->get($name);
-	print "$name($key) is $type: $synopsis\n";
-    }
-}
-
-sub tohtml{
-    my $self = shift;
-    my $data = "<table class='synopsistable'>\n";
-    my $name;
-    foreach $name (split /,/, $self->{names}) {
-	my($key,$type,$synopsis) = $self->get($name);
-	my $link = "<a href='module-$key.html'>";
-	$data .= ('  <tr>'
-		  . "<td><b><tt class='module'>$link$name</a></tt></b></td>\n"
-		  . "      <td class='synopsis'>$synopsis</td></tr>\n");
-    }
-    $data .= "</table>\n";
-    $data;
-}
-
-
-package testSynopsisTable;
-
-sub test{
-    # this little test is mostly to debug the stuff above, since this is
-    # my first Perl "object".
-    my $st = SynopsisTable->new();
-    $st->declare("sample", "sample", "standard");
-    $st->set_synopsis("sample", "This is a little synopsis....");
-    $st->declare("copy_reg", "copyreg", "standard");
-    $st->set_synopsis("copy_reg", "pickle support stuff");
-    $st->show();
-
-    print "\n\n";
-
-    my $st2 = SynopsisTable->new();
-    $st2->declare("st2module", "st2module", "built-in");
-    $st2->set_synopsis("st2module", "silly little synopsis");
-    $st2->show();
-}
-
-1;	# This must be the last line -- Perl is bogus!
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/push-docs.sh hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/push-docs.sh
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/push-docs.sh	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/push-docs.sh	1970-01-01 01:00:00.000000000 +0100
@@ -1,42 +0,0 @@
-#! /bin/sh
-
-#  Script to push docs from my development area to SourceForge, where the
-#  update-docs.sh script unpacks them into their final destination.
-
-TARGET=python.sourceforge.net:/home/users/fdrake/tmp
-
-ADDRESSES='python-dev@python.org doc-sig@python.org python-list@python.org'
-
-EXPLANATION=''
-
-if [ "$1" = '-m' ] ; then
-    EXPLANATION="$2"
-    shift 2
-elif [ "$1" ] ; then
-    EXPLANATION="`cat $1`"
-    shift 1
-fi
-
-START="`pwd`"
-MYDIR="`dirname $0`"
-cd "$MYDIR"
-MYDIR="`pwd`"
-
-cd ..
-
-# now in .../Doc/
-make --no-print-directory || exit $?
-make --no-print-directory bziphtml || exit $?
-RELEASE=`grep '^RELEASE=' Makefile | sed 's|RELEASE=||'`
-PACKAGE="html-$RELEASE.tar.bz2"
-scp "$PACKAGE" tools/update-docs.sh $TARGET/ || exit $?
-ssh python.sourceforge.net tmp/update-docs.sh $PACKAGE '&&' rm tmp/update-docs.sh || exit $?
-
-Mail -s '[development doc updates]' $ADDRESSES <<EOF
-The development version of the documentation has been updated:
-
-	http://python.sourceforge.net/devel-docs/
-
-$EXPLANATION
-EOF
-exit $?
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/refcounts.py hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/refcounts.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/refcounts.py	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/refcounts.py	1970-01-01 01:00:00.000000000 +0100
@@ -1,97 +0,0 @@
-"""Support functions for loading the reference count data file."""
-__version__ = '$Revision: 1.1.1.1 $'
-
-import os
-import string
-import sys
-
-
-# Determine the expected location of the reference count file:
-try:
-    p = os.path.dirname(__file__)
-except NameError:
-    p = sys.path[0]
-p = os.path.normpath(os.path.join(os.getcwd(), p, os.pardir,
-                                  "api", "refcounts.dat"))
-DEFAULT_PATH = p
-del p
-
-
-def load(path=DEFAULT_PATH):
-    return loadfile(open(path))
-
-
-def loadfile(fp):
-    d = {}
-    while 1:
-        line = fp.readline()
-        if not line:
-            break
-        line = string.strip(line)
-        if line[:1] in ("", "#"):
-            # blank lines and comments
-            continue
-        parts = string.split(line, ":", 4)
-        function, type, arg, refcount, comment = parts
-        if refcount == "null":
-            refcount = None
-        elif refcount:
-            refcount = int(refcount)
-        else:
-            refcount = None
-        #
-        # Get the entry, creating it if needed:
-        #
-        try:
-            entry = d[function]
-        except KeyError:
-            entry = d[function] = Entry(function)
-        #
-        # Update the entry with the new parameter or the result information.
-        #
-        if arg:
-            entry.args.append((arg, type, refcount))
-        else:
-            entry.result_type = type
-            entry.result_refs = refcount
-    return d
-
-
-class Entry:
-    def __init__(self, name):
-        self.name = name
-        self.args = []
-        self.result_type = ''
-        self.result_refs = None
-
-
-def dump(d):
-    """Dump the data in the 'canonical' format, with functions in
-    sorted order."""
-    items = d.items()
-    items.sort()
-    first = 1
-    for k, entry in items:
-        if first:
-            first = 0
-        else:
-            print
-        s = entry.name + ":%s:%s:%s:"
-        if entry.result_refs is None:
-            r = ""
-        else:
-            r = entry.result_refs
-        print s % (entry.result_type, "", r)
-        for t, n, r in entry.args:
-            if r is None:
-                r = ""
-            print s % (t, n, r)
-
-
-def main():
-    d = load()
-    dump(d)
-
-
-if __name__ == "__main__":
-    main()
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/sgmlconv/conversion.xml hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/sgmlconv/conversion.xml
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/sgmlconv/conversion.xml	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/sgmlconv/conversion.xml	1970-01-01 01:00:00.000000000 +0100
@@ -1,757 +0,0 @@
-<?xml version="1.0" encoding="iso-8859-1"?>
-<conversion>
-  <!-- Miscellaneous. -->
-  <macro name="declaremodule">
-    <attribute name="id" optional="yes"/>
-    <attribute name="type"/>
-    <attribute name="name"/>
-    </macro>
-  <macro name="modulesynopsis">
-    <content/>
-    </macro>
-  <macro name="platform">
-    <content/>
-    </macro>
-  <macro name="deprecated">
-    <attribute name="version"/>
-    <content/>
-    </macro>
-  <macro name="label">
-    <attribute name="id"/>
-    </macro>
-  <macro name="nodename" outputname="label">
-    <attribute name="id"/>
-    </macro>
-  <macro name="localmoduletable"/>
-  <macro name="manpage">
-    <attribute name="name"/>
-    <attribute name="section"/>
-    </macro>
-  <macro name="module">
-    <content/>
-    </macro>
-  <macro name="moduleauthor">
-    <attribute name="name"/>
-    <attribute name="email"/>
-    </macro>
-  <macro name="citetitle">
-    <attribute name="href" optional="yes"/>
-    <content/>
-    </macro>
-  <macro name="rfc">
-    <attribute name="num"/>
-    </macro>
-  <macro name="sectionauthor" outputname="author">
-    <attribute name="name"/>
-    <attribute name="email"/>
-    </macro>
-  <macro name="author">
-    <attribute name="name"/>
-    </macro>
-  <macro name="authoraddress">
-    <content/>
-    </macro>
-  <macro name="shortversion"/>
-  <macro name="versionadded">
-    <attribute name="version"/>
-    </macro>
-  <!-- This is broken:  we need to re-order the optional and required
-       parameters, making the optional parameter the content for the
-       element.  The processor is not powerful enough to handle this.
-    -->
-  <macro name="versionchanged">
-    <attribute name="how" optional="yes"/>
-    <attribute name="version"/>
-    </macro>
-
-  <!-- Module referencing. -->
-  <macro name="refmodule" outputname="module">
-    <attribute name="" optional="yes"/>
-    <attribute name="link">yes</attribute>
-    <content/>
-    </macro>
-
-  <!-- Information units. -->
-  <!-- C things. -->
-  <environment name="cfuncdesc">
-    <attribute name="type"/>
-    <attribute name="name"/>
-    <child name="args"/>
-    </environment>
-  <environment name="ctypedesc">
-    <attribute name="tag" optional="yes"/>
-    <attribute name="name"/>
-    </environment>
-  <environment name="cvardesc">
-    <attribute name="type"/>
-    <attribute name="name"/>
-    </environment>
-
-  <!-- Python things. -->
-  <macro name="optional">
-    <content/>
-    </macro>
-  <macro name="unspecified"/>
-  <macro name="moreargs"/>
-  <environment name="classdesc">
-    <attribute name="name"/>
-    <child name="args"/>
-    </environment>
-  <environment name="datadesc">
-    <attribute name="name"/>
-    </environment>
-  <macro name="dataline">
-    <attribute name="name"/>
-    </macro>
-  <environment name="excdesc">
-    <attribute name="name"/>
-    </environment>
-
-  <environment name="funcdesc">
-    <attribute name="name"/>
-    <child name="args"/>
-    </environment>
-  <macro name="funcline">
-    <attribute name="name"/>
-    <child name="args"/>
-    </macro>
-  <environment name="funcdescni" outputname="funcdesc">
-    <attribute name="index">no</attribute>
-    <attribute name="name"/>
-    <child name="args"/>
-    </environment>
-  <macro name="funclineni" outputname="funcline">
-    <attribute name="index">no</attribute>
-    <attribute name="name"/>
-    <child name="args"/>
-    </macro>
-
-  <environment name="memberdesc">
-    <attribute name="class" optional="yes"/>
-    <attribute name="name"/>
-    </environment>
-  <environment name="memberdescni" outputname="memberdesc">
-    <attribute name="index">no</attribute>
-    <attribute name="class" optional="yes"/>
-    <attribute name="name"/>
-    </environment>
-
-  <environment name="methoddesc">
-    <attribute name="class" optional="yes"/>
-    <attribute name="name"/>
-    <child name="args"/>
-    </environment>
-  <macro name="methodline">
-    <attribute name="class" optional="yes"/>
-    <attribute name="name"/>
-    <child name="args"/>
-    </macro>
-  <environment name="methoddescni">
-    <attribute name="index">no</attribute>
-    <attribute name="class" optional="yes"/>
-    <attribute name="name"/>
-    <child name="args"/>
-    </environment>
-  <macro name="methodlineni" outputname="methodline">
-    <attribute name="index">no</attribute>
-    <attribute name="class" optional="yes"/>
-    <attribute name="name"/>
-    <child name="args"/>
-    </macro>
-
-  <environment name="opcodedesc">
-    <attribute name="name"/>
-    <attribute name="var"/>
-    </environment>
-
-  <!-- "See also:" sections. -->
-  <macro name="seemodule">
-    <attribute name="ref" optional="yes"/>
-    <attribute name="name"/>
-    <child name="description"/>
-    </macro>
-  <macro name="seepep">
-    <attribute name="number"/>
-    <child name="title"/>
-    <child name="description"/>
-    </macro>
-  <macro name="seerfc">
-    <attribute name="number"/>
-    <child name="title"/>
-    <child name="description"/>
-    </macro>
-  <macro name="seetext">
-    <child name="description"/>
-    </macro>
-  <macro name="seetitle">
-    <attribute name="href" optional="yes"/>
-    <child name="title"/>
-    <child name="description"/>
-    </macro>
-  <macro name="seeurl">
-    <attribute name="href"/>
-    <child name="description"/>
-    </macro>
-
-  <!-- Index-generating markup. -->
-  <macro name="index" outputname="indexterm">
-    <attribute name="term1"/>
-    </macro>
-  <macro name="indexii" outputname="indexterm">
-    <attribute name="term1"/>
-    <attribute name="term2"/>
-    </macro>
-  <macro name="indexiii" outputname="indexterm">
-    <attribute name="term1"/>
-    <attribute name="term2"/>
-    <attribute name="term3"/>
-    </macro>
-  <macro name="indexiv" outputname="indexterm">
-    <attribute name="term1"/>
-    <attribute name="term2"/>
-    <attribute name="term3"/>
-    <attribute name="term4"/>
-    </macro>
-
-  <macro name="ttindex" outputname="indexterm">
-    <attribute name="style">tt</attribute>
-    <attribute name="term1"/>
-    </macro>
-
-  <macro name="refmodindex">
-    <attribute name="module"/>
-    </macro>
-  <macro name="stmodindex">
-    <attribute name="module"/>
-    </macro>
-  <macro name="refbimodindex" outputname="refmodindex">
-    <attribute name="module"/>
-    </macro>
-  <macro name="refexmodindex" outputname="refmodindex">
-    <attribute name="module"/>
-    </macro>
-  <macro name="refstmodindex" outputname="refmodindex">
-    <attribute name="module"/>
-    </macro>
-
-  <macro name="bifuncindex">
-    <attribute name="name"/>
-    </macro>
-  <macro name="exindex">
-    <attribute name="name"/>
-    </macro>
-  <macro name="obindex">
-    <attribute name="name"/>
-    </macro>
-  <macro name="kwindex">
-    <attribute name="name"/>
-    </macro>
-  <macro name="opindex">
-    <attribute name="type"/>
-    </macro>
-  <macro name="stindex">
-    <attribute name="type"/>
-    </macro>
-  <macro name="withsubitem">
-    <attribute name="text"/>
-    <content/>
-    </macro>
-  <macro name="setindexsubitem">
-    <attribute name="text"/>
-    </macro>
-
-  <!-- Entity management. -->
-  <macro name="include">
-    <attribute name="source"/>
-    </macro>
-  <macro name="input">
-    <attribute name="source"/>
-    </macro>
-
-  <!-- Large-scale document structure. -->
-  <macro name="documentclass">
-    <attribute name="classname"/>
-    </macro>
-
-  <macro name="usepackage">
-    <attribute name="options" optional="yes"/>
-    <attribute name="pkg"/>
-    </macro>
-
-  <environment name="document"
-               endcloses="chapter chapter* section section*
-                          subsection subsection*
-                          subsubsection subsubsection*
-                          paragraph paragraph* subparagraph subparagraph*"/>
-
-  <macro name="chapter"
-         closes="chapter chapter* section section* subsection subsection*
-                 subsubsection subsubsection*
-                 paragraph paragraph* subparagraph subparagraph*">
-    <text>
-</text>
-    <child name="title"/>
-    <content implied="yes"/>
-    </macro>
-  <macro name="chapter*" outputname="chapter"
-         closes="chapter chapter* section section* subsection subsection*
-                 subsubsection subsubsection*
-                 paragraph paragraph* subparagraph subparagraph*">
-    <attribute name="numbered">no</attribute>
-    <text>
-</text>
-    <child name="title"/>
-    <content implied="yes"/>
-    </macro>
-
-  <macro name="section"
-         closes="section section* subsection subsection*
-                 subsubsection subsubsection*
-                 paragraph paragraph* subparagraph subparagraph*">
-    <text>
-</text>
-    <child name="title"/>
-    <content implied="yes"/>
-    </macro>
-  <macro name="section*" outputname="section"
-         closes="section section* subsection subsection*
-                 subsubsection subsubsection*
-                 paragraph paragraph* subparagraph subparagraph*">
-    <attribute name="numbered">no</attribute>
-    <text>
-</text>
-    <child name="title"/>
-    <content implied="yes"/>
-    </macro>
-
-  <macro name="subsection"
-         closes="subsection subsection* subsubsection subsubsection*
-                 paragraph paragraph* subparagraph subparagraph*">
-    <text>
-</text>
-    <child name="title"/>
-    <content implied="yes"/>
-    </macro>
-  <macro name="subsection*" outputname="subsection"
-         closes="subsection subsection* subsubsection subsubsection*
-                 paragraph paragraph* subparagraph subparagraph*">
-    <attribute name="numbered">no</attribute>
-    <text>
-</text>
-    <child name="title"/>
-    <content implied="yes"/>
-    </macro>
-
-  <macro name="subsubsection"
-         closes="subsubsection subsubsection*
-                 paragraph paragraph* subparagraph subparagraph*">
-    <text>
-</text>
-    <child name="title"/>
-    <content implied="yes"/>
-    </macro>
-  <macro name="subsubsection*" outputname="subsubsection"
-         closes="subsubsection subsubsection*
-                 paragraph paragraph* subparagraph subparagraph*">
-    <attribute name="numbered">no</attribute>
-    <text>
-</text>
-    <child name="title"/>
-    <content implied="yes"/>
-    </macro>
-
-  <macro name="paragraph"
-         closes="paragraph paragraph* subparagraph subparagraph*">
-    <text>
-</text>
-    <child name="title"/>
-    <content implied="yes"/>
-    </macro>
-  <macro name="paragraph*" outputname="paragraph"
-         closes="paragraph paragraph* subparagraph subparagraph*">
-    <attribute name="numbered">no</attribute>
-    <text>
-</text>
-    <child name="title"/>
-    <content implied="yes"/>
-    </macro>
-
-  <macro name="subparagraph"
-         closes="subparagraph subparagraph*">
-    <text>
-</text>
-    <child name="title"/>
-    <content implied="yes"/>
-    </macro>
-  <macro name="subparagraph*" outputname="subparagraph"
-         closes="subparagraph subparagraph*">
-    <attribute name="numbered">no</attribute>
-    <text>
-</text>
-    <child name="title"/>
-    <content implied="yes"/>
-    </macro>
-  <macro name="title">
-    <content/>
-    </macro>
-
-  <macro name="appendix" outputname="back-matter"
-         closes="chapter chapter* section subsection subsubsection
-                 paragraph subparagraph"/>
-
-  <environment name="list"
-               endcloses="item">
-    <attribute name="bullet"/>
-    <attribute name="init"/>
-    </environment>
-  <macro name="item" closes="item">
-    <child name="leader" optional="yes"/>
-    <content implied="yes"/>
-    </macro>
-
-  <macro name="ref">
-    <attribute name="ref"/>
-    </macro>
-
-  <environment name="description" outputname="descriptionlist"
-               endcloses="item"/>
-
-  <environment name="enumerate" outputname="enumeration"
-               endcloses="item"/>
-
-  <environment name="fulllineitems"
-               endcloses="item"/>
-
-  <environment name="itemize"
-               endcloses="item"/>
-
-  <environment name="definitions" outputname="definitionlist"
-               encloses="term"/>
-  <macro name="term" closes="definition">
-    <!-- not really optional, but uses the [] syntax -->
-    <child name="term" optional="yes"/>
-    <child name="definition" implied="yes"/>
-    </macro>
-
-  <environment name="alltt" outputname="verbatim"/>
-  <environment name="comment" verbatim="yes"/>
-  <environment name="verbatim" verbatim="yes"/>
-  <environment name="verbatim*" verbatim="yes">
-    <!-- not used anywhere, but it's a standard LaTeXism -->
-    <attribute name="spaces">visible</attribute>
-    </environment>
-
-  <!-- Table markup. -->
-  <macro name="hline"/>
-  <environment name="tableii" outputname="table">
-    <attribute name="cols">2</attribute>
-    <attribute name="colspec"/>
-    <attribute name="style"/>
-    <child name="entry"/>
-    <text>
-         </text>
-    <child name="entry"/>
-    </environment>
-  <environment name="longtableii" outputname="table">
-    <attribute name="cols">2</attribute>
-    <attribute name="colspec"/>
-    <attribute name="style"/>
-    <child name="entry"/>
-    <text>
-         </text>
-    <child name="entry"/>
-    </environment>
-  <macro name="lineii" outputname="row">
-    <child name="entry"/>
-    <text>
-         </text>
-    <child name="entry"/>
-    </macro>
-
-  <environment name="tableiii" outputname="table">
-    <attribute name="cols">3</attribute>
-    <attribute name="colspec"/>
-    <attribute name="style"/>
-    <child name="entry"/>
-    <text>
-         </text>
-    <child name="entry"/>
-    <text>
-         </text>
-    <child name="entry"/>
-    </environment>
-  <environment name="longtableiii" outputname="table">
-    <attribute name="cols">3</attribute>
-    <attribute name="colspec"/>
-    <attribute name="style"/>
-    <child name="entry"/>
-    <text>
-         </text>
-    <child name="entry"/>
-    <text>
-         </text>
-    <child name="entry"/>
-    </environment>
-  <macro name="lineiii" outputname="row">
-    <child name="entry"/>
-    <text>
-         </text>
-    <child name="entry"/>
-    <text>
-         </text>
-    <child name="entry"/>
-    </macro>
-
-  <environment name="tableiv" outputname="table">
-    <attribute name="cols">4</attribute>
-    <attribute name="colspec"/>
-    <attribute name="style"/>
-    <child name="entry"/>
-    <text>
-         </text>
-    <child name="entry"/>
-    <text>
-         </text>
-    <child name="entry"/>
-    <text>
-         </text>
-    <child name="entry"/>
-    </environment>
-  <environment name="longtableiv" outputname="table">
-    <attribute name="cols">4</attribute>
-    <attribute name="colspec"/>
-    <attribute name="style"/>
-    <child name="entry"/>
-    <text>
-         </text>
-    <child name="entry"/>
-    <text>
-         </text>
-    <child name="entry"/>
-    <text>
-         </text>
-    <child name="entry"/>
-    </environment>
-  <macro name="lineiv" outputname="row">
-    <child name="entry"/>
-    <text>
-         </text>
-    <child name="entry"/>
-    <text>
-         </text>
-    <child name="entry"/>
-    <text>
-         </text>
-    <child name="entry"/>
-    </macro>
-
-  <!-- These are handled at a later translation stage, at least for now. -->
-  <macro name="Cpp" outputname="">
-    <text>C++</text>
-    </macro>
-  <macro name="geq" outputname="">
-    <entityref name="geq"/>
-    </macro>
-  <macro name="LaTeX" outputname="">
-    <text>LaTeX</text>
-    </macro>
-  <macro name="ldots" outputname="">
-    <text>...</text>
-    </macro>
-  <macro name="leq" outputname="">
-    <entityref name="leq"/>
-    </macro>
-  <macro name="TeX" outputname="">
-    <text>TeX</text>
-    </macro>
-  <macro name="version"/>
-
-  <!-- Distutils things. -->
-  <macro name="command">
-    <content/>
-    </macro>
-  <macro name="option">
-    <content/>
-    </macro>
-  <macro name="filevar" outputname="var">
-    <content/>
-    </macro>
-  <macro name="XXX" outputname="editorial-comment">
-    <content/>
-    </macro>
-
-  <!-- Misc. -->
-  <macro name="emph">
-    <content/>
-    </macro>
-  <macro name="strong">
-    <content/>
-    </macro>
-  <macro name="textrm">
-    <content/>
-    </macro>
-  <macro name="texttt">
-    <content/>
-    </macro>
-  <macro name="code">
-    <content/>
-    </macro>
-  <macro name="exception">
-    <content/>
-    </macro>
-  <macro name="keyword">
-    <content/>
-    </macro>
-  <macro name="samp">
-    <content/>
-    </macro>
-  <macro name="class">
-    <content/>
-    </macro>
-  <macro name="cdata">
-    <content/>
-    </macro>
-  <macro name="cfunction">
-    <content/>
-    </macro>
-  <macro name="ctype">
-    <content/>
-    </macro>
-  <macro name="pytype">
-    <content/>
-    </macro>
-  <macro name="character">
-    <content/>
-    </macro>
-  <macro name="constant">
-    <content/>
-    </macro>
-  <macro name="envvar" outputname="envar">
-    <content/>
-    </macro>
-  <macro name="file" outputname="filename">
-    <content/>
-    </macro>
-  <macro name="filenq" outputname="filename">
-    <attribute name="quote">no</attribute>
-    <content/>
-    </macro>
-  <macro name="function">
-    <content/>
-    </macro>
-  <macro name="kbd">
-    <content/>
-    </macro>
-  <macro name="makevar">
-    <content/>
-    </macro>
-  <macro name="method">
-    <content/>
-    </macro>
-  <macro name="member">
-    <content/>
-    </macro>
-  <macro name="mimetype">
-    <content/>
-    </macro>
-  <macro name="newsgroup">
-    <content/>
-    </macro>
-  <macro name="program" outputname="command">
-    <content/>
-    </macro>
-  <macro name="programopt" outputname="option">
-    <content/>
-    </macro>
-  <macro name="longprogramopt" outputname="longoption">
-    <content/>
-    </macro>
-  <macro name="regexp">
-    <content/>
-    </macro>
-  <macro name="var">
-    <content/>
-    </macro>
-  <macro name="email">
-    <content/>
-    </macro>
-  <macro name="url">
-    <content/>
-    </macro>
-  <macro name="footnote">
-    <content/>
-    </macro>
-  <macro name="dfn" outputname="definedterm">
-    <content/>
-    </macro>
-
-  <macro name="mbox">
-    <content/>
-    </macro>
-
-  <!-- minimal math stuff to get by -->
-  <macro name="pi"/>
-  <macro name="sqrt">
-    <content/>
-    </macro>
-  <macro name="frac" outputname="fraction">
-    <child name="numerator"/>
-    <child name="denominator"/>
-    </macro>
-  <macro name="sum">
-    <content/>
-    </macro>
-
-  <!-- Conversions to text; perhaps could be different?  There's -->
-  <!-- no way for a style sheet to work with these this way.	 -->
-  <macro name="ABC" outputname="">
-    <text>ABC</text>
-    </macro>
-  <macro name="ASCII" outputname="">
-    <text>ASCII</text>
-    </macro>
-  <macro name="C" outputname="">
-    <text>C</text>
-    </macro>
-  <macro name="EOF" outputname="">
-    <text>EOF</text>
-    </macro>
-  <macro name="e" outputname="">
-    <text>\</text>
-    </macro>
-  <macro name="NULL" outputname="constant">
-    <text>NULL</text>
-    </macro>
-  <macro name="POSIX" outputname="">
-    <text>POSIX</text>
-    </macro>
-  <macro name="UNIX" outputname="">
-    <text>Unix</text>
-    </macro>
-  <macro name="textasciitilde" outputname="">
-    <text>~</text>
-    </macro>
-
-  <!-- These will end up disappearing as well! -->
-  <macro name="catcode" outputname=""/>
-  <macro name="fi" outputname=""/>
-  <macro name="ifhtml" outputname=""/>
-  <macro name="indexname" outputname=""/>
-  <macro name="labelwidth" outputname=""/>
-  <macro name="large" outputname=""/>
-  <macro name="leftmargin" outputname=""/>
-  <macro name="makeindex" outputname=""/>
-  <macro name="makemodindex" outputname=""/>
-  <macro name="maketitle" outputname=""/>
-  <macro name="noindent" outputname=""/>
-  <macro name="protect" outputname=""/>
-  <macro name="renewcommand">
-    <attribute name="macro"/>
-    <attribute name="nargs" optional="yes"/>
-    <content/>
-    </macro>
-  <macro name="tableofcontents" outputname=""/>
-  <macro name="vspace">
-    <attribute name="size"/>
-    </macro>
-</conversion>
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/sgmlconv/docfixer.py hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/sgmlconv/docfixer.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/sgmlconv/docfixer.py	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/sgmlconv/docfixer.py	1970-01-01 01:00:00.000000000 +0100
@@ -1,1033 +0,0 @@
-#! /usr/bin/env python
-
-"""Perform massive transformations on a document tree created from the LaTeX
-of the Python documentation, and dump the ESIS data for the transformed tree.
-"""
-
-
-import errno
-import esistools
-import re
-import string
-import sys
-import xml.dom
-import xml.dom.minidom
-
-ELEMENT = xml.dom.Node.ELEMENT_NODE
-ENTITY_REFERENCE = xml.dom.Node.ENTITY_REFERENCE_NODE
-TEXT = xml.dom.Node.TEXT_NODE
-
-
-class ConversionError(Exception):
-    pass
-
-
-ewrite = sys.stderr.write
-try:
-    # We can only do this trick on Unix (if tput is on $PATH)!
-    if sys.platform != "posix" or not sys.stderr.isatty():
-        raise ImportError
-    import commands
-except ImportError:
-    bwrite = ewrite
-else:
-    def bwrite(s, BOLDON=commands.getoutput("tput bold"),
-               BOLDOFF=commands.getoutput("tput sgr0")):
-        ewrite("%s%s%s" % (BOLDON, s, BOLDOFF))
-
-
-PARA_ELEMENT = "para"
-
-DEBUG_PARA_FIXER = 0
-
-if DEBUG_PARA_FIXER:
-    def para_msg(s):
-        ewrite("*** %s\n" % s)
-else:
-    def para_msg(s):
-        pass
-
-
-def get_first_element(doc, gi):
-    for n in doc.childNodes:
-        if n.nodeName == gi:
-            return n
-
-def extract_first_element(doc, gi):
-    node = get_first_element(doc, gi)
-    if node is not None:
-        doc.removeChild(node)
-    return node
-
-
-def get_documentElement(node):
-    result = None
-    for child in node.childNodes:
-        if child.nodeType == ELEMENT:
-            result = child
-    return result
-
-
-def set_tagName(elem, gi):
-    elem.nodeName = elem.tagName = gi
-
-
-def find_all_elements(doc, gi):
-    nodes = []
-    if doc.nodeName == gi:
-        nodes.append(doc)
-    for child in doc.childNodes:
-        if child.nodeType == ELEMENT:
-            if child.tagName == gi:
-                nodes.append(child)
-            for node in child.getElementsByTagName(gi):
-                nodes.append(node)
-    return nodes
-
-def find_all_child_elements(doc, gi):
-    nodes = []
-    for child in doc.childNodes:
-        if child.nodeName == gi:
-            nodes.append(child)
-    return nodes
-
-
-def find_all_elements_from_set(doc, gi_set):
-    return __find_all_elements_from_set(doc, gi_set, [])
-
-def __find_all_elements_from_set(doc, gi_set, nodes):
-    if doc.nodeName in gi_set:
-        nodes.append(doc)
-    for child in doc.childNodes:
-        if child.nodeType == ELEMENT:
-            __find_all_elements_from_set(child, gi_set, nodes)
-    return nodes
-
-
-def simplify(doc, fragment):
-    # Try to rationalize the document a bit, since these things are simply
-    # not valid SGML/XML documents as they stand, and need a little work.
-    documentclass = "document"
-    inputs = []
-    node = extract_first_element(fragment, "documentclass")
-    if node is not None:
-        documentclass = node.getAttribute("classname")
-    node = extract_first_element(fragment, "title")
-    if node is not None:
-        inputs.append(node)
-    # update the name of the root element
-    node = get_first_element(fragment, "document")
-    if node is not None:
-        set_tagName(node, documentclass)
-    while 1:
-        node = extract_first_element(fragment, "input")
-        if node is None:
-            break
-        inputs.append(node)
-    if inputs:
-        docelem = get_documentElement(fragment)
-        inputs.reverse()
-        for node in inputs:
-            text = doc.createTextNode("\n")
-            docelem.insertBefore(text, docelem.firstChild)
-            docelem.insertBefore(node, text)
-        docelem.insertBefore(doc.createTextNode("\n"), docelem.firstChild)
-    while fragment.firstChild and fragment.firstChild.nodeType == TEXT:
-        fragment.removeChild(fragment.firstChild)
-
-
-def cleanup_root_text(doc):
-    discards = []
-    skip = 0
-    for n in doc.childNodes:
-        prevskip = skip
-        skip = 0
-        if n.nodeType == TEXT and not prevskip:
-            discards.append(n)
-        elif n.nodeName == "COMMENT":
-            skip = 1
-    for node in discards:
-        doc.removeChild(node)
-
-
-DESCRIPTOR_ELEMENTS = (
-    "cfuncdesc", "cvardesc", "ctypedesc",
-    "classdesc", "memberdesc", "memberdescni", "methoddesc", "methoddescni",
-    "excdesc", "funcdesc", "funcdescni", "opcodedesc",
-    "datadesc", "datadescni",
-    )
-
-def fixup_descriptors(doc, fragment):
-    sections = find_all_elements(fragment, "section")
-    for section in sections:
-        find_and_fix_descriptors(doc, section)
-
-
-def find_and_fix_descriptors(doc, container):
-    children = container.childNodes
-    for child in children:
-        if child.nodeType == ELEMENT:
-            tagName = child.tagName
-            if tagName in DESCRIPTOR_ELEMENTS:
-                rewrite_descriptor(doc, child)
-            elif tagName == "subsection":
-                find_and_fix_descriptors(doc, child)
-
-
-def rewrite_descriptor(doc, descriptor):
-    #
-    # Do these things:
-    #   1. Add an "index='no'" attribute to the element if the tagName
-    #      ends in 'ni', removing the 'ni' from the name.
-    #   2. Create a <signature> from the name attribute
-    #   2a.Create an <args> if it appears to be available.
-    #   3. Create additional <signature>s from <*line{,ni}> elements,
-    #      if found.
-    #   4. If a <versionadded> is found, move it to an attribute on the
-    #      descriptor.
-    #   5. Move remaining child nodes to a <description> element.
-    #   6. Put it back together.
-    #
-    # 1.
-    descname = descriptor.tagName
-    index = 1
-    if descname[-2:] == "ni":
-        descname = descname[:-2]
-        descriptor.setAttribute("index", "no")
-        set_tagName(descriptor, descname)
-        index = 0
-    desctype = descname[:-4] # remove 'desc'
-    linename = desctype + "line"
-    if not index:
-        linename = linename + "ni"
-    # 2.
-    signature = doc.createElement("signature")
-    name = doc.createElement("name")
-    signature.appendChild(doc.createTextNode("\n    "))
-    signature.appendChild(name)
-    name.appendChild(doc.createTextNode(descriptor.getAttribute("name")))
-    descriptor.removeAttribute("name")
-    # 2a.
-    if descriptor.hasAttribute("var"):
-        if descname != "opcodedesc":
-            raise RuntimeError, \
-                  "got 'var' attribute on descriptor other than opcodedesc"
-        variable = descriptor.getAttribute("var")
-        if variable:
-            args = doc.createElement("args")
-            args.appendChild(doc.createTextNode(variable))
-            signature.appendChild(doc.createTextNode("\n    "))
-            signature.appendChild(args)
-        descriptor.removeAttribute("var")
-    newchildren = [signature]
-    children = descriptor.childNodes
-    pos = skip_leading_nodes(children)
-    if pos < len(children):
-        child = children[pos]
-        if child.nodeName == "args":
-            # move <args> to <signature>, or remove if empty:
-            child.parentNode.removeChild(child)
-            if len(child.childNodes):
-                signature.appendChild(doc.createTextNode("\n    "))
-                signature.appendChild(child)
-    signature.appendChild(doc.createTextNode("\n  "))
-    # 3, 4.
-    pos = skip_leading_nodes(children, pos)
-    while pos < len(children) \
-          and children[pos].nodeName in (linename, "versionadded"):
-        if children[pos].tagName == linename:
-            # this is really a supplemental signature, create <signature>
-            oldchild = children[pos].cloneNode(1)
-            try:
-                sig = methodline_to_signature(doc, children[pos])
-            except KeyError:
-                print oldchild.toxml()
-                raise
-            newchildren.append(sig)
-        else:
-            # <versionadded added=...>
-            descriptor.setAttribute(
-                "added", children[pos].getAttribute("version"))
-        pos = skip_leading_nodes(children, pos + 1)
-    # 5.
-    description = doc.createElement("description")
-    description.appendChild(doc.createTextNode("\n"))
-    newchildren.append(description)
-    move_children(descriptor, description, pos)
-    last = description.childNodes[-1]
-    if last.nodeType == TEXT:
-        last.data = string.rstrip(last.data) + "\n  "
-    # 6.
-    # should have nothing but whitespace and signature lines in <descriptor>;
-    # discard them
-    while descriptor.childNodes:
-        descriptor.removeChild(descriptor.childNodes[0])
-    for node in newchildren:
-        descriptor.appendChild(doc.createTextNode("\n  "))
-        descriptor.appendChild(node)
-    descriptor.appendChild(doc.createTextNode("\n"))
-
-
-def methodline_to_signature(doc, methodline):
-    signature = doc.createElement("signature")
-    signature.appendChild(doc.createTextNode("\n    "))
-    name = doc.createElement("name")
-    name.appendChild(doc.createTextNode(methodline.getAttribute("name")))
-    methodline.removeAttribute("name")
-    signature.appendChild(name)
-    if len(methodline.childNodes):
-        args = doc.createElement("args")
-        signature.appendChild(doc.createTextNode("\n    "))
-        signature.appendChild(args)
-        move_children(methodline, args)
-    signature.appendChild(doc.createTextNode("\n  "))
-    return signature
-
-
-def move_children(origin, dest, start=0):
-    children = origin.childNodes
-    while start < len(children):
-        node = children[start]
-        origin.removeChild(node)
-        dest.appendChild(node)
-
-
-def handle_appendix(doc, fragment):
-    # must be called after simplfy() if document is multi-rooted to begin with
-    docelem = get_documentElement(fragment)
-    toplevel = docelem.tagName == "manual" and "chapter" or "section"
-    appendices = 0
-    nodes = []
-    for node in docelem.childNodes:
-        if appendices:
-            nodes.append(node)
-        elif node.nodeType == ELEMENT:
-            appnodes = node.getElementsByTagName("appendix")
-            if appnodes:
-                appendices = 1
-                parent = appnodes[0].parentNode
-                parent.removeChild(appnodes[0])
-                parent.normalize()
-    if nodes:
-        map(docelem.removeChild, nodes)
-        docelem.appendChild(doc.createTextNode("\n\n\n"))
-        back = doc.createElement("back-matter")
-        docelem.appendChild(back)
-        back.appendChild(doc.createTextNode("\n"))
-        while nodes and nodes[0].nodeType == TEXT \
-              and not string.strip(nodes[0].data):
-            del nodes[0]
-        map(back.appendChild, nodes)
-        docelem.appendChild(doc.createTextNode("\n"))
-
-
-def handle_labels(doc, fragment):
-    for label in find_all_elements(fragment, "label"):
-        id = label.getAttribute("id")
-        if not id:
-            continue
-        parent = label.parentNode
-        parentTagName = parent.tagName
-        if parentTagName == "title":
-            parent.parentNode.setAttribute("id", id)
-        else:
-            parent.setAttribute("id", id)
-        # now, remove <label id="..."/> from parent:
-        parent.removeChild(label)
-        if parentTagName == "title":
-            parent.normalize()
-            children = parent.childNodes
-            if children[-1].nodeType == TEXT:
-                children[-1].data = string.rstrip(children[-1].data)
-
-
-def fixup_trailing_whitespace(doc, wsmap):
-    queue = [doc]
-    while queue:
-        node = queue[0]
-        del queue[0]
-        if wsmap.has_key(node.nodeName):
-            ws = wsmap[node.tagName]
-            children = node.childNodes
-            children.reverse()
-            if children[0].nodeType == TEXT:
-                data = string.rstrip(children[0].data) + ws
-                children[0].data = data
-            children.reverse()
-            # hack to get the title in place:
-            if node.tagName == "title" \
-               and node.parentNode.firstChild.nodeType == ELEMENT:
-                node.parentNode.insertBefore(doc.createText("\n  "),
-                                             node.parentNode.firstChild)
-        for child in node.childNodes:
-            if child.nodeType == ELEMENT:
-                queue.append(child)
-
-
-def normalize(doc):
-    for node in doc.childNodes:
-        if node.nodeType == ELEMENT:
-            node.normalize()
-
-
-def cleanup_trailing_parens(doc, element_names):
-    d = {}
-    for gi in element_names:
-        d[gi] = gi
-    rewrite_element = d.has_key
-    queue = []
-    for node in doc.childNodes:
-        if node.nodeType == ELEMENT:
-            queue.append(node)
-    while queue:
-        node = queue[0]
-        del queue[0]
-        if rewrite_element(node.tagName):
-            children = node.childNodes
-            if len(children) == 1 \
-               and children[0].nodeType == TEXT:
-                data = children[0].data
-                if data[-2:] == "()":
-                    children[0].data = data[:-2]
-        else:
-            for child in node.childNodes:
-                if child.nodeType == ELEMENT:
-                    queue.append(child)
-
-
-def contents_match(left, right):
-    left_children = left.childNodes
-    right_children = right.childNodes
-    if len(left_children) != len(right_children):
-        return 0
-    for l, r in map(None, left_children, right_children):
-        nodeType = l.nodeType
-        if nodeType != r.nodeType:
-            return 0
-        if nodeType == ELEMENT:
-            if l.tagName != r.tagName:
-                return 0
-            # should check attributes, but that's not a problem here
-            if not contents_match(l, r):
-                return 0
-        elif nodeType == TEXT:
-            if l.data != r.data:
-                return 0
-        else:
-            # not quite right, but good enough
-            return 0
-    return 1
-
-
-def create_module_info(doc, section):
-    # Heavy.
-    node = extract_first_element(section, "modulesynopsis")
-    if node is None:
-        return
-    set_tagName(node, "synopsis")
-    lastchild = node.childNodes[-1]
-    if lastchild.nodeType == TEXT \
-       and lastchild.data[-1:] == ".":
-        lastchild.data = lastchild.data[:-1]
-    modauthor = extract_first_element(section, "moduleauthor")
-    if modauthor:
-        set_tagName(modauthor, "author")
-        modauthor.appendChild(doc.createTextNode(
-            modauthor.getAttribute("name")))
-        modauthor.removeAttribute("name")
-    platform = extract_first_element(section, "platform")
-    if section.tagName == "section":
-        modinfo_pos = 2
-        modinfo = doc.createElement("moduleinfo")
-        moddecl = extract_first_element(section, "declaremodule")
-        name = None
-        if moddecl:
-            modinfo.appendChild(doc.createTextNode("\n    "))
-            name = moddecl.attributes["name"].value
-            namenode = doc.createElement("name")
-            namenode.appendChild(doc.createTextNode(name))
-            modinfo.appendChild(namenode)
-            type = moddecl.attributes.get("type")
-            if type:
-                type = type.value
-                modinfo.appendChild(doc.createTextNode("\n    "))
-                typenode = doc.createElement("type")
-                typenode.appendChild(doc.createTextNode(type))
-                modinfo.appendChild(typenode)
-        versionadded = extract_first_element(section, "versionadded")
-        if versionadded:
-            modinfo.setAttribute("added", versionadded.getAttribute("version"))
-        title = get_first_element(section, "title")
-        if title:
-            children = title.childNodes
-            if len(children) >= 2 \
-               and children[0].nodeName == "module" \
-               and children[0].childNodes[0].data == name:
-                # this is it; morph the <title> into <short-synopsis>
-                first_data = children[1]
-                if first_data.data[:4] == " ---":
-                    first_data.data = string.lstrip(first_data.data[4:])
-                set_tagName(title, "short-synopsis")
-                if children[-1].nodeType == TEXT \
-                   and children[-1].data[-1:] == ".":
-                    children[-1].data = children[-1].data[:-1]
-                section.removeChild(title)
-                section.removeChild(section.childNodes[0])
-                title.removeChild(children[0])
-                modinfo_pos = 0
-            else:
-                ewrite("module name in title doesn't match"
-                       " <declaremodule/>; no <short-synopsis/>\n")
-        else:
-            ewrite("Unexpected condition: <section/> without <title/>\n")
-        modinfo.appendChild(doc.createTextNode("\n    "))
-        modinfo.appendChild(node)
-        if title and not contents_match(title, node):
-            # The short synopsis is actually different,
-            # and needs to be stored:
-            modinfo.appendChild(doc.createTextNode("\n    "))
-            modinfo.appendChild(title)
-        if modauthor:
-            modinfo.appendChild(doc.createTextNode("\n    "))
-            modinfo.appendChild(modauthor)
-        if platform:
-            modinfo.appendChild(doc.createTextNode("\n    "))
-            modinfo.appendChild(platform)
-        modinfo.appendChild(doc.createTextNode("\n  "))
-        section.insertBefore(modinfo, section.childNodes[modinfo_pos])
-        section.insertBefore(doc.createTextNode("\n  "), modinfo)
-        #
-        # The rest of this removes extra newlines from where we cut out
-        # a lot of elements.  A lot of code for minimal value, but keeps
-        # keeps the generated *ML from being too funny looking.
-        #
-        section.normalize()
-        children = section.childNodes
-        for i in range(len(children)):
-            node = children[i]
-            if node.nodeName == "moduleinfo":
-                nextnode = children[i+1]
-                if nextnode.nodeType == TEXT:
-                    data = nextnode.data
-                    if len(string.lstrip(data)) < (len(data) - 4):
-                        nextnode.data = "\n\n\n" + string.lstrip(data)
-
-
-def cleanup_synopses(doc, fragment):
-    for node in find_all_elements(fragment, "section"):
-        create_module_info(doc, node)
-
-
-def fixup_table_structures(doc, fragment):
-    for table in find_all_elements(fragment, "table"):
-        fixup_table(doc, table)
-
-
-def fixup_table(doc, table):
-    # create the table head
-    thead = doc.createElement("thead")
-    row = doc.createElement("row")
-    move_elements_by_name(doc, table, row, "entry")
-    thead.appendChild(doc.createTextNode("\n    "))
-    thead.appendChild(row)
-    thead.appendChild(doc.createTextNode("\n    "))
-    # create the table body
-    tbody = doc.createElement("tbody")
-    prev_row = None
-    last_was_hline = 0
-    children = table.childNodes
-    for child in children:
-        if child.nodeType == ELEMENT:
-            tagName = child.tagName
-            if tagName == "hline" and prev_row is not None:
-                prev_row.setAttribute("rowsep", "1")
-            elif tagName == "row":
-                prev_row = child
-    # save the rows:
-    tbody.appendChild(doc.createTextNode("\n    "))
-    move_elements_by_name(doc, table, tbody, "row", sep="\n    ")
-    # and toss the rest:
-    while children:
-        child = children[0]
-        nodeType = child.nodeType
-        if nodeType == TEXT:
-            if string.strip(child.data):
-                raise ConversionError("unexpected free data in <%s>: %r"
-                                      % (table.tagName, child.data))
-            table.removeChild(child)
-            continue
-        if nodeType == ELEMENT:
-            if child.tagName != "hline":
-                raise ConversionError(
-                    "unexpected <%s> in table" % child.tagName)
-            table.removeChild(child)
-            continue
-        raise ConversionError(
-            "unexpected %s node in table" % child.__class__.__name__)
-    # nothing left in the <table>; add the <thead> and <tbody>
-    tgroup = doc.createElement("tgroup")
-    tgroup.appendChild(doc.createTextNode("\n  "))
-    tgroup.appendChild(thead)
-    tgroup.appendChild(doc.createTextNode("\n  "))
-    tgroup.appendChild(tbody)
-    tgroup.appendChild(doc.createTextNode("\n  "))
-    table.appendChild(tgroup)
-    # now make the <entry>s look nice:
-    for row in table.getElementsByTagName("row"):
-        fixup_row(doc, row)
-
-
-def fixup_row(doc, row):
-    entries = []
-    map(entries.append, row.childNodes[1:])
-    for entry in entries:
-        row.insertBefore(doc.createTextNode("\n         "), entry)
-#    row.appendChild(doc.createTextNode("\n      "))
-
-
-def move_elements_by_name(doc, source, dest, name, sep=None):
-    nodes = []
-    for child in source.childNodes:
-        if child.nodeName == name:
-            nodes.append(child)
-    for node in nodes:
-        source.removeChild(node)
-        dest.appendChild(node)
-        if sep:
-            dest.appendChild(doc.createTextNode(sep))
-
-
-RECURSE_INTO_PARA_CONTAINERS = (
-    "chapter", "abstract", "enumerate",
-    "section", "subsection", "subsubsection",
-    "paragraph", "subparagraph", "back-matter",
-    "howto", "manual",
-    "item", "itemize", "fulllineitems", "enumeration", "descriptionlist",
-    "definitionlist", "definition",
-    )
-
-PARA_LEVEL_ELEMENTS = (
-    "moduleinfo", "title", "verbatim", "enumerate", "item",
-    "interpreter-session", "back-matter", "interactive-session",
-    "opcodedesc", "classdesc", "datadesc",
-    "funcdesc", "methoddesc", "excdesc", "memberdesc", "membderdescni",
-    "funcdescni", "methoddescni", "excdescni",
-    "tableii", "tableiii", "tableiv", "localmoduletable",
-    "sectionauthor", "seealso", "itemize",
-    # include <para>, so we can just do it again to get subsequent paras:
-    PARA_ELEMENT,
-    )
-
-PARA_LEVEL_PRECEEDERS = (
-    "setindexsubitem", "author",
-    "stindex", "obindex", "COMMENT", "label", "input", "title",
-    "versionadded", "versionchanged", "declaremodule", "modulesynopsis",
-    "moduleauthor", "indexterm", "leader",
-    )
-
-
-def fixup_paras(doc, fragment):
-    for child in fragment.childNodes:
-        if child.nodeName in RECURSE_INTO_PARA_CONTAINERS:
-            fixup_paras_helper(doc, child)
-    descriptions = find_all_elements(fragment, "description")
-    for description in descriptions:
-        fixup_paras_helper(doc, description)
-
-
-def fixup_paras_helper(doc, container, depth=0):
-    # document is already normalized
-    children = container.childNodes
-    start = skip_leading_nodes(children)
-    while len(children) > start:
-        if children[start].nodeName in RECURSE_INTO_PARA_CONTAINERS:
-            # Something to recurse into:
-            fixup_paras_helper(doc, children[start])
-        else:
-            # Paragraph material:
-            build_para(doc, container, start, len(children))
-            if DEBUG_PARA_FIXER and depth == 10:
-                sys.exit(1)
-        start = skip_leading_nodes(children, start + 1)
-
-
-def build_para(doc, parent, start, i):
-    children = parent.childNodes
-    after = start + 1
-    have_last = 0
-    BREAK_ELEMENTS = PARA_LEVEL_ELEMENTS + RECURSE_INTO_PARA_CONTAINERS
-    # Collect all children until \n\n+ is found in a text node or a
-    # member of BREAK_ELEMENTS is found.
-    for j in range(start, i):
-        after = j + 1
-        child = children[j]
-        nodeType = child.nodeType
-        if nodeType == ELEMENT:
-            if child.tagName in BREAK_ELEMENTS:
-                after = j
-                break
-        elif nodeType == TEXT:
-            pos = string.find(child.data, "\n\n")
-            if pos == 0:
-                after = j
-                break
-            if pos >= 1:
-                child.splitText(pos)
-                break
-    else:
-        have_last = 1
-    if (start + 1) > after:
-        raise ConversionError(
-            "build_para() could not identify content to turn into a paragraph")
-    if children[after - 1].nodeType == TEXT:
-        # we may need to split off trailing white space:
-        child = children[after - 1]
-        data = child.data
-        if string.rstrip(data) != data:
-            have_last = 0
-            child.splitText(len(string.rstrip(data)))
-    para = doc.createElement(PARA_ELEMENT)
-    prev = None
-    indexes = range(start, after)
-    indexes.reverse()
-    for j in indexes:
-        node = parent.childNodes[j]
-        parent.removeChild(node)
-        para.insertBefore(node, prev)
-        prev = node
-    if have_last:
-        parent.appendChild(para)
-        parent.appendChild(doc.createTextNode("\n\n"))
-        return len(parent.childNodes)
-    else:
-        nextnode = parent.childNodes[start]
-        if nextnode.nodeType == TEXT:
-            if nextnode.data and nextnode.data[0] != "\n":
-                nextnode.data = "\n" + nextnode.data
-        else:
-            newnode = doc.createTextNode("\n")
-            parent.insertBefore(newnode, nextnode)
-            nextnode = newnode
-            start = start + 1
-        parent.insertBefore(para, nextnode)
-        return start + 1
-
-
-def skip_leading_nodes(children, start=0):
-    """Return index into children of a node at which paragraph building should
-    begin or a recursive call to fixup_paras_helper() should be made (for
-    subsections, etc.).
-
-    When the return value >= len(children), we've built all the paras we can
-    from this list of children.
-    """
-    i = len(children)
-    while i > start:
-        # skip over leading comments and whitespace:
-        child = children[start]
-        nodeType = child.nodeType
-        if nodeType == TEXT:
-            data = child.data
-            shortened = string.lstrip(data)
-            if shortened:
-                if data != shortened:
-                    # break into two nodes: whitespace and non-whitespace
-                    child.splitText(len(data) - len(shortened))
-                    return start + 1
-                return start
-            # all whitespace, just skip
-        elif nodeType == ELEMENT:
-            tagName = child.tagName
-            if tagName in RECURSE_INTO_PARA_CONTAINERS:
-                return start
-            if tagName not in PARA_LEVEL_ELEMENTS + PARA_LEVEL_PRECEEDERS:
-                return start
-        start = start + 1
-    return start
-
-
-def fixup_rfc_references(doc, fragment):
-    for rfcnode in find_all_elements(fragment, "rfc"):
-        rfcnode.appendChild(doc.createTextNode(
-            "RFC " + rfcnode.getAttribute("num")))
-
-
-def fixup_signatures(doc, fragment):
-    for child in fragment.childNodes:
-        if child.nodeType == ELEMENT:
-            args = child.getElementsByTagName("args")
-            for arg in args:
-                fixup_args(doc, arg)
-                arg.normalize()
-            args = child.getElementsByTagName("constructor-args")
-            for arg in args:
-                fixup_args(doc, arg)
-                arg.normalize()
-
-
-def fixup_args(doc, arglist):
-    for child in arglist.childNodes:
-        if child.nodeName == "optional":
-            # found it; fix and return
-            arglist.insertBefore(doc.createTextNode("["), child)
-            optkids = child.childNodes
-            while optkids:
-                k = optkids[0]
-                child.removeChild(k)
-                arglist.insertBefore(k, child)
-            arglist.insertBefore(doc.createTextNode("]"), child)
-            arglist.removeChild(child)
-            return fixup_args(doc, arglist)
-
-
-def fixup_sectionauthors(doc, fragment):
-    for sectauth in find_all_elements(fragment, "sectionauthor"):
-        section = sectauth.parentNode
-        section.removeChild(sectauth)
-        set_tagName(sectauth, "author")
-        sectauth.appendChild(doc.createTextNode(
-            sectauth.getAttribute("name")))
-        sectauth.removeAttribute("name")
-        after = section.childNodes[2]
-        title = section.childNodes[1]
-        if title.nodeName != "title":
-            after = section.childNodes[0]
-        section.insertBefore(doc.createTextNode("\n  "), after)
-        section.insertBefore(sectauth, after)
-
-
-def fixup_verbatims(doc):
-    for verbatim in find_all_elements(doc, "verbatim"):
-        child = verbatim.childNodes[0]
-        if child.nodeType == TEXT \
-           and string.lstrip(child.data)[:3] == ">>>":
-            set_tagName(verbatim, "interactive-session")
-
-
-def add_node_ids(fragment, counter=0):
-    fragment.node_id = counter
-    for node in fragment.childNodes:
-        counter = counter + 1
-        if node.nodeType == ELEMENT:
-            counter = add_node_ids(node, counter)
-        else:
-            node.node_id = counter
-    return counter + 1
-
-
-REFMODINDEX_ELEMENTS = ('refmodindex', 'refbimodindex',
-                        'refexmodindex', 'refstmodindex')
-
-def fixup_refmodindexes(fragment):
-    # Locate <ref*modindex>...</> co-located with <module>...</>, and
-    # remove the <ref*modindex>, replacing it with index=index on the
-    # <module> element.
-    nodes = find_all_elements_from_set(fragment, REFMODINDEX_ELEMENTS)
-    d = {}
-    for node in nodes:
-        parent = node.parentNode
-        d[parent.node_id] = parent
-    del nodes
-    map(fixup_refmodindexes_chunk, d.values())
-
-
-def fixup_refmodindexes_chunk(container):
-    # node is probably a <para>; let's see how often it isn't:
-    if container.tagName != PARA_ELEMENT:
-        bwrite("--- fixup_refmodindexes_chunk(%s)\n" % container)
-    module_entries = find_all_elements(container, "module")
-    if not module_entries:
-        return
-    index_entries = find_all_elements_from_set(container, REFMODINDEX_ELEMENTS)
-    removes = []
-    for entry in index_entries:
-        children = entry.childNodes
-        if len(children) != 0:
-            bwrite("--- unexpected number of children for %s node:\n"
-                   % entry.tagName)
-            ewrite(entry.toxml() + "\n")
-            continue
-        found = 0
-        module_name = entry.getAttribute("module")
-        for node in module_entries:
-            if len(node.childNodes) != 1:
-                continue
-            this_name = node.childNodes[0].data
-            if this_name == module_name:
-                found = 1
-                node.setAttribute("index", "yes")
-        if found:
-            removes.append(entry)
-    for node in removes:
-        container.removeChild(node)
-
-
-def fixup_bifuncindexes(fragment):
-    nodes = find_all_elements(fragment, 'bifuncindex')
-    d = {}
-    # make sure that each parent is only processed once:
-    for node in nodes:
-        parent = node.parentNode
-        d[parent.node_id] = parent
-    del nodes
-    map(fixup_bifuncindexes_chunk, d.values())
-
-
-def fixup_bifuncindexes_chunk(container):
-    removes = []
-    entries = find_all_child_elements(container, "bifuncindex")
-    function_entries = find_all_child_elements(container, "function")
-    for entry in entries:
-        function_name = entry.getAttribute("name")
-        found = 0
-        for func_entry in function_entries:
-            t2 = func_entry.childNodes[0].data
-            if t2[-2:] != "()":
-                continue
-            t2 = t2[:-2]
-            if t2 == function_name:
-                func_entry.setAttribute("index", "yes")
-                func_entry.setAttribute("module", "__builtin__")
-                if not found:
-                    found = 1
-                    removes.append(entry)
-    for entry in removes:
-        container.removeChild(entry)
-
-
-def join_adjacent_elements(container, gi):
-    queue = [container]
-    while queue:
-        parent = queue.pop()
-        i = 0
-        children = parent.childNodes
-        nchildren = len(children)
-        while i < (nchildren - 1):
-            child = children[i]
-            if child.nodeName == gi:
-                if children[i+1].nodeName == gi:
-                    ewrite("--- merging two <%s/> elements\n" % gi)
-                    child = children[i]
-                    nextchild = children[i+1]
-                    nextchildren = nextchild.childNodes
-                    while len(nextchildren):
-                        node = nextchildren[0]
-                        nextchild.removeChild(node)
-                        child.appendChild(node)
-                    parent.removeChild(nextchild)
-                    continue
-            if child.nodeType == ELEMENT:
-                queue.append(child)
-            i = i + 1
-
-
-_token_rx = re.compile(r"[a-zA-Z][a-zA-Z0-9.-]*$")
-
-def write_esis(doc, ofp, knownempty):
-    for node in doc.childNodes:
-        nodeType = node.nodeType
-        if nodeType == ELEMENT:
-            gi = node.tagName
-            if knownempty(gi):
-                if node.hasChildNodes():
-                    raise ValueError, \
-                          "declared-empty node <%s> has children" % gi
-                ofp.write("e\n")
-            for k, value in node.attributes.items():
-                if _token_rx.match(value):
-                    dtype = "TOKEN"
-                else:
-                    dtype = "CDATA"
-                ofp.write("A%s %s %s\n" % (k, dtype, esistools.encode(value)))
-            ofp.write("(%s\n" % gi)
-            write_esis(node, ofp, knownempty)
-            ofp.write(")%s\n" % gi)
-        elif nodeType == TEXT:
-            ofp.write("-%s\n" % esistools.encode(node.data))
-        elif nodeType == ENTITY_REFERENCE:
-            ofp.write("&%s\n" % node.nodeName)
-        else:
-            raise RuntimeError, "unsupported node type: %s" % nodeType
-
-
-def convert(ifp, ofp):
-    events = esistools.parse(ifp)
-    toktype, doc = events.getEvent()
-    fragment = doc.createDocumentFragment()
-    events.expandNode(fragment)
-
-    normalize(fragment)
-    simplify(doc, fragment)
-    handle_labels(doc, fragment)
-    handle_appendix(doc, fragment)
-    fixup_trailing_whitespace(doc, {
-        "abstract": "\n",
-        "title": "",
-        "chapter": "\n\n",
-        "section": "\n\n",
-        "subsection": "\n\n",
-        "subsubsection": "\n\n",
-        "paragraph": "\n\n",
-        "subparagraph": "\n\n",
-        })
-    cleanup_root_text(doc)
-    cleanup_trailing_parens(fragment, ["function", "method", "cfunction"])
-    cleanup_synopses(doc, fragment)
-    fixup_descriptors(doc, fragment)
-    fixup_verbatims(fragment)
-    normalize(fragment)
-    fixup_paras(doc, fragment)
-    fixup_sectionauthors(doc, fragment)
-    fixup_table_structures(doc, fragment)
-    fixup_rfc_references(doc, fragment)
-    fixup_signatures(doc, fragment)
-    add_node_ids(fragment)
-    fixup_refmodindexes(fragment)
-    fixup_bifuncindexes(fragment)
-    # Take care of ugly hacks in the LaTeX markup to avoid LaTeX and
-    # LaTeX2HTML screwing with GNU-style long options (the '--' problem).
-    join_adjacent_elements(fragment, "option")
-    #
-    d = {}
-    for gi in events.parser.get_empties():
-        d[gi] = gi
-    if d.has_key("author"):
-        del d["author"]
-    if d.has_key("rfc"):
-        del d["rfc"]
-    knownempty = d.has_key
-    #
-    try:
-        write_esis(fragment, ofp, knownempty)
-    except IOError, (err, msg):
-        # Ignore EPIPE; it just means that whoever we're writing to stopped
-        # reading.  The rest of the output would be ignored.  All other errors
-        # should still be reported,
-        if err != errno.EPIPE:
-            raise
-
-
-def main():
-    if len(sys.argv) == 1:
-        ifp = sys.stdin
-        ofp = sys.stdout
-    elif len(sys.argv) == 2:
-        ifp = open(sys.argv[1])
-        ofp = sys.stdout
-    elif len(sys.argv) == 3:
-        ifp = open(sys.argv[1])
-        import StringIO
-        ofp = StringIO.StringIO()
-    else:
-        usage()
-        sys.exit(2)
-    convert(ifp, ofp)
-    if len(sys.argv) == 3:
-        fp = open(sys.argv[2], "w")
-        fp.write(ofp.getvalue())
-        fp.close()
-        ofp.close()
-
-
-if __name__ == "__main__":
-    main()
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/sgmlconv/esis2sgml.py hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/sgmlconv/esis2sgml.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/sgmlconv/esis2sgml.py	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/sgmlconv/esis2sgml.py	1970-01-01 01:00:00.000000000 +0100
@@ -1,263 +0,0 @@
-#! /usr/bin/env python
-
-"""Convert ESIS events to SGML or XML markup.
-
-This is limited, but seems sufficient for the ESIS generated by the
-latex2esis.py script when run over the Python documentation.
-"""
-
-# This should have an explicit option to indicate whether the *INPUT* was
-# generated from an SGML or an XML application.
-
-import errno
-import esistools
-import os
-import re
-import string
-
-from xml.sax.saxutils import escape
-
-
-AUTOCLOSE = ()
-
-EMPTIES_FILENAME = "../sgml/empties.dat"
-LIST_EMPTIES = 0
-
-
-_elem_map = {}
-_attr_map = {}
-_token_map = {}
-
-_normalize_case = str
-
-def map_gi(sgmlgi, map):
-    uncased = _normalize_case(sgmlgi)
-    try:
-        return map[uncased]
-    except IndexError:
-        map[uncased] = sgmlgi
-        return sgmlgi
-
-def null_map_gi(sgmlgi, map):
-    return sgmlgi
-
-
-def format_attrs(attrs, xml=0):
-    attrs = attrs.items()
-    attrs.sort()
-    parts = []
-    append = parts.append
-    for name, value in attrs:
-        if xml:
-            append('%s="%s"' % (name, escape(value)))
-        else:
-            # this is a little bogus, but should do for now
-            if name == value and isnmtoken(value):
-                append(value)
-            elif istoken(value):
-                if value == "no" + name:
-                    append(value)
-                else:
-                    append("%s=%s" % (name, value))
-            else:
-                append('%s="%s"' % (name, escape(value)))
-    if parts:
-        parts.insert(0, '')
-    return string.join(parts)
-
-
-_nmtoken_rx = re.compile("[a-z][-._a-z0-9]*$", re.IGNORECASE)
-def isnmtoken(s):
-    return _nmtoken_rx.match(s) is not None
-
-_token_rx = re.compile("[a-z0-9][-._a-z0-9]*$", re.IGNORECASE)
-def istoken(s):
-    return _token_rx.match(s) is not None
-
-
-def convert(ifp, ofp, xml=0, autoclose=(), verbatims=()):
-    if xml:
-        autoclose = ()
-    attrs = {}
-    lastopened = None
-    knownempties = []
-    knownempty = 0
-    lastempty = 0
-    inverbatim = 0
-    while 1:
-        line = ifp.readline()
-        if not line:
-            break
-
-        type = line[0]
-        data = line[1:]
-        if data and data[-1] == "\n":
-            data = data[:-1]
-        if type == "-":
-            data = esistools.decode(data)
-            data = escape(data)
-            if not inverbatim:
-                data = string.replace(data, "---", "&mdash;")
-            ofp.write(data)
-            if "\n" in data:
-                lastopened = None
-            knownempty = 0
-            lastempty = 0
-        elif type == "(":
-            if data == "COMMENT":
-                ofp.write("<!--")
-                continue
-            data = map_gi(data, _elem_map)
-            if knownempty and xml:
-                ofp.write("<%s%s/>" % (data, format_attrs(attrs, xml)))
-            else:
-                ofp.write("<%s%s>" % (data, format_attrs(attrs, xml)))
-            if knownempty and data not in knownempties:
-                # accumulate knowledge!
-                knownempties.append(data)
-            attrs = {}
-            lastopened = data
-            lastempty = knownempty
-            knownempty = 0
-            inverbatim = data in verbatims
-        elif type == ")":
-            if data == "COMMENT":
-                ofp.write("-->")
-                continue
-            data = map_gi(data, _elem_map)
-            if xml:
-                if not lastempty:
-                    ofp.write("</%s>" % data)
-            elif data not in knownempties:
-                if data in autoclose:
-                    pass
-                elif lastopened == data:
-                    ofp.write("</>")
-                else:
-                    ofp.write("</%s>" % data)
-            lastopened = None
-            lastempty = 0
-            inverbatim = 0
-        elif type == "A":
-            name, type, value = string.split(data, " ", 2)
-            name = map_gi(name, _attr_map)
-            attrs[name] = esistools.decode(value)
-        elif type == "e":
-            knownempty = 1
-        elif type == "&":
-            ofp.write("&%s;" % data)
-            knownempty = 0
-        else:
-            raise RuntimeError, "unrecognized ESIS event type: '%s'" % type
-
-    if LIST_EMPTIES:
-        dump_empty_element_names(knownempties)
-
-
-def dump_empty_element_names(knownempties):
-    d = {}
-    for gi in knownempties:
-        d[gi] = gi
-    knownempties.append("")
-    if os.path.isfile(EMPTIES_FILENAME):
-        fp = open(EMPTIES_FILENAME)
-        while 1:
-            line = fp.readline()
-            if not line:
-                break
-            gi = string.strip(line)
-            if gi:
-                d[gi] = gi
-    fp = open(EMPTIES_FILENAME, "w")
-    gilist = d.keys()
-    gilist.sort()
-    fp.write(string.join(gilist, "\n"))
-    fp.write("\n")
-    fp.close()
-
-
-def update_gi_map(map, names, fromsgml=1):
-    for name in string.split(names, ","):
-        if fromsgml:
-            uncased = string.lower(name)
-        else:
-            uncased = name
-        map[uncased] = name
-
-
-def main():
-    import getopt
-    import sys
-    #
-    autoclose = AUTOCLOSE
-    xml = 1
-    xmldecl = 0
-    elem_names = ''
-    attr_names = ''
-    value_names = ''
-    verbatims = ('verbatim', 'interactive-session')
-    opts, args = getopt.getopt(sys.argv[1:], "adesx",
-                               ["autoclose=", "declare", "sgml", "xml",
-                                "elements-map=", "attributes-map",
-                                "values-map="])
-    for opt, arg in opts:
-        if opt in ("-d", "--declare"):
-            xmldecl = 1
-        elif opt == "-e":
-            global LIST_EMPTIES
-            LIST_EMPTIES = 1
-        elif opt in ("-s", "--sgml"):
-            xml = 0
-        elif opt in ("-x", "--xml"):
-            xml = 1
-        elif opt in ("-a", "--autoclose"):
-            autoclose = string.split(arg, ",")
-        elif opt == "--elements-map":
-            elem_names = ("%s,%s" % (elem_names, arg))[1:]
-        elif opt == "--attributes-map":
-            attr_names = ("%s,%s" % (attr_names, arg))[1:]
-        elif opt == "--values-map":
-            value_names = ("%s,%s" % (value_names, arg))[1:]
-    #
-    # open input streams:
-    #
-    if len(args) == 0:
-        ifp = sys.stdin
-        ofp = sys.stdout
-    elif len(args) == 1:
-        ifp = open(args[0])
-        ofp = sys.stdout
-    elif len(args) == 2:
-        ifp = open(args[0])
-        ofp = open(args[1], "w")
-    else:
-        usage()
-        sys.exit(2)
-    #
-    # setup the name maps:
-    #
-    if elem_names or attr_names or value_names:
-        # assume the origin was SGML; ignore case of the names from the ESIS
-        # stream but set up conversion tables to get the case right on output
-        global _normalize_case
-        _normalize_case = string.lower
-        update_gi_map(_elem_map, string.split(elem_names, ","))
-        update_gi_map(_attr_map, string.split(attr_names, ","))
-        update_gi_map(_values_map, string.split(value_names, ","))
-    else:
-        global map_gi
-        map_gi = null_map_gi
-    #
-    # run the conversion:
-    #
-    try:
-        if xml and xmldecl:
-            opf.write('<?xml version="1.0" encoding="iso8859-1"?>\n')
-        convert(ifp, ofp, xml=xml, autoclose=autoclose, verbatims=verbatims)
-    except IOError, (err, msg):
-        if err != errno.EPIPE:
-            raise
-
-
-if __name__ == "__main__":
-    main()
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/sgmlconv/esistools.py hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/sgmlconv/esistools.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/sgmlconv/esistools.py	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/sgmlconv/esistools.py	1970-01-01 01:00:00.000000000 +0100
@@ -1,309 +0,0 @@
-"""Miscellaneous utility functions useful for dealing with ESIS streams."""
-
-import re
-import string
-
-import xml.dom.pulldom
-
-import xml.sax
-import xml.sax.handler
-import xml.sax.xmlreader
-
-
-_data_match = re.compile(r"[^\\][^\\]*").match
-
-def decode(s):
-    r = ''
-    while s:
-        m = _data_match(s)
-        if m:
-            r = r + m.group()
-            s = s[m.end():]
-        elif s[1] == "\\":
-            r = r + "\\"
-            s = s[2:]
-        elif s[1] == "n":
-            r = r + "\n"
-            s = s[2:]
-        elif s[1] == "%":
-            s = s[2:]
-            n, s = s.split(";", 1)
-            r = r + unichr(int(n))
-        else:
-            raise ValueError, "can't handle " + `s`
-    return r
-
-
-_charmap = {}
-for c in map(chr, range(256)):
-    _charmap[c] = c
-_charmap["\n"] = r"\n"
-_charmap["\\"] = r"\\"
-del c
-
-_null_join = ''.join
-def encode(s):
-    return _null_join(map(_charmap.get, s))
-
-
-class ESISReader(xml.sax.xmlreader.XMLReader):
-    """SAX Reader which reads from an ESIS stream.
-
-    No verification of the document structure is performed by the
-    reader; a general verifier could be used as the target
-    ContentHandler instance.
-
-    """
-    _decl_handler = None
-    _lexical_handler = None
-
-    _public_id = None
-    _system_id = None
-
-    _buffer = ""
-    _is_empty = 0
-    _lineno = 0
-    _started = 0
-
-    def __init__(self, contentHandler=None, errorHandler=None):
-        xml.sax.xmlreader.XMLReader.__init__(self)
-        self._attrs = {}
-        self._attributes = Attributes(self._attrs)
-        self._locator = Locator()
-        self._empties = {}
-        if contentHandler:
-            self.setContentHandler(contentHandler)
-        if errorHandler:
-            self.setErrorHandler(errorHandler)
-
-    def get_empties(self):
-        return self._empties.keys()
-
-    #
-    #  XMLReader interface
-    #
-
-    def parse(self, source):
-        raise RuntimeError
-        self._locator._public_id = source.getPublicId()
-        self._locator._system_id = source.getSystemId()
-        fp = source.getByteStream()
-        handler = self.getContentHandler()
-        if handler:
-            handler.startDocument()
-        lineno = 0
-        while 1:
-            token, data = self._get_token(fp)
-            if token is None:
-                break
-            lineno = lineno + 1
-            self._locator._lineno = lineno
-            self._handle_token(token, data)
-        handler = self.getContentHandler()
-        if handler:
-            handler.startDocument()
-
-    def feed(self, data):
-        if not self._started:
-            handler = self.getContentHandler()
-            if handler:
-                handler.startDocument()
-            self._started = 1
-        data = self._buffer + data
-        self._buffer = None
-        lines = data.split("\n")
-        if lines:
-            for line in lines[:-1]:
-                self._lineno = self._lineno + 1
-                self._locator._lineno = self._lineno
-                if not line:
-                    e = xml.sax.SAXParseException(
-                        "ESIS input line contains no token type mark",
-                        None, self._locator)
-                    self.getErrorHandler().error(e)
-                else:
-                    self._handle_token(line[0], line[1:])
-            self._buffer = lines[-1]
-        else:
-            self._buffer = ""
-
-    def close(self):
-        handler = self.getContentHandler()
-        if handler:
-            handler.endDocument()
-        self._buffer = ""
-
-    def _get_token(self, fp):
-        try:
-            line = fp.readline()
-        except IOError, e:
-            e = SAXException("I/O error reading input stream", e)
-            self.getErrorHandler().fatalError(e)
-            return
-        if not line:
-            return None, None
-        if line[-1] == "\n":
-            line = line[:-1]
-        if not line:
-            e = xml.sax.SAXParseException(
-                "ESIS input line contains no token type mark",
-                None, self._locator)
-            self.getErrorHandler().error(e)
-            return
-        return line[0], line[1:]
-
-    def _handle_token(self, token, data):
-        handler = self.getContentHandler()
-        if token == '-':
-            if data and handler:
-                handler.characters(decode(data))
-        elif token == ')':
-            if handler:
-                handler.endElement(decode(data))
-        elif token == '(':
-            if self._is_empty:
-                self._empties[data] = 1
-            if handler:
-                handler.startElement(data, self._attributes)
-            self._attrs.clear()
-            self._is_empty = 0
-        elif token == 'A':
-            name, value = data.split(' ', 1)
-            if value != "IMPLIED":
-                type, value = value.split(' ', 1)
-                self._attrs[name] = (decode(value), type)
-        elif token == '&':
-            # entity reference in SAX?
-            pass
-        elif token == '?':
-            if handler:
-                if ' ' in data:
-                    target, data = string.split(data, None, 1)
-                else:
-                    target, data = data, ""
-                handler.processingInstruction(target, decode(data))
-        elif token == 'N':
-            handler = self.getDTDHandler()
-            if handler:
-                handler.notationDecl(data, self._public_id, self._system_id)
-            self._public_id = None
-            self._system_id = None
-        elif token == 'p':
-            self._public_id = decode(data)
-        elif token == 's':
-            self._system_id = decode(data)
-        elif token == 'e':
-            self._is_empty = 1
-        elif token == 'C':
-            pass
-        else:
-            e = SAXParseException("unknown ESIS token in event stream",
-                                  None, self._locator)
-            self.getErrorHandler().error(e)
-
-    def setContentHandler(self, handler):
-        old = self.getContentHandler()
-        if old:
-            old.setDocumentLocator(None)
-        if handler:
-            handler.setDocumentLocator(self._locator)
-        xml.sax.xmlreader.XMLReader.setContentHandler(self, handler)
-
-    def getProperty(self, property):
-        if property == xml.sax.handler.property_lexical_handler:
-            return self._lexical_handler
-
-        elif property == xml.sax.handler.property_declaration_handler:
-            return self._decl_handler
-
-        else:
-            raise xml.sax.SAXNotRecognizedException("unknown property %s"
-                                                    % `property`)
-
-    def setProperty(self, property, value):
-        if property == xml.sax.handler.property_lexical_handler:
-            if self._lexical_handler:
-                self._lexical_handler.setDocumentLocator(None)
-            if value:
-                value.setDocumentLocator(self._locator)
-            self._lexical_handler = value
-
-        elif property == xml.sax.handler.property_declaration_handler:
-            if self._decl_handler:
-                self._decl_handler.setDocumentLocator(None)
-            if value:
-                value.setDocumentLocator(self._locator)
-            self._decl_handler = value
-
-        else:
-            raise xml.sax.SAXNotRecognizedException()
-
-    def getFeature(self, feature):
-        if feature == xml.sax.handler.feature_namespaces:
-            return 1
-        else:
-            return xml.sax.xmlreader.XMLReader.getFeature(self, feature)
-
-    def setFeature(self, feature, enabled):
-        if feature == xml.sax.handler.feature_namespaces:
-            pass
-        else:
-            xml.sax.xmlreader.XMLReader.setFeature(self, feature, enabled)
-
-
-class Attributes(xml.sax.xmlreader.AttributesImpl):
-    # self._attrs has the form {name: (value, type)}
-
-    def getType(self, name):
-        return self._attrs[name][1]
-
-    def getValue(self, name):
-        return self._attrs[name][0]
-
-    def getValueByQName(self, name):
-        return self._attrs[name][0]
-
-    def __getitem__(self, name):
-        return self._attrs[name][0]
-
-    def get(self, name, default=None):
-        if self._attrs.has_key(name):
-            return self._attrs[name][0]
-        return default
-
-    def items(self):
-        L = []
-        for name, (value, type) in self._attrs.items():
-            L.append((name, value))
-        return L
-
-    def values(self):
-        L = []
-        for value, type in self._attrs.values():
-            L.append(value)
-        return L
-
-
-class Locator(xml.sax.xmlreader.Locator):
-    _lineno = -1
-    _public_id = None
-    _system_id = None
-
-    def getLineNumber(self):
-        return self._lineno
-
-    def getPublicId(self):
-        return self._public_id
-
-    def getSystemId(self):
-        return self._system_id
-
-
-def parse(stream_or_string, parser=None):
-    if type(stream_or_string) in [type(""), type(u"")]:
-        stream = open(stream_or_string)
-    else:
-        stream = stream_or_string
-    if not parser:
-        parser = ESISReader()
-    return xml.dom.pulldom.DOMEventStream(stream, parser, (2 ** 14) - 20)
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/sgmlconv/latex2esis.py hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/sgmlconv/latex2esis.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/sgmlconv/latex2esis.py	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/sgmlconv/latex2esis.py	1970-01-01 01:00:00.000000000 +0100
@@ -1,555 +0,0 @@
-#! /usr/bin/env python
-
-"""Generate ESIS events based on a LaTeX source document and
-configuration data.
-
-The conversion is not strong enough to work with arbitrary LaTeX
-documents; it has only been designed to work with the highly stylized
-markup used in the standard Python documentation.  A lot of
-information about specific markup is encoded in the control table
-passed to the convert() function; changing this table can allow this
-tool to support additional LaTeX markups.
-
-The format of the table is largely undocumented; see the commented
-headers where the table is specified in main().  There is no provision 
-to load an alternate table from an external file.
-"""
-
-import errno
-import getopt
-import os
-import re
-import string
-import sys
-import UserList
-import xml.sax.saxutils
-
-from types import ListType, StringType, TupleType
-
-try:
-    from xml.parsers.xmllib import XMLParser
-except ImportError:
-    from xmllib import XMLParser
-
-
-from esistools import encode
-
-
-DEBUG = 0
-
-
-class LaTeXFormatError(Exception):
-    pass
-
-
-class LaTeXStackError(LaTeXFormatError):
-    def __init__(self, found, stack):
-        msg = "environment close for %s doesn't match;\n  stack = %s" \
-              % (found, stack)
-        self.found = found
-        self.stack = stack[:]
-        LaTeXFormatError.__init__(self, msg)
-
-
-_begin_env_rx = re.compile(r"[\\]begin{([^}]*)}")
-_end_env_rx = re.compile(r"[\\]end{([^}]*)}")
-_begin_macro_rx = re.compile(r"[\\]([a-zA-Z]+[*]?) ?({|\s*\n?)")
-_comment_rx = re.compile("%+ ?(.*)\n[ \t]*")
-_text_rx = re.compile(r"[^]~%\\{}]+")
-_optional_rx = re.compile(r"\s*[[]([^]]*)[]]")
-# _parameter_rx is this complicated to allow {...} inside a parameter;
-# this is useful to match tabular layout specifications like {c|p{24pt}}
-_parameter_rx = re.compile("[ \n]*{(([^{}}]|{[^}]*})*)}")
-_token_rx = re.compile(r"[a-zA-Z][a-zA-Z0-9.-]*$")
-_start_group_rx = re.compile("[ \n]*{")
-_start_optional_rx = re.compile("[ \n]*[[]")
-
-
-ESCAPED_CHARS = "$%#^ {}&~"
-
-
-def dbgmsg(msg):
-    if DEBUG:
-        sys.stderr.write(msg + "\n")
-
-def pushing(name, point, depth):
-    dbgmsg("pushing <%s> at %s" % (name, point))
-
-def popping(name, point, depth):
-    dbgmsg("popping </%s> at %s" % (name, point))
-
-
-class _Stack(UserList.UserList):
-    def append(self, entry):
-        if type(entry) is not StringType:
-            raise LaTeXFormatError("cannot push non-string on stack: "
-                                   + `entry`)
-        #dbgmsg("%s<%s>" % (" "*len(self.data), entry))
-        self.data.append(entry)
-
-    def pop(self, index=-1):
-        entry = self.data[index]
-        del self.data[index]
-        #dbgmsg("%s</%s>" % (" "*len(self.data), entry))
-
-    def __delitem__(self, index):
-        entry = self.data[index]
-        del self.data[index]
-        #dbgmsg("%s</%s>" % (" "*len(self.data), entry))
-
-
-def new_stack():
-    if DEBUG:
-        return _Stack()
-    return []
-
-
-class Conversion:
-    def __init__(self, ifp, ofp, table):
-        self.write = ofp.write
-        self.ofp = ofp
-        self.table = table
-        self.line = string.join(map(string.rstrip, ifp.readlines()), "\n")
-        self.preamble = 1
-
-    def convert(self):
-        self.subconvert()
-
-    def subconvert(self, endchar=None, depth=0):
-        #
-        # Parses content, including sub-structures, until the character
-        # 'endchar' is found (with no open structures), or until the end
-        # of the input data is endchar is None.
-        #
-        stack = new_stack()
-        line = self.line
-        while line:
-            if line[0] == endchar and not stack:
-                self.line = line
-                return line
-            m = _comment_rx.match(line)
-            if m:
-                text = m.group(1)
-                if text:
-                    self.write("(COMMENT\n- %s \n)COMMENT\n-\\n\n"
-                               % encode(text))
-                line = line[m.end():]
-                continue
-            m = _begin_env_rx.match(line)
-            if m:
-                name = m.group(1)
-                entry = self.get_env_entry(name)
-                # re-write to use the macro handler
-                line = r"\%s %s" % (name, line[m.end():])
-                continue
-            m = _end_env_rx.match(line)
-            if m:
-                # end of environment
-                envname = m.group(1)
-                entry = self.get_entry(envname)
-                while stack and envname != stack[-1] \
-                      and stack[-1] in entry.endcloses:
-                    self.write(")%s\n" % stack.pop())
-                if stack and envname == stack[-1]:
-                    self.write(")%s\n" % entry.outputname)
-                    del stack[-1]
-                else:
-                    raise LaTeXStackError(envname, stack)
-                line = line[m.end():]
-                continue
-            m = _begin_macro_rx.match(line)
-            if m:
-                # start of macro
-                macroname = m.group(1)
-                if macroname == "c":
-                    # Ugh!  This is a combining character...
-                    endpos = m.end()
-                    self.combining_char("c", line[endpos])
-                    line = line[endpos + 1:]
-                    continue
-                entry = self.get_entry(macroname)
-                if entry.verbatim:
-                    # magic case!
-                    pos = string.find(line, "\\end{%s}" % macroname)
-                    text = line[m.end(1):pos]
-                    stack.append(entry.name)
-                    self.write("(%s\n" % entry.outputname)
-                    self.write("-%s\n" % encode(text))
-                    self.write(")%s\n" % entry.outputname)
-                    stack.pop()
-                    line = line[pos + len("\\end{%s}" % macroname):]
-                    continue
-                while stack and stack[-1] in entry.closes:
-                    top = stack.pop()
-                    topentry = self.get_entry(top)
-                    if topentry.outputname:
-                        self.write(")%s\n-\\n\n" % topentry.outputname)
-                #
-                if entry.outputname:
-                    if entry.empty:
-                        self.write("e\n")
-                #
-                params, optional, empty, environ = self.start_macro(macroname)
-                # rip off the macroname
-                if params:
-                    line = line[m.end(1):]
-                elif empty:
-                    line = line[m.end(1):]
-                else:
-                    line = line[m.end():]
-                opened = 0
-                implied_content = 0
-
-                # handle attribute mappings here:
-                for pentry in params:
-                    if pentry.type == "attribute":
-                        if pentry.optional:
-                            m = _optional_rx.match(line)
-                            if m and entry.outputname:
-                                line = line[m.end():]
-                                self.dump_attr(pentry, m.group(1))
-                        elif pentry.text and entry.outputname:
-                            # value supplied by conversion spec:
-                            self.dump_attr(pentry, pentry.text)
-                        else:
-                            m = _parameter_rx.match(line)
-                            if not m:
-                                raise LaTeXFormatError(
-                                    "could not extract parameter %s for %s: %s"
-                                    % (pentry.name, macroname, `line[:100]`))
-                            if entry.outputname:
-                                self.dump_attr(pentry, m.group(1))
-                            line = line[m.end():]
-                    elif pentry.type == "child":
-                        if pentry.optional:
-                            m = _optional_rx.match(line)
-                            if m:
-                                line = line[m.end():]
-                                if entry.outputname and not opened:
-                                    opened = 1
-                                    self.write("(%s\n" % entry.outputname)
-                                    stack.append(macroname)
-                                stack.append(pentry.name)
-                                self.write("(%s\n" % pentry.name)
-                                self.write("-%s\n" % encode(m.group(1)))
-                                self.write(")%s\n" % pentry.name)
-                                stack.pop()
-                        else:
-                            if entry.outputname and not opened:
-                                opened = 1
-                                self.write("(%s\n" % entry.outputname)
-                                stack.append(entry.name)
-                            self.write("(%s\n" % pentry.name)
-                            stack.append(pentry.name)
-                            self.line = skip_white(line)[1:]
-                            line = self.subconvert(
-                                "}", len(stack) + depth + 1)[1:]
-                            self.write(")%s\n" % stack.pop())
-                    elif pentry.type == "content":
-                        if pentry.implied:
-                            implied_content = 1
-                        else:
-                            if entry.outputname and not opened:
-                                opened = 1
-                                self.write("(%s\n" % entry.outputname)
-                                stack.append(entry.name)
-                            line = skip_white(line)
-                            if line[0] != "{":
-                                raise LaTeXFormatError(
-                                    "missing content for " + macroname)
-                            self.line = line[1:]
-                            line = self.subconvert("}", len(stack) + depth + 1)
-                            if line and line[0] == "}":
-                                line = line[1:]
-                    elif pentry.type == "text" and pentry.text:
-                        if entry.outputname and not opened:
-                            opened = 1
-                            stack.append(entry.name)
-                            self.write("(%s\n" % entry.outputname)
-                        #dbgmsg("--- text: %s" % `pentry.text`)
-                        self.write("-%s\n" % encode(pentry.text))
-                    elif pentry.type == "entityref":
-                        self.write("&%s\n" % pentry.name)
-                if entry.outputname:
-                    if not opened:
-                        self.write("(%s\n" % entry.outputname)
-                        stack.append(entry.name)
-                    if not implied_content:
-                        self.write(")%s\n" % entry.outputname)
-                        stack.pop()
-                continue
-            if line[0] == endchar and not stack:
-                self.line = line[1:]
-                return self.line
-            if line[0] == "}":
-                # end of macro or group
-                macroname = stack[-1]
-                if macroname:
-                    conversion = self.table[macroname]
-                    if conversion.outputname:
-                        # otherwise, it was just a bare group
-                        self.write(")%s\n" % conversion.outputname)
-                del stack[-1]
-                line = line[1:]
-                continue
-            if line[0] == "~":
-                # don't worry about the "tie" aspect of this command
-                line = line[1:]
-                self.write("- \n")
-                continue
-            if line[0] == "{":
-                stack.append("")
-                line = line[1:]
-                continue
-            if line[0] == "\\" and line[1] in ESCAPED_CHARS:
-                self.write("-%s\n" % encode(line[1]))
-                line = line[2:]
-                continue
-            if line[:2] == r"\\":
-                self.write("(BREAK\n)BREAK\n")
-                line = line[2:]
-                continue
-            if line[:2] == r"\_":
-                line = "_" + line[2:]
-                continue
-            if line[:2] in (r"\'", r'\"'):
-                # combining characters...
-                self.combining_char(line[1], line[2])
-                line = line[3:]
-                continue
-            m = _text_rx.match(line)
-            if m:
-                text = encode(m.group())
-                self.write("-%s\n" % text)
-                line = line[m.end():]
-                continue
-            # special case because of \item[]
-            # XXX can we axe this???
-            if line[0] == "]":
-                self.write("-]\n")
-                line = line[1:]
-                continue
-            # avoid infinite loops
-            extra = ""
-            if len(line) > 100:
-                extra = "..."
-            raise LaTeXFormatError("could not identify markup: %s%s"
-                                   % (`line[:100]`, extra))
-        while stack:
-            entry = self.get_entry(stack[-1])
-            if entry.closes:
-                self.write(")%s\n-%s\n" % (entry.outputname, encode("\n")))
-                del stack[-1]
-            else:
-                break
-        if stack:
-            raise LaTeXFormatError("elements remain on stack: "
-                                   + string.join(stack, ", "))
-        # otherwise we just ran out of input here...
-
-    # This is a really limited table of combinations, but it will have
-    # to do for now.
-    _combinations = {
-        ("c", "c"): 0x00E7,
-        ("'", "e"): 0x00E9,
-        ('"', "o"): 0x00F6,
-        }
-
-    def combining_char(self, prefix, char):
-        ordinal = self._combinations[(prefix, char)]
-        self.write("-\\%%%d;\n" % ordinal)
-
-    def start_macro(self, name):
-        conversion = self.get_entry(name)
-        parameters = conversion.parameters
-        optional = parameters and parameters[0].optional
-        return parameters, optional, conversion.empty, conversion.environment
-
-    def get_entry(self, name):
-        entry = self.table.get(name)
-        if entry is None:
-            dbgmsg("get_entry(%s) failing; building default entry!" % `name`)
-            # not defined; build a default entry:
-            entry = TableEntry(name)
-            entry.has_content = 1
-            entry.parameters.append(Parameter("content"))
-            self.table[name] = entry
-        return entry
-
-    def get_env_entry(self, name):
-        entry = self.table.get(name)
-        if entry is None:
-            # not defined; build a default entry:
-            entry = TableEntry(name, 1)
-            entry.has_content = 1
-            entry.parameters.append(Parameter("content"))
-            entry.parameters[-1].implied = 1
-            self.table[name] = entry
-        elif not entry.environment:
-            raise LaTeXFormatError(
-                name + " is defined as a macro; expected environment")
-        return entry
-
-    def dump_attr(self, pentry, value):
-        if not (pentry.name and value):
-            return
-        if _token_rx.match(value):
-            dtype = "TOKEN"
-        else:
-            dtype = "CDATA"
-        self.write("A%s %s %s\n" % (pentry.name, dtype, encode(value)))
-
-
-def convert(ifp, ofp, table):
-    c = Conversion(ifp, ofp, table)
-    try:
-        c.convert()
-    except IOError, (err, msg):
-        if err != errno.EPIPE:
-            raise
-
-
-def skip_white(line):
-    while line and line[0] in " %\n\t\r":
-        line = string.lstrip(line[1:])
-    return line
-
-
-
-class TableEntry:
-    def __init__(self, name, environment=0):
-        self.name = name
-        self.outputname = name
-        self.environment = environment
-        self.empty = not environment
-        self.has_content = 0
-        self.verbatim = 0
-        self.auto_close = 0
-        self.parameters = []
-        self.closes = []
-        self.endcloses = []
-
-class Parameter:
-    def __init__(self, type, name=None, optional=0):
-        self.type = type
-        self.name = name
-        self.optional = optional
-        self.text = ''
-        self.implied = 0
-
-
-class TableParser(XMLParser):
-    def __init__(self, table=None):
-        if table is None:
-            table = {}
-        self.__table = table
-        self.__current = None
-        self.__buffer = ''
-        XMLParser.__init__(self)
-
-    def get_table(self):
-        for entry in self.__table.values():
-            if entry.environment and not entry.has_content:
-                p = Parameter("content")
-                p.implied = 1
-                entry.parameters.append(p)
-                entry.has_content = 1
-        return self.__table
-
-    def start_environment(self, attrs):
-        name = attrs["name"]
-        self.__current = TableEntry(name, environment=1)
-        self.__current.verbatim = attrs.get("verbatim") == "yes"
-        if attrs.has_key("outputname"):
-            self.__current.outputname = attrs.get("outputname")
-        self.__current.endcloses = string.split(attrs.get("endcloses", ""))
-    def end_environment(self):
-        self.end_macro()
-
-    def start_macro(self, attrs):
-        name = attrs["name"]
-        self.__current = TableEntry(name)
-        self.__current.closes = string.split(attrs.get("closes", ""))
-        if attrs.has_key("outputname"):
-            self.__current.outputname = attrs.get("outputname")
-    def end_macro(self):
-        self.__table[self.__current.name] = self.__current
-        self.__current = None
-
-    def start_attribute(self, attrs):
-        name = attrs.get("name")
-        optional = attrs.get("optional") == "yes"
-        if name:
-            p = Parameter("attribute", name, optional=optional)
-        else:
-            p = Parameter("attribute", optional=optional)
-        self.__current.parameters.append(p)
-        self.__buffer = ''
-    def end_attribute(self):
-        self.__current.parameters[-1].text = self.__buffer
-
-    def start_entityref(self, attrs):
-        name = attrs["name"]
-        p = Parameter("entityref", name)
-        self.__current.parameters.append(p)
-
-    def start_child(self, attrs):
-        name = attrs["name"]
-        p = Parameter("child", name, attrs.get("optional") == "yes")
-        self.__current.parameters.append(p)
-        self.__current.empty = 0
-
-    def start_content(self, attrs):
-        p = Parameter("content")
-        p.implied = attrs.get("implied") == "yes"
-        if self.__current.environment:
-            p.implied = 1
-        self.__current.parameters.append(p)
-        self.__current.has_content = 1
-        self.__current.empty = 0
-
-    def start_text(self, attrs):
-        self.__current.empty = 0
-        self.__buffer = ''
-    def end_text(self):
-        p = Parameter("text")
-        p.text = self.__buffer
-        self.__current.parameters.append(p)
-
-    def handle_data(self, data):
-        self.__buffer = self.__buffer + data
-
-
-def load_table(fp, table=None):
-    parser = TableParser(table=table)
-    parser.feed(fp.read())
-    parser.close()
-    return parser.get_table()
-
-
-def main():
-    global DEBUG
-    #
-    opts, args = getopt.getopt(sys.argv[1:], "D", ["debug"])
-    for opt, arg in opts:
-        if opt in ("-D", "--debug"):
-            DEBUG = DEBUG + 1
-    if len(args) == 0:
-        ifp = sys.stdin
-        ofp = sys.stdout
-    elif len(args) == 1:
-        ifp = open(args)
-        ofp = sys.stdout
-    elif len(args) == 2:
-        ifp = open(args[0])
-        ofp = open(args[1], "w")
-    else:
-        usage()
-        sys.exit(2)
-
-    table = load_table(open(os.path.join(sys.path[0], 'conversion.xml')))
-    convert(ifp, ofp, table)
-
-
-if __name__ == "__main__":
-    main()
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/sgmlconv/Makefile hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/sgmlconv/Makefile
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/sgmlconv/Makefile	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/sgmlconv/Makefile	1970-01-01 01:00:00.000000000 +0100
@@ -1,67 +0,0 @@
-# Simple makefile to control XML generation for the entire document tree.
-# This should be used from the top-level directory (Doc/), not the directory
-# that actually contains this file:
-#
-#  $ pwd
-#  .../Doc
-#  $ make -f tools/sgmlconv/Makefile
-
-TOPDIR=.
-TOOLSDIR=tools
-
-SGMLRULES=../$(TOOLSDIR)/sgmlconv/make.rules
-# The 'inst' directory breaks the conversion, so skip it for now.
-SUBDIRS=api dist ext lib mac ref tut
-SUBMAKE=$(MAKE) -f $(SGMLRULES) TOOLSDIR=../$(TOOLSDIR)
-
-all:	xml
-
-.PHONY: esis xml
-.PHONY: $(SUBDIRS)
-
-xml:
-	for DIR in $(SUBDIRS) ; do \
-	    (cd $$DIR; $(SUBMAKE) xml) || exit $$? ; done
-
-esis:
-	for DIR in $(SUBDIRS) ; do \
-	    (cd $$DIR; $(SUBMAKE) esis) || exit $$? ; done
-
-esis1:
-	for DIR in $(SUBDIRS) ; do \
-	    (cd $$DIR; $(SUBMAKE) esis1) || exit $$? ; done
-
-tarball:  xml
-	tar cf - tools/sgmlconv */*.xml | gzip -9 >xml-1.5.2b2.tgz
-
-api:
-	cd api; $(SUBMAKE)
-
-dist:
-	cd dist; $(SUBMAKE)
-
-ext:
-	cd ext; $(SUBMAKE)
-
-inst:
-	cd inst; $(SUBMAKE)
-
-lib:
-	cd lib; $(SUBMAKE)
-
-mac:
-	cd mac; $(SUBMAKE)
-
-ref:
-	cd ref; $(SUBMAKE)
-
-tut:
-	cd tut; $(SUBMAKE)
-
-clean:
-	for DIR in $(SUBDIRS) ; do \
-	    (cd $$DIR; $(SUBMAKE) clean) ; done
-
-clobber:
-	for DIR in $(SUBDIRS) ; do \
-	    (cd $$DIR; $(SUBMAKE) clobber) ; done
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/sgmlconv/make.rules hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/sgmlconv/make.rules
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/sgmlconv/make.rules	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/sgmlconv/make.rules	1970-01-01 01:00:00.000000000 +0100
@@ -1,48 +0,0 @@
-# -*- makefile -*-
-#
-# Extra magic needed by the LaTeX->XML conversion process.  This requires
-# $(TOOLSDIR) to be properly defined.
-
-DOCFIXER=	$(TOOLSDIR)/sgmlconv/docfixer.py
-ESIS2ML=	$(TOOLSDIR)/sgmlconv/esis2sgml.py
-LATEX2ESIS=	$(TOOLSDIR)/sgmlconv/latex2esis.py
-CONVERSION=	$(TOOLSDIR)/sgmlconv/conversion.xml
-
-ESISTARGETS=	$(patsubst %.tex,%.esis,$(wildcard *.tex))
-ESIS1TARGETS=	$(patsubst %.tex,%.esis1,$(wildcard *.tex))
-XMLTARGETS=	$(patsubst %.tex,%.xml,$(wildcard *.tex))
-
-L2EFLAGS=
-
-all:	xml
-
-esis:	$(ESISTARGETS)
-esis1:	$(ESIS1TARGETS)
-xml:	$(XMLTARGETS)
-
-ESISTOOLS=	$(TOOLSDIR)/sgmlconv/esistools.py
-
-$(ESISTARGETS): $(LATEX2ESIS) $(DOCFIXER) $(ESISTOOLS) $(CONVERSION)
-$(ESIS1TARGETS): $(LATEX2ESIS) $(CONVERSION)
-# This variant is easier to work with while debugging the conversion spec:
-#$(ESISTARGETS): $(LATEX2ESIS) $(DOCFIXER) $(ESISTOOLS)
-$(XMLTARGETS): $(ESIS2ML)
-
-
-.SUFFIXES: .esis .esis1 .tex .xml
-
-.tex.esis1:
-	$(LATEX2ESIS) $(L2EFLAGS) $< $@
-
-.esis1.esis:
-	$(DOCFIXER) $< $@
-
-.esis.xml:
-	$(ESIS2ML) --xml $< $@
-
-
-clean:
-	rm -f *.esis *.esis1
-
-clobber: clean
-	rm -f *.xml
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/sgmlconv/README hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/sgmlconv/README
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/sgmlconv/README	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/sgmlconv/README	1970-01-01 01:00:00.000000000 +0100
@@ -1,58 +0,0 @@
-These scripts and Makefile fragment are used to convert the Python
-documentation in LaTeX format to XML.
-
-This material is preliminary and incomplete.  Python 2.0 is required.
-
-To convert all documents to XML:
-
-	cd Doc/
-	make -f tools/sgmlconv/Makefile
-
-To convert one document to XML:
-
-	cd Doc/<document-dir>
-	make -f ../tools/sgmlconv/make.rules TOOLSDIR=../tools
-
-Please send comments and bug reports to python-docs@python.org.
-
-
-What do the tools do?
----------------------
-
-latex2esis.py
-    Reads in a conversion specification written in XML
-    (conversion.xml), reads a LaTeX document fragment, and interprets
-    the markup according to the specification.  The output is a stream
-    of ESIS events like those created by the nsgmls SGML parser, but
-    is *not* guaranteed to represent a single tree!  This is done to
-    allow conversion per entity rather than per document.  Since many
-    of the LaTeX files for the Python documentation contain two
-    sections on closely related modules, it is important to allow both
-    of the resulting <section> elements to exist in the same output
-    stream.  Additionally, since comments are not supported in ESIS,
-    comments are converted to <COMMENT> elements, which might exist at
-    the same level as the top-level content elements.
-
-    The output of latex2esis.py gets saved as <filename>.esis1.
-
-docfixer.py
-    This is the really painful part of the conversion.  Well, it's the 
-    second really painful part, but more of the pain is specific to
-    the structure of the Python documentation and desired output
-    rather than to the parsing of LaTeX markup.
-
-    This script loads the ESIS data created by latex2esis.py into a
-    DOM document *fragment* (remember, the latex2esis.py output may
-    not be well-formed).  Once loaded, it walks over the tree many
-    times looking for a variety of possible specific
-    micro-conversions.  Most of the code is not in any way "general".
-    After processing the fragment, a new ESIS data stream is written
-    out.  Like the input, it may not represent a well-formed
-    document, but does represent a parsed entity.
-
-    The output of docfixer.py is what gets saved in <filename>.esis.
-
-esis2sgml.py
-    Reads an ESIS stream and convert to SGML or XML.  This also
-    converts <COMMENT> elements to real comments.  This works quickly
-    because there's not much to actually do.
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/support.py hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/support.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/support.py	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/support.py	1970-01-01 01:00:00.000000000 +0100
@@ -1,149 +0,0 @@
-"""Miscellaneous support code shared by some of the tool scripts.
-
-This includes option parsing code, HTML formatting code, and a couple of
-useful helpers.
-
-"""
-__version__ = '$Revision: 1.1.1.1 $'
-
-
-import getopt
-import string
-import sys
-
-
-class Options:
-    __short_args = "a:c:ho:"
-    __long_args = [
-        # script controls
-        "columns=", "help", "output=",
-
-        # content components
-        "address=", "iconserver=",
-        "title=", "uplink=", "uptitle="]
-
-    outputfile = "-"
-    columns = 1
-    letters = 0
-    uplink = "./"
-    uptitle = "Python Documentation Index"
-
-    def __init__(self):
-        self.args = []
-        self.variables = {"address": "",
-                          "iconserver": "icons",
-                          "imgtype": "gif",
-                          "title": "Global Module Index",
-                          }
-
-    def add_args(self, short=None, long=None):
-        if short:
-            self.__short_args = self.__short_args + short
-        if long:
-            self.__long_args = self.__long_args + long
-
-    def parse(self, args):
-        try:
-            opts, args = getopt.getopt(args, self.__short_args,
-                                       self.__long_args)
-        except getopt.error:
-            sys.stdout = sys.stderr
-            self.usage()
-            sys.exit(2)
-        self.args = self.args + args
-        for opt, val in opts:
-            if opt in ("-a", "--address"):
-                val = string.strip(val)
-                if val:
-                    val = "<address>\n%s\n</address>\n" % val
-                    self.variables["address"] = val
-            elif opt in ("-h", "--help"):
-                self.usage()
-                sys.exit()
-            elif opt in ("-o", "--output"):
-                self.outputfile = val
-            elif opt in ("-c", "--columns"):
-                self.columns = int(val)
-            elif opt == "--title":
-                self.variables["title"] = val.strip()
-            elif opt == "--uplink":
-                self.uplink = val.strip()
-            elif opt == "--uptitle":
-                self.uptitle = val.strip()
-            elif opt == "--iconserver":
-                self.variables["iconserver"] = val.strip() or "."
-            else:
-                self.handle_option(opt, val)
-        if self.uplink and self.uptitle:
-            self.variables["uplinkalt"] = "up"
-            self.variables["uplinkicon"] = "up"
-        else:
-            self.variables["uplinkalt"] = ""
-            self.variables["uplinkicon"] = "blank"
-        self.variables["uplink"] = self.uplink
-        self.variables["uptitle"] = self.uptitle
-
-    def handle_option(self, opt, val):
-        raise getopt.error("option %s not recognized" % opt)
-
-    def get_header(self):
-        return HEAD % self.variables
-
-    def get_footer(self):
-        return TAIL % self.variables
-
-    def get_output_file(self, filename=None):
-        if filename is None:
-            filename = self.outputfile
-        if filename == "-":
-            return sys.stdout
-        else:
-            return open(filename, "w")
-
-
-NAVIGATION = '''\
-<div class="navigation">
-<table width="100%%" cellpadding="0" cellspacing="2">
-<tr>
-<td><img width="32" height="32" align="bottom" border="0" alt=""
- src="%(iconserver)s/blank.%(imgtype)s"></td>
-<td><a href="%(uplink)s"
- title="%(uptitle)s"><img width="32" height="32" align="bottom" border="0"
- alt="%(uplinkalt)s"
- src="%(iconserver)s/%(uplinkicon)s.%(imgtype)s"></a></td>
-<td><img width="32" height="32" align="bottom" border="0" alt=""
- src="%(iconserver)s/blank.%(imgtype)s"></td>
-<td align="center" width="100%%">%(title)s</td>
-<td><img width="32" height="32" align="bottom" border="0" alt=""
- src="%(iconserver)s/blank.%(imgtype)s"></td>
-<td><img width="32" height="32" align="bottom" border="0" alt=""
- src="%(iconserver)s/blank.%(imgtype)s"></td>
-<td><img width="32" height="32" align="bottom" border="0" alt=""
- src="%(iconserver)s/blank.%(imgtype)s"></td>
-</tr></table>
-<b class="navlabel">Up:</b> <span class="sectref"><a href="%(uplink)s"
- title="%(uptitle)s">%(uptitle)s</A></span>
-<br></div>
-'''
-
-HEAD = '''\
-<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
-<html>
-<head>
-  <title>%(title)s</title>
-  <meta name="description" content="%(title)s">
-  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
-  <link rel="STYLESHEET" href="lib/lib.css">
-</head>
-<body>
-''' + NAVIGATION + '''\
-<hr>
-
-<h2>%(title)s</h2>
-
-'''
-
-TAIL = "<hr>\n" + NAVIGATION + '''\
-%(address)s</body>
-</html>
-'''
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/templates/howto.tex hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/templates/howto.tex
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/templates/howto.tex	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/templates/howto.tex	1970-01-01 01:00:00.000000000 +0100
@@ -1,105 +0,0 @@
-\documentclass{howto}
-
-%  This is a template for short or medium-size Python-related documents, 
-% mostly notably the series of HOWTOs, but it can be used for any
-% document you like.   
-
-% The title should be descriptive enough for people to be able to find
-% the relevant document. 
-\title{Spammifying Sprockets in Python}
-
-% Increment the release number whenever significant changes are made.
-% The author and/or editor can define 'significant' however they like.
-\release{0.00}
-
-% At minimum, give your name and an e-mail address.  You can include a
-% snail-mail address if you like.
-\author{Me, 'cause I wrote it}
-\authoraddress{Me, 'cause I'm self-employed.}
-
-\begin{document}
-\maketitle
-
-% This makes the Abstract go on a separate page in the HTML version;
-% if a copyright notice is used, it should go immediately after this.
-%
-\ifhtml
-\chapter*{Front Matter\label{front}}
-\fi
-
-% Copyright statement should go here, if needed.
-% ...
-
-% The abstract should be a paragraph or two long, and describe the
-% scope of the document.
-\begin{abstract}
-\noindent
-This document describes how to spammify sprockets.  It is a useful
-example of a Python HOWTO document.  It is not dependent on any
-particular sprocket implementation, and includes a Python-based
-implementation in the \module{sprunkit} module.
-\end{abstract}
-
-\tableofcontents
-
-Spammifying sprockets from Python is both fun and entertaining.
-Applying the techniques described here, you can also fill your hard
-disk quite effectively.
-
-\section{What is Sprocket Spammification?}
-
-You have to ask?  It's the only thing to do to your sprockets!
-
-
-\section{Why Use Python?}
-
-Python is an excellent language from which to spammify your sprockets
-since you can do it on any platform.
-
-
-\section{Software Requirements}
-
-You need to have the following software installed:
-
-% The {itemize} environment uses a bullet for each \item.  If you want the 
-% \item's numbered, use the {enumerate} environment instead.
-\begin{itemize}
-  \item  Python 1.9.
-  \item  Some sprocket definition files.
-  \item  At least one sprocket system implementation.
-\end{itemize}
-
-Note that the \module{sprunkit} is provided with this package and
-implements ActiveSprockets in Python.
-
-
-% The preceding sections will have been written in a gentler,
-% introductory style.  You may also wish to include a reference
-% section, documenting all the functions/exceptions/constants.
-% Often, these will be placed in separate files and input like this:
-
-\input{module}
-
-
-\appendix
-
-\section{This is an Appendix}
-
-To create an appendix in a Python HOWTO document, use markup like
-this:
-
-\begin{verbatim}
-\appendix
-
-\section{This is an Appendix}
-
-To create an appendix in a Python HOWTO document, ....
-
-
-\section{This is another}
-
-Just add another \section{}, but don't say \appendix again.
-\end{verbatim}
-
-
-\end{document}
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/templates/manual.tex hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/templates/manual.tex
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/templates/manual.tex	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/templates/manual.tex	1970-01-01 01:00:00.000000000 +0100
@@ -1,82 +0,0 @@
-\documentclass{manual}
-
-\title{Big Python Manual}
-
-\author{Your Name Here}
-
-% Please at least include a long-lived email address;
-% the rest is at your discretion.
-\authoraddress{
-	Organization name, if applicable \\
-	Street address, if you want to use it \\
-	E-mail: \email{your-email@your.domain}
-}
-
-\date{April 30, 1999}		% update before release!
-				% Use an explicit date so that reformatting
-				% doesn't cause a new date to be used.  Setting
-				% the date to \today can be used during draft
-				% stages to make it easier to handle versions.
-
-\release{x.y}			% release version; this is used to define the
-				% \version macro
-
-\makeindex			% tell \index to actually write the .idx file
-\makemodindex			% If this contains a lot of module sections.
-
-
-\begin{document}
-
-\maketitle
-
-% This makes the contents more accessible from the front page of the HTML.
-\ifhtml
-\chapter*{Front Matter\label{front}}
-\fi
-
-%\input{copyright}
-
-\begin{abstract}
-
-\noindent
-Big Python is a special version of Python for users who require larger 
-keys on their keyboards.  It accomodates their special needs by ...
-
-\end{abstract}
-
-\tableofcontents
-
-
-\chapter{...}
-
-My chapter.
-
-
-\appendix
-\chapter{...}
-
-My appendix.
-
-The \code{\e appendix} markup need not be repeated for additional
-appendices.
-
-
-%
-%  The ugly "%begin{latexonly}" pseudo-environments are really just to
-%  keep LaTeX2HTML quiet during the \renewcommand{} macros; they're
-%  not really valuable.
-%
-%  If you don't want the Module Index, you can remove all of this up
-%  until the second \input line.
-%
-%begin{latexonly}
-\renewcommand{\indexname}{Module Index}
-%end{latexonly}
-\input{mod\jobname.ind}		% Module Index
-
-%begin{latexonly}
-\renewcommand{\indexname}{Index}
-%end{latexonly}
-\input{\jobname.ind}			% Index
-
-\end{document}
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/templates/module.tex hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/templates/module.tex
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/templates/module.tex	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/templates/module.tex	1970-01-01 01:00:00.000000000 +0100
@@ -1,163 +0,0 @@
-% Template for a library manual section.
-% PLEASE REMOVE THE COMMENTS AFTER USING THE TEMPLATE
-
-% ==== 0. ====
-% Copy this file to <mydir>/lib<mymodule>.tex, and edit that file
-% according to the instructions below.
-
-
-% ==== 1. ====
-% The section prologue.  Give the section a title and provide some
-% meta-information.  References to the module should use
-% \refbimodindex, \refstmodindex, \refexmodindex or \refmodindex, as
-% appropriate.
-
-\section{\module{spam} ---
-         Short descrition, for section title}
-
-% Choose one of these to specify the module module name.  If there's
-% an underscore in the name, use
-% \declaremodule[modname]{...}{mod_name} instead.
-%
-\declaremodule{builtin}{spam}		% standard library, in C
-\declaremodule{standard}{spam}		% standard library, in Python
-\declaremodule{extension}{spam}		% not standard, in C
-\declaremodule{}{spam}			% not standard, in Python
-
-% Portability statement:  Uncomment and fill in the parameter to specify the
-% availability of the module.  The parameter can be Unix, IRIX, SunOS, Mac,
-% Windows, or lots of other stuff.  When ``Mac'' is specified, the availability
-% statement will say ``Macintosh'' and the Module Index may say ``Mac''.
-% Please use a name that has already been used whenever applicable.  If this
-% is omitted, no availability statement is produced or implied.
-%
-%   \platform{UNIX}
-
-% These apply to all modules:
-
-\moduleauthor{name}{email}		% Author of the module code;
-					% omit if not known.
-\sectionauthor{name}{email}		% Author of the documentation,
-					% even if not a module section.
-
-
-% Leave at least one blank line after this, to simplify ad-hoc tools
-% that are sometimes used to massage these files.
-\modulesynopsis{This is a one-line descrition, for the chapter header.}
-
-
-% ==== 2. ====
-% Give a short overview of what the module does.
-% If it is platform specific, mention this.
-% Mention other important restrictions or general operating principles.
-% For example:
-
-The \module{spam} module defines operations for handling cans of Spam.
-It knows the four generally available Spam varieties and understands
-both can sizes.
-
-Because spamification requires \UNIX{} process management, the module
-is only available on genuine \UNIX{} systems.
-
-
-% ==== 3. ====
-% List the public functions defined by the module.  Begin with a
-% standard phrase.  You may also list the exceptions and other data
-% items defined in the module, insofar as they are important for the
-% user.
-
-The \module{spam} module defines the following functions:
-
-% ---- 3.1. ----
-% For each function, use a ``funcdesc'' block.  This has exactly two
-% parameters (each parameters is contained in a set of curly braces):
-% the first parameter is the function name (this automatically
-% generates an index entry); the second parameter is the function's
-% argument list.  If there are no arguments, use an empty pair of
-% curly braces.  If there is more than one argument, separate the
-% arguments with backslash-comma.  Optional parts of the parameter
-% list are contained in \optional{...} (this generates a set of square
-% brackets around its parameter).  Arguments are automatically set in
-% italics in the parameter list.  Each argument should be mentioned at
-% least once in the description; each usage (even inside \code{...})
-% should be enclosed in \var{...}.
-
-\begin{funcdesc}{open}{filename\optional{, mode\optional{, buffersize}}}
-Open the file \var{filename} as a can of Spam.  The optional
-\var{mode} and \var{buffersize} arguments specify the read/write mode
-(\code{'r'} (default) or \code{'w'}) and the buffer size (default:
-system dependent).
-\end{funcdesc}
-
-% ---- 3.2. ----
-% Data items are described using a ``datadesc'' block.  This has only
-% one parameter: the item's name.
-
-\begin{datadesc}{cansize}
-The default can size, in ounces.  Legal values are 7 and 12.  The
-default varies per supermarket.  This variable should not be changed
-once the \function{open()} function has been called.
-\end{datadesc}
-
-% --- 3.3. ---
-% Exceptions are described using a ``excdesc'' block.  This has only
-% one parameter: the exception name.  Exceptions defined as classes in
-% the source code should be documented using this environment, but
-% constructor parameters must be ommitted.
-
-\begin{excdesc}{error}
-Exception raised when an operation fails for a Spam specific reason.
-The exception argument is a string describing the reason of the
-failure.
-\end{excdesc}
-
-% ---- 3.4. ----
-% Other standard environments:
-%
-%  classdesc	- Python classes; same arguments are funcdesc
-%  methoddesc	- methods, like funcdesc but has an optional parameter 
-%		  to give the type name: \begin{methoddesc}[mytype]{name}{args}
-%		  By default, the type name will be the name of the
-%		  last class defined using classdesc.  The type name
-%		  is required if the type is implemented in C (because 
-%		  there's no classdesc) or if the class isn't directly 
-%		  documented (if it's private).
-%  memberdesc	- data members, like datadesc, but with an optional
-%		  type name like methoddesc.
-
-
-% ==== 4. ====
-% Now is probably a good time for a complete example.  (Alternatively,
-% an example giving the flavor of the module may be given before the
-% detailed list of functions.)
-
-\subsection{Example \label{spam-example}}
-
-The following example demonstrates how to open a can of spam using the
-\module{spam} module.
-
-\begin{verbatim}
->>> import spam
->>> can = spam.open('/etc/passwd')
->>> can.empty()
->>> can.close()
-\end{verbatim}
-% Note that there is no trailing ">>> " prompt shown.
-
-% ==== 5. ====
-% If your module defines new object types (for a built-in module) or
-% classes (for a module written in Python), you should list the
-% methods and instance variables (if any) of each type or class in a
-% separate subsection.
-
-\subsection{Spam Objects}
-\label{spam-objects}
-% This label is generally useful for referencing this section, but is
-% also used to give a filename when generating HTML.
-
-Spam objects, as returned by \function{open()} above, have the
-following methods:
-
-\begin{methoddesc}[spam]{empty}{}
-Empty the can into the trash.
-\end{methoddesc}
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/texinputs/boilerplate.tex hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/texinputs/boilerplate.tex
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/texinputs/boilerplate.tex	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/texinputs/boilerplate.tex	1970-01-01 01:00:00.000000000 +0100
@@ -1,10 +0,0 @@
-\author{Guido van Rossum\\
-	Fred L. Drake, Jr., editor}
-\authoraddress{
-	\strong{PythonLabs}\\
-	E-mail: \email{python-docs@python.org}
-}
-
-\date{April 15, 2001}		% XXX update before release!
-\release{2.1}			% software release, not documentation
-\setshortversion{2.1}		% major.minor only for software
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/texinputs/copyright.tex hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/texinputs/copyright.tex
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/texinputs/copyright.tex	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/texinputs/copyright.tex	1970-01-01 01:00:00.000000000 +0100
@@ -1,108 +0,0 @@
-\begin{small}
-Copyright \copyright{} 2001 Python Software Foundation.
-All rights reserved.
-
-Copyright \copyright{} 2000 BeOpen.com.
-All rights reserved.
-
-Copyright \copyright{} 1995-2000 Corporation for National Research Initiatives.
-All rights reserved.
-
-Copyright \copyright{} 1991-1995 Stichting Mathematisch Centrum.
-All rights reserved.
-
-%%begin{latexonly}
-\vskip 4mm
-%%end{latexonly}
-
-\centerline{\strong{BEOPEN.COM TERMS AND CONDITIONS FOR PYTHON 2.0}}
-
-\centerline{\strong{BEOPEN PYTHON OPEN SOURCE LICENSE AGREEMENT VERSION 1}}
-
-\begin{enumerate}
-
-\item
-This LICENSE AGREEMENT is between BeOpen.com (``BeOpen''), having an
-office at 160 Saratoga Avenue, Santa Clara, CA 95051, and the
-Individual or Organization (``Licensee'') accessing and otherwise
-using this software in source or binary form and its associated
-documentation (``the Software'').
-
-\item
-Subject to the terms and conditions of this BeOpen Python License
-Agreement, BeOpen hereby grants Licensee a non-exclusive,
-royalty-free, world-wide license to reproduce, analyze, test, perform
-and/or display publicly, prepare derivative works, distribute, and
-otherwise use the Software alone or in any derivative version,
-provided, however, that the BeOpen Python License is retained in the
-Software, alone or in any derivative version prepared by Licensee.
-
-\item
-BeOpen is making the Software available to Licensee on an ``AS IS''
-basis.  BEOPEN MAKES NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR
-IMPLIED.  BY WAY OF EXAMPLE, BUT NOT LIMITATION, BEOPEN MAKES NO AND
-DISCLAIMS ANY REPRESENTATION OR WARRANTY OF MERCHANTABILITY OR FITNESS
-FOR ANY PARTICULAR PURPOSE OR THAT THE USE OF THE SOFTWARE WILL NOT
-INFRINGE ANY THIRD PARTY RIGHTS.
-
-\item
-BEOPEN SHALL NOT BE LIABLE TO LICENSEE OR ANY OTHER USERS OF THE
-SOFTWARE FOR ANY INCIDENTAL, SPECIAL, OR CONSEQUENTIAL DAMAGES OR LOSS
-AS A RESULT OF USING, MODIFYING OR DISTRIBUTING THE SOFTWARE, OR ANY
-DERIVATIVE THEREOF, EVEN IF ADVISED OF THE POSSIBILITY THEREOF.
-
-\item
-This License Agreement will automatically terminate upon a material
-breach of its terms and conditions.
-
-\item
-This License Agreement shall be governed by and interpreted in all
-respects by the law of the State of California, excluding conflict of
-law provisions.  Nothing in this License Agreement shall be deemed to
-create any relationship of agency, partnership, or joint venture
-between BeOpen and Licensee.  This License Agreement does not grant
-permission to use BeOpen trademarks or trade names in a trademark
-sense to endorse or promote products or services of Licensee, or any
-third party.  As an exception, the ``BeOpen Python'' logos available
-at http://www.pythonlabs.com/logos.html may be used according to the
-permissions granted on that web page.
-
-\item
-By copying, installing or otherwise using the software, Licensee
-agrees to be bound by the terms and conditions of this License
-Agreement.
-\end{enumerate}
-
-
-\centerline{\strong{CNRI OPEN SOURCE GPL-COMPATIBLE LICENSE AGREEMENT}}
-
-Python 1.6.1 is made available subject to the terms and conditions in
-CNRI's License Agreement.  This Agreement together with Python 1.6.1 may
-be located on the Internet using the following unique, persistent
-identifier (known as a handle): 1895.22/1013.  This Agreement may also
-be obtained from a proxy server on the Internet using the following
-URL: \url{http://hdl.handle.net/1895.22/1013}.
-
-
-\centerline{\strong{CWI PERMISSIONS STATEMENT AND DISCLAIMER}}
-
-Copyright \copyright{} 1991 - 1995, Stichting Mathematisch Centrum
-Amsterdam, The Netherlands.  All rights reserved.
-
-Permission to use, copy, modify, and distribute this software and its
-documentation for any purpose and without fee is hereby granted,
-provided that the above copyright notice appear in all copies and that
-both that copyright notice and this permission notice appear in
-supporting documentation, and that the name of Stichting Mathematisch
-Centrum or CWI not be used in advertising or publicity pertaining to
-distribution of the software without specific, written prior
-permission.
-
-STICHTING MATHEMATISCH CENTRUM DISCLAIMS ALL WARRANTIES WITH REGARD TO
-THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
-FITNESS, IN NO EVENT SHALL STICHTING MATHEMATISCH CENTRUM BE LIABLE
-FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
-WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
-ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
-OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
-\end{small}
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/texinputs/distutils.sty hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/texinputs/distutils.sty
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/texinputs/distutils.sty	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/texinputs/distutils.sty	1970-01-01 01:00:00.000000000 +0100
@@ -1,33 +0,0 @@
-%
-% LaTeX commands and macros needed for the two Distutils manuals,
-% inst.tex and dist.tex.
-%
-% $Id: distutils.sty,v 1.1.1.1 2001/07/16 11:53:03 msjogren Exp $
-%
-
-% My gripe list about the Python style files:
-%  * I want italics in verbatim environments for variable
-%    text (verbatim.sty?)
-%  * I hate escaping underscores (url.sty fixes this)
-
-% '\command' is for Distutils commands which, depending on your
-% perspective, are just arguments to the setup script, or sub-
-% commands of the setup script, or the classes that implement
-% each "command".
-\newcommand{\command}[1]{\code{#1}}
-
-% '\option' is for Distutils options *in* the setup script.  Command-
-% line options *to* the setup script are marked up in the usual
-% way, ie. with '\programopt' or '\longprogramopt'
-\newcommand{\option}[1]{\textsf{\small{#1}}}
-
-% '\filevar' is for variable components of file/path names -- eg.
-% when you put 'prefix' in a pathname, you mark it up with
-% '\filevar' so that it still looks pathname-ish, but is
-% distinguished from the literal part of the path.  Fred says
-% this can be accomplished just fine with '\var', but I violently
-% disagree.  Pistols at dawn will sort this one out.
-\newcommand{\filevar}[1]{{\textsl{\filenq{#1}}}}
-
-% Just while the code and docs are still under development.
-\newcommand{\XXX}[1]{\textbf{**#1**}}
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/texinputs/fncychap.sty hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/texinputs/fncychap.sty
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/texinputs/fncychap.sty	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/texinputs/fncychap.sty	1970-01-01 01:00:00.000000000 +0100
@@ -1,433 +0,0 @@
-%%% Derived from the original fncychap.sty,
-%%% but changed ``TWELV'' to ``TWELVE''.
-
-%%% Copyright   Ulf A. Lindgren
-%%%             Department of Applied Electronics
-%%%             Chalmers University of Technology
-%%%             S-412 96 Gothenburg, Sweden
-%%%             E-mail lindgren@ae.chalmers.se
-%%%
-%%% Note        Permission is granted to modify this file under
-%%%             the condition that it is saved using another
-%%%             file and package name.
-%%%
-%%% Revision    1.1
-%%%
-%%%             Jan. 8th Modified package name base date option
-%%%             Jan. 22th Modified FmN and FmTi for error in book.cls
-%%%                  \MakeUppercase{#}->{\MakeUppercase#}
-%%%             Apr. 6th Modified Lenny option to prevent undesired 
-%%%                  skip of line.
-%%%             Nov. 8th Fixed \@chapapp for AMS
-%%%             Feb. 11th Fixed appendix problem related to Bjarne
-%%% Last modified    Feb. 11th 1998
-
-\NeedsTeXFormat{LaTeX2e}[1995/12/01]
-\ProvidesPackage{fncychap}
-             [1997/04/06 v1.11
-                 LaTeX package (Revised chapters)]
-
-%%%% DEFINITION OF Chapapp variables
-\newcommand{\CNV}{\huge\bfseries}
-\newcommand{\ChNameVar}[1]{\renewcommand{\CNV}{#1}}
-
-
-%%%% DEFINITION OF TheChapter variables
-\newcommand{\CNoV}{\huge\bfseries}
-\newcommand{\ChNumVar}[1]{\renewcommand{\CNoV}{#1}}
-
-\newif\ifUCN
-\UCNfalse
-\newif\ifLCN
-\LCNfalse
-\def\ChNameLowerCase{\LCNtrue\UCNfalse}
-\def\ChNameUpperCase{\UCNtrue\LCNfalse}
-\def\ChNameAsIs{\UCNfalse\LCNfalse}
-
-%%%%% Fix for AMSBook 971008
-
-\@ifundefined{@chapapp}{\let\@chapapp\chaptername}{}
-
-
-%%%%% Fix for Bjarne and appendix 980211
-
-\newif\ifinapp
-\inappfalse
-\renewcommand\appendix{\par
-  \setcounter{chapter}{0}%
-  \setcounter{section}{0}%
-  \inapptrue%
-  \renewcommand\@chapapp{\appendixname}%
-  \renewcommand\thechapter{\@Alph\c@chapter}}
-
-%%%%%
-
-\newcommand{\FmN}[1]{%
-\ifUCN
-   {\MakeUppercase#1}\LCNfalse
-\else
-   \ifLCN
-      {\MakeLowercase#1}\UCNfalse
-   \else #1
-   \fi
-\fi}
-
-
-%%%% DEFINITION OF Title variables
-\newcommand{\CTV}{\Huge\bfseries}
-\newcommand{\ChTitleVar}[1]{\renewcommand{\CTV}{#1}}
-
-%%%% DEFINITION OF the basic rule width
-\newlength{\RW}
-\setlength{\RW}{1pt}
-\newcommand{\ChRuleWidth}[1]{\setlength{\RW}{#1}}
-
-\newif\ifUCT
-\UCTfalse
-\newif\ifLCT
-\LCTfalse
-\def\ChTitleLowerCase{\LCTtrue\UCTfalse}
-\def\ChTitleUpperCase{\UCTtrue\LCTfalse}
-\def\ChTitleAsIs{\UCTfalse\LCTfalse}
-\newcommand{\FmTi}[1]{%
-\ifUCT
-
-   {\MakeUppercase#1}\LCTfalse
-\else
-   \ifLCT
-      {\MakeLowercase#1}\UCTfalse
-   \else #1
-   \fi
-\fi}
-
-
-
-\newlength{\mylen}
-\newlength{\myhi}
-\newlength{\px}
-\newlength{\py}
-\newlength{\pyy}
-\newlength{\pxx}
-
-
-\def\mghrulefill#1{\leavevmode\leaders\hrule\@height #1\hfill\kern\z@}
-
-\newcommand{\DOCH}{%
-  \CNV\FmN{\@chapapp}\space \CNoV\thechapter
-  \par\nobreak
-  \vskip 20\p@
-  }
-\newcommand{\DOTI}[1]{%
-    \CTV\FmTi{#1}\par\nobreak
-    \vskip 40\p@
-    }
-\newcommand{\DOTIS}[1]{%
-    \CTV\FmTi{#1}\par\nobreak
-    \vskip 40\p@
-    }
-
-%%%%%% SONNY DEF
-
-\DeclareOption{Sonny}{%
-  \ChNameVar{\Large\sf}
-  \ChNumVar{\Huge}
-  \ChTitleVar{\Large\sf}
-  \ChRuleWidth{0.5pt}
-  \ChNameUpperCase
-  \renewcommand{\DOCH}{%
-    \raggedleft
-    \CNV\FmN{\@chapapp}\space \CNoV\thechapter
-    \par\nobreak
-    \vskip 40\p@}
-  \renewcommand{\DOTI}[1]{%
-    \CTV\raggedleft\mghrulefill{\RW}\par\nobreak
-    \vskip 5\p@
-    \CTV\FmTi{#1}\par\nobreak
-    \mghrulefill{\RW}\par\nobreak
-    \vskip 40\p@}
-  \renewcommand{\DOTIS}[1]{%
-    \CTV\raggedleft\mghrulefill{\RW}\par\nobreak
-    \vskip 5\p@
-    \CTV\FmTi{#1}\par\nobreak
-    \mghrulefill{\RW}\par\nobreak
-    \vskip 40\p@}
-}
-
-%%%%%% LENNY DEF
-
-\DeclareOption{Lenny}{%
-
-  \ChNameVar{\fontsize{14}{16}\usefont{OT1}{phv}{m}{n}\selectfont}
-  \ChNumVar{\fontsize{60}{62}\usefont{OT1}{ptm}{m}{n}\selectfont}
-  \ChTitleVar{\Huge\bfseries\rm}
-  \ChRuleWidth{1pt}
-  \renewcommand{\DOCH}{%
-    \settowidth{\px}{\CNV\FmN{\@chapapp}}
-    \addtolength{\px}{2pt}
-    \settoheight{\py}{\CNV\FmN{\@chapapp}}
-    \addtolength{\py}{1pt}
-
-    \settowidth{\mylen}{\CNV\FmN{\@chapapp}\space\CNoV\thechapter}
-    \addtolength{\mylen}{1pt}
-    \settowidth{\pxx}{\CNoV\thechapter}
-    \addtolength{\pxx}{-1pt}
-
-    \settoheight{\pyy}{\CNoV\thechapter}
-    \addtolength{\pyy}{-2pt}
-    \setlength{\myhi}{\pyy}
-    \addtolength{\myhi}{-1\py}
-    \par
-    \parbox[b]{\textwidth}{%
-    \rule[\py]{\RW}{\myhi}%
-    \hskip -\RW%
-    \rule[\pyy]{\px}{\RW}%
-    \hskip -\px%
-    \raggedright%
-    \CNV\FmN{\@chapapp}\space\CNoV\thechapter%
-    \hskip1pt%
-    \mghrulefill{\RW}%
-    \rule{\RW}{\pyy}\par\nobreak%
-    \vskip -\baselineskip%
-    \vskip -\pyy%
-    \hskip \mylen%
-    \mghrulefill{\RW}\par\nobreak%
-    \vskip \pyy}%
-    \vskip 20\p@}
- 
-
-  \renewcommand{\DOTI}[1]{%
-    \raggedright
-    \CTV\FmTi{#1}\par\nobreak
-    \vskip 40\p@}
-
-  \renewcommand{\DOTIS}[1]{%
-    \raggedright
-    \CTV\FmTi{#1}\par\nobreak
-    \vskip 40\p@}
- }
-
-
-%%%%%%% GLENN DEF
-
-
-\DeclareOption{Glenn}{%
-  \ChNameVar{\bfseries\Large\sf}
-  \ChNumVar{\Huge}
-  \ChTitleVar{\bfseries\Large\rm}
-  \ChRuleWidth{1pt}
-  \ChNameUpperCase
-  \ChTitleUpperCase
-  \renewcommand{\DOCH}{%
-    \settoheight{\myhi}{\CTV\FmTi{Test}}
-    \setlength{\py}{\baselineskip}
-    \addtolength{\py}{\RW}
-    \addtolength{\py}{\myhi}
-    \setlength{\pyy}{\py}
-    \addtolength{\pyy}{-1\RW}
-     
-    \raggedright
-    \CNV\FmN{\@chapapp}\space\CNoV\thechapter
-    \hskip 3pt\mghrulefill{\RW}\rule[-1\pyy]{2\RW}{\py}\par\nobreak}
-
-  \renewcommand{\DOTI}[1]{%
-    \addtolength{\pyy}{-4pt}
-    \settoheight{\myhi}{\CTV\FmTi{#1}}
-    \addtolength{\myhi}{\py}
-    \addtolength{\myhi}{-1\RW}
-    \vskip -1\pyy
-    \rule{2\RW}{\myhi}\mghrulefill{\RW}\hskip 2pt
-    \raggedleft\CTV\FmTi{#1}\par\nobreak
-    \vskip 80\p@}
-
-  \renewcommand{\DOTIS}[1]{%
-    \setlength{\py}{10pt}
-    \setlength{\pyy}{\py}
-    \addtolength{\pyy}{\RW}
-    \setlength{\myhi}{\baselineskip}
-    \addtolength{\myhi}{\pyy}
-    \mghrulefill{\RW}\rule[-1\py]{2\RW}{\pyy}\par\nobreak
-%    \addtolength{}{}
-\vskip -1\baselineskip
-    \rule{2\RW}{\myhi}\mghrulefill{\RW}\hskip 2pt
-    \raggedleft\CTV\FmTi{#1}\par\nobreak
-    \vskip 60\p@}
-  }
-
-%%%%%%% CONNY DEF
-
-\DeclareOption{Conny}{%
-  \ChNameUpperCase
-  \ChTitleUpperCase  
-  \ChNameVar{\centering\Huge\rm\bfseries}
-  \ChNumVar{\Huge}
-  \ChTitleVar{\centering\Huge\rm}
-  \ChRuleWidth{2pt}
-
-  \renewcommand{\DOCH}{%
-    \mghrulefill{3\RW}\par\nobreak
-    \vskip -0.5\baselineskip
-    \mghrulefill{\RW}\par\nobreak
-    \CNV\FmN{\@chapapp}\space \CNoV\thechapter
-    \par\nobreak
-    \vskip -0.5\baselineskip
-   }
-  \renewcommand{\DOTI}[1]{%
-    \mghrulefill{\RW}\par\nobreak
-    \CTV\FmTi{#1}\par\nobreak
-    \vskip 60\p@
-    }
-  \renewcommand{\DOTIS}[1]{%
-    \mghrulefill{\RW}\par\nobreak
-    \CTV\FmTi{#1}\par\nobreak
-    \vskip 60\p@
-    }
-  }
-
-%%%%%%% REJNE DEF
-
-\DeclareOption{Rejne}{%
-
-  \ChNameUpperCase
-  \ChTitleUpperCase  
-  \ChNameVar{\centering\Large\rm}
-  \ChNumVar{\Huge}
-  \ChTitleVar{\centering\Huge\rm}
-  \ChRuleWidth{1pt}
-  \renewcommand{\DOCH}{%
-    \settoheight{\py}{\CNoV\thechapter}
-    \addtolength{\py}{-1pt}
-    \CNV\FmN{\@chapapp}\par\nobreak
-    \vskip 20\p@
-    \setlength{\myhi}{2\baselineskip}
-    \setlength{\px}{\myhi}
-    \addtolength{\px}{-1\RW}
-    \rule[-1\px]{\RW}{\myhi}\mghrulefill{\RW}\hskip
-    10pt\raisebox{-0.5\py}{\CNoV\thechapter}\hskip
-10pt\mghrulefill{\RW}\rule[-1\px]{\RW}{\myhi}\par\nobreak
-     \vskip -1\p@
-    }
-  \renewcommand{\DOTI}[1]{%
-    \setlength{\mylen}{\textwidth}
-    \addtolength{\mylen}{-2\RW}
-    {\vrule width\RW}\parbox{\mylen}{\CTV\FmTi{#1}}{\vrule
-width\RW}\par\nobreak
-    \vskip
--1pt\rule{\RW}{2\baselineskip}\mghrulefill{\RW}\rule{\RW}{2\baselineskip}
-    \vskip 60\p@
-    }
-  \renewcommand{\DOTIS}[1]{%
-    \setlength{\py}{\fboxrule}
-    \setlength{\fboxrule}{\RW}
-    \setlength{\mylen}{\textwidth}
-    \addtolength{\mylen}{-2\RW}
-    \fbox{\parbox{\mylen}{\vskip
-2\baselineskip\CTV\FmTi{#1}\par\nobreak\vskip \baselineskip}} 
-    \setlength{\fboxrule}{\py}
-    \vskip 60\p@
-    }
-  }
-
-
-%%%%%%% BJARNE DEF
-
-\DeclareOption{Bjarne}{%
-  \ChNameUpperCase
-  \ChTitleUpperCase  
-  \ChNameVar{\raggedleft\normalsize\rm}
-  \ChNumVar{\raggedleft \bfseries\Large}
-  \ChTitleVar{\raggedleft \Large\rm}
-  \ChRuleWidth{1pt}
-
-
-%% Note thechapter -> c@chapter fix appendix bug
-
-  \newcounter{AlphaCnt}
-  \newcounter{AlphaDecCnt}
-  \newcommand{\AlphaNo}{%
-    \ifcase\number\theAlphaCnt
-      \ifnum\c@chapter=0
-        ZERO\else{}\fi
-    \or ONE\or TWO\or THREE\or FOUR\or FIVE
-    \or SIX\or SEVEN\or EIGHT\or NINE\or TEN
-    \or ELEVEN\or TWELVE\or THIRTEEN\or FOURTEEN\or FIFTEEN
-    \or SIXTEEN\or SEVENTEEN\or EIGHTEEN\or NINETEEN\fi
-}
-
-  \newcommand{\AlphaDecNo}{%
-    \setcounter{AlphaDecCnt}{0}
-    \@whilenum\number\theAlphaCnt>0\do
-      {\addtocounter{AlphaCnt}{-10}
-       \addtocounter{AlphaDecCnt}{1}}
-     \ifnum\number\theAlphaCnt=0
-     \else
-       \addtocounter{AlphaDecCnt}{-1}
-       \addtocounter{AlphaCnt}{10}
-     \fi
-     
-     
-    \ifcase\number\theAlphaDecCnt\or TEN\or TWENTY\or THIRTY\or
-    FORTY\or FIFTY\or SIXTY\or SEVENTY\or EIGHTY\or NINETY\fi
-    }
-  \newcommand{\TheAlphaChapter}{%
-    
-    \ifinapp 
-      \thechapter
-    \else
-      \setcounter{AlphaCnt}{\c@chapter}
-      \ifnum\c@chapter<20
-        \AlphaNo
-      \else
-        \AlphaDecNo\AlphaNo
-      \fi
-    \fi
-    }  
-  \renewcommand{\DOCH}{%
-    \mghrulefill{\RW}\par\nobreak
-    \CNV\FmN{\@chapapp}\par\nobreak 
-    \CNoV\TheAlphaChapter\par\nobreak
-    \vskip -1\baselineskip\vskip 5pt\mghrulefill{\RW}\par\nobreak
-    \vskip 20\p@
-    }
-  \renewcommand{\DOTI}[1]{%
-    \CTV\FmTi{#1}\par\nobreak
-    \vskip 40\p@
-    }
-  \renewcommand{\DOTIS}[1]{%
-    \CTV\FmTi{#1}\par\nobreak
-    \vskip 40\p@
-    }
-}
-
-\DeclareOption*{%
-  \PackageWarning{fancychapter}{unknown style option}
-  }
-
-\ProcessOptions* \relax
-
-\def\@makechapterhead#1{%
-  \vspace*{50\p@}%
-  {\parindent \z@ \raggedright \normalfont
-    \ifnum \c@secnumdepth >\m@ne
-      \DOCH
-    \fi
-    \interlinepenalty\@M
-    \DOTI{#1}
-  }}
-\def\@schapter#1{\if@twocolumn
-                   \@topnewpage[\@makeschapterhead{#1}]%
-                 \else
-                   \@makeschapterhead{#1}%
-                   \@afterheading
-                 \fi}
-\def\@makeschapterhead#1{%
-  \vspace*{50\p@}%
-  {\parindent \z@ \raggedright
-    \normalfont
-    \interlinepenalty\@M
-    \DOTIS{#1}
-    \vskip 40\p@
-  }}
-
-\endinput
-
-
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/texinputs/howto.cls hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/texinputs/howto.cls
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/texinputs/howto.cls	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/texinputs/howto.cls	1970-01-01 01:00:00.000000000 +0100
@@ -1,106 +0,0 @@
-%
-% howto.cls for the Python documentation
-%
-
-\NeedsTeXFormat{LaTeX2e}[1995/12/01]
-\ProvidesClass{howto}
-             [1998/02/25 Document class (Python HOWTO)]
-
-\RequirePackage{pypaper}
-
-% Change the options here to get a different set of basic options,  This
-% is where to add things like "a4paper" or "10pt".
-%
-\LoadClass[twoside]{article}
-
-\setcounter{secnumdepth}{1}
-
-% Optional packages:
-%
-% If processing of these documents fails at your TeX installation,
-% these may be commented out (independently) to make things work.
-% These are both supplied with the current version of the teTeX
-% distribution.
-%
-% The "fancyhdr" package makes nicer page footers reasonable to
-% implement, and is used to put the chapter and section information in 
-% the footers.
-%
-\RequirePackage{fancyhdr}\typeout{Using fancier footers than usual.}
-
-
-% Required package:
-%
-% This gives us all the Python-specific markup that we really want.
-% This should come last.  Do not change this.
-%
-\RequirePackage{python}
-
-% support for module synopsis sections:
-\newcommand{\py@ModSynopsisFilename}{\jobname.syn}
-
-
-% need to do one of these....
-\newcommand{\py@doHorizontalRule}{\rule{\textwidth}{1pt}}
-
-
-% Change the title page to look a bit better, and fit in with the
-% fncychap ``Bjarne'' style a bit better.
-%
-\renewcommand{\maketitle}{
-  \py@doHorizontalRule
-  \@ifundefined{pdfinfo}{}{{
-    % This \def is required to deal with multi-line authors; it
-    % changes \\ to ', ' (comma-space), making it pass muster for
-    % generating document info in the PDF file.
-    \def\\{, }
-    \pdfinfo{
-      /Author (\@author)
-      /Title (\@title)
-    }
-  }}
-  \begin{flushright}
-    {\rm\Huge\py@HeaderFamily \@title} \par
-    {\em\large\py@HeaderFamily \py@release} \par
-    \vspace{25pt}
-    {\Large\py@HeaderFamily \@author} \par
-    \vspace{25pt}
-    \@date \par
-    \py@authoraddress \par
-  \end{flushright}
-  \@thanks
-  \setcounter{footnote}{0}
-  \let\thanks\relax\let\maketitle\relax
-  \gdef\@thanks{}\gdef\@author{}\gdef\@title{}
-}
-
-
-\let\py@OldTableofcontents=\tableofcontents
-\renewcommand{\tableofcontents}{
-  \begingroup
-    \parskip = 0mm
-    \py@OldTableofcontents
-  \endgroup
-  \py@doHorizontalRule
-  \vspace{12pt}
-  \py@doing@page@targetstrue
-}  
-
-% Fix the theindex environment to add an entry to the Table of
-% Contents; this is much nicer than just having to jump to the end of
-% the book and flip around, especially with multiple indexes.
-%
-\let\py@OldTheindex=\theindex
-\renewcommand{\theindex}{
-  \clearpage
-  \py@OldTheindex
-  \addcontentsline{toc}{section}{\indexname}
-}
-
-\@ifundefined{fancyhf}{
-  \pagestyle{plain}}{
-  \pagestyle{normal}}		% start this way; change for
-\pagenumbering{arabic}		% ToC & chapters
-\setcounter{secnumdepth}{2}
-
-\thispagestyle{empty}
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/texinputs/ltxmarkup.sty hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/texinputs/ltxmarkup.sty
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/texinputs/ltxmarkup.sty	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/texinputs/ltxmarkup.sty	1970-01-01 01:00:00.000000000 +0100
@@ -1,40 +0,0 @@
-% Created by Fred L. Drake, Jr. <fdrake@acm.org>, as part of the
-% Python Documentation Project.
-%
-% Define some simple markup for the LaTeX command documentation:
-
-\ProvidesPackage{ltxmarkup}
-\RequirePackage{python}      % fulllineitems environment
-
-% These two macros are used in constructing the last parameter to the
-% envdesc and macrodesc environments.
-
-\newcommand{\py@ltx@optparam}[1]{{[}\var{#1}{]}}
-\newcommand{\py@ltx@param}[1]{\{\var{#1}\}}
-
-\newenvironment{envdesc}[2]{
-  \begin{fulllineitems}
-    \item[\code{\e begin\{{\bfseries #1}\}{%
-      \let\op=\py@ltx@optparam%
-      \let\p=\py@ltx@param%
-      \let\unspecified=\py@unspecified%
-      \let\moreargs=\py@moreargs%
-         #2}}]
-    \item[\code{\e end\{{\bfseries #1}\}}]
-    \index{#1 environment@\idxcode{#1} environment}
-    \index{environments!#1@\idxcode{#1}}
-}{\end{fulllineitems}}
-
-\newenvironment{macrodesc}[2]{
-  \begin{fulllineitems}
-    \item[\code{{\e\bfseries#1}{%
-      \let\op=\py@ltx@optparam%
-      \let\p=\py@ltx@param%
-      \let\unspecified=\py@unspecified%
-      \let\moreargs=\py@moreargs%
-      #2}}]
-    \index{#1@\idxcode{\e #1}}
-}{\end{fulllineitems}}
-
-\newcommand{\env}[1]{\code{#1}}
-\newcommand{\macro}[1]{\code{\e#1}}
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/texinputs/manual.cls hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/texinputs/manual.cls
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/texinputs/manual.cls	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/texinputs/manual.cls	1970-01-01 01:00:00.000000000 +0100
@@ -1,152 +0,0 @@
-%
-% manual.cls for the Python documentation
-%
-
-\NeedsTeXFormat{LaTeX2e}[1995/12/01]
-\ProvidesClass{manual}
-             [1998/03/03 Document class (Python manual)]
-
-\RequirePackage{pypaper}
-
-% Change the options here to get a different set of basic options, but only
-% if you have to.  Paper and font size should be adjusted in pypaper.sty.
-%
-\LoadClass[\py@paper,\py@ptsize,twoside,openright]{report}
-
-\setcounter{secnumdepth}{2}
-
-% Optional packages:
-%
-% If processing of these documents fails at your TeX installation,
-% these may be commented out (independently) to make things work.
-% These are both supplied with the current version of the teTeX
-% distribution.
-%
-% The "fancyhdr" package makes nicer page footers reasonable to
-% implement, and is used to put the chapter and section information in 
-% the footers.
-%
-\RequirePackage{fancyhdr}\typeout{Using fancier footers than usual.}
-
-
-% Required packages:
-%
-% The "fncychap" package is used to get the nice chapter headers.  The
-% .sty file is distributed with Python, so you should not need to disable
-% it.  You'd also end up with a mixed page style; uglier than stock LaTeX!
-%
-\RequirePackage[Bjarne]{fncychap}\typeout{Using fancy chapter headings.}
-% Do horizontal rules it this way to match:
-\newcommand{\py@doHorizontalRule}{\mghrulefill{\RW}}
-%
-%
-% This gives us all the Python-specific markup that we really want.
-% This should come last.  Do not change this.
-%
-\RequirePackage{python}
-
-% support for module synopsis sections:
-\newcommand{\py@ModSynopsisFilename}{\jobname\thechapter.syn}
-\let\py@OldChapter=\chapter
-\renewcommand{\chapter}{
-  \py@ProcessModSynopsis
-  \py@closeModSynopsisFile
-  \py@OldChapter
-}
-
-
-% Change the title page to look a bit better, and fit in with the
-% fncychap ``Bjarne'' style a bit better.
-%
-\renewcommand{\maketitle}{%
-  \begin{titlepage}%
-    \let\footnotesize\small
-    \let\footnoterule\relax
-    \py@doHorizontalRule%
-    \@ifundefined{pdfinfo}{}{{
-      % This \def is required to deal with multi-line authors; it
-      % changes \\ to ', ' (comma-space), making it pass muster for
-      % generating document info in the PDF file.
-      \def\\{, }
-      \pdfinfo{
-        /Author (\@author)
-        /Title (\@title)
-      }
-    }}
-    \begin{flushright}%
-      {\rm\Huge\py@HeaderFamily \@title \par}%
-      {\em\LARGE\py@HeaderFamily \py@release \par}
-      \vfill
-      {\LARGE\py@HeaderFamily \@author \par}
-      \vfill\vfill
-      {\large
-       \@date \par
-       \vfill
-       \py@authoraddress \par
-      }%
-    \end{flushright}%\par
-    \@thanks
-  \end{titlepage}%
-  \setcounter{footnote}{0}%
-  \let\thanks\relax\let\maketitle\relax
-  \gdef\@thanks{}\gdef\@author{}\gdef\@title{}
-}
-
-
-% Catch the end of the {abstract} environment, but here make sure the
-% abstract is followed by a blank page if the 'openright' option is used.
-%
-\let\py@OldEndAbstract=\endabstract
-\renewcommand{\endabstract}{
-  \if@openright
-    \ifodd\value{page}
-      \typeout{Adding blank page after the abstract.}
-      \vfil\pagebreak
-    \fi
-  \fi
-  \py@OldEndAbstract
-}
-
-% This wraps the \tableofcontents macro with all the magic to get the
-% spacing right and have the right number of pages if the 'openright'
-% option has been used.  This eliminates a fair amount of crud in the
-% individual document files.
-%
-\let\py@OldTableofcontents=\tableofcontents
-\renewcommand{\tableofcontents}{%
-  \setcounter{page}{1}%
-  \pagebreak%
-  \pagestyle{plain}%
-  {%
-    \parskip = 0mm%
-    \py@OldTableofcontents%
-    \if@openright%
-      \ifodd\value{page}%
-        \typeout{Adding blank page after the table of contents.}%
-        \pagebreak\hspace{0pt}%
-      \fi%
-    \fi%
-    \cleardoublepage%
-  }%
-  \pagenumbering{arabic}%
-  \@ifundefined{fancyhf}{}{\pagestyle{normal}}%
-  \py@doing@page@targetstrue%
-}
-% This is needed to get the width of the section # area wide enough in the
-% library reference.  Doing it here keeps it the same for all the manuals.
-%
-\renewcommand*\l@section{\@dottedtocline{1}{1.5em}{2.6em}}
-\renewcommand*\l@subsection{\@dottedtocline{2}{4.1em}{3.5em}}
-\setcounter{tocdepth}{1}
-
-
-% Fix the theindex environment to add an entry to the Table of
-% Contents; this is much nicer than just having to jump to the end of
-% the book and flip around, especially with multiple indexes.
-%
-\let\py@OldTheindex=\theindex
-\renewcommand{\theindex}{
-  \cleardoublepage
-  \py@OldTheindex
-  \addcontentsline{toc}{chapter}{\indexname}
-}
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/texinputs/pypaper.sty hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/texinputs/pypaper.sty
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/texinputs/pypaper.sty	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/texinputs/pypaper.sty	1970-01-01 01:00:00.000000000 +0100
@@ -1,18 +0,0 @@
-%
-%  Change this to say a4paper instead of letterpaper if you want A4.  These
-%  are the latex defaults.
-%
-\newcommand{\py@paper}{letterpaper}
-\newcommand{\py@ptsize}{10pt}
-
-%  These set up the fonts for the documents.
-%
-%  The "times" package makes the default font the PostScript Times
-%  font, which makes for smaller PostScript and a font that more people 
-%  like.
-%
-%  The "avant" package causes the AvantGarde font to be used for
-%  sans-serif text, instead of the uglier Helvetica set up by the "times"
-%  package.
-%
-\RequirePackage{times}\typeout{Using Times instead of Computer Modern.}
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/texinputs/python.ist hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/texinputs/python.ist
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/texinputs/python.ist	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/texinputs/python.ist	1970-01-01 01:00:00.000000000 +0100
@@ -1,11 +0,0 @@
-line_max 100
-headings_flag 1
-heading_prefix "  \\bigletter "
-
-preamble "\\begin{theindex}
-\\def\\bigletter#1{{\\Large\\sffamily#1}\\nopagebreak\\vspace{1mm}}
-
-"
-
-symhead_positive "{Symbols}"
-numhead_positive "{Numbers}"
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/texinputs/python.sty hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/texinputs/python.sty
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/texinputs/python.sty	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/texinputs/python.sty	1970-01-01 01:00:00.000000000 +0100
@@ -1,1082 +0,0 @@
-%
-% python.sty for the Python docummentation  [works only with with Latex2e]
-%
-
-\NeedsTeXFormat{LaTeX2e}[1995/12/01]
-\ProvidesPackage{python}
-             [1998/01/11 LaTeX package (Python markup)]
-
-\RequirePackage{longtable}
-
-% Uncomment these two lines to ignore the paper size and make the page 
-% size more like a typical published manual.
-%\renewcommand{\paperheight}{9in}
-%\renewcommand{\paperwidth}{8.5in}   % typical squarish manual
-%\renewcommand{\paperwidth}{7in}     % O'Reilly ``Programmming Python''
-
-% These packages can be used to add marginal annotations which indicate
-% index entries and labels; useful for reviewing this messy documentation!
-%
-%\RequirePackage{showkeys}
-%\RequirePackage{showidx}
-
-% for PDF output, use maximal compression & a lot of other stuff
-% (test for PDF recommended by Tanmoy Bhattacharya <tanmoy@qcd.lanl.gov>)
-%
-\newif\ifpy@doing@page@targets
-\py@doing@page@targetsfalse
-
-\ifx\pdfoutput\undefined\else\ifcase\pdfoutput
-\else
-  \input{pdfcolor}
-  \let\py@LinkColor=\NavyBlue
-  \let\py@NormalColor=\Black
-  \pdfcompresslevel=9
-  \pdfpagewidth=\paperwidth    % page width of PDF output
-  \pdfpageheight=\paperheight  % page height of PDF output
-  %
-  % Pad the number with '0' to 3 digits wide so no page name is a prefix
-  % of any other.
-  %
-  \newcommand{\py@targetno}[1]{\ifnum#1<100 0\fi\ifnum#1<10 0\fi#1}
-  \newcommand{\py@pageno}{\py@targetno\thepage}
-  %
-  % This definition allows the entries in the page-view of the ToC to be
-  % active links.  Some work, some don't.
-  %
-  \let\py@OldContentsline=\contentsline
-  %
-  % Macro that takes two args: the name to link to and the content of
-  % the link.  This takes care of the PDF magic, getting the colors
-  % the same for each link, and avoids having lots of garbage all over 
-  % this style file.
-  \newcommand{\py@linkToName}[2]{%
-    \pdfannotlink attr{/Border [0 0 0]} goto name{#1}%
-      \py@LinkColor#2\py@NormalColor%
-    \pdfendlink%
-  }    
-  % Compute the padded page number separately since we end up with a pair of
-  % \relax tokens; this gets the right string computed and works.
-  \renewcommand{\contentsline}[3]{%
-    \def\my@pageno{\py@targetno{#3}}%
-    \py@OldContentsline{#1}{\py@linkToName{page\my@pageno}{#2}}{#3}%
-  }
-  \AtEndDocument{
-    \InputIfFileExists{\jobname.bkm}{\pdfcatalog{/PageMode /UseOutlines}}{}
-  }
-  \newcommand{\py@target}[1]{%
-    \ifpy@doing@page@targets%
-      {\pdfdest name{#1} xyz}%
-    \fi%
-  }
-  \let\py@OldLabel=\label
-  \renewcommand{\label}[1]{%
-    \py@OldLabel{#1}%
-    \py@target{label-#1}%
-  }
-  % This stuff adds a page# destination to every PDF page, where # is three
-  % digits wide, padded with leading zeros.  This doesn't really help with
-  % the frontmatter, but does fine with the body.
-  %
-  % This is *heavily* based on the hyperref package.
-  %
-  \def\@begindvi{%
-    \unvbox \@begindvibox
-    \@hyperfixhead
-  }
-  \def\@hyperfixhead{%
-   \let\H@old@thehead\@thehead
-       \global\def\@foo{\py@target{page\py@pageno}}%
-     \expandafter\ifx\expandafter\@empty\H@old@thehead
-       \def\H@old@thehead{\hfil}\fi
-    \def\@thehead{\@foo\relax\H@old@thehead}%
-  }
-\fi\fi
-
-% Increase printable page size (copied from fullpage.sty)
-\topmargin 0pt
-\advance \topmargin by -\headheight
-\advance \topmargin by -\headsep
-
-% attempt to work a little better for A4 users
-\textheight \paperheight
-\advance\textheight by -2in
-
-\oddsidemargin 0pt
-\evensidemargin 0pt
-%\evensidemargin -.25in  % for ``manual size'' documents
-\marginparwidth 0.5in
-
-\textwidth \paperwidth
-\advance\textwidth by -2in
-
-
-% Style parameters and macros used by most documents here
-\raggedbottom
-\sloppy
-\parindent = 0mm
-\parskip = 2mm
-\hbadness = 5000                % don't print trivial gripes
-
-\pagestyle{empty}               % start this way; change for
-\pagenumbering{roman}           % ToC & chapters
-
-% Use this to set the font family for headers and other decor:
-\newcommand{\py@HeaderFamily}{\sffamily}
-
-% Redefine the 'normal' header/footer style when using "fancyhdr" package:
-\@ifundefined{fancyhf}{}{
-  % Use \pagestyle{normal} as the primary pagestyle for text.
-  \fancypagestyle{normal}{
-    \fancyhf{}
-    \fancyfoot[LE,RO]{{\py@HeaderFamily\thepage}}
-    \fancyfoot[LO]{{\py@HeaderFamily\nouppercase{\rightmark}}}
-    \fancyfoot[RE]{{\py@HeaderFamily\nouppercase{\leftmark}}}
-    \renewcommand{\headrulewidth}{0pt}
-    \renewcommand{\footrulewidth}{0.4pt}
-  }
-  % Update the plain style so we get the page number & footer line,
-  % but not a chapter or section title.  This is to keep the first
-  % page of a chapter and the blank page between chapters `clean.'
-  \fancypagestyle{plain}{
-    \fancyhf{}
-    \fancyfoot[LE,RO]{{\py@HeaderFamily\thepage}}
-    \renewcommand{\headrulewidth}{0pt}
-    \renewcommand{\footrulewidth}{0.4pt}
-  }
-  % Redefine \cleardoublepage so that the blank page between chapters
-  % gets the plain style and not the fancy style.  This is described
-  % in the documentation for the fancyhdr package by Piet von Oostrum.
-  \@ifundefined{chapter}{}{
-    \renewcommand{\cleardoublepage}{
-      \clearpage\if@openright \ifodd\c@page\else
-      \hbox{}
-      \thispagestyle{plain}
-      \newpage
-      \if@twocolumn\hbox{}\newpage\fi\fi\fi
-    }
-  }
-}
-
-% This sets up the {verbatim} environment to be indented and a minipage,
-% and to have all the other mostly nice properties that we want for
-% code samples.
-
-\let\py@OldVerbatim=\verbatim
-\let\py@OldEndVerbatim=\endverbatim
-\RequirePackage{verbatim}
-
-% Variable used by begin code command
-\newlength{\py@codewidth}
-
-\renewcommand{\verbatim}{%
-  \setlength{\parindent}{1cm}%
-  % Calculate the text width for the minipage:
-  \setlength{\py@codewidth}{\linewidth}%
-  \addtolength{\py@codewidth}{-\parindent}%
-  %
-  \par\indent%
-  \begin{minipage}[t]{\py@codewidth}%
-    \small%
-    \py@OldVerbatim%
-}
-\renewcommand{\endverbatim}{%
-    \py@OldEndVerbatim%
-  \end{minipage}%
-}
-
-% This does a similar thing for the {alltt} environment:
-\RequirePackage{alltt}
-\let\py@OldAllTT=\alltt
-\let\py@OldEndAllTT=\endalltt
-
-\renewcommand{\alltt}{%
-  \setlength{\parindent}{1cm}%
-  % Calculate the text width for the minipage:
-  \setlength{\py@codewidth}{\linewidth}%
-  \addtolength{\py@codewidth}{-\parindent}%
-  %
-  \par\indent%
-  \begin{minipage}[t]{\py@codewidth}%
-    \small%
-    \py@OldAllTT%
-}
-\renewcommand{\endalltt}{%
-    \py@OldEndAllTT%
-  \end{minipage}%
-}
-
-
-\newcommand{\py@modulebadkey}{{--just-some-junk--}}
-
-
-%%  Lots of index-entry generation support.
-
-% Command to wrap around stuff that refers to function / module /
-% attribute names  in the index.  Default behavior: like \code{}.  To
-% just keep the index entries in the roman font, uncomment the second
-% definition; it matches O'Reilly style more.
-%
-\newcommand{\py@idxcode}[1]{\texttt{#1}}
-%\renewcommand{\py@idxcode}[1]{#1}
-
-% Command to generate two index entries (using subentries)
-\newcommand{\indexii}[2]{\index{#1!#2}\index{#2!#1}}
-
-% And three entries (using only one level of subentries)
-\newcommand{\indexiii}[3]{\index{#1!#2 #3}\index{#2!#3, #1}\index{#3!#1 #2}}
-
-% And four (again, using only one level of subentries)
-\newcommand{\indexiv}[4]{
-\index{#1!#2 #3 #4}
-\index{#2!#3 #4, #1}
-\index{#3!#4, #1 #2}
-\index{#4!#1 #2 #3}
-}
-
-% Command to generate a reference to a function, statement, keyword,
-% operator.
-\newcommand{\kwindex}[1]{\indexii{keyword}{#1@{\py@idxcode{#1}}}}
-\newcommand{\stindex}[1]{\indexii{statement}{#1@{\py@idxcode{#1}}}}
-\newcommand{\opindex}[1]{\indexii{operator}{#1@{\py@idxcode{#1}}}}
-\newcommand{\exindex}[1]{\indexii{exception}{#1@{\py@idxcode{#1}}}}
-\newcommand{\obindex}[1]{\indexii{object}{#1}}
-\newcommand{\bifuncindex}[1]{%
-  \index{#1@{\py@idxcode{#1()}} (built-in function)}}
-
-% Add an index entry for a module
-\newcommand{\py@refmodule}[2]{\index{#1@{\py@idxcode{#1}} (#2module)}}
-\newcommand{\refmodindex}[1]{\py@refmodule{#1}{}}
-\newcommand{\refbimodindex}[1]{\py@refmodule{#1}{built-in }}
-\newcommand{\refexmodindex}[1]{\py@refmodule{#1}{extension }}
-\newcommand{\refstmodindex}[1]{\py@refmodule{#1}{standard }}
-
-% Refer to a module's documentation using a hyperlink of the module's
-% name, at least if we're building PDF:
-\@ifundefined{pdfannotlink}{%
-  \newcommand{\refmodule}[2][\py@modulebadkey]{\module{#2}}
-}{%
-  \newcommand{\refmodule}[2][\py@modulebadkey]{%
-    \ifx\py@modulebadkey#1\def\py@modulekey{#2}\else\def\py@modulekey{#1}\fi%
-    \py@linkToName{label-module-\py@modulekey}{\module{#2}}%
-  }
-}
-
-% support for the module index
-\newif\ifpy@UseModuleIndex
-\py@UseModuleIndexfalse
-
-\newcommand{\makemodindex}{
-  \newwrite\modindexfile
-  \openout\modindexfile=mod\jobname.idx
-  \py@UseModuleIndextrue
-}
-
-% Add the defining entry for a module
-\newcommand{\py@modindex}[2]{%
-  \renewcommand{\py@thismodule}{#1}
-  \setindexsubitem{(in module #1)}%
-  \index{#1@{\py@idxcode{#1}} (#2module)|textbf}%
-  \ifpy@UseModuleIndex%
-    \@ifundefined{py@modplat@\py@thismodulekey}{
-      \write\modindexfile{\protect\indexentry{#1@{\texttt{#1}}}{\thepage}}%
-    }{\write\modindexfile{\protect\indexentry{#1@{\texttt{#1} %
-        \emph{(\py@platformof[\py@thismodulekey]{})}}}{\thepage}}%
-    }
-  \fi%
-}
-
-% *** XXX *** THE NEXT FOUR MACROS ARE NOW OBSOLETE !!! ***
-
-% built-in & Python modules in the main distribution
-\newcommand{\bimodindex}[1]{\py@modindex{#1}{built-in }%
-  \typeout{*** MACRO bimodindex IS OBSOLETE -- USE declaremodule INSTEAD!}}
-\newcommand{\stmodindex}[1]{\py@modindex{#1}{standard }%
-  \typeout{*** MACRO stmodindex IS OBSOLETE -- USE declaremodule INSTEAD!}}
-
-% Python & extension modules outside the main distribution
-\newcommand{\modindex}[1]{\py@modindex{#1}{}%
-  \typeout{*** MACRO modindex IS OBSOLETE -- USE declaremodule INSTEAD!}}
-\newcommand{\exmodindex}[1]{\py@modindex{#1}{extension }%
-  \typeout{*** MACRO exmodindex IS OBSOLETE -- USE declaremodule INSTEAD!}}
-
-% Additional string for an index entry
-\newif\ifpy@usingsubitem\py@usingsubitemfalse
-\newcommand{\py@indexsubitem}{}
-\newcommand{\setindexsubitem}[1]{\renewcommand{\py@indexsubitem}{ #1}%
-                                 \py@usingsubitemtrue}
-\newcommand{\ttindex}[1]{%
-  \ifpy@usingsubitem
-    \index{#1@{\py@idxcode{#1}}\py@indexsubitem}%
-  \else%
-    \index{#1@{\py@idxcode{#1}}}%
-  \fi%
-}
-\newcommand{\withsubitem}[2]{%
-  \begingroup%
-    \def\ttindex##1{\index{##1@{\py@idxcode{##1}} #1}}%
-    #2%
-  \endgroup%
-}
-
-
-% Module synopsis processing -----------------------------------------------
-%
-\newcommand{\py@thisclass}{}
-\newcommand{\py@thismodule}{}
-\newcommand{\py@thismodulekey}{}
-\newcommand{\py@thismoduletype}{}
-
-\newcommand{\py@standardIndexModule}[1]{\py@modindex{#1}{standard }}
-\newcommand{\py@builtinIndexModule}[1]{\py@modindex{#1}{built-in }}
-\newcommand{\py@extensionIndexModule}[1]{\py@modindex{#1}{extension }}
-\newcommand{\py@IndexModule}[1]{\py@modindex{#1}{}}
-
-\newif\ifpy@HaveModSynopsis       \py@HaveModSynopsisfalse
-\newif\ifpy@ModSynopsisFileIsOpen \py@ModSynopsisFileIsOpenfalse
-\newif\ifpy@HaveModPlatform       \py@HaveModPlatformfalse
-
-% \declaremodule[key]{type}{name}
-\newcommand{\declaremodule}[3][\py@modulebadkey]{
-  \py@openModSynopsisFile
-  \renewcommand{\py@thismoduletype}{#2}
-  \ifx\py@modulebadkey#1
-    \renewcommand{\py@thismodulekey}{#3}
-  \else
-    \renewcommand{\py@thismodulekey}{#1}
-  \fi
-  \@ifundefined{py@#2IndexModule}{%
-    \typeout{*** MACRO declaremodule called with unknown module type: `#2'}
-    \py@IndexModule{#3}%
-  }{%
-    \csname py@#2IndexModule\endcsname{#3}%
-  }
-  \label{module-\py@thismodulekey}
-}
-\newif\ifpy@ModPlatformFileIsOpen \py@ModPlatformFileIsOpenfalse
-\newcommand{\py@ModPlatformFilename}{\jobname.pla}
-\newcommand{\platform}[1]{
-  \ifpy@ModPlatformFileIsOpen\else
-    \newwrite\py@ModPlatformFile
-    \openout\py@ModPlatformFile=\py@ModPlatformFilename
-    \py@ModPlatformFileIsOpentrue
-  \fi
-}
-\InputIfFileExists{\jobname.pla}{}{}
-\newcommand{\py@platformof}[2][\py@modulebadkey]{%
-  \ifx\py@modulebadkey#1 \def\py@key{#2}%
-  \else \def\py@key{#1}%
-  \fi%
-  \csname py@modplat@\py@key\endcsname%
-}
-\newcommand{\ignorePlatformAnnotation}[1]{}
-
-% \moduleauthor{name}{email}
-\newcommand{\moduleauthor}[2]{}
-
-% \sectionauthor{name}{email}
-\newcommand{\sectionauthor}[2]{}
-
-
-\newcommand{\py@defsynopsis}{Module has no synopsis.}
-\newcommand{\py@modulesynopsis}{\py@defsynopsis}
-\newcommand{\modulesynopsis}[1]{
-  \py@HaveModSynopsistrue
-  \renewcommand{\py@modulesynopsis}{#1}
-}
-
-% define the file
-\newwrite\py@ModSynopsisFile
-
-% hacked from \addtocontents from latex.ltx:
-\long\def\py@writeModSynopsisFile#1{%
-  \protected@write\py@ModSynopsisFile%
-      {\let\label\@gobble \let\index\@gobble \let\glossary\@gobble}%
-      {\string#1}%
-}
-\newcommand{\py@closeModSynopsisFile}{
-  \ifpy@ModSynopsisFileIsOpen
-    \closeout\py@ModSynopsisFile
-    \py@ModSynopsisFileIsOpenfalse
-  \fi
-}
-\newcommand{\py@openModSynopsisFile}{
-  \ifpy@ModSynopsisFileIsOpen\else
-    \openout\py@ModSynopsisFile=\py@ModSynopsisFilename
-    \py@ModSynopsisFileIsOpentrue
-  \fi
-}
-
-\newcommand{\py@ProcessModSynopsis}{
-  \ifpy@HaveModSynopsis
-    \py@writeModSynopsisFile{\modulesynopsis%
-      {\py@thismodulekey}{\py@thismodule}%
-      {\py@thismoduletype}{\py@modulesynopsis}}%
-    \py@HaveModSynopsisfalse
-  \fi
-  \renewcommand{\py@modulesynopsis}{\py@defsynopsis}
-}
-\AtEndDocument{\py@ProcessModSynopsis\py@closeModSynopsisFile}
-
-
-\long\def\py@writeModPlatformFile#1{%
-  \protected@write\py@ModPlatformFile%
-    {\let\label\@gobble \let\index\@gobble \let\glossary\@gobble}%
-    {\string#1}%
-}
-
-
-\newcommand{\localmoduletable}{
-  \IfFileExists{\py@ModSynopsisFilename}{
-    \begin{synopsistable}
-      \input{\py@ModSynopsisFilename}
-    \end{synopsistable}
-  }{}
-}
-
-\@ifundefined{pdfoutput}{
-  \newcommand{\py@ModSynopsisSummary}[4]{\bfcode{#2} & #4\\}
-}{
-  \newcommand{\py@ModSynopsisSummary}[4]{%
-    \py@linkToName{label-module-#1}{\bfcode{#2}} & #4\\
-  }
-}
-\newenvironment{synopsistable}{
-  % key, name, type, synopsis
-  \let\modulesynopsis=\py@ModSynopsisSummary
-  \begin{tabular}{ll}
-}{
-  \end{tabular}
-}
-%
-% --------------------------------------------------------------------------
-
-
-\newcommand{\py@reset}{
-  \py@usingsubitemfalse
-  \py@ProcessModSynopsis
-  \renewcommand{\py@thisclass}{}
-  \renewcommand{\py@thismodule}{}
-  \renewcommand{\py@thismodulekey}{}
-  \renewcommand{\py@thismoduletype}{}
-}
-
-% Augment the sectioning commands used to get our own font family in place,
-% and reset some internal data items:
-\renewcommand{\section}{\py@reset%
-                        \@startsection{section}{1}{\z@}%
-                                    {-3.5ex \@plus -1ex \@minus -.2ex}%
-                                    {2.3ex \@plus.2ex}%
-                                    {\reset@font\Large\py@HeaderFamily}}
-\renewcommand{\subsection}{\@startsection{subsection}{2}{\z@}%
-                                    {-3.25ex\@plus -1ex \@minus -.2ex}%
-                                    {1.5ex \@plus .2ex}%
-                                    {\reset@font\large\py@HeaderFamily}}
-\renewcommand{\subsubsection}{\@startsection{subsubsection}{3}{\z@}%
-                                    {-3.25ex\@plus -1ex \@minus -.2ex}%
-                                    {1.5ex \@plus .2ex}%
-                                    {\reset@font\normalsize\py@HeaderFamily}}
-\renewcommand{\paragraph}{\@startsection{paragraph}{4}{\z@}%
-                                    {3.25ex \@plus1ex \@minus.2ex}%
-                                    {-1em}%
-                                    {\reset@font\normalsize\py@HeaderFamily}}
-\renewcommand{\subparagraph}{\@startsection{subparagraph}{5}{\parindent}%
-                                    {3.25ex \@plus1ex \@minus .2ex}%
-                                    {-1em}%
-                                    {\reset@font\normalsize\py@HeaderFamily}}
-
-
-% This gets the underscores closer to the right width; the only change
-% from standard LaTeX is the width specified.
-
-\DeclareTextCommandDefault{\textunderscore}{%
-  \leavevmode \kern.06em\vbox{\hrule\@width.55em}}
-
-% Underscore hack (only act like subscript operator if in math mode)
-%
-% The following is due to Mark Wooding (the old version didn't work with
-% Latex 2e.
-
-\DeclareRobustCommand\hackscore{%
-  \ifmmode_\else\textunderscore\fi%
-}
-\begingroup
-\catcode`\_\active
-\def\next{%
-  \AtBeginDocument{\catcode`\_\active\def_{\hackscore{}}}%
-}
-\expandafter\endgroup\next
-
-
-% Now for a lot of semantically-loaded environments that do a ton of magical
-% things to get the right formatting and index entries for the stuff in
-% Python modules and C API.
-
-
-% {fulllineitems} is used in one place in libregex.tex, but is really for
-% internal use in this file.
-%
-\newcommand{\py@itemnewline}[1]{%
-  \@tempdima\linewidth%
-  \advance\@tempdima \leftmargin\makebox[\@tempdima][l]{#1}%
-}
-
-\newenvironment{fulllineitems}{
-  \begin{list}{}{\labelwidth \leftmargin \labelsep 0pt
-                 \rightmargin 0pt \topsep -\parskip \partopsep \parskip
-                 \itemsep -\parsep
-                 \let\makelabel=\py@itemnewline}
-}{\end{list}}
-
-% \optional is mostly for use in the arguments parameters to the various
-% {*desc} environments defined below, but may be used elsewhere.  Known to
-% be used in the debugger chapter.
-%
-% Typical usage:
-%
-%     \begin{funcdesc}{myfunc}{reqparm\optional{, optparm}}
-%                                    ^^^       ^^^
-%                          No space here       No space here
-%
-% When a function has multiple optional parameters, \optional should be
-% nested, not chained.  This is right:
-%
-%     \begin{funcdesc}{myfunc}{\optional{parm1\optional{, parm2}}}
-%
-\let\py@badkey=\@undefined
-
-\newcommand{\optional}[1]{%
-  {\textnormal{\Large[}}{#1}\hspace{0.5mm}{\textnormal{\Large]}}}
-
-% This can be used when a function or method accepts an varying number 
-% of arguments, such as by using the *args syntax in the parameter list.
-\newcommand{\py@moreargs}{...}
-
-% This can be used when you don't want to document the parameters to a 
-% function or method, but simply state that it's an alias for
-% something else.
-\newcommand{\py@unspecified}{...}
-
-% C functions ------------------------------------------------------------
-% \begin{cfuncdesc}[refcount]{type}{name}{arglist}
-% Note that the [refcount] slot should only be filled in by
-% tools/anno-api.py; it pulls the value from the refcounts database.
-\newenvironment{cfuncdesc}[4][\py@badkey]{
-  \begin{fulllineitems}
-    \item[\code{#2 \bfcode{#3}(\py@varvars{#4})}\index{#3@{\py@idxcode{#3()}}}]
-    \ifx#1\@undefined\else%
-      \emph{Return value: \textbf{#1}.}\\
-    \fi
-}{\end{fulllineitems}}
-
-% C variables ------------------------------------------------------------
-% \begin{cvardesc}{type}{name}
-\newenvironment{cvardesc}[2]{
-  \begin{fulllineitems}
-    \item[\code{#1 \bfcode{#2}}\index{#2@{\py@idxcode{#2}}}]
-}{\end{fulllineitems}}
-
-% C data types -----------------------------------------------------------
-% \begin{ctypedesc}[index name]{typedef name}
-\newenvironment{ctypedesc}[2][\py@badkey]{
-  \begin{fulllineitems}
-    \item[\bfcode{#2}%
-    \ifx#1\@undefined%
-      \index{#2@{\py@idxcode{#2}} (C type)}
-    \else%
-      \index{#2@{\py@idxcode{#1}} (C type)}
-    \fi]
-}{\end{fulllineitems}}
-
-% Funky macros -----------------------------------------------------------
-% \begin{csimplemacro}{name}
-% -- "simple" because it has no args; NOT for constant definitions!
-\newenvironment{csimplemacrodesc}[1]{
-  \begin{fulllineitems}
-    \item[\bfcode{#1}\index{#1@{\py@idxcode{#1}} (macro)}]
-}{\end{fulllineitems}}
-
-% simple functions (not methods) -----------------------------------------
-% \begin{funcdesc}{name}{args}
-\newcommand{\funcline}[2]{%
-  \funclineni{#1}{#2}%
-  \index{#1@{\py@idxcode{#1()}} (in module \py@thismodule)}}
-\newenvironment{funcdesc}[2]{
-  \begin{fulllineitems}
-    \funcline{#1}{#2}
-}{\end{fulllineitems}}
-
-% similar to {funcdesc}, but doesn't add to the index
-\newcommand{\funclineni}[2]{\item[\code{\bfcode{#1}(\py@varvars{#2})}]}
-\newenvironment{funcdescni}[2]{
-  \begin{fulllineitems}
-    \funclineni{#1}{#2}
-}{\end{fulllineitems}}
-
-% classes ----------------------------------------------------------------
-% \begin{classdesc}{name}{constructor args}
-\newenvironment{classdesc}[2]{
-  % Using \renewcommand doesn't work for this, for unknown reasons:
-  \global\def\py@thisclass{#1}
-  \begin{fulllineitems}
-    \item[\strong{class }\code{\bfcode{#1}(\py@varvars{#2})}%
-      \index{#1@{\py@idxcode{#1}} (class in \py@thismodule)}]
-}{\end{fulllineitems}}
-
-% \begin{excclassdesc}{name}{constructor args}
-% but indexes as an exception
-\newenvironment{excclassdesc}[2]{
-  % Using \renewcommand doesn't work for this, for unknown reasons:
-  \global\def\py@thisclass{#1}
-  \begin{fulllineitems}
-    \item[\strong{exception }\code{\bfcode{#1}(\py@varvars{#2})}%
-      \index{#1@{\py@idxcode{#1}} (exception in \py@thismodule)}]
-}{\end{fulllineitems}}
-
-
-\let\py@classbadkey=\@undefined
-
-% object method ----------------------------------------------------------
-% \begin{methoddesc}[classname]{methodname}{args}
-\newcommand{\methodline}[3][\@undefined]{
-  \methodlineni{#2}{#3}
-  \ifx#1\@undefined
-    \index{#2@{\py@idxcode{#2()}} (\py@thisclass\ method)}
-  \else
-    \index{#2@{\py@idxcode{#2()}} (#1 method)}
-  \fi
-}
-\newenvironment{methoddesc}[3][\@undefined]{
-  \begin{fulllineitems}
-    \ifx#1\@undefined
-      \methodline{#2}{#3}
-    \else
-      \def\py@thisclass{#1}
-      \methodline{#2}{#3}
-    \fi
-}{\end{fulllineitems}}
-
-% similar to {methoddesc}, but doesn't add to the index
-% (never actually uses the optional argument)
-\newcommand{\methodlineni}[3][\py@classbadkey]{%
-  \item[\code{\bfcode{#2}(\py@varvars{#3})}]}
-\newenvironment{methoddescni}[3][\py@classbadkey]{
-  \begin{fulllineitems}
-    \methodlineni{#2}{#3}
-}{\end{fulllineitems}}
-
-% object data attribute --------------------------------------------------
-% \begin{memberdesc}[classname]{membername}
-\newcommand{\memberline}[2][\py@classbadkey]{%
-  \ifx#1\@undefined
-    \memberlineni{#2}
-    \index{#2@{\py@idxcode{#2}} (\py@thisclass\ attribute)}
-  \else
-    \memberlineni{#2}
-    \index{#2@{\py@idxcode{#2}} (#1 attribute)}
-  \fi
-}
-\newenvironment{memberdesc}[2][\py@classbadkey]{
-  \begin{fulllineitems}
-    \ifx#1\@undefined
-      \memberline{#2}
-    \else
-      \def\py@thisclass{#1}
-      \memberline{#2}
-    \fi
-}{\end{fulllineitems}}
-
-% similar to {memberdesc}, but doesn't add to the index
-% (never actually uses the optional argument)
-\newcommand{\memberlineni}[2][\py@classbadkey]{\item[\bfcode{#2}]}
-\newenvironment{memberdescni}[2][\py@classbadkey]{
-  \begin{fulllineitems}
-    \memberlineni{#2}
-}{\end{fulllineitems}}
-
-% For exceptions: --------------------------------------------------------
-% \begin{excdesc}{name}
-%  -- for constructor information, use excclassdesc instead
-\newenvironment{excdesc}[1]{
-  \begin{fulllineitems}
-    \item[\strong{exception }\bfcode{#1}%
-          \index{#1@{\py@idxcode{#1}} (exception in \py@thismodule)}]
-}{\end{fulllineitems}}
-
-% Module data or constants: ----------------------------------------------
-% \begin{datadesc}{name}
-\newcommand{\dataline}[1]{%
-  \datalineni{#1}\index{#1@{\py@idxcode{#1}} (data in \py@thismodule)}}
-\newenvironment{datadesc}[1]{
-  \begin{fulllineitems}
-    \dataline{#1}
-}{\end{fulllineitems}}
-
-% similar to {datadesc}, but doesn't add to the index
-\newcommand{\datalineni}[1]{\item[\bfcode{#1}]\nopagebreak}
-\newenvironment{datadescni}[1]{
-  \begin{fulllineitems}
-    \datalineni{#1}
-}{\end{fulllineitems}}
-
-% bytecode instruction ---------------------------------------------------
-% \begin{opcodedesc}{name}{var}
-% -- {var} may be {}
-\newenvironment{opcodedesc}[2]{
-  \begin{fulllineitems}
-    \item[\bfcode{#1}\quad\var{#2}]
-}{\end{fulllineitems}}
-
-
-\newcommand{\nodename}[1]{\label{#1}}
-
-% For these commands, use \command{} to get the typography right, not 
-% {\command}.  This works better with the texinfo translation.
-\newcommand{\ABC}{{\sc abc}}
-\newcommand{\UNIX}{{\sc Unix}}
-\newcommand{\POSIX}{POSIX}
-\newcommand{\ASCII}{{\sc ascii}}
-\newcommand{\Cpp}{C\protect\raisebox{.18ex}{++}}
-\newcommand{\C}{C}
-\newcommand{\EOF}{{\sc eof}}
-\newcommand{\NULL}{\constant{NULL}}
-
-% Also for consistency: spell Python "Python", not "python"!
-
-% code is the most difficult one...
-\newcommand{\code}[1]{\textrm{\@vobeyspaces\@noligs\def\{{\char`\{}\def\}{\char`\}}\def\~{\char`\~}\def\^{\char`\^}\def\e{\char`\\}\def\${\char`\$}\def\#{\char`\#}\def\&{\char`\&}\def\%{\char`\%}%
-\texttt{#1}}}
-
-\newcommand{\bfcode}[1]{\code{\bfseries#1}} % bold-faced code font
-\newcommand{\kbd}[1]{\code{#1}}
-\newcommand{\samp}[1]{`\code{#1}'}
-% This weird definition of \var{} allows it to always appear in roman
-% italics, and won't get funky in code fragments when we play around
-% with fonts.  This also works directly in math mode.
-\newcommand{\var}[1]{%
-  \ifmmode%
-    \hbox{\normalsize\textrm{\textit{#1\/}}}%
-  \else%
-    \normalsize\textrm{\textit{#1\/}}%
-  \fi%
-}
-\renewcommand{\emph}[1]{{\em #1}}
-\newcommand{\dfn}[1]{\emph{#1}}
-\newcommand{\strong}[1]{{\bf #1}}
-% let's experiment with a new font:
-\newcommand{\file}[1]{`{\small\textsf{#1}}'}
-\newcommand{\filenq}[1]{{\small\textsf{#1}}}
-
-% Use this def/redef approach for \url{} since hyperref defined this already,
-% but only if we actually used hyperref:
-\@ifundefined{pdfannotlink}{
-  \newcommand{\py@url}[1]{\mbox{\small\textsf{#1}}}
-}{
-  \newcommand{\py@url}[1]{{%
-    \pdfannotlink attr{/Border [0 0 0]} user{/S /URI /URI (#1)}%
-    \py@LinkColor%                              color of the link text
-    \mbox{\small\textsf{#1}}%
-    \py@NormalColor%                    Turn it back off; these are declarative
-    \pdfendlink}%                       and don't appear bound to the current
-  }%                                    formatting "box".
-}
-\let\url=\py@url
-\newcommand{\email}[1]{{\small\textsf{#1}}}
-\newcommand{\newsgroup}[1]{{\small\textsf{#1}}}
-
-\newcommand{\py@varvars}[1]{{%
-  {\let\unspecified=\py@unspecified%
-   \let\moreargs=\py@moreargs%
-   \var{#1}}}}
-
-% I'd really like to get rid of this!
-\newif\iftexi\texifalse
-
-% This is used to get l2h to put the copyright and abstract on
-% a separate HTML page.
-\newif\ifhtml\htmlfalse
-
-
-% These should be used for all references to identifiers which are
-% used to refer to instances of specific language constructs.  See the
-% names for specific semantic assignments.
-%
-% For now, don't do anything really fancy with them; just use them as
-% logical markup.  This might change in the future.
-%
-\newcommand{\module}[1]{\texttt{#1}}
-\newcommand{\keyword}[1]{\texttt{#1}}
-\newcommand{\exception}[1]{\texttt{#1}}
-\newcommand{\class}[1]{\texttt{#1}}
-\newcommand{\function}[1]{\texttt{#1}}
-\newcommand{\member}[1]{\texttt{#1}}
-\newcommand{\method}[1]{\texttt{#1}}
-
-\newcommand{\pytype}[1]{#1}             % built-in Python type
-
-\newcommand{\cfunction}[1]{\texttt{#1}}
-\newcommand{\ctype}[1]{\texttt{#1}}     % C struct or typedef name
-\newcommand{\cdata}[1]{\texttt{#1}}     % C variable, typically global
-
-\newcommand{\mimetype}[1]{{\small\textsf{#1}}}
-% The \! is a "negative thin space" in math mode.
-\newcommand{\regexp}[1]{%
-  {\tiny$^{^\lceil}\!\!$%
-   {\normalsize\code{#1}}%
-   $\!\rfloor\!$%
-  }}
-\newcommand{\envvar}[1]{%
-  #1%
-  \index{#1@{#1}}%
-  \index{environment variables!{#1}}%
-}
-\newcommand{\makevar}[1]{#1}            % variable in a Makefile
-\newcommand{\character}[1]{\samp{#1}}
-
-% constants defined in Python modules or C headers, not language constants:
-\newcommand{\constant}[1]{\code{#1}}    % manifest constant, not syntactic
-
-\newcommand{\manpage}[2]{{\emph{#1}(#2)}}
-\newcommand{\pep}[1]{PEP #1\index{Python Enhancement Proposals!PEP #1}}
-\newcommand{\rfc}[1]{RFC #1\index{RFC!RFC #1}}
-\newcommand{\program}[1]{\strong{#1}}
-\newcommand{\programopt}[1]{\strong{#1}}
-% Note that \longprogramopt provides the '--'!
-\newcommand{\longprogramopt}[1]{\strong{-{}-#1}}
-
-% cited titles:  \citetitle{Title of Work}
-%       online:  \citetitle[url-to-resource]{Title of Work}
-\newcommand{\citetitle}[2][URL]{\emph{#2}}
-
-
-% Deprecation stuff.
-% Should be extended to allow an index / list of deprecated stuff.  But
-% there's a lot of stuff that needs to be done to make that automatable.
-%
-% First parameter is the release number that deprecates the feature, the
-% second is the action the should be taken by users of the feature.
-%
-% Example:
-%  \deprecated{1.5.1}{Use \method{frobnicate()} instead.}
-%
-\newcommand{\deprecated}[2]{%
-  \strong{Deprecated since release #1.}  #2\par}
-
-% New stuff.
-% This should be used to mark things which have been added to the
-% development tree but that aren't in the release, but are documented.
-% This allows release of documentation that already includes updated
-% descriptions.  Place at end of descriptor environment.
-%
-% Example:
-%  \versionadded{1.5.2}
-%  \versionchanged[short explanation]{2.0}
-%
-\newcommand{\versionadded}[1]{%
-  {  New in version #1.  }}
-\newcommand{\versionchanged}[2][\py@badkey]{%
-  \ifx#1\@undefined%
-    {  Changed in version #2.  }%
-  \else%
-    {  Changed in version #2:\ #1.  }%
-  \fi%
-}
-
-
-% Tables.
-%
-\newenvironment{tableii}[4]{%
-  \begin{center}%
-    \def\lineii##1##2{\csname#2\endcsname{##1}&##2\\}%
-    \begin{tabular}{#1}\strong{#3}&\strong{#4} \\* \hline%
-}{%
-    \end{tabular}%
-  \end{center}%
-}
-
-\newenvironment{longtableii}[4]{%
-  \begin{center}%
-    \def\lineii##1##2{\csname#2\endcsname{##1}&##2\\}%
-    \begin{longtable}[c]{#1}\strong{#3}&\strong{#4} \\* \hline\endhead%
-}{%
-    \end{longtable}%
-  \end{center}%
-}
-
-\newenvironment{tableiii}[5]{%
-  \begin{center}%
-    \def\lineiii##1##2##3{\csname#2\endcsname{##1}&##2&##3\\}%
-    \begin{tabular}{#1}\strong{#3}&\strong{#4}&\strong{#5} \\%
-      \hline%
-}{%
-    \end{tabular}%
-  \end{center}%
-}
-
-\newenvironment{longtableiii}[5]{%
-  \begin{center}%
-    \def\lineiii##1##2##3{\csname#2\endcsname{##1}&##2&##3\\}%
-    \begin{longtable}[c]{#1}\strong{#3}&\strong{#4}&\strong{#5} \\%
-      \hline\endhead%
-}{%
-    \end{longtable}%
-  \end{center}%
-}
-
-\newenvironment{tableiv}[6]{%
-  \begin{center}%
-    \def\lineiv##1##2##3##4{\csname#2\endcsname{##1}&##2&##3&##4\\}%
-    \begin{tabular}{#1}\strong{#3}&\strong{#4}&\strong{#5}&\strong{#6} \\%
-      \hline%
-}{%
-    \end{tabular}%
-  \end{center}%
-}
-
-\newenvironment{longtableiv}[6]{%
-  \begin{center}%
-    \def\lineiv##1##2##3##4{\csname#2\endcsname{##1}&##2&##3&##4\\}%
-    \begin{longtable}[c]{#1}\strong{#3}&\strong{#4}&\strong{#5}&\strong{#6}%
-      \\%
-      \hline\endhead%
-}{%
-    \end{longtable}%
-  \end{center}%
-}
-
-% Cross-referencing (AMK, new impl. FLD)
-% Sample usage:
-%  \begin{seealso}
-%    \seemodule{rand}{Uniform random number generator.}; % Module xref
-%    \seetext{\emph{Encyclopedia Britannica}}.           % Ref to a book
-% 
-%    % A funky case: module name contains '_'; have to supply an optional key
-%    \seemodule[copyreg]{copy_reg}{Interface constructor registration for
-%                                  \module{pickle}.}
-%  \end{seealso}
-%
-% Note that the last parameter for \seemodule and \seetext should be complete
-% sentences and be terminated with the proper punctuation.
-
-\@ifundefined{pdfannotlink}{%
-  \newcommand{\py@seemodule}[3][\py@modulebadkey]{%
-    \par%
-    \ifx\py@modulebadkey#1\def\py@modulekey{#2}\else\def\py@modulekey{#1}\fi%
-    \begin{fulllineitems}
-      \item[Module \module{#2} (section \ref{module-\py@modulekey}):]
-      #3
-    \end{fulllineitems}
-  }
-}{\newcommand{\py@seemodule}[3][\py@modulebadkey]{%
-    \par%
-    \ifx\py@modulebadkey#1\def\py@modulekey{#2}\else\def\py@modulekey{#1}\fi%
-    \begin{fulllineitems}
-      \item[\py@linkToName{label-module-\py@modulekey}{Module \module{#2}}
-            (section \ref{module-\py@modulekey}):]
-      #3
-    \end{fulllineitems}
-  }
-}
-% \seetitle[url]{title}{why it's interesting}
-\newcommand{\py@seetitle}[3][\py@modulebadkey]{%
-  \par
-  \begin{fulllineitems}
-    \item[\citetitle{#2}]
-    \ifx\py@modulebadkey#1\else
-      \item[{\small{(\url{#1})}}]
-    \fi
-    #3
-  \end{fulllineitems}
-}
-% \seepep{number}{title}{why it's interesting}
-\newcommand{\py@seepep}[3]{%
-  \par%
-  \begin{fulllineitems}
-    \item[\pep{#1}, ``\emph{#2}'']
-    #3
-  \end{fulllineitems}
-}
-% \seerfc{number}{title}{why it's interesting}
-\newcommand{\py@seerfc}[3]{%
-  \par%
-  \begin{fulllineitems}
-    \item[\rfc{#1}, ``\emph{#2}'']
-    #3
-  \end{fulllineitems}
-}
-% \seeurl{url}{why it's interesting}
-\newcommand{\py@seeurl}[2]{%
-  \par%
-  \begin{fulllineitems}
-    \item[\url{#1}]
-    #2
-  \end{fulllineitems}
-}
-\newenvironment{seealso}[0]{
-  \par
-  \strong{See Also:}\par
-  \def\seetext##1{\par{##1}}
-  \let\seemodule=\py@seemodule
-  \let\seepep=\py@seepep
-  \let\seerfc=\py@seerfc
-  \let\seetitle=\py@seetitle
-  \let\seeurl=\py@seeurl
-}{\par}
-
-
-% Allow the Python release number to be specified independently of the
-% \date{}.  This allows the date to reflect the document's date and
-% release to specify the Python release that is documented.
-%
-\newcommand{\py@release}{}
-\newcommand{\version}{}
-\newcommand{\shortversion}{}
-\newcommand{\releasename}{Release}
-\newcommand{\release}[1]{%
-  \renewcommand{\py@release}{\releasename\space\version}%
-  \renewcommand{\version}{#1}}
-\newcommand{\setshortversion}[1]{%
-  \renewcommand{\shortversion}{#1}}
-
-% Allow specification of the author's address separately from the
-% author's name.  This can be used to format them differently, which
-% is a good thing.
-%
-\newcommand{\py@authoraddress}{}
-\newcommand{\authoraddress}[1]{\renewcommand{\py@authoraddress}{#1}}
-\let\developersaddress=\authoraddress
-\let\developer=\author
-\let\developers=\author
-
-% This sets up the fancy chapter headings that make the documents look
-% at least a little better than the usual LaTeX output.
-%
-\@ifundefined{ChTitleVar}{}{
-  \ChNameVar{\raggedleft\normalsize\py@HeaderFamily}
-  \ChNumVar{\raggedleft \bfseries\Large\py@HeaderFamily}
-  \ChTitleVar{\raggedleft \rm\Huge\py@HeaderFamily}
-  % This creates chapter heads without the leading \vspace*{}:
-  \def\@makechapterhead#1{%
-    {\parindent \z@ \raggedright \normalfont
-      \ifnum \c@secnumdepth >\m@ne
-        \DOCH
-      \fi
-      \interlinepenalty\@M
-      \DOTI{#1}
-    }
-  }
-}
-
-
-% Definition lists; requested by AMK for HOWTO documents.  Probably useful
-% elsewhere as well, so keep in in the general style support.
-%
-\newenvironment{definitions}{%
-  \begin{description}%
-  \def\term##1{\item[##1]\mbox{}\\*[0mm]}
-}{%
-  \end{description}%
-}
-
-% Tell TeX about pathological hyphenation cases:
-\hyphenation{Base-HTTP-Re-quest-Hand-ler}
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/texinputs/reportingbugs.tex hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/texinputs/reportingbugs.tex
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/texinputs/reportingbugs.tex	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/texinputs/reportingbugs.tex	1970-01-01 01:00:00.000000000 +0100
@@ -1,65 +0,0 @@
-\label{reporting-bugs}
-
-Python is a mature programming language which has established a
-reputation for stability.  In order to maintain this reputation, the
-developers would like to know of any deficiencies you find in Python
-or its documentation.
-
-All bug reports should be submitted via the Python Bug Tracker on
-SourceForge (\url{http://sourceforge.net/bugs/?group_id=5470}).  The
-bug tracker offers a Web form which allows pertinent information to be
-entered and submitted to the developers.
-
-Before submitting a report, please log into SourceForge if you are a
-member; this will make it possible for the developers to contact you
-for additional information if needed.  If you are not a SourceForge
-member but would not mind the developers contacting you, you may
-include your email address in your bug description.  In this case,
-please realize that the information is publically available and cannot
-be protected.
-
-The first step in filing a report is to determine whether the problem
-has already been reported.  The advantage in doing so, aside from
-saving the developers time, is that you learn what has been done to
-fix it; it may be that the problem has already been fixed for the next
-release, or additional information is needed (in which case you are
-welcome to provide it if you can!).  To do this, search the bug
-database using the search box near the bottom of the page.
-
-If the problem you're reporting is not already in the bug tracker, go
-back to the Python Bug Tracker
-(\url{http://sourceforge.net/bugs/?group_id=5470}).  Select the
-``Submit a Bug'' link at the top of the page to open the bug reporting
-form.
-
-The submission form has a number of fields.  The only fields that are
-required are the ``Summary'' and ``Details'' fields.  For the summary,
-enter a \emph{very} short description of the problem; less than ten
-words is good.  In the Details field, describe the problem in detail,
-including what you expected to happen and what did happen.  Be sure to
-include the version of Python you used, whether any extension modules
-were involved, and what hardware and software platform you were using
-(including version information as appropriate).
-
-The only other field that you may want to set is the ``Category''
-field, which allows you to place the bug report into a broad category
-(such as ``Documentation'' or ``Library'').
-
-Each bug report will be assigned to a developer who will determine
-what needs to be done to correct the problem.  If you have a
-SourceForge account and logged in to report the problem, you will
-receive an update each time action is taken on the bug.
-
-
-\begin{seealso}
-  \seetitle[http://www-mice.cs.ucl.ac.uk/multimedia/software/documentation/ReportingBugs.html]{How
-        to Report Bugs Effectively}{Article which goes into some
-        detail about how to create a useful bug report.  This
-        describes what kind of information is useful and why it is
-        useful.}
-
-  \seetitle[http://www.mozilla.org/quality/bug-writing-guidelines.html]{Bug
-        Writing Guidelines}{Information about writing a good bug
-        report.  Some of this is specific to the Mozilla project, but
-        describes general good practices.}
-\end{seealso}
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/toc2bkm.py hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/toc2bkm.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/toc2bkm.py	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/toc2bkm.py	1970-01-01 01:00:00.000000000 +0100
@@ -1,143 +0,0 @@
-#! /usr/bin/env python
-
-"""Convert a LaTeX .toc file to some PDFTeX magic to create that neat outline.
-
-The output file has an extension of '.bkm' instead of '.out', since hyperref
-already uses that extension.
-"""
-
-import getopt
-import os
-import re
-import string
-import sys
-
-
-# Ench item in an entry is a tuple of:
-#
-#   Section #,  Title String,  Page #,  List of Sub-entries
-#
-# The return value of parse_toc() is such a tuple.
-
-cline_re = r"""^
-\\contentsline\ \{([a-z]*)}             # type of section in $1
-\{(?:\\numberline\ \{([0-9.A-Z]+)})?     # section number
-(.*)}                                   # title string
-\{(\d+)}$"""                            # page number
-
-cline_rx = re.compile(cline_re, re.VERBOSE)
-
-OUTER_TO_INNER = -1
-
-_transition_map = {
-    ('chapter', 'section'): OUTER_TO_INNER,
-    ('section', 'subsection'): OUTER_TO_INNER,
-    ('subsection', 'subsubsection'): OUTER_TO_INNER,
-    ('subsubsection', 'subsection'): 1,
-    ('subsection', 'section'): 1,
-    ('section', 'chapter'): 1,
-    ('subsection', 'chapter'): 2,
-    ('subsubsection', 'section'): 2,
-    ('subsubsection', 'chapter'): 3,
-    }
-
-INCLUDED_LEVELS = ("chapter", "section", "subsection", "subsubsection")
-
-
-def parse_toc(fp, bigpart=None):
-    toc = top = []
-    stack = [toc]
-    level = bigpart or 'chapter'
-    lineno = 0
-    while 1:
-        line = fp.readline()
-        if not line:
-            break
-        lineno = lineno + 1
-        m = cline_rx.match(line)
-        if m:
-            stype, snum, title, pageno = m.group(1, 2, 3, 4)
-            title = clean_title(title)
-            entry = (stype, snum, title, string.atoi(pageno), [])
-            if stype == level:
-                toc.append(entry)
-            else:
-                if stype not in INCLUDED_LEVELS:
-                    # we don't want paragraphs & subparagraphs
-                    continue
-                direction = _transition_map[(level, stype)]
-                if direction == OUTER_TO_INNER:
-                    toc = toc[-1][-1]
-                    stack.insert(0, toc)
-                    toc.append(entry)
-                else:
-                    for i in range(direction):
-                        del stack[0]
-                        toc = stack[0]
-                    toc.append(entry)
-                level = stype
-        else:
-            sys.stderr.write("l.%s: " + line)
-    return top
-
-
-hackscore_rx = re.compile(r"\\hackscore\s*{[^}]*}")
-raisebox_rx = re.compile(r"\\raisebox\s*{[^}]*}")
-title_rx = re.compile(r"\\([a-zA-Z])+\s+")
-title_trans = string.maketrans("", "")
-
-def clean_title(title):
-    title = raisebox_rx.sub("", title)
-    title = hackscore_rx.sub(r"\\_", title)
-    pos = 0
-    while 1:
-        m = title_rx.search(title, pos)
-        if m:
-            start = m.start()
-            if title[start:start+15] != "\\textunderscore":
-                title = title[:start] + title[m.end():]
-            pos = start + 1
-        else:
-            break
-    title = string.translate(title, title_trans, "{}")
-    return title
-
-
-def write_toc(toc, fp):
-    for entry in toc:
-        write_toc_entry(entry, fp, 0)
-
-def write_toc_entry(entry, fp, layer):
-    stype, snum, title, pageno, toc = entry
-    s = "\\pdfoutline goto name{page%03d}" % pageno
-    if toc:
-        s = "%s count -%d" % (s, len(toc))
-    if snum:
-        title = "%s %s" % (snum, title)
-    s = "%s {%s}\n" % (s, title)
-    fp.write(s)
-    for entry in toc:
-        write_toc_entry(entry, fp, layer + 1)
-
-
-def process(ifn, ofn, bigpart=None):
-    toc = parse_toc(open(ifn), bigpart)
-    write_toc(toc, open(ofn, "w"))
-
-
-def main():
-    bigpart = None
-    opts, args = getopt.getopt(sys.argv[1:], "c:")
-    if opts:
-        bigpart = opts[0][1]
-    if not args:
-        usage()
-        sys.exit(2)
-    for filename in args:
-        base, ext = os.path.splitext(filename)
-        ext = ext or ".toc"
-        process(base + ext, base + ".bkm", bigpart)
-
-
-if __name__ == "__main__":
-    main()
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/update-docs.sh hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/update-docs.sh
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/update-docs.sh	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/update-docs.sh	1970-01-01 01:00:00.000000000 +0100
@@ -1,21 +0,0 @@
-#! /bin/sh
-
-# Script which installs a development snapshot of the documentation
-# into the "Python @ SourceForge" website.
-#
-# The push-docs.sh script pushes this to the SourceForge when needed
-# and removes it when done.
-
-if [ -z "$HOME" ] ; then
-    HOME=`grep fdrake /etc/passwd | sed 's|^.*:\([^:]*\):[^:]*$|\1|'`
-    export HOME
-fi
-
-UPDATES="$HOME/tmp/$1"
-
-cd /home/groups/python/htdocs || exit $?
-rm -rf devel-docs || exit $?
-mkdir devel-docs || exit $?
-cd devel-docs || exit $?
-(bzip2 -dc "$UPDATES" | tar xf -) || exit $?
-rm "$UPDATES" || exit $?
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/whichlibs hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/whichlibs
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/doc/tools/whichlibs	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/doc/tools/whichlibs	1970-01-01 01:00:00.000000000 +0100
@@ -1,2 +0,0 @@
-#!/bin/sh
-sed -n 's%^\\input{\(lib[a-zA-Z0-9_]*\)}.*%../lib/\1.tex%p' ../lib/lib.tex
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/INSTALL hue-release-3.9.0/desktop/core/ext-py/pyopenssl/INSTALL
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/INSTALL	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/INSTALL	1970-01-01 01:00:00.000000000 +0100
@@ -1,146 +0,0 @@
-
-INSTALLATION INSTRUCTIONS FOR pyOpenSSL
-------------------------------------------------------------------------------
-
-I have tested this on Debian Linux systems (woody and sid), Solaris 2.6 and
-2.7. Others have successfully compiled it on Windows and NT.
-
-
--- Building the Module on a Unix System --
-
-pyOpenSSL uses distutils, so there really shouldn't be any problems. To build
-the library:
-
-  $ python setup.py build
-
-If your OpenSSL header files aren't in /usr/include, you may need to supply
-the -I flag to let the setup script know where to look. The same goes for the
-libraries of course, use the -L flag. Note that build won't accept these
-flags, so you have to run first build_ext and then build! Example:
-
-  $ python setup.py build_ext -I/usr/local/ssl/include -L/usr/local/ssl/lib
-  $ python setup.py build
-
-Now you should have a directory called OpenSSL that contains e.g. SSL.so and
-__init__.py somewhere in the build dicrectory, so just:
-
-  $ python setup.py install
-
-If you, for some arcane reason, don't want the module to appear in the
-site-packages directory, use the --prefix option.
-
-You can, of course, do
-
-  $ python setup.py --help
-
-to find out more about how to use the script.
-
-
--- Building the Module on a Windows System --
-
-First you should get OpenSSL linked with the same runtime library that Python
-uses.  If you are using Python 2.6 you can use the installer at:
-
-  http://www.slproweb.com/products/Win32OpenSSL.html
-
-The binaries in the installer are built with Visual Studio 2008 at the
-time of this writing, which is the same compiler used for building the
-official Python 2.6 installers.
-
-If you want to build pyOpenSSL for an older Python version, it is preferred
-to build OpenSSL yourself, either with the Visual Studio 2003 compiler or
-with the MinGW compiler.  This way you avoid all potential incompatibilities
-between different versions of runtime library (msvcrt.dll).  To build
-OpenSSL follow the instructions in its source distribution and make sure
-that you build a shared library, not a static one.  pyOpenSSL fails some of
-its tests when linked with the static OpenSSL libraries.  Use the same
-compiler for OpenSSL that you will use for pyOpenSSL later.  Make sure that
-OpenSSL is properly installed before continuing.  To install OpenSSL when
-building with MinGW, use the folowing script:
-
-set OPENSSL_INSTALL_DIR=%1
-mkdir %OPENSSL_INSTALL_DIR%
-mkdir %OPENSSL_INSTALL_DIR%\bin
-mkdir %OPENSSL_INSTALL_DIR%\include
-mkdir %OPENSSL_INSTALL_DIR%\include\openssl
-mkdir %OPENSSL_INSTALL_DIR%\lib
-copy /b .\*.dll            %OPENSSL_INSTALL_DIR%\bin
-copy /b .\out\openssl.exe  %OPENSSL_INSTALL_DIR%\bin
-copy /b .\outinc\openssl\* %OPENSSL_INSTALL_DIR%\include\openssl
-copy /b .\out\*.a          %OPENSSL_INSTALL_DIR%\lib
-
-Ensure that OpenSSL's openssl.exe executable can be found on PATH before
-running pyOpenSSL's setup script.  The setup script finds OpenSSL's include
-dir and lib dir based on the location of openssl.exe, and the test suite
-requires openssl.exe for output comparison.  Alternatively, you can specify
-the --with-openssl option to setup.py's build_ext command with the path to
-the OpenSSL installation dir:
-
-  > python setup.py build_ext --with-openssl=C:\path\to\openssl build
-
-pyOpenSSL is known to build with mingw32 for Python 2.3 through Python 2.5.
-Before using the mingw32 compiler for Python 2.3, you will have to create
-a Python library that MinGW understands. Find and download the pexports
-program, put it and MinGW's bin directory on path, then run from Python's
-install dir:
-
-> pexports python23.dll > libs\python23.def
-> dlltool --dllname python23.dll --def libs\python23.def \
-          --output-lib libs\libpython23.a
-
-For Python 2.4 and 2.5, no special preparation is needed, just make sure that
-MinGW's gcc is on PATH.  You can specify that mingw32 be used by passing
-the --compiler argument to build_ext:
-
-  C:\pyOpenSSL-X.Y> setup.py build_ext -c mingw32 bdist_msi
-
-The bdist_msi command will build an MSI installer.  It can be substituted
-with another bdist command if another kind of installer is desired or with
-the install command if you want to install directly.
-
-For Python 2.4 and 2.5 you can use Visual Studio 2003 in addition to MinGW.
-For Python 2.6, the official Windows installer of which is built with
-Microsoft Visual Studio 2008 (version 9.0), Microsoft Visual Studio 2008
-(version 9.0) is required.
-
-To build with MSVC, just omit the compiler specific option:
-
-  C:\pyOpenSSL-X.Y> setup.py bdist_msi
-
-The resulting binary distribution will be placed in the dist directory. To
-install it, depending on what kind of distribution you create, run it,
-unzip it, or copy it to Python installation's site-packages.
-
-And similarily, you can do
-
-    setup.py --help
-
-to get more information.
-
-Big thanks to Itamar Shtull-Trauring, Oleg Orlov, Zooko O'Whielacronx, Chris
-Galvan, Å½iga Seilnacht, and #python and #distutils on FreeNode for their
-help with Windows build instructions and to Michael Schneider for providing
-Windows build hosts.
-
--- Documentation --
-
-The documentation is written in LaTeX, using the standard Python templates,
-and tools to compile it into a number of forms are included.  You need to
-supply things like dvips, latex2html yourself of course!
-
-To build the text, html, postscript or dvi forms of the documentation, this is
-what you do:
-
-    cd doc
-    # To make the text-only documentation:
-    make text
-    # To make the dvi form:
-    make dvi
-
-It's as simple as that.  Note that since Python's mkhowto script is used, if
-you do first ``make dvi'' and then ``make ps'', the dvi file will disappear.
-I included a special build target ``make all'' that will build all the
-documentation in an order that won't let anything disappear.
-
-
-@(#) $Id: INSTALL,v 1.7 2002/06/14 12:14:19 martin Exp $
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/INSTALL.rst hue-release-3.9.0/desktop/core/ext-py/pyopenssl/INSTALL.rst
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/INSTALL.rst	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/INSTALL.rst	2015-04-14 04:50:11.000000000 +0200
@@ -0,0 +1,19 @@
+Installation
+============
+
+To install pyOpenSSL::
+
+  $ pip install pyopenssl
+
+If you are installing in order to *develop* on pyOpenSSL, move to the root directory of a pyOpenSSL checkout, and run::
+
+  $ pip install -e .
+
+
+Documentation
+=============
+
+The documentation is written in reStructuredText and built using Sphinx::
+
+  $ cd doc
+  $ make html
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/MANIFEST.in hue-release-3.9.0/desktop/core/ext-py/pyopenssl/MANIFEST.in
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/MANIFEST.in	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/MANIFEST.in	2015-04-14 16:51:21.000000000 +0200
@@ -1,7 +1,8 @@
-recursive-include       OpenSSL     *.h
-include     LICENSE ChangeLog INSTALL README TODO MANIFEST.in OpenSSL/RATIONALE
-include     doc/pyOpenSSL.tex doc/Makefile
-recursive-include   doc/tools   *
+include     LICENSE ChangeLog TODO MANIFEST.in OpenSSL/RATIONALE *.rst tox.ini memdbg.py runtests.py OpenSSL/test/README
+exclude leakcheck
+recursive-include   doc         *
 recursive-include   examples    *
 recursive-include   rpm         *
+recursive-exclude   leakcheck   *.py *.pem
 global-exclude  *.pyc
+prune               doc/_build
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/memdbg.py hue-release-3.9.0/desktop/core/ext-py/pyopenssl/memdbg.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/memdbg.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/memdbg.py	2014-01-11 19:56:38.000000000 +0100
@@ -0,0 +1,82 @@
+import sys
+sys.modules['ssl'] = None
+sys.modules['_hashlib'] = None
+
+
+import traceback
+
+from cffi import api as _api
+_ffi = _api.FFI()
+_ffi.cdef(
+    """
+    void *malloc(size_t size);
+    void free(void *ptr);
+    void *realloc(void *ptr, size_t size);
+
+    int  CRYPTO_set_mem_functions(void *(*m)(size_t),void *(*r)(void *,size_t), void (*f)(void *));
+
+    int backtrace(void **buffer, int size);
+    char **backtrace_symbols(void *const *buffer, int size);
+    void backtrace_symbols_fd(void *const *buffer, int size, int fd);
+    """)
+_api = _ffi.verify(
+    """
+    #include <openssl/crypto.h>
+    #include <stdlib.h>
+    #include <execinfo.h>
+    """, libraries=["crypto"])
+C = _ffi.dlopen(None)
+
+verbose = False
+
+def log(s):
+    if verbose:
+        print(s)
+
+def _backtrace():
+    buf = _ffi.new("void*[]", 64)
+    result = _api.backtrace(buf, len(buf))
+    strings = _api.backtrace_symbols(buf, result)
+    stack = [_ffi.string(strings[i]) for i in range(result)]
+    C.free(strings)
+    return stack
+
+
+@_ffi.callback("void*(*)(size_t)")
+def malloc(n):
+    memory = C.malloc(n)
+    python_stack = traceback.extract_stack(limit=3)
+    c_stack = _backtrace()
+    heap[memory] = [(n, python_stack, c_stack)]
+    log("malloc(%d) -> %s" % (n, memory))
+    return memory
+
+
+@_ffi.callback("void*(*)(void*, size_t)")
+def realloc(p, n):
+    memory = C.realloc(p, n)
+    old = heap.pop(p)
+
+    python_stack = traceback.extract_stack(limit=3)
+    c_stack = _backtrace()
+
+    old.append((n, python_stack, c_stack))
+    heap[memory] = old
+    log("realloc(0x%x, %d) -> %s" % (int(_ffi.cast("int", p)), n, memory))
+    return memory
+
+
+@_ffi.callback("void(*)(void*)")
+def free(p):
+    if p != _ffi.NULL:
+        C.free(p)
+        del heap[p]
+        log("free(0x%x)" % (int(_ffi.cast("int", p)),))
+
+
+if _api.CRYPTO_set_mem_functions(malloc, realloc, free):
+    log('Enabled memory debugging')
+    heap = {}
+else:
+    log('Failed to enable memory debugging')
+    heap = None
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/crl.c hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/crl.c
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/crl.c	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/crl.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,290 +0,0 @@
-#include <Python.h>
-#define crypto_MODULE
-#include "crypto.h"
-
-
-X509_REVOKED * X509_REVOKED_dup(X509_REVOKED *orig) {
-    X509_REVOKED *dupe = NULL;
-
-    dupe = X509_REVOKED_new();
-    if (dupe == NULL) {
-        return NULL;
-    }
-    if (orig->serialNumber) {
-        dupe->serialNumber = M_ASN1_INTEGER_dup(orig->serialNumber); 
-    }
-    if (orig->revocationDate) {
-        dupe->revocationDate = M_ASN1_INTEGER_dup(orig->revocationDate); 
-    }
-    if (orig->extensions) {
-        STACK_OF(X509_EXTENSION) *sk = NULL;
-        X509_EXTENSION * ext;
-        int j;
-
-        sk = sk_X509_EXTENSION_new_null();
-        for (j = 0; j < sk_X509_EXTENSION_num(orig->extensions); j++) {
-            ext = sk_X509_EXTENSION_value(orig->extensions, j);
-            ext = X509_EXTENSION_dup(ext);
-            sk_X509_EXTENSION_push(sk, ext);
-        }
-        dupe->extensions = sk;
-    }
-    dupe->sequence = orig->sequence;
-    return dupe;
-}
-
-static char crypto_CRL_get_revoked_doc[] = "\n\
-Return revoked portion of the CRL structure (by value\n\
-not reference).\n\
-\n\
-@return: A tuple of Revoked objects.\n\
-";
-static PyObject *
-crypto_CRL_get_revoked(crypto_CRLObj *self, PyObject *args) {
-    int j, num_rev;
-    X509_REVOKED *r = NULL;
-    PyObject *obj = NULL, *rev_obj;
-
-    if (!PyArg_ParseTuple(args, ":get_revoked")) {
-        return NULL;
-    }
-
-    num_rev = sk_X509_REVOKED_num(self->crl->crl->revoked);
-    if (num_rev < 0) {
-        Py_INCREF(Py_None);
-        return Py_None;
-    }
-    if ((obj = PyTuple_New(num_rev)) == NULL) {
-        return NULL;
-    }
-
-    for (j = 0; j < num_rev; j++) {
-        r = sk_X509_REVOKED_value(self->crl->crl->revoked, j);
-        r = X509_REVOKED_dup(r);
-        if (r == NULL ) {
-            goto error;
-        }
-        rev_obj = (PyObject *) crypto_Revoked_New(r);
-        if (rev_obj == NULL) {
-            goto error;
-        }
-        r = NULL; /* it's now owned by rev_obj */
-        PyTuple_SET_ITEM(obj, j, rev_obj);
-    }
-    return obj;
-
- error:
-    if (r) {
-        X509_REVOKED_free(r);
-    }
-    Py_XDECREF(obj);
-    return NULL;
-}
-
-static char crypto_CRL_add_revoked_doc[] = "\n\
-Add a revoked (by value not reference) to the CRL structure\n\
-\n\
-@param cert: The new revoked.\n\
-@type cert: L{X509}\n\
-@return: None\n\
-";
-static PyObject *
-crypto_CRL_add_revoked(crypto_CRLObj *self, PyObject *args, PyObject *keywds) {
-    crypto_RevokedObj * rev_obj = NULL;
-    static char *kwlist[] = {"revoked", NULL};
-    X509_REVOKED * dup;
-
-    if (!PyArg_ParseTupleAndKeywords(args, keywds, "O!:add_revoked", 
-        kwlist, &crypto_Revoked_Type, &rev_obj)) {
-        return NULL;
-    }
-
-    dup = X509_REVOKED_dup( rev_obj->revoked );
-    if (dup == NULL) {
-        return NULL;
-    }
-    X509_CRL_add0_revoked(self->crl, dup);
-
-    Py_INCREF(Py_None);
-    return Py_None;
-}
-
-static char crypto_CRL_export_doc[] = "\n\
-export(cert, key[, type[, days]]) -> export a CRL as a string\n\
-\n\
-@param cert: Used to sign CRL.\n\
-@type cert: L{X509}\n\
-@param key: Used to sign CRL.\n\
-@type key: L{PKey}\n\
-@param type: The export format, either L{FILETYPE_PEM}, L{FILETYPE_ASN1}, or L{FILETYPE_TEXT}.\n\
-@param days: The number of days until the next update of this CRL.\n\
-@type days: L{int}\n\
-@return: L{str}\n\
-";
-static PyObject *
-crypto_CRL_export(crypto_CRLObj *self, PyObject *args, PyObject *keywds) {
-    int ret, buf_len, type = X509_FILETYPE_PEM, days = 100;
-    char *temp;
-    BIO *bio;
-    PyObject *buffer;
-    crypto_PKeyObj *key;
-    ASN1_TIME *tmptm;
-    crypto_X509Obj *x509;
-    static char *kwlist[] = {"cert", "key", "type", "days", NULL};
-    
-    if (!PyArg_ParseTupleAndKeywords(args, keywds, "O!O!|ii:dump_crl", kwlist,
-                                     &crypto_X509_Type, &x509, 
-                                     &crypto_PKey_Type, &key, &type, &days)) {
-        return NULL;
-    }
-    
-    bio = BIO_new(BIO_s_mem());
-    tmptm = ASN1_TIME_new();
-    if (!tmptm) {
-        return 0;
-    }
-    X509_gmtime_adj(tmptm,0);
-    X509_CRL_set_lastUpdate(self->crl, tmptm);
-    X509_gmtime_adj(tmptm,days*24*60*60);
-    X509_CRL_set_nextUpdate(self->crl, tmptm);
-    ASN1_TIME_free(tmptm);
-    X509_CRL_set_issuer_name(self->crl, X509_get_subject_name(x509->x509));
-    X509_CRL_sign(self->crl, key->pkey, EVP_md5());
-    switch (type) {
-        case X509_FILETYPE_PEM:
-            ret = PEM_write_bio_X509_CRL(bio, self->crl);
-            break;
-
-        case X509_FILETYPE_ASN1:
-            ret = (int) i2d_X509_CRL_bio(bio, self->crl);
-            break;
-
-        case X509_FILETYPE_TEXT:
-            ret = X509_CRL_print(bio, self->crl);
-            break;
-
-        default:
-            PyErr_SetString(
-                PyExc_ValueError,
-                "type argument must be FILETYPE_PEM, FILETYPE_ASN1, or FILETYPE_TEXT");
-            return NULL;
-    }
-    if (!ret) {
-        exception_from_error_queue(crypto_Error);
-        BIO_free(bio);
-        return NULL;
-    }
-    buf_len = BIO_get_mem_data(bio, &temp);
-    buffer = PyBytes_FromStringAndSize(temp, buf_len);
-    BIO_free(bio);
-    return buffer;
-}
-
-crypto_CRLObj *
-crypto_CRL_New(X509_CRL *crl) {
-    crypto_CRLObj *self;
-
-    self = PyObject_New(crypto_CRLObj, &crypto_CRL_Type);
-    if (self == NULL) {
-        return NULL;
-    }
-    self->crl = crl;
-    return self;
-}
-
-/*
- * ADD_METHOD(name) expands to a correct PyMethodDef declaration
- *   {  'name', (PyCFunction)crypto_CRL_name, METH_VARARGS, crypto_CRL_name_doc }
- * for convenience
- */
-#define ADD_METHOD(name)        \
-    { #name, (PyCFunction)crypto_CRL_##name, METH_VARARGS, crypto_CRL_##name##_doc }
-#define ADD_KW_METHOD(name)        \
-    { #name, (PyCFunction)crypto_CRL_##name, METH_VARARGS | METH_KEYWORDS, crypto_CRL_##name##_doc }
-static PyMethodDef crypto_CRL_methods[] = {
-    ADD_KW_METHOD(add_revoked),
-    ADD_METHOD(get_revoked),
-    ADD_KW_METHOD(export),
-    { NULL, NULL }
-};
-#undef ADD_METHOD
-
-
-static void
-crypto_CRL_dealloc(crypto_CRLObj *self) {
-    X509_CRL_free(self->crl);
-    self->crl = NULL;
-
-    PyObject_Del(self);
-}
-
-static char crypto_CRL_doc[] = "\n\
-CRL() -> CRL instance\n\
-\n\
-Create a new empty CRL object.\n\
-\n\
-@returns: The CRL object\n\
-";
-
-static PyObject* crypto_CRL_new(PyTypeObject *subtype, PyObject *args, PyObject *kwargs) {
-    if (!PyArg_ParseTuple(args, ":CRL")) {
-        return NULL;
-    }
-    
-    return (PyObject *)crypto_CRL_New(X509_CRL_new());
-}
-
-PyTypeObject crypto_CRL_Type = {
-    PyOpenSSL_HEAD_INIT(&PyType_Type, 0)
-    "CRL",
-    sizeof(crypto_CRLObj),
-    0,
-    (destructor)crypto_CRL_dealloc,
-    NULL, /* print */
-    NULL, /* getattr */
-    NULL, /* setattr */
-    NULL, /* compare */
-    NULL, /* repr */
-    NULL, /* as_number */
-    NULL, /* as_sequence */
-    NULL, /* as_mapping */
-    NULL, /* hash */
-    NULL, /* call */
-    NULL, /* str */
-    NULL, /* getattro */
-    NULL, /* setattro */
-    NULL, /* as_buffer */
-    Py_TPFLAGS_DEFAULT,
-    crypto_CRL_doc, /* doc */
-    NULL, /* traverse */
-    NULL, /* clear */
-    NULL, /* tp_richcompare */
-    0, /* tp_weaklistoffset */
-    NULL, /* tp_iter */
-    NULL, /* tp_iternext */
-    crypto_CRL_methods, /* tp_methods */
-    NULL, /* tp_members */
-    NULL, /* tp_getset */
-    NULL, /* tp_base */
-    NULL, /* tp_dict */
-    NULL, /* tp_descr_get */
-    NULL, /* tp_descr_set */
-    0, /* tp_dictoffset */
-    NULL, /* tp_init */
-    NULL, /* tp_alloc */
-    crypto_CRL_new, /* tp_new */
-};
-
-int init_crypto_crl(PyObject *module) {
-    if (PyType_Ready(&crypto_CRL_Type) < 0) {
-        return 0;
-    }
-
-    /* PyModule_AddObject steals a reference.
-     */
-    Py_INCREF((PyObject *)&crypto_CRL_Type);
-    if (PyModule_AddObject(module, "CRL", (PyObject *)&crypto_CRL_Type) != 0) {
-        return 0;
-    }
-    return 1;
-}
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/crl.h hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/crl.h
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/crl.h	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/crl.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,19 +0,0 @@
-#ifndef PyOpenSSL_crypto_CRL_H_
-#define PyOpenSSL_crypto_CRL_H_
-
-#include <Python.h>
-
-extern  int       init_crypto_crl   (PyObject *);
-
-extern  PyTypeObject      crypto_CRL_Type;
-
-#define crypto_CRL_Check(v) ((v)->ob_type == &crypto_CRL_Type)
-
-typedef struct {
-    PyObject_HEAD
-    X509_CRL *crl;
-} crypto_CRLObj;
-
-crypto_CRLObj * crypto_CRL_New(X509_CRL *crl);
-
-#endif
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/crypto.c hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/crypto.c
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/crypto.c	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/crypto.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,898 +0,0 @@
-/*
- * crypto.c
- *
- * Copyright (C) AB Strakt
- * Copyright (C) Keyphrene
- * Copyright (C) Jean-Paul Calderone
- * See LICENSE for details.
- *
- * Main file of crypto sub module.
- * See the file RATIONALE for a short explanation of why this module was written.
- *
- * Reviewed 2001-07-23
- */
-#include <Python.h>
-#define crypto_MODULE
-#include "crypto.h"
-#include "pkcs12.h"
-
-static char crypto_doc[] = "\n\
-Main file of crypto sub module.\n\
-See the file RATIONALE for a short explanation of why this module was written.\n\
-";
-
-void **ssl_API;
-
-PyObject *crypto_Error;
-
-int crypto_byte_converter(PyObject *input, void* output) {
-    char **message = output;
-    if (input == Py_None) {
-        *message = NULL;
-    } else if (PyBytes_CheckExact(input)) {
-        *message = PyBytes_AsString(input);
-    } else {
-        return 0;
-    }
-    return 1;
-}
-
-static int
-global_passphrase_callback(char *buf, int len, int rwflag, void *cb_arg)
-{
-    PyObject *func, *argv, *ret;
-    int nchars;
-
-    func = (PyObject *)cb_arg;
-    argv = Py_BuildValue("(i)", rwflag);
-    ret = PyEval_CallObject(func, argv);
-    Py_DECREF(argv);
-    if (ret == NULL)
-        return 0;
-    if (!PyBytes_Check(ret))
-    {
-        PyErr_SetString(PyExc_ValueError, "String expected");
-        return 0;
-    }
-    nchars = PyBytes_Size(ret);
-    if (nchars > len)
-        nchars = len;
-    strncpy(buf, PyBytes_AsString(ret), nchars);
-    return nchars;
-}
-
-static char crypto_load_privatekey_doc[] = "\n\
-Load a private key from a buffer\n\
-\n\
-@param type: The file type (one of FILETYPE_PEM, FILETYPE_ASN1)\n\
-@param buffer: The buffer the key is stored in\n\
-@param passphrase: (optional) if encrypted PEM format, this can be\n\
-                   either the passphrase to use, or a callback for\n\
-                   providing the passphrase.\n\
-\n\
-@return: The PKey object\n\
-";
-
-static PyObject *
-crypto_load_privatekey(PyObject *spam, PyObject *args)
-{
-    crypto_PKeyObj *crypto_PKey_New(EVP_PKEY *, int);
-    int type, len;
-    char *buffer;
-    PyObject *pw = NULL;
-    pem_password_cb *cb = NULL;
-    void *cb_arg = NULL;
-    BIO *bio;
-    EVP_PKEY *pkey;
-
-    if (!PyArg_ParseTuple(args, "is#|O:load_privatekey", &type, &buffer, &len, &pw))
-        return NULL;
-
-    if (pw != NULL)
-    {
-        if (PyBytes_Check(pw))
-        {
-            cb = NULL;
-            cb_arg = PyBytes_AsString(pw);
-        }
-        else if (PyCallable_Check(pw))
-        {
-            cb = global_passphrase_callback;
-            cb_arg = pw;
-        }
-        else
-        {
-            PyErr_SetString(PyExc_TypeError, "Last argument must be string or callable");
-            return NULL;
-        }
-    }
-
-    bio = BIO_new_mem_buf(buffer, len);
-    switch (type)
-    {
-        case X509_FILETYPE_PEM:
-            pkey = PEM_read_bio_PrivateKey(bio, NULL, cb, cb_arg);
-            break;
-
-        case X509_FILETYPE_ASN1:
-            pkey = d2i_PrivateKey_bio(bio, NULL);
-            break;
-
-        default:
-            PyErr_SetString(PyExc_ValueError, "type argument must be FILETYPE_PEM or FILETYPE_ASN1");
-            BIO_free(bio);
-            return NULL;
-    }
-    BIO_free(bio);
-
-    if (pkey == NULL)
-    {
-        exception_from_error_queue(crypto_Error);
-        return NULL;
-    }
-
-    return (PyObject *)crypto_PKey_New(pkey, 1);
-}
-
-static char crypto_dump_privatekey_doc[] = "\n\
-Dump a private key to a buffer\n\
-\n\
-@param type: The file type (one of FILETYPE_PEM, FILETYPE_ASN1)\n\
-@param pkey: The PKey to dump\n\
-@param cipher: (optional) if encrypted PEM format, the cipher to\n\
-               use\n\
-@param passphrase - (optional) if encrypted PEM format, this can be either\n\
-                    the passphrase to use, or a callback for providing the\n\
-                    passphrase.\n\
-@return: The buffer with the dumped key in\n\
-@rtype: C{str}\n\
-";
-
-static PyObject *
-crypto_dump_privatekey(PyObject *spam, PyObject *args)
-{
-    int type, ret, buf_len;
-    char *temp;
-    PyObject *buffer;
-    char *cipher_name = NULL;
-    const EVP_CIPHER *cipher = NULL;
-    PyObject *pw = NULL;
-    pem_password_cb *cb = NULL;
-    void *cb_arg = NULL;
-    BIO *bio;
-    RSA *rsa;
-    crypto_PKeyObj *pkey;
-
-    if (!PyArg_ParseTuple(args, "iO!|sO:dump_privatekey", &type,
-			  &crypto_PKey_Type, &pkey, &cipher_name, &pw))
-        return NULL;
-
-    if (cipher_name != NULL && pw == NULL)
-    {
-        PyErr_SetString(PyExc_ValueError, "Illegal number of arguments");
-        return NULL;
-    }
-    if (cipher_name != NULL)
-    {
-        cipher = EVP_get_cipherbyname(cipher_name);
-        if (cipher == NULL)
-        {
-            PyErr_SetString(PyExc_ValueError, "Invalid cipher name");
-            return NULL;
-        }
-        if (PyBytes_Check(pw))
-        {
-            cb = NULL;
-            cb_arg = PyBytes_AsString(pw);
-        }
-        else if (PyCallable_Check(pw))
-        {
-            cb = global_passphrase_callback;
-            cb_arg = pw;
-        }
-        else
-        {
-            PyErr_SetString(PyExc_TypeError, "Last argument must be string or callable");
-            return NULL;
-        }
-    }
-
-    bio = BIO_new(BIO_s_mem());
-    switch (type)
-    {
-        case X509_FILETYPE_PEM:
-            ret = PEM_write_bio_PrivateKey(bio, pkey->pkey, cipher, NULL, 0, cb, cb_arg);
-            if (PyErr_Occurred())
-            {
-                BIO_free(bio);
-                return NULL;
-            }
-            break;
-
-        case X509_FILETYPE_ASN1:
-            ret = i2d_PrivateKey_bio(bio, pkey->pkey);
-            break;
-
-        case X509_FILETYPE_TEXT:
-            rsa = EVP_PKEY_get1_RSA(pkey->pkey);
-            ret = RSA_print(bio, rsa, 0);
-            RSA_free(rsa); 
-            break;
-
-        default:
-            PyErr_SetString(PyExc_ValueError, "type argument must be FILETYPE_PEM, FILETYPE_ASN1, or FILETYPE_TEXT");
-            BIO_free(bio);
-            return NULL;
-    }
-
-    if (ret == 0)
-    {
-        BIO_free(bio);
-        exception_from_error_queue(crypto_Error);
-        return NULL;
-    }
-
-    buf_len = BIO_get_mem_data(bio, &temp);
-    buffer = PyBytes_FromStringAndSize(temp, buf_len);
-    BIO_free(bio);
-
-    return buffer;
-}
-
-static char crypto_load_certificate_doc[] = "\n\
-Load a certificate from a buffer\n\
-\n\
-@param type: The file type (one of FILETYPE_PEM, FILETYPE_ASN1)\n\
-             buffer - The buffer the certificate is stored in\n\
-@return: The X509 object\n\
-";
-
-static PyObject *
-crypto_load_certificate(PyObject *spam, PyObject *args)
-{
-    crypto_X509Obj *crypto_X509_New(X509 *, int);
-    int type, len;
-    char *buffer;
-    BIO *bio;
-    X509 *cert;
-
-    if (!PyArg_ParseTuple(args, "is#:load_certificate", &type, &buffer, &len))
-        return NULL;
-
-    bio = BIO_new_mem_buf(buffer, len);
-    switch (type)
-    {
-        case X509_FILETYPE_PEM:
-            cert = PEM_read_bio_X509(bio, NULL, NULL, NULL);
-            break;
-
-        case X509_FILETYPE_ASN1:
-            cert = d2i_X509_bio(bio, NULL);
-            break;
-
-        default:
-            PyErr_SetString(PyExc_ValueError, "type argument must be FILETYPE_PEM or FILETYPE_ASN1");
-            BIO_free(bio);
-            return NULL;
-    }
-    BIO_free(bio);
-
-    if (cert == NULL)
-    {
-        exception_from_error_queue(crypto_Error);
-        return NULL;
-    }
-
-    return (PyObject *)crypto_X509_New(cert, 1);
-}
-
-static char crypto_dump_certificate_doc[] = "\n\
-Dump a certificate to a buffer\n\
-\n\
-@param type: The file type (one of FILETYPE_PEM, FILETYPE_ASN1)\n\
-@param cert: The certificate to dump\n\
-@return: The buffer with the dumped certificate in\n\
-";
-
-static PyObject *
-crypto_dump_certificate(PyObject *spam, PyObject *args)
-{
-    int type, ret, buf_len;
-    char *temp;
-    PyObject *buffer;
-    BIO *bio;
-    crypto_X509Obj *cert;
-
-    if (!PyArg_ParseTuple(args, "iO!:dump_certificate", &type,
-			  &crypto_X509_Type, &cert))
-        return NULL;
-
-    bio = BIO_new(BIO_s_mem());
-    switch (type)
-    {
-        case X509_FILETYPE_PEM:
-            ret = PEM_write_bio_X509(bio, cert->x509);
-            break;
-
-        case X509_FILETYPE_ASN1:
-            ret = i2d_X509_bio(bio, cert->x509);
-            break;
-
-        case X509_FILETYPE_TEXT:
-            ret = X509_print_ex(bio, cert->x509, 0, 0);
-            break;
-
-        default:
-            PyErr_SetString(PyExc_ValueError, "type argument must be FILETYPE_PEM, FILETYPE_ASN1, or FILETYPE_TEXT");
-            BIO_free(bio);
-            return NULL;
-    }
-
-    if (ret == 0)
-    {
-        BIO_free(bio);
-        exception_from_error_queue(crypto_Error);
-        return NULL;
-    }
-
-    buf_len = BIO_get_mem_data(bio, &temp);
-    buffer = PyBytes_FromStringAndSize(temp, buf_len);
-    BIO_free(bio);
-
-    return buffer;
-}
-
-static char crypto_load_certificate_request_doc[] = "\n\
-Load a certificate request from a buffer\n\
-\n\
-@param type: The file type (one of FILETYPE_PEM, FILETYPE_ASN1)\n\
-             buffer - The buffer the certificate request is stored in\n\
-@return: The X509Req object\n\
-";
-
-static PyObject *
-crypto_load_certificate_request(PyObject *spam, PyObject *args)
-{
-    crypto_X509ReqObj *crypto_X509Req_New(X509_REQ *, int);
-    int type, len;
-    char *buffer;
-    BIO *bio;
-    X509_REQ *req;
-
-    if (!PyArg_ParseTuple(args, "is#:load_certificate_request", &type, &buffer, &len))
-        return NULL;
-
-    bio = BIO_new_mem_buf(buffer, len);
-    switch (type)
-    {
-        case X509_FILETYPE_PEM:
-            req = PEM_read_bio_X509_REQ(bio, NULL, NULL, NULL);
-            break;
-
-        case X509_FILETYPE_ASN1:
-            req = d2i_X509_REQ_bio(bio, NULL);
-            break;
-
-        default:
-            PyErr_SetString(PyExc_ValueError, "type argument must be FILETYPE_PEM or FILETYPE_ASN1");
-            BIO_free(bio);
-            return NULL;
-    }
-    BIO_free(bio);
-
-    if (req == NULL)
-    {
-        exception_from_error_queue(crypto_Error);
-        return NULL;
-    }
-
-    return (PyObject *)crypto_X509Req_New(req, 1);
-}
-
-static char crypto_dump_certificate_request_doc[] = "\n\
-Dump a certificate request to a buffer\n\
-\n\
-@param type: The file type (one of FILETYPE_PEM, FILETYPE_ASN1)\n\
-             req  - The certificate request to dump\n\
-@return: The buffer with the dumped certificate request in\n\
-";
-
-static PyObject *
-crypto_dump_certificate_request(PyObject *spam, PyObject *args)
-{
-    int type, ret, buf_len;
-    char *temp;
-    PyObject *buffer;
-    BIO *bio;
-    crypto_X509ReqObj *req;
-
-    if (!PyArg_ParseTuple(args, "iO!:dump_certificate_request", &type,
-			  &crypto_X509Req_Type, &req))
-        return NULL;
-
-    bio = BIO_new(BIO_s_mem());
-    switch (type)
-    {
-        case X509_FILETYPE_PEM:
-            ret = PEM_write_bio_X509_REQ(bio, req->x509_req);
-            break;
-
-        case X509_FILETYPE_ASN1:
-            ret = i2d_X509_REQ_bio(bio, req->x509_req);
-            break;
-
-        case X509_FILETYPE_TEXT:
-            ret = X509_REQ_print_ex(bio, req->x509_req, 0, 0);
-            break;
-
-        default:
-            PyErr_SetString(PyExc_ValueError, "type argument must be FILETYPE_PEM, FILETYPE_ASN1, or FILETYPE_TEXT");
-            BIO_free(bio);
-            return NULL;
-    }
-
-    if (ret == 0)
-    {
-        BIO_free(bio);
-        exception_from_error_queue(crypto_Error);
-        return NULL;
-    }
-
-    buf_len = BIO_get_mem_data(bio, &temp);
-    buffer = PyBytes_FromStringAndSize(temp, buf_len);
-    BIO_free(bio);
-
-    return buffer;
-}
-
-static char crypto_load_crl_doc[] = "\n\
-Load a certificate revocation list from a buffer\n\
-\n\
-@param type: The file type (one of FILETYPE_PEM, FILETYPE_ASN1)\n\
-@param buffer: The buffer the CRL is stored in\n\
-\n\
-@return: The PKey object\n\
-";
-
-static PyObject *
-crypto_load_crl(PyObject *spam, PyObject *args) {
-    int type, len;
-    char *buffer;
-    BIO *bio;
-    X509_CRL *crl;
-
-    if (!PyArg_ParseTuple(args, "is#:load_crl", &type, &buffer, &len)) {
-        return NULL;
-    }
-
-    bio = BIO_new_mem_buf(buffer, len);
-    switch (type) {
-        case X509_FILETYPE_PEM:
-            crl = PEM_read_bio_X509_CRL(bio, NULL, NULL, NULL);
-            break;
-
-        case X509_FILETYPE_ASN1:
-            crl = d2i_X509_CRL_bio(bio, NULL);
-            break;
-
-        default:
-            PyErr_SetString(PyExc_ValueError, "type argument must be FILETYPE_PEM or FILETYPE_ASN1");
-            BIO_free(bio);
-            return NULL;
-    }
-    BIO_free(bio);
-
-    if (crl == NULL) {
-        exception_from_error_queue(crypto_Error);
-        return NULL;
-    }
-
-    return (PyObject *)crypto_CRL_New(crl);
-}
-
-static char crypto_load_pkcs7_data_doc[] = "\n\
-Load pkcs7 data from a buffer\n\
-\n\
-@param type: The file type (one of FILETYPE_PEM or FILETYPE_ASN1)\n\
-             buffer - The buffer with the pkcs7 data.\n\
-@return: The PKCS7 object\n\
-";
-
-static PyObject *
-crypto_load_pkcs7_data(PyObject *spam, PyObject *args)
-{
-    int type, len;
-    char *buffer;
-    BIO *bio;
-    PKCS7 *pkcs7 = NULL;
-
-    if (!PyArg_ParseTuple(args, "is#:load_pkcs7_data", &type, &buffer, &len))
-        return NULL;
-
-    /* 
-     * Try to read the pkcs7 data from the bio 
-     */
-    bio = BIO_new_mem_buf(buffer, len);
-    switch (type)
-    {
-        case X509_FILETYPE_PEM:
-            pkcs7 = PEM_read_bio_PKCS7(bio, NULL, NULL, NULL);
-            break;
-
-        case X509_FILETYPE_ASN1:
-            pkcs7 = d2i_PKCS7_bio(bio, NULL);
-            break;
-
-        default:
-            PyErr_SetString(PyExc_ValueError,
-                    "type argument must be FILETYPE_PEM or FILETYPE_ASN1");
-            return NULL;
-    }
-    BIO_free(bio);
-
-    /*
-     * Check if we got a PKCS7 structure
-     */
-    if (pkcs7 == NULL)
-    {
-        exception_from_error_queue(crypto_Error);
-        return NULL;
-    }
-
-    return (PyObject *)crypto_PKCS7_New(pkcs7, 1);
-}
-
-static char crypto_load_pkcs12_doc[] = "\n\
-Load a PKCS12 object from a buffer\n\
-\n\
-@param buffer: The buffer the certificate is stored in\n\
-               passphrase (Optional) - The password to decrypt the PKCS12 lump\n\
-@returns: The PKCS12 object\n\
-";
-
-static PyObject *
-crypto_load_pkcs12(PyObject *spam, PyObject *args)
-{
-    int len;
-    char *buffer, *passphrase = NULL;
-    BIO *bio;
-    PKCS12 *p12;
-
-    if (!PyArg_ParseTuple(args, "s#|s:load_pkcs12", &buffer, &len, &passphrase))
-        return NULL;
-
-    bio = BIO_new_mem_buf(buffer, len);
-    if ((p12 = d2i_PKCS12_bio(bio, NULL)) == NULL)
-    {
-      BIO_free(bio);
-      exception_from_error_queue(crypto_Error);
-      return NULL;
-    }
-    BIO_free(bio);
-
-    return (PyObject *)crypto_PKCS12_New(p12, passphrase);
-}
-
-
-static char crypto_X509_verify_cert_error_string_doc[] = "\n\
-Get X509 verify certificate error string.\n\
-\n\
-@param errnum: The error number.\n\
-@return: Error string as a Python string\n\
-";
-
-static PyObject *
-crypto_X509_verify_cert_error_string(PyObject *spam, PyObject *args)
-{
-    int errnum;
-    const char *str;
-
-    if (!PyArg_ParseTuple(args, "i", &errnum))
-        return NULL;
-
-    str = X509_verify_cert_error_string(errnum);
-    return PyText_FromString(str);
-}
-
-static char crypto_exception_from_error_queue_doc[] = "\n\
-Raise an exception from the current OpenSSL error queue.\n\
-";
-
-static PyObject *
-crypto_exception_from_error_queue(PyObject *spam, PyObject *eggs) {
-    exception_from_error_queue(crypto_Error);
-    return NULL;
-}
-
-static char crypto_sign_doc[] = "\n\
-Sign data with a digest\n\
-\n\
-@param pkey: Pkey to sign with\n\
-@param data: data to be signed\n\
-@param digest: message digest to use\n\
-@return: signature\n\
-";
-
-static PyObject *
-crypto_sign(PyObject *spam, PyObject *args) {
-    PyObject *buffer;
-    crypto_PKeyObj *pkey;
-    char *data = NULL;
-    int data_len;
-    char *digest_name;
-    int err;
-    unsigned int sig_len;
-    const EVP_MD *digest;
-    EVP_MD_CTX md_ctx;
-    unsigned char sig_buf[512];
-
-    if (!PyArg_ParseTuple(
-            args, "O!" BYTESTRING_FMT "#s:sign", &crypto_PKey_Type,
-            &pkey, &data, &data_len, &digest_name)) {
-        return NULL;
-    }
-
-    if ((digest = EVP_get_digestbyname(digest_name)) == NULL) {
-        PyErr_SetString(PyExc_ValueError, "No such digest method");
-        return NULL;
-    }
-
-    EVP_SignInit(&md_ctx, digest);
-    EVP_SignUpdate(&md_ctx, data, data_len);
-    sig_len = sizeof(sig_buf);
-    err = EVP_SignFinal(&md_ctx, sig_buf, &sig_len, pkey->pkey);
-
-    if (err != 1) {
-        exception_from_error_queue(crypto_Error);
-        return NULL;
-    }
-
-    buffer = PyBytes_FromStringAndSize((char*)sig_buf, sig_len);
-    return buffer;
-}
-
-static char crypto_verify_doc[] = "\n\
-Verify a signature\n\
-\n\
-@param cert: signing certificate (X509 object)\n\
-@param signature: signature returned by sign function\n\
-@param data: data to be verified\n\
-@param digest: message digest to use\n\
-@return: None if the signature is correct, raise exception otherwise\n\
-";
-
-static PyObject *
-crypto_verify(PyObject *spam, PyObject *args) {
-    crypto_X509Obj *cert;
-    unsigned char *signature;
-    int sig_len;
-    char *data, *digest_name;
-    int data_len;
-    int err;
-    const EVP_MD *digest;
-    EVP_MD_CTX md_ctx;
-    EVP_PKEY *pkey;
-
-#ifdef PY3
-    if (!PyArg_ParseTuple(args, "O!" BYTESTRING_FMT "#" BYTESTRING_FMT "#s:verify", &crypto_X509_Type, &cert, &signature, &sig_len, &data, &data_len, &digest_name)) {
-#else
-    if (!PyArg_ParseTuple(args, "O!t#s#s:verify", &crypto_X509_Type, &cert, &signature, &sig_len, &data, &data_len, &digest_name)) {
-#endif
-        return NULL;
-    }
-
-    if ((digest = EVP_get_digestbyname(digest_name)) == NULL){
-        PyErr_SetString(PyExc_ValueError, "No such digest method");
-        return NULL;
-    }
-
-    pkey = X509_get_pubkey(cert->x509);
-    if (pkey == NULL) {
-        PyErr_SetString(PyExc_ValueError, "No public key");
-        return NULL;
-    }
-
-    EVP_VerifyInit(&md_ctx, digest);
-    EVP_VerifyUpdate(&md_ctx, data, data_len);
-    err = EVP_VerifyFinal(&md_ctx, signature, sig_len, pkey);
-    EVP_PKEY_free(pkey);
-
-    if (err != 1) {
-        exception_from_error_queue(crypto_Error);
-        return NULL;
-    }
-
-    Py_INCREF(Py_None);
-    return Py_None;
-}
-
-/* Methods in the OpenSSL.crypto module (i.e. none) */
-static PyMethodDef crypto_methods[] = {
-    /* Module functions */
-    { "load_privatekey",  (PyCFunction)crypto_load_privatekey,  METH_VARARGS, crypto_load_privatekey_doc },
-    { "dump_privatekey",  (PyCFunction)crypto_dump_privatekey,  METH_VARARGS, crypto_dump_privatekey_doc },
-    { "load_certificate", (PyCFunction)crypto_load_certificate, METH_VARARGS, crypto_load_certificate_doc },
-    { "dump_certificate", (PyCFunction)crypto_dump_certificate, METH_VARARGS, crypto_dump_certificate_doc },
-    { "load_certificate_request", (PyCFunction)crypto_load_certificate_request, METH_VARARGS, crypto_load_certificate_request_doc },
-    { "dump_certificate_request", (PyCFunction)crypto_dump_certificate_request, METH_VARARGS, crypto_dump_certificate_request_doc },
-    { "load_crl",         (PyCFunction)crypto_load_crl,         METH_VARARGS, crypto_load_crl_doc },
-    { "load_pkcs7_data", (PyCFunction)crypto_load_pkcs7_data, METH_VARARGS, crypto_load_pkcs7_data_doc },
-    { "load_pkcs12", (PyCFunction)crypto_load_pkcs12, METH_VARARGS, crypto_load_pkcs12_doc },
-    { "sign", (PyCFunction)crypto_sign, METH_VARARGS, crypto_sign_doc },
-    { "verify", (PyCFunction)crypto_verify, METH_VARARGS, crypto_verify_doc },
-    { "X509_verify_cert_error_string", (PyCFunction)crypto_X509_verify_cert_error_string, METH_VARARGS, crypto_X509_verify_cert_error_string_doc },
-    { "_exception_from_error_queue", (PyCFunction)crypto_exception_from_error_queue, METH_NOARGS, crypto_exception_from_error_queue_doc },
-    { NULL, NULL }
-};
-
-
-#ifdef WITH_THREAD
-
-#include <pythread.h>
-
-/**
- * This array will store all of the mutexes available to OpenSSL.
- */
-static PyThread_type_lock *mutex_buf = NULL;
-
-
-/**
- * Callback function supplied to OpenSSL to acquire or release a lock.
- *
- */
-static void locking_function(int mode, int n, const char * file, int line) {
-    if (mode & CRYPTO_LOCK) {
-        PyThread_acquire_lock(mutex_buf[n], WAIT_LOCK);
-    } else {
-        PyThread_release_lock(mutex_buf[n]);
-    }
-}
-
-
-/**
- * Initialize OpenSSL for use from multiple threads.
- *
- * Returns: 0 if initialization fails, 1 otherwise.
- */
-static int init_openssl_threads(void) {
-    int i;
-
-    mutex_buf = (PyThread_type_lock *)malloc(
-        CRYPTO_num_locks() * sizeof(PyThread_type_lock));
-    if (!mutex_buf) {
-        return 0;
-    }
-    for (i = 0; i < CRYPTO_num_locks(); ++i) {
-        mutex_buf[i] = PyThread_allocate_lock();
-    }
-    CRYPTO_set_id_callback((unsigned long (*)(void))PyThread_get_thread_ident);
-    CRYPTO_set_locking_callback(locking_function);
-    return 1;
-}
-
-/* /\** */
-/*  * Clean up after OpenSSL thread initialization. */
-/*  *\/ */
-/* static int deinit_openssl_threads() { */
-/*     int i; */
-
-/*     if (!mutex_buf) { */
-/*         return 0; */
-/*     } */
-/*     CRYPTO_set_id_callback(NULL); */
-/*     CRYPTO_set_locking_callback(NULL); */
-/*     for (i = 0; i < CRYPTO_num_locks(); i++) { */
-/*         PyThread_free_lock(mutex_buf[i]); */
-/*     } */
-/*     free(mutex_buf); */
-/*     mutex_buf = NULL; */
-/*     return 1; */
-/* } */
-
-#endif
-
-#ifdef PY3
-static struct PyModuleDef cryptomodule = {
-    PyModuleDef_HEAD_INIT,
-    "crypto",
-    crypto_doc,
-    -1,
-    crypto_methods
-};
-#endif
-
-/*
- * Initialize crypto sub module
- *
- * Arguments: None
- * Returns:   None
- */
-PyOpenSSL_MODINIT(crypto) {
-#ifndef PY3
-    static void *crypto_API[crypto_API_pointers];
-    PyObject *c_api_object;
-#endif
-    PyObject *module;
-
-    ERR_load_crypto_strings();
-    OpenSSL_add_all_algorithms();
-
-#ifdef PY3
-    module = PyModule_Create(&cryptomodule);
-#else
-    module = Py_InitModule3("crypto", crypto_methods, crypto_doc);
-#endif
-
-    if (module == NULL) {
-        PyOpenSSL_MODRETURN(NULL);
-    }
-
-#ifndef PY3
-    /* Initialize the C API pointer array */
-    crypto_API[crypto_X509_New_NUM]      = (void *)crypto_X509_New;
-    crypto_API[crypto_X509Name_New_NUM]  = (void *)crypto_X509Name_New;
-    crypto_API[crypto_X509Req_New_NUM]   = (void *)crypto_X509Req_New;
-    crypto_API[crypto_X509Store_New_NUM] = (void *)crypto_X509Store_New;
-    crypto_API[crypto_PKey_New_NUM]      = (void *)crypto_PKey_New;
-    crypto_API[crypto_X509Extension_New_NUM] = (void *)crypto_X509Extension_New;
-    crypto_API[crypto_PKCS7_New_NUM]     = (void *)crypto_PKCS7_New;
-    crypto_API[crypto_NetscapeSPKI_New_NUM]     = (void *)crypto_NetscapeSPKI_New;
-    c_api_object = PyCObject_FromVoidPtr((void *)crypto_API, NULL);
-    if (c_api_object != NULL) {
-        /* PyModule_AddObject steals a reference.
-         */
-        Py_INCREF(c_api_object);
-        PyModule_AddObject(module, "_C_API", c_api_object);
-    }
-#endif
-
-    crypto_Error = PyErr_NewException("OpenSSL.crypto.Error", NULL, NULL);
-    if (crypto_Error == NULL)
-        goto error;
-
-    /* PyModule_AddObject steals a reference.
-     */
-    Py_INCREF(crypto_Error);
-    if (PyModule_AddObject(module, "Error", crypto_Error) != 0)
-        goto error;
-
-    PyModule_AddIntConstant(module, "FILETYPE_PEM",  X509_FILETYPE_PEM);
-    PyModule_AddIntConstant(module, "FILETYPE_ASN1", X509_FILETYPE_ASN1);
-    PyModule_AddIntConstant(module, "FILETYPE_TEXT", X509_FILETYPE_TEXT);
-
-    PyModule_AddIntConstant(module, "TYPE_RSA", crypto_TYPE_RSA);
-    PyModule_AddIntConstant(module, "TYPE_DSA", crypto_TYPE_DSA);
-
-#ifdef WITH_THREAD
-    if (!init_openssl_threads())
-        goto error;
-#endif
-    if (!init_crypto_x509(module))
-        goto error;
-    if (!init_crypto_x509name(module))
-        goto error;
-    if (!init_crypto_x509store(module))
-        goto error;
-    if (!init_crypto_x509req(module))
-        goto error;
-    if (!init_crypto_pkey(module))
-        goto error;
-    if (!init_crypto_x509extension(module))
-        goto error;
-    if (!init_crypto_pkcs7(module))
-        goto error;
-    if (!init_crypto_pkcs12(module))
-        goto error;
-    if (!init_crypto_netscape_spki(module))
-        goto error;
-    if (!init_crypto_crl(module))
-        goto error;
-    if (!init_crypto_revoked(module))
-        goto error;
-
-    PyOpenSSL_MODRETURN(module);
-
-error:
-    PyOpenSSL_MODRETURN(NULL);
-    ;
-}
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/crypto.h hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/crypto.h
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/crypto.h	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/crypto.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,142 +0,0 @@
-/*
- * crypto.h
- *
- * Copyright (C) AB Strakt
- * See LICENSE for details.
- *
- * Exports from crypto.c.
- * See the file RATIONALE for a short explanation of why this module was written.
- *
- * Reviewed 2001-07-23
- *
- */
-#ifndef PyOpenSSL_CRYPTO_H_
-#define PyOpenSSL_CRYPTO_H_
-
-#include <Python.h>
-/* Work around a bug in OpenSSL 1.0.0 which is caused by winsock.h being
-   included (from dtls1.h) too late by the OpenSSL header files, overriding
-   the fixes (in ossl_typ.h) for symbol clashes caused by this OS header
-   file.
-   
-   In order to have those fixes still take effect, we include winsock.h
-   here, prior to including any OpenSSL header files.
-   
- */
-#ifdef _WIN32
-# include "winsock.h"
-#endif
-
-#include "x509.h"
-#include "x509name.h"
-#include "netscape_spki.h"
-#include "x509store.h"
-#include "x509req.h"
-#include "pkey.h"
-#include "x509ext.h"
-#include "pkcs7.h"
-#include "pkcs12.h"
-#include "crl.h"
-#include "revoked.h"
-#include "../util.h"
-
-extern PyObject *crypto_Error;
-
-#define crypto_X509_New_NUM             0
-#define crypto_X509_New_RETURN          crypto_X509Obj *
-#define crypto_X509_New_PROTO           (X509 *, int)
-
-#define crypto_X509Req_New_NUM          1
-#define crypto_X509Req_New_RETURN       crypto_X509ReqObj *
-#define crypto_X509Req_New_PROTO        (X509_REQ *, int)
-
-#define crypto_X509Store_New_NUM        2
-#define crypto_X509Store_New_RETURN     crypto_X509StoreObj *
-#define crypto_X509Store_New_PROTO      (X509_STORE *, int)
-
-#define crypto_PKey_New_NUM             3
-#define crypto_PKey_New_RETURN          crypto_PKeyObj *
-#define crypto_PKey_New_PROTO           (EVP_PKEY *, int)
-
-#define crypto_X509Name_New_NUM         4
-#define crypto_X509Name_New_RETURN      crypto_X509NameObj *
-#define crypto_X509Name_New_PROTO       (X509_NAME *, int)
-
-#define crypto_X509Extension_New_NUM    5
-#define crypto_X509Extension_New_RETURN crypto_X509ExtensionObj *
-#define crypto_X509Extension_New_PROTO  (char *, int, char *, crypto_X509Obj *, crypto_X509Obj *)
-
-#define crypto_PKCS7_New_NUM            6
-#define crypto_PKCS7_New_RETURN         crypto_PKCS7Obj *
-#define crypto_PKCS7_New_PROTO          (PKCS7 *, int)
-
-#define crypto_NetscapeSPKI_New_NUM         7
-#define crypto_NetscapeSPKI_New_RETURN      crypto_NetscapeSPKIObj *
-#define crypto_NetscapeSPKI_New_PROTO       (NETSCAPE_SPKI *, int)
-
-#define crypto_API_pointers             8
-
-#if defined(PY3) || defined(crypto_MODULE)
-
-#ifdef _WIN32
-#define EXPORT __declspec(dllexport)
-#else
-#define EXPORT
-#endif
-
-extern EXPORT crypto_X509_New_RETURN      crypto_X509_New      crypto_X509_New_PROTO;
-extern EXPORT crypto_X509Name_New_RETURN  crypto_X509Name_New  crypto_X509Name_New_PROTO;
-extern crypto_X509Req_New_RETURN   crypto_X509Req_New   crypto_X509Req_New_PROTO;
-extern EXPORT crypto_X509Store_New_RETURN crypto_X509Store_New crypto_X509Store_New_PROTO;
-extern crypto_PKey_New_RETURN      crypto_PKey_New      crypto_PKey_New_PROTO;
-extern crypto_X509Extension_New_RETURN crypto_X509Extension_New crypto_X509Extension_New_PROTO;
-extern crypto_PKCS7_New_RETURN     crypto_PKCS7_New     crypto_PKCS7_New_PROTO;
-extern crypto_NetscapeSPKI_New_RETURN  crypto_NetscapeSPKI_New  crypto_NetscapeSPKI_New_PROTO;
-
-int crypto_byte_converter(PyObject *input, void *output);
-
-#else /* crypto_MODULE */
-
-extern void **crypto_API;
-
-#define crypto_X509_New         \
- (*(crypto_X509_New_RETURN (*)crypto_X509_New_PROTO) crypto_API[crypto_X509_New_NUM])
-#define crypto_X509Name_New     \
- (*(crypto_X509Name_New_RETURN (*)crypto_X509Name_New_PROTO) crypto_API[crypto_X509Name_New_NUM])
-#define crypto_X509Req_New      \
- (*(crypto_X509Req_New_RETURN (*)crypto_X509Req_New_PROTO) crypto_API[crypto_X509Req_New_NUM])
-#define crypto_X509Store_New    \
- (*(crypto_X509Store_New_RETURN (*)crypto_X509Store_New_PROTO) crypto_API[crypto_X509Store_New_NUM])
-#define crypto_PKey_New         \
- (*(crypto_PKey_New_RETURN (*)crypto_PKey_New_PROTO) crypto_API[crypto_PKey_New_NUM])
-#define crypto_X509Extension_New\
- (*(crypto_X509Extension_New_RETURN (*)crypto_X509Extension_New_PROTO) crypto_API[crypto_X509Extension_New_NUM])
-#define crypto_PKCS7_New        \
- (*(crypto_PKCS7_New_RETURN (*)crypto_PKCS7_New_PROTO) crypto_API[crypto_PKCS7_New_NUM])
-#define crypto_NetscapeSPKI_New     \
- (*(crypto_NetscapeSPKI_New_RETURN (*)crypto_NetscapeSPKI_New_PROTO) crypto_API[crypto_NetscapeSPKI_New_NUM])
-
-#define import_crypto() \
-{ \
-  PyObject *crypto_module = PyImport_ImportModule("OpenSSL.crypto"); \
-  if (crypto_module != NULL) { \
-    PyObject *crypto_dict, *crypto_api_object; \
-    crypto_dict = PyModule_GetDict(crypto_module); \
-    crypto_api_object = PyDict_GetItemString(crypto_dict, "_C_API"); \
-    if (crypto_api_object && PyCObject_Check(crypto_api_object)) { \
-      crypto_API = (void **)PyCObject_AsVoidPtr(crypto_api_object); \
-    } \
-  } \
-}
-
-#endif /* crypto_MODULE */
-
-/* Define a new type for emitting text.  Hopefully these don't collide with
- * future official OpenSSL constants, but the switch statement of
- * dump_certificate() will alert us if it matters.
- */
-#ifndef X509_FILETYPE_TEXT 
-#define X509_FILETYPE_TEXT  (58)
-#endif
-
-#endif /* PyOpenSSL_CRYPTO_H_ */
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/netscape_spki.c hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/netscape_spki.c
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/netscape_spki.c	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/netscape_spki.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,316 +0,0 @@
-/*
- * netscape_spki.c
- *
- * Copyright (C) Tollef Fog Heen
- * See LICENSE for details.
- *
- * Netscape SPKI handling, thin wrapper
- */
-#include <Python.h>
-#define crypto_MODULE
-#include "crypto.h"
-
-/*
- * Constructor for Nestcape_SPKI, never called by Python code directly
- *
- * Arguments: name    - A "real" NetscapeSPKI object
- *            dealloc - Boolean value to specify whether the destructor should
- *                      free the "real" NetscapeSPKI object
- * Returns:   The newly created NetscapeSPKI object
- */
-crypto_NetscapeSPKIObj *
-crypto_NetscapeSPKI_New(NETSCAPE_SPKI *name, int dealloc)
-{
-    crypto_NetscapeSPKIObj *self;
-
-    self = PyObject_New(crypto_NetscapeSPKIObj, &crypto_NetscapeSPKI_Type);
-
-    if (self == NULL)
-        return NULL;
-
-    self->netscape_spki = name;
-    self->dealloc = dealloc;
-
-    return self;
-}
-
-
-static char crypto_NetscapeSPKI_doc[] = "\n\
-NetscapeSPKI([enc]) -> NetscapeSPKI instance\n\
-\n\
-@param enc: Base64 encoded NetscapeSPKI object.\n\
-@type enc: C{str}\n\
-@return: The NetscapeSPKI object\n\
-";
-
-static PyObject *
-crypto_NetscapeSPKI_new(PyTypeObject *subtype, PyObject *args, PyObject *kwargs) {
-    char *enc = NULL;
-    int enc_len = -1;
-    NETSCAPE_SPKI *spki;
-
-    if (!PyArg_ParseTuple(args, "|s#:NetscapeSPKI", &enc, &enc_len))
-        return NULL;
-
-    if (enc_len >= 0)
-        spki = NETSCAPE_SPKI_b64_decode(enc, enc_len);
-    else
-        spki = NETSCAPE_SPKI_new();
-    if (spki == NULL)
-    {
-        exception_from_error_queue(crypto_Error);
-        return NULL;
-    }
-    return (PyObject *)crypto_NetscapeSPKI_New(spki, 1);
-}
-
-
-/*
- * Deallocate the memory used by the NetscapeSPKI object
- *
- * Arguments: self - The NetscapeSPKI object
- * Returns:   None
- */
-static void
-crypto_NetscapeSPKI_dealloc(crypto_NetscapeSPKIObj *self)
-{
-    /* Sometimes we don't have to dealloc this */
-    if (self->dealloc)
-        NETSCAPE_SPKI_free(self->netscape_spki);
-
-    PyObject_Del(self);
-}
-
-static char crypto_NetscapeSPKI_sign_doc[] = "\n\
-Sign the certificate request using the supplied key and digest\n\
-\n\
-@param pkey: The key to sign with\n\
-@param digest: The message digest to use\n\
-@return: None\n\
-";
-
-static PyObject *
-crypto_NetscapeSPKI_sign(crypto_NetscapeSPKIObj *self, PyObject *args)
-{
-    crypto_PKeyObj *pkey;
-    char *digest_name;
-    const EVP_MD *digest;
-
-    if (!PyArg_ParseTuple(args, "O!s:sign", &crypto_PKey_Type, &pkey,
-			  &digest_name))
-        return NULL;
-
-    if (pkey->only_public) {
-	PyErr_SetString(PyExc_ValueError, "Key has only public part");
-	return NULL;
-    }
-
-    if (!pkey->initialized) {
-	PyErr_SetString(PyExc_ValueError, "Key is uninitialized");
-	return NULL;
-    }
-
-    if ((digest = EVP_get_digestbyname(digest_name)) == NULL)
-    {
-        PyErr_SetString(PyExc_ValueError, "No such digest method");
-        return NULL;
-    }
-
-    if (!NETSCAPE_SPKI_sign(self->netscape_spki, pkey->pkey, digest))
-    {
-        exception_from_error_queue(crypto_Error);
-        return NULL;
-    }
-
-    Py_INCREF(Py_None);
-    return Py_None;
-}
-
-static char crypto_NetscapeSPKI_verify_doc[] = "\n\
-Verifies a certificate request using the supplied public key\n\
-\n\
-@param key: a public key\n\
-@return: True if the signature is correct.\n\
-@raise OpenSSL.crypto.Error: If the signature is invalid or there is a\n\
-    problem verifying the signature.\n\
-";
-
-PyObject *
-crypto_NetscapeSPKI_verify(crypto_NetscapeSPKIObj *self, PyObject *args)
-{
-    crypto_PKeyObj *pkey;
-    int answer;
-
-    if (!PyArg_ParseTuple(args, "O!:verify", &crypto_PKey_Type, &pkey)) {
-        return NULL;
-    }
-
-    if ((answer = NETSCAPE_SPKI_verify(self->netscape_spki, pkey->pkey)) <= 0) {
-        exception_from_error_queue(crypto_Error);
-        return NULL;
-    }
-
-    return PyLong_FromLong((long)answer);
-}
-
-static char crypto_NetscapeSPKI_b64_encode_doc[] = "\n\
-Generate a base64 encoded string from an SPKI\n\
-\n\
-@return: The base64 encoded string\n\
-";
-
-PyObject *
-crypto_NetscapeSPKI_b64_encode(crypto_NetscapeSPKIObj *self, PyObject *args)
-{
-    char *str;
-
-    if (!PyArg_ParseTuple(args, ":b64_encode"))
-        return NULL;
-
-    str = NETSCAPE_SPKI_b64_encode(self->netscape_spki);
-    return PyBytes_FromString(str);
-}
-
-
-static char crypto_NetscapeSPKI_get_pubkey_doc[] = "\n\
-Get the public key of the certificate\n\
-\n\
-@return: The public key\n\
-";
-
-static PyObject *
-crypto_NetscapeSPKI_get_pubkey(crypto_NetscapeSPKIObj *self, PyObject *args)
-{
-    crypto_PKeyObj *crypto_PKey_New(EVP_PKEY *, int);
-    EVP_PKEY *pkey;
-    crypto_PKeyObj *py_pkey;
-
-    if (!PyArg_ParseTuple(args, ":get_pubkey"))
-        return NULL;
-
-    if ((pkey = NETSCAPE_SPKI_get_pubkey(self->netscape_spki)) == NULL)
-    {
-        exception_from_error_queue(crypto_Error);
-        return NULL;
-    }
-
-    py_pkey = crypto_PKey_New(pkey, 1);
-    if (py_pkey != NULL) {
-	py_pkey->only_public = 1;
-    }
-    return (PyObject *)py_pkey;
-}
-
-static char crypto_NetscapeSPKI_set_pubkey_doc[] = "\n\
-Set the public key of the certificate\n\
-\n\
-@param pkey: The public key\n\
-@return: None\n\
-";
-
-static PyObject *
-crypto_NetscapeSPKI_set_pubkey(crypto_NetscapeSPKIObj *self, PyObject *args)
-{
-    crypto_PKeyObj *pkey;
-
-    if (!PyArg_ParseTuple(args, "O!:set_pubkey", &crypto_PKey_Type, &pkey))
-        return NULL;
-
-    if (!NETSCAPE_SPKI_set_pubkey(self->netscape_spki, pkey->pkey))
-    {
-        exception_from_error_queue(crypto_Error);
-        return NULL;
-    }
-
-    Py_INCREF(Py_None);
-    return Py_None;
-}
-
-/*
- * ADD_METHOD(name) expands to a correct PyMethodDef declaration
- *   {  'name', (PyCFunction)crypto_NetscapeSPKI_name, METH_VARARGS }
- * for convenience
- */
-#define ADD_METHOD(name)        \
-    { #name, (PyCFunction)crypto_NetscapeSPKI_##name, METH_VARARGS, crypto_NetscapeSPKI_##name##_doc }
-static PyMethodDef crypto_NetscapeSPKI_methods[] =
-{
-    ADD_METHOD(get_pubkey),
-    ADD_METHOD(set_pubkey),
-    ADD_METHOD(b64_encode),
-    ADD_METHOD(sign),
-    ADD_METHOD(verify),
-    { NULL, NULL }
-};
-#undef ADD_METHOD
-
-PyTypeObject crypto_NetscapeSPKI_Type = {
-    PyOpenSSL_HEAD_INIT(&PyType_Type, 0)
-    "NetscapeSPKI",
-    sizeof(crypto_NetscapeSPKIObj),
-    0,
-    (destructor)crypto_NetscapeSPKI_dealloc,
-    NULL, /* print */
-    NULL, /* getattr */
-    NULL, /* setattr */
-    NULL, /* compare */
-    NULL, /* repr */
-    NULL, /* as_number */
-    NULL, /* as_sequence */
-    NULL, /* as_mapping */
-    NULL,  /* hash */
-    NULL, /* call */
-    NULL, /* str */
-    NULL, /* getattro */
-    NULL, /* setattro */
-    NULL, /* as_buffer */
-    Py_TPFLAGS_DEFAULT,
-    crypto_NetscapeSPKI_doc, /* doc */
-    NULL, /* traverse */
-    NULL, /* clear */
-    NULL, /* tp_richcompare */
-    0, /* tp_weaklistoffset */
-    NULL, /* tp_iter */
-    NULL, /* tp_iternext */
-    crypto_NetscapeSPKI_methods, /* tp_methods */
-    NULL, /* tp_members */
-    NULL, /* tp_getset */
-    NULL, /* tp_base */
-    NULL, /* tp_dict */
-    NULL, /* tp_descr_get */
-    NULL, /* tp_descr_set */
-    0, /* tp_dictoffset */
-    NULL, /* tp_init */
-    NULL, /* tp_alloc */
-    crypto_NetscapeSPKI_new, /* tp_new */
-};
-
-
-/*
- * Initialize the X509Name part of the crypto module
- *
- * Arguments: module - The crypto module
- * Returns:   None
- */
-int
-init_crypto_netscape_spki(PyObject *module) {
-    if (PyType_Ready(&crypto_NetscapeSPKI_Type) < 0) {
-        return 0;
-    }
-
-    /* PyModule_AddObject steals a reference
-     */
-    Py_INCREF((PyObject *)&crypto_NetscapeSPKI_Type);
-    if (PyModule_AddObject(module, "NetscapeSPKI", (PyObject *)&crypto_NetscapeSPKI_Type) != 0) {
-        return 0;
-    }
-
-    /* PyModule_AddObject steals a reference
-     */
-    Py_INCREF((PyObject *)&crypto_NetscapeSPKI_Type);
-    if (PyModule_AddObject(module, "NetscapeSPKIType", (PyObject *)&crypto_NetscapeSPKI_Type) != 0) {
-        return 0;
-    }
-
-    return 1;
-}
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/netscape_spki.h hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/netscape_spki.h
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/netscape_spki.h	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/netscape_spki.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,30 +0,0 @@
-/*
- * netscape_spki.h
- *
- * Copyright (C) Tollef Fog Heen
- * See LICENSE for details.
- *
- * Handle Netscape SPKI (challenge response) certificate requests.
- *
- *
- */
-#ifndef PyOpenSSL_crypto_Netscape_SPKI_H_
-#define PyOpenSSL_crypto_Netscape_SPKI_H_
-
-#include <Python.h>
-#include <openssl/ssl.h>
-
-extern  int     init_crypto_netscape_spki       (PyObject *);
-
-extern  PyTypeObject      crypto_NetscapeSPKI_Type;
-
-#define crypto_NetscapeSPKI_Check(v) ((v)->ob_type == &crypto_NetscapeSPKI_Type)
-
-typedef struct {
-    PyObject_HEAD
-    NETSCAPE_SPKI           *netscape_spki;
-    int                  dealloc;
-} crypto_NetscapeSPKIObj;
-
-
-#endif
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/pkcs12.c hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/pkcs12.c
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/pkcs12.c	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/pkcs12.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,580 +0,0 @@
-/*
- * pkcs12.c
- *
- * Copyright (C) AB Strakt
- * See LICENSE for details.
- *
- * Certificate transport (PKCS12) handling code,
- * mostly thin wrappers around OpenSSL.
- * See the file RATIONALE for a short explanation of why
- * this module was written.
- *
- * Reviewed 2001-07-23
- */
-#include <Python.h>
-#define crypto_MODULE
-#include "crypto.h"
-
-/*
- * PKCS12 is a standard exchange format for digital certificates.
- * See e.g. the OpenSSL homepage http://www.openssl.org/ for more information
- */
-
-static void crypto_PKCS12_dealloc(crypto_PKCS12Obj *self);
-static int crypto_PKCS12_clear(crypto_PKCS12Obj *self);
-
-static char crypto_PKCS12_get_certificate_doc[] = "\n\
-Return certificate portion of the PKCS12 structure\n\
-\n\
-@return: X509 object containing the certificate\n\
-";
-static PyObject *
-crypto_PKCS12_get_certificate(crypto_PKCS12Obj *self, PyObject *args)
-{
-    if (!PyArg_ParseTuple(args, ":get_certificate"))
-        return NULL;
-
-    Py_INCREF(self->cert);
-    return self->cert;
-}
-
-static char crypto_PKCS12_set_certificate_doc[] = "\n\
-Replace the certificate portion of the PKCS12 structure\n\
-\n\
-@param cert: The new certificate.\n\
-@type cert: L{X509} or L{NoneType}\n\
-@return: None\n\
-";
-static PyObject *
-crypto_PKCS12_set_certificate(crypto_PKCS12Obj *self, PyObject *args, PyObject *keywds) {
-    PyObject *cert = NULL;
-    static char *kwlist[] = {"cert", NULL};
-
-    if (!PyArg_ParseTupleAndKeywords(args, keywds, "O:set_certificate",
-        kwlist, &cert))
-        return NULL;
-
-    if (cert != Py_None && ! crypto_X509_Check(cert)) {
-        PyErr_SetString(PyExc_TypeError, "cert must be type X509 or None");
-        return NULL;
-    }
-
-    Py_INCREF(cert);  /* Make consistent before calling Py_DECREF() */
-    Py_DECREF(self->cert);
-    self->cert = cert;
-
-    Py_INCREF(Py_None);
-    return Py_None;
-}
-
-static char crypto_PKCS12_get_privatekey_doc[] = "\n\
-Return private key portion of the PKCS12 structure\n\
-\n\
-@returns: PKey object containing the private key\n\
-";
-static crypto_PKeyObj *
-crypto_PKCS12_get_privatekey(crypto_PKCS12Obj *self, PyObject *args)
-{
-    if (!PyArg_ParseTuple(args, ":get_privatekey"))
-        return NULL;
-
-    Py_INCREF(self->key);
-    return (crypto_PKeyObj *) self->key;
-}
-
-static char crypto_PKCS12_set_privatekey_doc[] = "\n\
-Replace or set the certificate portion of the PKCS12 structure\n\
-\n\
-@param pkey: The new private key.\n\
-@type pkey: L{PKey}\n\
-@return: None\n\
-";
-static PyObject *
-crypto_PKCS12_set_privatekey(crypto_PKCS12Obj *self, PyObject *args, PyObject *keywds) {
-    PyObject *pkey = NULL;
-    static char *kwlist[] = {"pkey", NULL};
-
-    if (!PyArg_ParseTupleAndKeywords(args, keywds, "O:set_privatekey",
-        kwlist, &pkey))
-        return NULL;
-
-    if (pkey != Py_None && ! crypto_PKey_Check(pkey)) {
-        PyErr_SetString(PyExc_TypeError, "pkey must be type X509 or None");
-        return NULL;
-    }
-
-    Py_INCREF(pkey);  /* Make consistent before calling Py_DECREF() */
-    Py_DECREF(self->key);
-    self->key = pkey;
-
-    Py_INCREF(Py_None);
-    return Py_None;
-}
-
-static char crypto_PKCS12_get_ca_certificates_doc[] = "\n\
-Return CA certificates within of the PKCS12 object\n\
-\n\
-@return: A newly created tuple containing the CA certificates in the chain,\n\
-         if any are present, or None if no CA certificates are present.\n\
-";
-static PyObject *
-crypto_PKCS12_get_ca_certificates(crypto_PKCS12Obj *self, PyObject *args)
-{
-    if (!PyArg_ParseTuple(args, ":get_ca_certificates"))
-        return NULL;
-
-    Py_INCREF(self->cacerts);
-    return self->cacerts;
-}
-
-static char crypto_PKCS12_set_ca_certificates_doc[] = "\n\
-Replace or set the CA certificates withing the PKCS12 object.\n\
-\n\
-@param cacerts: The new CA certificates.\n\
-@type cacerts: Iterable of L{X509} or L{NoneType}\n\
-@return: None\n\
-";
-static PyObject *
-crypto_PKCS12_set_ca_certificates(crypto_PKCS12Obj *self, PyObject *args, PyObject *keywds)
-{
-    PyObject *obj;
-    PyObject *cacerts;
-    static char *kwlist[] = {"cacerts", NULL};
-    int i, len; /* Py_ssize_t for Python 2.5+ */
-
-    if (!PyArg_ParseTupleAndKeywords(args, keywds, "O:set_ca_certificates",
-        kwlist, &cacerts))
-        return NULL;
-    if (cacerts == Py_None) {
-        Py_INCREF(cacerts);
-    } else {
-        /* It's iterable */
-        cacerts = PySequence_Tuple(cacerts);
-        if (cacerts == NULL) {
-            return NULL;
-        }
-        len = PyTuple_Size(cacerts);
-
-        /* Check is's a simple list filled only with X509 objects. */
-        for (i = 0; i < len; i++) {
-            obj = PyTuple_GetItem(cacerts, i);
-            if (!crypto_X509_Check(obj)) {
-                Py_DECREF(cacerts);
-                PyErr_SetString(PyExc_TypeError, "iterable must only contain X509Type");
-                return NULL;
-            }
-        }
-    }
-
-    Py_DECREF(self->cacerts);
-    self->cacerts = cacerts;
-
-    Py_INCREF(Py_None);
-    return Py_None;
-}
-
-static char crypto_PKCS12_get_friendlyname_doc[] = "\n\
-Return friendly name portion of the PKCS12 structure\n\
-\n\
-@returns: String containing the friendlyname\n\
-";
-static PyObject *
-crypto_PKCS12_get_friendlyname(crypto_PKCS12Obj *self, PyObject *args) {
-    if (!PyArg_ParseTuple(args, ":get_friendlyname"))
-        return NULL;
-
-    Py_INCREF(self->friendlyname);
-    return (PyObject *) self->friendlyname;
-}
-
-static char crypto_PKCS12_set_friendlyname_doc[] = "\n\
-Replace or set the certificate portion of the PKCS12 structure\n\
-\n\
-@param name: The new friendly name.\n\
-@type name: L{str}\n\
-@return: None\n\
-";
-static PyObject *
-crypto_PKCS12_set_friendlyname(crypto_PKCS12Obj *self, PyObject *args, PyObject *keywds) {
-    PyObject *name = NULL;
-    static char *kwlist[] = {"name", NULL};
-
-    if (!PyArg_ParseTupleAndKeywords(args, keywds, "O:set_friendlyname",
-        kwlist, &name))
-        return NULL;
-
-    if (name != Py_None && ! PyBytes_CheckExact(name)) {
-        PyErr_SetString(PyExc_TypeError, "name must be a byte string or None");
-        return NULL;
-    }
-
-    Py_INCREF(name);  /* Make consistent before calling Py_DECREF() */
-    Py_DECREF(self->friendlyname);
-    self->friendlyname = name;
-
-    Py_INCREF(Py_None);
-    return Py_None;
-}
-
-static char crypto_PKCS12_export_doc[] = "\n\
-export([passphrase=None][, friendly_name=None][, iter=2048][, maciter=1]\n\
-Dump a PKCS12 object as a string.  See also \"man PKCS12_create\".\n\
-\n\
-@param passphrase: used to encrypt the PKCS12\n\
-@type passphrase: L{str}\n\
-@param iter: How many times to repeat the encryption\n\
-@type iter: L{int}\n\
-@param maciter: How many times to repeat the MAC\n\
-@type maciter: L{int}\n\
-@return: The string containing the PKCS12\n\
-";
-static PyObject *
-crypto_PKCS12_export(crypto_PKCS12Obj *self, PyObject *args, PyObject *keywds) {
-    int i; /* Py_ssize_t for Python 2.5+ */
-    PyObject *obj;
-    int buf_len;
-    PyObject *buffer;
-    char *temp, *passphrase = NULL, *friendly_name = NULL;
-    BIO *bio;
-    PKCS12 *p12;
-    EVP_PKEY *pkey = NULL;
-    STACK_OF(X509) *cacerts = NULL;
-    X509 *x509 = NULL;
-    int iter = 0;  /* defaults to PKCS12_DEFAULT_ITER */
-    int maciter = 0;
-    static char *kwlist[] = {"passphrase", "iter", "maciter", NULL};
-
-    if (!PyArg_ParseTupleAndKeywords(args, keywds, "|zii:export",
-        kwlist, &passphrase, &iter, &maciter))
-        return NULL;
-
-    if (self->key != Py_None) {
-        pkey = ((crypto_PKeyObj*) self->key)->pkey;
-    }
-    if (self->cert != Py_None) {
-        x509 = ((crypto_X509Obj*) self->cert)->x509;
-    }
-    if (self->cacerts != Py_None) {
-        cacerts = sk_X509_new_null();
-        for (i = 0; i < PyTuple_Size(self->cacerts); i++) {  /* For each CA cert */
-            obj = PySequence_GetItem(self->cacerts, i);
-            /* assert(PyObject_IsInstance(obj, (PyObject *) &crypto_X509_Type )); */
-            sk_X509_push(cacerts, (( crypto_X509Obj* ) obj)->x509);
-            Py_DECREF(obj);
-        }
-    }
-    if (self->friendlyname != Py_None) {
-        friendly_name = PyBytes_AsString(self->friendlyname);
-    }
-
-    p12 = PKCS12_create(passphrase, friendly_name, pkey, x509, cacerts,
-                        NID_pbe_WithSHA1And3_Key_TripleDES_CBC,
-                        NID_pbe_WithSHA1And3_Key_TripleDES_CBC,
-                        iter, maciter, 0);
-    sk_X509_free(cacerts); /* NULL safe.  Free just the container. */
-    if (p12 == NULL) {
-        exception_from_error_queue(crypto_Error);
-        return NULL;
-    }
-    bio = BIO_new(BIO_s_mem());
-    i2d_PKCS12_bio(bio, p12);
-    buf_len = BIO_get_mem_data(bio, &temp);
-    buffer = PyBytes_FromStringAndSize(temp, buf_len);
-    BIO_free(bio);
-    return buffer;
-}
-
-/*
- * ADD_METHOD(name) expands to a correct PyMethodDef declaration
- *   {  'name', (PyCFunction)crypto_PKCS12_name, METH_VARARGS, crypto_PKCS12_name_doc }
- * for convenience
- */
-#define ADD_METHOD(name)        \
-    { #name, (PyCFunction)crypto_PKCS12_##name, METH_VARARGS, crypto_PKCS12_##name##_doc }
-#define ADD_KW_METHOD(name)        \
-    { #name, (PyCFunction)crypto_PKCS12_##name, METH_VARARGS | METH_KEYWORDS, crypto_PKCS12_##name##_doc }
-static PyMethodDef crypto_PKCS12_methods[] =
-{
-    ADD_METHOD(get_certificate),
-    ADD_KW_METHOD(set_certificate),
-    ADD_METHOD(get_privatekey),
-    ADD_KW_METHOD(set_privatekey),
-    ADD_METHOD(get_ca_certificates),
-    ADD_KW_METHOD(set_ca_certificates),
-    ADD_METHOD(get_friendlyname),
-    ADD_KW_METHOD(set_friendlyname),
-    ADD_KW_METHOD(export),
-    { NULL, NULL }
-};
-#undef ADD_METHOD
-
-/*
- * Constructor for PKCS12 objects, never called by Python code directly.
- * The strategy for this object is to create all the Python objects
- * corresponding to the cert/key/CA certs right away
- *
- * Arguments: p12        - A "real" PKCS12 object or NULL
- *            passphrase - Passphrase to use when decrypting the PKCS12 object
- * Returns:   The newly created PKCS12 object
- */
-crypto_PKCS12Obj *
-crypto_PKCS12_New(PKCS12 *p12, char *passphrase) {
-    crypto_PKCS12Obj *self = NULL;
-    PyObject *cacertobj = NULL;
-
-    unsigned char *alias_str;
-    int alias_len;
-
-    X509 *cert = NULL;
-    EVP_PKEY *pkey = NULL;
-    STACK_OF(X509) *cacerts = NULL;
-
-    int i, cacert_count = 0;
-
-    /* allocate space for the CA cert stack */
-    if((cacerts = sk_X509_new_null()) == NULL) {
-        goto error;   /* out of memory? */
-    }
-
-    /* parse the PKCS12 lump */
-    if (p12) {
-        if (!PKCS12_parse(p12, passphrase, &pkey, &cert, &cacerts)) {
-	    /*
-             * If PKCS12_parse fails, and it allocated cacerts, it seems to
-             * free cacerts, but not re-NULL the pointer.  Zounds!  Make sure
-             * it is re-set to NULL here, else we'll have a double-free below.
-             */
-            cacerts = NULL;
-            exception_from_error_queue(crypto_Error);
-            goto error;
-        } else {
-	  /*
-	   * OpenSSL 1.0.0 sometimes leaves an X509_check_private_key error in
-	   * the queue for no particular reason.  This error isn't interesting
-	   * to anyone outside this function.  It's not even interesting to
-	   * us.  Get rid of it.
-	   */
-	  flush_error_queue();
-	}
-    }
-
-    if (!(self = PyObject_GC_New(crypto_PKCS12Obj, &crypto_PKCS12_Type))) {
-        goto error;
-    }
-
-    /* client certificate and friendlyName */
-    if (cert == NULL) {
-        Py_INCREF(Py_None);
-        self->cert = Py_None;
-        Py_INCREF(Py_None);
-        self->friendlyname = Py_None;
-    } else {
-        if ((self->cert = (PyObject *)crypto_X509_New(cert, 1)) == NULL) {
-            goto error;
-        }
-
-        /*  Now we need to extract the friendlyName of the PKCS12
-         *  that was stored by PKCS_parse() in the alias of the
-         *  certificate. */
-        alias_str = X509_alias_get0(cert, &alias_len);
-        if (alias_str) {
-            self->friendlyname = Py_BuildValue(BYTESTRING_FMT "#", alias_str, alias_len);
-            if (!self->friendlyname) {
-                /*
-                 * XXX Untested
-                 */
-                goto error;
-            }
-            /* success */
-        } else {
-            Py_INCREF(Py_None);
-            self->friendlyname = Py_None;
-        }
-    }
-
-    /* private key */
-    if (pkey == NULL) {
-        Py_INCREF(Py_None);
-        self->key = Py_None;
-    } else {
-        if ((self->key = (PyObject *)crypto_PKey_New(pkey, 1)) == NULL)
-            goto error;
-    }
-
-    /* CA certs */
-    cacert_count = sk_X509_num(cacerts);
-    if (cacert_count <= 0) {
-        Py_INCREF(Py_None);
-        self->cacerts = Py_None;
-    } else {
-        if ((self->cacerts = PyTuple_New(cacert_count)) == NULL) {
-            goto error;
-        }
-
-        for (i = 0; i < cacert_count; i++) {
-            cert = sk_X509_value(cacerts, i);
-            if ((cacertobj = (PyObject *)crypto_X509_New(cert, 1)) == NULL) {
-                goto error;
-            }
-            PyTuple_SET_ITEM(self->cacerts, i, cacertobj);
-        }
-    }
-
-    sk_X509_free(cacerts); /* Don't free the certs, just the container. */
-    PyObject_GC_Track(self);
-
-    return self;
-
-error:
-    sk_X509_free(cacerts); /* NULL safe. Free just the container. */
-    if (self) {
-        crypto_PKCS12_clear(self);
-        PyObject_GC_Del(self);
-    }
-    return NULL;
-}
-
-static char crypto_PKCS12_doc[] = "\n\
-PKCS12() -> PKCS12 instance\n\
-\n\
-Create a new empty PKCS12 object.\n\
-\n\
-@returns: The PKCS12 object\n\
-";
-static PyObject *
-crypto_PKCS12_new(PyTypeObject *subtype, PyObject *args, PyObject *kwargs) {
-    if (!PyArg_ParseTuple(args, ":PKCS12")) {
-        return NULL;
-    }
-
-    return (PyObject *)crypto_PKCS12_New(NULL, NULL);
-}
-
-/*
- * Call the visitproc on all contained objects.
- *
- * Arguments: self - The PKCS12 object
- *            visit - Function to call
- *            arg - Extra argument to visit
- * Returns:   0 if all goes well, otherwise the return code from the first
- *            call that gave non-zero result.
- */
-static int
-crypto_PKCS12_traverse(crypto_PKCS12Obj *self, visitproc visit, void *arg)
-{
-    int ret = 0;
-
-    if (ret == 0 && self->cert != NULL)
-        ret = visit(self->cert, arg);
-    if (ret == 0 && self->key != NULL)
-        ret = visit(self->key, arg);
-    if (ret == 0 && self->cacerts != NULL)
-        ret = visit(self->cacerts, arg);
-    if (ret == 0 && self->friendlyname != NULL)
-        ret = visit(self->friendlyname, arg);
-    return ret;
-}
-
-/*
- * Decref all contained objects and zero the pointers.
- *
- * Arguments: self - The PKCS12 object
- * Returns:   Always 0.
- */
-static int
-crypto_PKCS12_clear(crypto_PKCS12Obj *self)
-{
-    Py_XDECREF(self->cert);
-    self->cert = NULL;
-    Py_XDECREF(self->key);
-    self->key = NULL;
-    Py_XDECREF(self->cacerts);
-    self->cacerts = NULL;
-    Py_XDECREF(self->friendlyname);
-    self->friendlyname = NULL;
-    return 0;
-}
-
-/*
- * Deallocate the memory used by the PKCS12 object
- *
- * Arguments: self - The PKCS12 object
- * Returns:   None
- */
-static void
-crypto_PKCS12_dealloc(crypto_PKCS12Obj *self)
-{
-    PyObject_GC_UnTrack(self);
-    crypto_PKCS12_clear(self);
-    PyObject_GC_Del(self);
-}
-
-PyTypeObject crypto_PKCS12_Type = {
-    PyOpenSSL_HEAD_INIT(&PyType_Type, 0)
-    "PKCS12",
-    sizeof(crypto_PKCS12Obj),
-    0,
-    (destructor)crypto_PKCS12_dealloc,
-    NULL, /* print */
-    NULL, /* getattr */
-    NULL, /* setattr */
-    NULL, /* compare */
-    NULL, /* repr */
-    NULL, /* as_number */
-    NULL, /* as_sequence */
-    NULL, /* as_mapping */
-    NULL, /* hash */
-    NULL, /* call */
-    NULL, /* str */
-    NULL, /* getattro */
-    NULL, /* setattro */
-    NULL, /* as_buffer */
-    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC,
-    crypto_PKCS12_doc,
-    (traverseproc)crypto_PKCS12_traverse,
-    (inquiry)crypto_PKCS12_clear,
-    NULL, /* tp_richcompare */
-    0, /* tp_weaklistoffset */
-    NULL, /* tp_iter */
-    NULL, /* tp_iternext */
-    crypto_PKCS12_methods, /* tp_methods */
-    NULL, /* tp_members */
-    NULL, /* tp_getset */
-    NULL, /* tp_base */
-    NULL, /* tp_dict */
-    NULL, /* tp_descr_get */
-    NULL, /* tp_descr_set */
-    0, /* tp_dictoffset */
-    NULL, /* tp_init */
-    NULL, /* tp_alloc */
-    crypto_PKCS12_new, /* tp_new */
-};
-
-/*
- * Initialize the PKCS12 part of the crypto sub module
- *
- * Arguments: module - The crypto module
- * Returns:   None
- */
-int
-init_crypto_pkcs12(PyObject *module) {
-    if (PyType_Ready(&crypto_PKCS12_Type) < 0) {
-        return 0;
-    }
-
-    /* PyModule_AddObject steals a reference.
-     */
-    Py_INCREF((PyObject *)&crypto_PKCS12_Type);
-    if (PyModule_AddObject(module, "PKCS12", (PyObject *)&crypto_PKCS12_Type) != 0) {
-        return 0;
-    }
-
-    /* PyModule_AddObject steals a reference.
-     */
-    Py_INCREF((PyObject *)&crypto_PKCS12_Type);
-    if (PyModule_AddObject(module, "PKCS12Type", (PyObject *)&crypto_PKCS12_Type) != 0) {
-        return 0;
-    }
-
-    return 1;
-}
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/pkcs12.h hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/pkcs12.h
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/pkcs12.h	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/pkcs12.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,39 +0,0 @@
-/*
- * pkcs12.h
- *
- * Copyright (C) AB Strakt
- * See LICENSE for details.
- *
- * Export PKCS12 functions and data structure.
- *
- */
-#ifndef PyOpenSSL_crypto_PKCS12_H_
-#define PyOpenSSL_crypto_PKCS12_H_
-
-#include <Python.h>
-#include <openssl/pkcs12.h>
-#include <openssl/asn1.h>
-
-extern  int       init_crypto_pkcs12   (PyObject *);
-
-extern  PyTypeObject      crypto_PKCS12_Type;
-
-#define crypto_PKCS12_Check(v) ((v)->ob_type == &crypto_PKCS12_Type)
-
-typedef struct {
-    PyObject_HEAD
-    /*
-     * These either refer to a PyObject* of the appropriate type, or Py_None if
-     * they don't have a value.  They aren't set to NULL except during
-     * finalization.
-     */
-    PyObject            *cert;
-    PyObject            *key;
-    PyObject            *cacerts;
-    PyObject            *friendlyname;
-} crypto_PKCS12Obj;
-
-crypto_PKCS12Obj *
-crypto_PKCS12_New(PKCS12 *p12, char *passphrase);
-
-#endif
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/pkcs7.c hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/pkcs7.c
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/pkcs7.c	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/pkcs7.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,216 +0,0 @@
-/*
- * pkcs7.c
- *
- * Copyright (C) AB Strakt
- * See LICENSE for details.
- *
- * PKCS7 handling code, mostly thin wrappers around OpenSSL.
- * See the file RATIONALE for a short explanation of why this module was written.
- *
- */
-#include <Python.h>
-#define crypto_MODULE
-#include "crypto.h"
-
-static char crypto_PKCS7_type_is_signed_doc[] = "\n\
-Check if this NID_pkcs7_signed object\n\
-\n\
-@return: True if the PKCS7 is of type signed\n\
-";
-
-static PyObject *
-crypto_PKCS7_type_is_signed(crypto_PKCS7Obj *self, PyObject *args)
-{
-    if (!PyArg_ParseTuple(args, ":type_is_signed")) 
-        return NULL;
-
-    if (PKCS7_type_is_signed(self->pkcs7))
-        return PyLong_FromLong(1L);
-    else
-        return PyLong_FromLong(0L);
-}
-
-static char crypto_PKCS7_type_is_enveloped_doc[] = "\n\
-Check if this NID_pkcs7_enveloped object\n\
-\n\
-@returns: True if the PKCS7 is of type enveloped\n\
-";
-
-static PyObject *
-crypto_PKCS7_type_is_enveloped(crypto_PKCS7Obj *self, PyObject *args)
-{
-    if (!PyArg_ParseTuple(args, ":type_is_enveloped")) 
-        return NULL;
-
-    if (PKCS7_type_is_enveloped(self->pkcs7))
-        return PyLong_FromLong(1L);
-    else
-        return PyLong_FromLong(0L);
-}
-
-static char crypto_PKCS7_type_is_signedAndEnveloped_doc[] = "\n\
-Check if this NID_pkcs7_signedAndEnveloped object\n\
-\n\
-@returns: True if the PKCS7 is of type signedAndEnveloped\n\
-";
-
-static PyObject *
-crypto_PKCS7_type_is_signedAndEnveloped(crypto_PKCS7Obj *self, PyObject *args)
-{
-    if (!PyArg_ParseTuple(args, ":type_is_signedAndEnveloped")) 
-        return NULL;
-
-    if (PKCS7_type_is_signedAndEnveloped(self->pkcs7))
-        return PyLong_FromLong(1L);
-    else
-        return PyLong_FromLong(0L);
-}
-
-static char crypto_PKCS7_type_is_data_doc[] = "\n\
-Check if this NID_pkcs7_data object\n\
-\n\
-@return: True if the PKCS7 is of type data\n\
-";
-
-static PyObject *
-crypto_PKCS7_type_is_data(crypto_PKCS7Obj *self, PyObject *args)
-{
-    if (!PyArg_ParseTuple(args, ":type_is_data")) 
-        return NULL;
-
-    if (PKCS7_type_is_data(self->pkcs7))
-        return PyLong_FromLong(1L);
-    else
-        return PyLong_FromLong(0L);
-}
-
-static char crypto_PKCS7_get_type_name_doc[] = "\n\
-Returns the type name of the PKCS7 structure\n\
-\n\
-@return: A string with the typename\n\
-";
-
-static PyObject *
-crypto_PKCS7_get_type_name(crypto_PKCS7Obj *self, PyObject *args)
-{
-    if (!PyArg_ParseTuple(args, ":get_type_name")) 
-        return NULL;
-
-    /* 
-     * return a string with the typename
-     */
-    return PyBytes_FromString(OBJ_nid2sn(OBJ_obj2nid(self->pkcs7->type)));
-}
-
-/*
- * ADD_METHOD(name) expands to a correct PyMethodDef declaration
- *   {  'name', (PyCFunction)crypto_PKCS7_name, METH_VARARGS }
- * for convenience
- */
-#define ADD_METHOD(name)        \
-    { #name, (PyCFunction)crypto_PKCS7_##name, METH_VARARGS, crypto_PKCS7_##name##_doc }
-static PyMethodDef crypto_PKCS7_methods[] =
-{
-    ADD_METHOD(type_is_signed),
-    ADD_METHOD(type_is_enveloped),
-    ADD_METHOD(type_is_signedAndEnveloped),
-    ADD_METHOD(type_is_data),
-    ADD_METHOD(get_type_name),
-    { NULL, NULL }
-};
-#undef ADD_METHOD
-
-
-/*
- * Constructor for PKCS7 objects, never called by Python code directly
- *
- * Arguments: pkcs7    - A "real" pkcs7 certificate object
- *            dealloc - Boolean value to specify whether the destructor should
- *                      free the "real" pkcs7 object
- * Returns:   The newly created pkcs7 object
- */
-crypto_PKCS7Obj *
-crypto_PKCS7_New(PKCS7 *pkcs7, int dealloc)
-{
-    crypto_PKCS7Obj *self;
-
-    self = PyObject_New(crypto_PKCS7Obj, &crypto_PKCS7_Type);
-
-    if (self == NULL)
-        return NULL;
-
-    self->pkcs7 = pkcs7;
-    self->dealloc = dealloc;
-
-    return self;
-}
-
-/*
- * Deallocate the memory used by the PKCS7 object
- *
- * Arguments: self - The PKCS7 object
- * Returns:   None
- */
-static void
-crypto_PKCS7_dealloc(crypto_PKCS7Obj *self)
-{
-    /* Sometimes we don't have to dealloc the "real" PKCS7 pointer ourselves */
-    if (self->dealloc)
-        PKCS7_free(self->pkcs7);
-
-    PyObject_Del(self);
-}
-
-PyTypeObject crypto_PKCS7_Type = {
-    PyOpenSSL_HEAD_INIT(&PyType_Type, 0)
-    "PKCS7",
-    sizeof(crypto_PKCS7Obj),
-    0,
-    (destructor)crypto_PKCS7_dealloc,
-    NULL, /* print */
-    NULL, /* getattr */
-    NULL, /* setattr */
-    NULL, /* compare */
-    NULL, /* repr */
-    NULL, /* as_number */
-    NULL, /* as_sequence */
-    NULL, /* as_mapping */
-    NULL, /* hash */
-    NULL, /* call */
-    NULL,  /* str */
-    NULL, /* getattro */
-    NULL, /* setattro */
-    NULL, /* as_buffer */
-    Py_TPFLAGS_DEFAULT,
-    NULL, /* doc */
-    NULL, /* traverse */
-    NULL, /* clear */
-    NULL, /* tp_richcompare */
-    0, /* tp_weaklistoffset */
-    NULL, /* tp_iter */
-    NULL, /* tp_iternext */
-    crypto_PKCS7_methods, /* tp_methods */
-};
-
-/*
- * Initialize the PKCS7 part of the crypto sub module
- *
- * Arguments: module - The crypto module
- * Returns:   None
- */
-int
-init_crypto_pkcs7(PyObject *module) {
-    if (PyType_Ready(&crypto_PKCS7_Type) < 0) {
-        return 0;
-    }
-
-    /* PyModule_AddObject steals a reference.
-     */
-    Py_INCREF((PyObject *)&crypto_PKCS7_Type);
-    if (PyModule_AddObject(module, "PKCS7Type", (PyObject *)&crypto_PKCS7_Type) != 0) {
-        return 0;
-    }
-
-    return 1;
-}
-
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/pkcs7.h hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/pkcs7.h
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/pkcs7.h	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/pkcs7.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,30 +0,0 @@
-/*
- * pkcs7.h
- *
- * Copyright (C) AB Strakt
- * See LICENSE for details.
- *
- * Export pkcs7 functions and data structure.
- * See the file RATIONALE for a short explanation of why this module was written.
- *
- */
-#ifndef PyOpenSSL_crypto_PKCS7_H_
-#define PyOpenSSL_crypto_PKCS7_H_
-
-#include <Python.h>
-#include <openssl/pkcs7.h>
-
-extern  int       init_crypto_pkcs7   (PyObject *);
-
-extern  PyTypeObject      crypto_PKCS7_Type;
-
-#define crypto_PKCS7_Check(v) ((v)->ob_type == &crypto_PKCS7_Type)
-
-typedef struct {
-    PyObject_HEAD
-    PKCS7                *pkcs7;
-    int                  dealloc;
-} crypto_PKCS7Obj;
-
-
-#endif
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/pkey.c hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/pkey.c
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/pkey.c	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/pkey.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,303 +0,0 @@
-/*
- * pkey.c
- *
- * Copyright (C) AB Strakt
- * Copyright (C) Jean-Paul Calderone
- * See LICENSE for details.
- *
- * Public/rivate key handling code, mostly thin wrappers around OpenSSL.
- * See the file RATIONALE for a short explanation of why this module was written.
- *
- */
-#include <Python.h>
-#define crypto_MODULE
-#include "crypto.h"
-
-/*
- * This is done every time something fails, so turning it into a macro is
- * really nice.
- *
- * Arguments:   None
- * Returns:     Doesn't return
- */
-#define FAIL() \
-do {                                    \
-    exception_from_error_queue(crypto_Error); \
-    return NULL;                        \
-} while (0)
-    
-
-static char crypto_PKey_generate_key_doc[] = "\n\
-Generate a key of a given type, with a given number of a bits\n\
-\n\
-@param type: The key type (TYPE_RSA or TYPE_DSA)\n\
-@param bits: The number of bits\n\
-@return: None\n\
-";
-
-static PyObject *
-crypto_PKey_generate_key(crypto_PKeyObj *self, PyObject *args)
-{
-    int type, bits;
-    RSA *rsa;
-    DSA *dsa;
-
-    if (!PyArg_ParseTuple(args, "ii:generate_key", &type, &bits))
-        return NULL;
-
-    switch (type)
-    {
-        case crypto_TYPE_RSA:
-            if (bits <= 0) {
-                PyErr_SetString(PyExc_ValueError, "Invalid number of bits");
-                return NULL;
-            }
-            if ((rsa = RSA_generate_key(bits, 0x10001, NULL, NULL)) == NULL)
-                FAIL();
-            if (!EVP_PKEY_assign_RSA(self->pkey, rsa))
-                FAIL();
-	    break;
-
-        case crypto_TYPE_DSA:
-            if ((dsa = DSA_generate_parameters(bits, NULL, 0, NULL, NULL, NULL, NULL)) == NULL)
-                FAIL();
-            if (!DSA_generate_key(dsa))
-                FAIL();
-            if (!EVP_PKEY_assign_DSA(self->pkey, dsa))
-                FAIL();
-	    break;
-
-        default:
-	    PyErr_SetString(crypto_Error, "No such key type");
-	    return NULL;
-
-    }
-    self->initialized = 1;
-    Py_INCREF(Py_None);
-    return Py_None;
-}
-
-static char crypto_PKey_bits_doc[] = "\n\
-Returns the number of bits of the key\n\
-\n\
-@return: The number of bits of the key.\n\
-";
-
-static PyObject *
-crypto_PKey_bits(crypto_PKeyObj *self, PyObject *args)
-{
-    if (!PyArg_ParseTuple(args, ":bits"))
-        return NULL;
-
-    return PyLong_FromLong(EVP_PKEY_bits(self->pkey));
-}
-
-static char crypto_PKey_type_doc[] = "\n\
-Returns the type of the key\n\
-\n\
-@return: The type of the key.\n\
-";
-
-static PyObject *
-crypto_PKey_type(crypto_PKeyObj *self, PyObject *args)
-{
-    if (!PyArg_ParseTuple(args, ":type"))
-        return NULL;
-
-    return PyLong_FromLong(self->pkey->type);
-}
-
-static char crypto_PKey_check_doc[] = "\n\
-Check the consistency of an RSA private key.\n\
-\n\
-@return: True if key is consistent.\n\
-@raise Error: if the key is inconsistent.\n\
-@raise TypeError: if the key is of a type which cannot be checked.\n\
-    Only RSA keys can currently be checked.\n\
-";
-
-static PyObject *
-crypto_PKey_check(crypto_PKeyObj *self, PyObject *args) {
-    int r;
-
-    if (!PyArg_ParseTuple(args, ":check")) {
-        return NULL;
-    }
-
-    if (self->pkey->type == EVP_PKEY_RSA) {
-        RSA *rsa;
-        rsa = EVP_PKEY_get1_RSA(self->pkey);
-        r = RSA_check_key(rsa);
-        if (r == 1) {
-            return PyBool_FromLong(1L);
-        } else {
-            FAIL();
-        }
-    } else {
-        PyErr_SetString(PyExc_TypeError, "key type unsupported");
-        return NULL;
-    }
-}
-
-/*
- * ADD_METHOD(name) expands to a correct PyMethodDef declaration
- *   {  'name', (PyCFunction)crypto_PKey_name, METH_VARARGS }
- * for convenience
- */
-#define ADD_METHOD(name)        \
-    { #name, (PyCFunction)crypto_PKey_##name, METH_VARARGS, crypto_PKey_##name##_doc }
-static PyMethodDef crypto_PKey_methods[] =
-{
-    ADD_METHOD(generate_key),
-    ADD_METHOD(bits),
-    ADD_METHOD(type),
-    ADD_METHOD(check),
-    { NULL, NULL }
-};
-#undef ADD_METHOD
-
-
-/*
- * Constructor for PKey objects, never called by Python code directly
- *
- * Arguments: pkey    - A "real" EVP_PKEY object
- *            dealloc - Boolean value to specify whether the destructor should
- *                      free the "real" EVP_PKEY object
- * Returns:   The newly created PKey object
- */
-crypto_PKeyObj *
-crypto_PKey_New(EVP_PKEY *pkey, int dealloc)
-{
-    crypto_PKeyObj *self;
-
-    self = PyObject_New(crypto_PKeyObj, &crypto_PKey_Type);
-
-    if (self == NULL)
-        return NULL;
-
-    self->pkey = pkey;
-    self->dealloc = dealloc;
-    self->only_public = 0;
-
-    /*
-     * Heuristic.  Most call-sites pass an initialized EVP_PKEY.  Not
-     * necessarily the case that they will, though.  That's part of why this is
-     * a hack. -exarkun
-     */
-    self->initialized = 1;
-
-    return self;
-}
-
-static char crypto_PKey_doc[] = "\n\
-PKey() -> PKey instance\n\
-\n\
-Create a new PKey object.\n\
-\n\
-@return: The PKey object\n\
-";
-static PyObject*
-crypto_PKey_new(PyTypeObject *subtype, PyObject *args, PyObject *kwargs) {
-    crypto_PKeyObj *self;
-
-    if (!PyArg_ParseTuple(args, ":PKey")) {
-        return NULL;
-    }
-
-    self = crypto_PKey_New(EVP_PKEY_new(), 1);
-    if (self) {
-	self->initialized = 0;
-    }
-
-    return (PyObject *)self;
-}
-
-
-/*
- * Deallocate the memory used by the PKey object
- *
- * Arguments: self - The PKey object
- * Returns:   None
- */
-static void
-crypto_PKey_dealloc(crypto_PKeyObj *self)
-{
-    /* Sometimes we don't have to dealloc the "real" EVP_PKEY pointer ourselves */
-    if (self->dealloc)
-        EVP_PKEY_free(self->pkey);
-
-    PyObject_Del(self);
-}
-
-PyTypeObject crypto_PKey_Type = {
-    PyOpenSSL_HEAD_INIT(&PyType_Type, 0)
-    "OpenSSL.crypto.PKey",
-    sizeof(crypto_PKeyObj),
-    0,
-    (destructor)crypto_PKey_dealloc,
-    NULL, /* print */
-    NULL, /* getattr */
-    NULL, /* setattr */
-    NULL, /* compare */
-    NULL, /* repr */
-    NULL, /* as_number */
-    NULL, /* as_sequence */
-    NULL, /* as_mapping */
-    NULL, /* hash */
-    NULL, /* call */
-    NULL, /* str */
-    NULL, /* getattro */
-    NULL, /* setattro */
-    NULL, /* as_buffer */
-    Py_TPFLAGS_DEFAULT,
-    crypto_PKey_doc, /* doc */
-    NULL, /* traverse */
-    NULL, /* clear */
-    NULL, /* tp_richcompare */
-    0, /* tp_weaklistoffset */
-    NULL, /* tp_iter */
-    NULL, /* tp_iternext */
-    crypto_PKey_methods, /* tp_methods */
-    NULL, /* tp_members */
-    NULL, /* tp_getset */
-    NULL, /* tp_base */
-    NULL, /* tp_dict */
-    NULL, /* tp_descr_get */
-    NULL, /* tp_descr_set */
-    0, /* tp_dictoffset */
-    NULL, /* tp_init */
-    NULL, /* tp_alloc */
-    crypto_PKey_new, /* tp_new */
-};
-
-
-/*
- * Initialize the PKey part of the crypto sub module
- *
- * Arguments: module - The crypto module
- * Returns:   None
- */
-int
-init_crypto_pkey(PyObject *module)
-{
-    if (PyType_Ready(&crypto_PKey_Type) < 0) {
-        return 0;
-    }
-
-    /* PyModule_AddObject steals a reference.
-     */
-    Py_INCREF((PyObject *)&crypto_PKey_Type);
-    if (PyModule_AddObject(module, "PKey", (PyObject *)&crypto_PKey_Type) != 0) {
-        return 0;
-    }
-
-    /* PyModule_AddObject steals a reference.
-     */
-    Py_INCREF((PyObject *)&crypto_PKey_Type);
-    if (PyModule_AddObject(module, "PKeyType", (PyObject *)&crypto_PKey_Type) != 0) {
-        return 0;
-    }
-
-    return 1;
-}
-
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/pkey.h hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/pkey.h
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/pkey.h	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/pkey.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,52 +0,0 @@
-/*
- * pkey.h
- *
- * Copyright (C) AB Strakt
- * Copyright (C) Jean-Paul Calderone
- * See LICENSE for details.
- *
- * Export pkey functions and data structure.
- * See the file RATIONALE for a short explanation of why this module was written.
- *
- */
-#ifndef PyOpenSSL_crypto_PKEY_H_
-#define PyOpenSSL_crypto_PKEY_H_
-
-extern  int       init_crypto_pkey   (PyObject *);
-
-extern  PyTypeObject    crypto_PKey_Type;
-
-#define crypto_PKey_Check(v) ((v)->ob_type == &crypto_PKey_Type)
-
-typedef struct {
-    PyObject_HEAD
-
-    /*
-     * A pointer to the underlying OpenSSL structure.
-     */
-    EVP_PKEY            *pkey;
-
-    /*
-     * A flag indicating the underlying pkey object has no private parts (so it
-     * can't sign, for example).  This is a bit of a temporary hack.
-     * Public-only should be represented as a different type. -exarkun
-     */
-    int                  only_public;
-
-    /*
-     * A flag indicating whether the underlying pkey object has no meaningful
-     * data in it whatsoever.  This is a temporary hack.  It should be
-     * impossible to create PKeys in an unusable state. -exarkun
-     */
-    int                  initialized;
-
-    /*
-     * A flag indicating whether pkey will be freed when this object is freed.
-     */
-    int                  dealloc;
-} crypto_PKeyObj;
-
-#define crypto_TYPE_RSA           EVP_PKEY_RSA
-#define crypto_TYPE_DSA           EVP_PKEY_DSA
-
-#endif
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/revoked.c hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/revoked.c
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/revoked.c	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/revoked.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,444 +0,0 @@
-#include <Python.h>
-#define crypto_MODULE
-#include "crypto.h"
-
-#ifdef _WIN32
-#define strcasecmp(string1, string2) _stricmp(string1, string2)
-#endif
-
-/* http://www.openssl.org/docs/apps/x509v3_config.html#CRL_distribution_points_ */
-/* which differs from crl_reasons of crypto/x509v3/v3_enum.c that matches */
-/* OCSP_crl_reason_str.  We use the latter, just like the command line program.  */
-static const char *crl_reasons[] = {
-    "unspecified",
-    "keyCompromise",
-    "CACompromise",
-    "affiliationChanged",
-    "superseded",
-    "cessationOfOperation",
-    "certificateHold",
-    NULL,
-    "removeFromCRL",
-};
-
-#define NUM_REASONS (sizeof(crl_reasons) / sizeof(char *))
-
-static char crypto_Revoked_all_reasons_doc[] = "\n\
-Return a list of all the supported reason strings.\n\
-\n\
-@return: A list of reason strings.\n\
-";
-static PyObject *
-crypto_Revoked_all_reasons(crypto_RevokedObj *self, PyObject *args) {
-    PyObject *list, *str;
-    int j;
-
-    list = PyList_New(0);
-    for (j = 0; j < NUM_REASONS; j++) {
-        if(crl_reasons[j]) {
-            str = PyBytes_FromString(crl_reasons[j]);
-            PyList_Append(list, str);
-            Py_DECREF(str);
-        }
-    }
-    return list;
-}
-
-static PyObject *
-X509_EXTENSION_value_to_PyString(X509_EXTENSION *ex) {
-    BIO *bio = NULL;
-    PyObject *str = NULL;
-    int str_len;
-    char *tmp_str;
-
-    /* Create a openssl BIO buffer */
-    bio = BIO_new(BIO_s_mem());
-    if (bio == NULL) {
-        goto err;
-    }
-
-    /* These are not the droids you are looking for. */
-    if (!X509V3_EXT_print(bio, ex, 0, 0)) {
-        if (M_ASN1_OCTET_STRING_print(bio, ex->value) == 0) {
-            goto err;
-        }
-    }
-
-    /* Convert to a Python string. */
-    str_len = BIO_get_mem_data(bio, &tmp_str);
-    str = PyBytes_FromStringAndSize(tmp_str, str_len);
-
-    /* Cleanup */
-    BIO_free(bio);
-    return str;
-
- err:
-    if (bio) {
-        BIO_free(bio);
-    }
-    if (str) {
-        Py_DECREF(str);
-    }
-    return NULL;
-}
-
-static void
-delete_reason(STACK_OF(X509_EXTENSION) *sk) {
-    X509_EXTENSION * ext;
-    int j;
-
-    for (j = 0; j < sk_X509_EXTENSION_num(sk); j++) {
-         ext = sk_X509_EXTENSION_value(sk, j);
-         if (OBJ_obj2nid(ext->object) == NID_crl_reason) {
-             X509_EXTENSION_free(ext);
-             (void) sk_X509_EXTENSION_delete(sk, j);
-             break;
-         }
-    }
-}
-
-static int
-reason_str_to_code(const char * reason_str) {
-    int reason_code = -1, j;
-    char *spaceless_reason, * sp;
-
-    /*  Remove spaces so that the responses of
-     *  get_reason() work in set_reason()  */
-    if ((spaceless_reason = strdup(reason_str)) == NULL) {
-        return -1;
-    }
-
-    while ((sp = strchr(spaceless_reason, ' '))) {
-       memmove(sp, sp+1, strlen(sp));
-    }
-
-    for (j = 0; j < NUM_REASONS; j++) {
-        if(crl_reasons[j] && !strcasecmp(spaceless_reason, crl_reasons[j])) {
-            reason_code = j;
-            break;
-        }
-    }
-    free(spaceless_reason);
-    return reason_code;
-}
-
-
-static char crypto_Revoked_set_reason_doc[] = "\n\
-Set the reason of a Revoked object.\n\
-\n\
-@param reason: The reason string.\n\
-@type reason: L{str}\n\
-@return: None\n\
-";
-static PyObject *
-crypto_Revoked_set_reason(crypto_RevokedObj *self, PyObject *args, PyObject *keywds) {
-    static char *kwlist[] = {"reason", NULL};
-    const char *reason_str = NULL;
-    int reason_code;
-    ASN1_ENUMERATED *rtmp = NULL;
-
-    if (!PyArg_ParseTupleAndKeywords(
-            args, keywds, "O&:set_reason", kwlist,
-            crypto_byte_converter, &reason_str)) {
-        return NULL;
-    }
-
-    if(reason_str == NULL) {
-        delete_reason(self->revoked->extensions);
-        goto done;
-    }
-
-    reason_code = reason_str_to_code(reason_str);
-    if (reason_code == -1) {
-        PyErr_SetString(PyExc_ValueError, "bad reason string");
-        return NULL;
-    }
-
-    rtmp = ASN1_ENUMERATED_new();
-    if (!rtmp || !ASN1_ENUMERATED_set(rtmp, reason_code)) {
-        goto err;
-    }
-    delete_reason(self->revoked->extensions);
-    if (!X509_REVOKED_add1_ext_i2d(self->revoked, NID_crl_reason, rtmp, 0, 0)) {
-        goto err;
-    }
-
- done:
-    Py_INCREF(Py_None);
-    return Py_None;
-
- err:
-    exception_from_error_queue(crypto_Error);
-    return NULL;
-}
-
-
-static char crypto_Revoked_get_reason_doc[] = "\n\
-Return the reason of a Revoked object.\n\
-\n\
-@return: The reason as a string\n\
-";
-static PyObject *
-crypto_Revoked_get_reason(crypto_RevokedObj *self, PyObject *args) {
-    X509_EXTENSION * ext;
-    int j;
-    STACK_OF(X509_EXTENSION) *sk = NULL;
-
-    if (!PyArg_ParseTuple(args, ":get_reason")) {
-        return NULL;
-    }
-
-    sk = self->revoked->extensions;
-    for (j = 0; j < sk_X509_EXTENSION_num(sk); j++) {
-         ext = sk_X509_EXTENSION_value(sk, j);
-         if (OBJ_obj2nid(ext->object) == NID_crl_reason) {
-             return X509_EXTENSION_value_to_PyString(ext);
-         }
-    }
-
-    Py_INCREF(Py_None);
-    return Py_None;
-}
-
-
-static char crypto_Revoked_get_rev_date_doc[] = "\n\
-Retrieve the revocation date\n\
-\n\
-@return: A string giving the timestamp, in the format:\n\
-\n\
-                 YYYYMMDDhhmmssZ\n\
-                 YYYYMMDDhhmmss+hhmm\n\
-                 YYYYMMDDhhmmss-hhmm\n\
-";
-
-static PyObject*
-crypto_Revoked_get_rev_date(crypto_RevokedObj *self, PyObject *args) {
-    /* returns a borrowed reference.  */
-    return _get_asn1_time(
-        ":get_rev_date", self->revoked->revocationDate, args);
-}
-
-static char crypto_Revoked_set_rev_date_doc[] = "\n\
-Set the revocation timestamp\n\
-\n\
-@param when: A string giving the timestamp, in the format:\n\
-\n\
-                 YYYYMMDDhhmmssZ\n\
-                 YYYYMMDDhhmmss+hhmm\n\
-                 YYYYMMDDhhmmss-hhmm\n\
-\n\
-@return: None\n\
-";
-
-static PyObject*
-crypto_Revoked_set_rev_date(crypto_RevokedObj *self, PyObject *args) {
-    return _set_asn1_time(
-        BYTESTRING_FMT ":set_rev_date", self->revoked->revocationDate, args);
-}
-
-/* The integer is converted to an upper-case hex string
- * without a '0x' prefix. */
-static PyObject *
-ASN1_INTEGER_to_PyString(ASN1_INTEGER *asn1_int) {
-    BIO *bio = NULL;
-    PyObject *str = NULL;
-    int str_len;
-    char *tmp_str;
-
-    /* Create a openssl BIO buffer */
-    bio = BIO_new(BIO_s_mem());
-    if (bio == NULL) {
-        goto err;
-    }
-
-    /* Write the integer to the BIO as a hex string. */
-    if (i2a_ASN1_INTEGER(bio, asn1_int) < 0) {
-        goto err;
-    }
-
-    /* Convert to a Python string. */
-    str_len = BIO_get_mem_data(bio, &tmp_str);
-    str = PyBytes_FromStringAndSize(tmp_str, str_len);
-
-    /* Cleanup */
-    BIO_free(bio);
-    return str;
-
- err:
-    if (bio) {
-        BIO_free(bio);
-    }
-    if (str) {
-        Py_DECREF(str);
-    }
-    return NULL;
-}
-
-
-static char crypto_Revoked_get_serial_doc[] = "\n\
-Return the serial number of a Revoked structure\n\
-\n\
-@return: The serial number as a string\n\
-";
-static PyObject *
-crypto_Revoked_get_serial(crypto_RevokedObj *self, PyObject *args) {
-    if (!PyArg_ParseTuple(args, ":get_serial")) {
-        return NULL;
-    }
-
-    if (self->revoked->serialNumber == NULL) {
-        /* never happens */
-        Py_INCREF(Py_None);
-        return Py_None;
-    } else {
-        return ASN1_INTEGER_to_PyString(self->revoked->serialNumber);
-    }
-}
-
-static char crypto_Revoked_set_serial_doc[] = "\n\
-Set the serial number of a revoked Revoked structure\n\
-\n\
-@param hex_str: The new serial number.\n\
-@type hex_str: L{str}\n\
-@return: None\n\
-";
-static PyObject *
-crypto_Revoked_set_serial(crypto_RevokedObj *self, PyObject *args, PyObject *keywds) {
-    static char *kwlist[] = {"hex_str", NULL};
-    const char *hex_str = NULL;
-    BIGNUM *serial = NULL;
-    ASN1_INTEGER *tmpser = NULL;
-
-    if (!PyArg_ParseTupleAndKeywords(args, keywds, BYTESTRING_FMT ":set_serial",
-                                     kwlist, &hex_str)) {
-        return NULL;
-    }
-
-    if (!BN_hex2bn(&serial, hex_str) ) {
-        PyErr_SetString(PyExc_ValueError, "bad hex string");
-        return NULL;
-    }
-
-    tmpser = BN_to_ASN1_INTEGER(serial, NULL);
-    BN_free(serial);
-    serial = NULL;
-    X509_REVOKED_set_serialNumber(self->revoked, tmpser);
-    ASN1_INTEGER_free(tmpser);
-
-    Py_INCREF(Py_None);
-    return Py_None;
-}
-
-
-crypto_RevokedObj *
-crypto_Revoked_New(X509_REVOKED *revoked) {
-    crypto_RevokedObj *self;
-
-    self = PyObject_New(crypto_RevokedObj, &crypto_Revoked_Type);
-    if (self == NULL) {
-        return NULL;
-    }
-    self->revoked = revoked;
-    return self;
-}
-
-/*
- * ADD_METHOD(name) expands to a correct PyMethodDef declaration
- *   {  'name', (PyCFunction)crypto_Revoked_name, METH_VARARGS, crypto_Revoked_name_doc }
- * for convenience
- */
-#define ADD_METHOD(name)        \
-    { #name, (PyCFunction)crypto_Revoked_##name, METH_VARARGS, crypto_Revoked_##name##_doc }
-#define ADD_KW_METHOD(name)        \
-    { #name, (PyCFunction)crypto_Revoked_##name, METH_VARARGS | METH_KEYWORDS, crypto_Revoked_##name##_doc }
-static PyMethodDef crypto_Revoked_methods[] = {
-    ADD_METHOD(all_reasons),
-    ADD_METHOD(get_reason),
-    ADD_KW_METHOD(set_reason),
-    ADD_METHOD(get_rev_date),
-    ADD_METHOD(set_rev_date),
-    ADD_METHOD(get_serial),
-    ADD_KW_METHOD(set_serial),
-    { NULL, NULL }
-};
-#undef ADD_METHOD
-
-
-static void
-crypto_Revoked_dealloc(crypto_RevokedObj *self) {
-    X509_REVOKED_free(self->revoked);
-    self->revoked = NULL;
-
-    PyObject_Del(self);
-}
-
-static char crypto_Revoked_doc[] = "\n\
-Revoked() -> Revoked instance\n\
-\n\
-Create a new empty Revoked object.\n\
-\n\
-@returns: The Revoked object\n\
-";
-
-static PyObject* crypto_Revoked_new(PyTypeObject *subtype, PyObject *args, PyObject *kwargs) {
-    if (!PyArg_ParseTuple(args, ":Revoked")) {
-        return NULL;
-    }
-
-    return (PyObject *)crypto_Revoked_New(X509_REVOKED_new());
-}
-
-PyTypeObject crypto_Revoked_Type = {
-    PyOpenSSL_HEAD_INIT(&PyType_Type, 0)
-    "Revoked",
-    sizeof(crypto_RevokedObj),
-    0,
-    (destructor)crypto_Revoked_dealloc,
-    NULL, /* print */
-    NULL, /* getattr */
-    NULL, /* setattr */
-    NULL, /* compare */
-    NULL, /* repr */
-    NULL, /* as_number */
-    NULL, /* as_sequence */
-    NULL, /* as_mapping */
-    NULL, /* hash */
-    NULL, /* call */
-    NULL, /* str */
-    NULL, /* getattro */
-    NULL, /* setattro */
-    NULL, /* as_buffer */
-    Py_TPFLAGS_DEFAULT,
-    crypto_Revoked_doc, /* doc */
-    NULL, /* traverse */
-    NULL, /* clear */
-    NULL, /* tp_richcompare */
-    0, /* tp_weaklistoffset */
-    NULL, /* tp_iter */
-    NULL, /* tp_iternext */
-    crypto_Revoked_methods, /* tp_methods */
-    NULL, /* tp_members */
-    NULL, /* tp_getset */
-    NULL, /* tp_base */
-    NULL, /* tp_dict */
-    NULL, /* tp_descr_get */
-    NULL, /* tp_descr_set */
-    0, /* tp_dictoffset */
-    NULL, /* tp_init */
-    NULL, /* tp_alloc */
-    crypto_Revoked_new, /* tp_new */
-};
-
-int init_crypto_revoked(PyObject *module) {
-    if(PyType_Ready(&crypto_Revoked_Type) < 0) {
-        return 0;
-    }
-
-    /* PyModule_AddObject steals a reference.
-     */
-    Py_INCREF((PyObject *)&crypto_Revoked_Type);
-    if (PyModule_AddObject(module, "Revoked", (PyObject *)&crypto_Revoked_Type) != 0) {
-        return 0;
-    }
-    return 1;
-}
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/revoked.h hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/revoked.h
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/revoked.h	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/revoked.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,18 +0,0 @@
-#ifndef PyOpenSSL_crypto_REVOKED_H_
-#define PyOpenSSL_crypto_REVOKED_H_
-
-#include <Python.h>
-
-extern  PyTypeObject      crypto_Revoked_Type;
-
-#define crypto_Revoked_Check(v) ((v)->ob_type == &crypto_Revoked_Type)
-
-typedef struct {
-    PyObject_HEAD
-    X509_REVOKED *revoked;
-} crypto_RevokedObj;
-
-extern  int       init_crypto_revoked   (PyObject *);
-extern crypto_RevokedObj * crypto_Revoked_New(X509_REVOKED *revoked);
-
-#endif
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/x509.c hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/x509.c
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/x509.c	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/x509.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,929 +0,0 @@
-/*
- * x509.c
- *
- * Copyright (C) AB Strakt
- * Copyright (C) Jean-Paul Calderone
- * See LICENSE for details.
- *
- * Certificate (X.509) handling code, mostly thin wrappers around OpenSSL.
- * See the file RATIONALE for a short explanation of why this module was written.
- *
- * Reviewed 2001-07-23
- */
-#include <Python.h>
-#define crypto_MODULE
-#include "crypto.h"
-#include "x509ext.h"
-
-/*
- * X.509 is a standard for digital certificates.  See e.g. the OpenSSL homepage
- * http://www.openssl.org/ for more information
- */
-
-static char crypto_X509_get_version_doc[] = "\n\
-Return version number of the certificate\n\
-\n\
-@return: Version number as a Python integer\n\
-";
-
-static PyObject *
-crypto_X509_get_version(crypto_X509Obj *self, PyObject *args)
-{
-    if (!PyArg_ParseTuple(args, ":get_version"))
-        return NULL;
-
-    return PyLong_FromLong((long)X509_get_version(self->x509));
-}
-
-static char crypto_X509_set_version_doc[] = "\n\
-Set version number of the certificate\n\
-\n\
-@param version: The version number\n\
-@return: None\n\
-";
-
-static PyObject *
-crypto_X509_set_version(crypto_X509Obj *self, PyObject *args)
-{
-    int version;
-
-    if (!PyArg_ParseTuple(args, "i:set_version", &version))
-        return NULL;
-
-    X509_set_version(self->x509, version);
-
-    Py_INCREF(Py_None);
-    return Py_None;
-}
-
-static char crypto_X509_get_serial_number_doc[] = "\n\
-Return serial number of the certificate\n\
-\n\
-@return: Serial number as a Python integer\n\
-";
-
-static PyObject *
-crypto_X509_get_serial_number(crypto_X509Obj *self, PyObject *args)
-{
-    ASN1_INTEGER *asn1_i;
-    BIGNUM *bignum;
-    char *hex;
-    PyObject *res;
-
-    if (!PyArg_ParseTuple(args, ":get_serial_number"))
-        return NULL;
-
-    asn1_i = X509_get_serialNumber(self->x509);
-    bignum = ASN1_INTEGER_to_BN(asn1_i, NULL);
-    hex = BN_bn2hex(bignum);
-    res = PyLong_FromString(hex, NULL, 16);
-    BN_free(bignum);
-    free(hex);
-    return res;
-}
-
-static char crypto_X509_set_serial_number_doc[] = "\n\
-Set serial number of the certificate\n\
-\n\
-@param serial: The serial number\n\
-@return: None\n\
-";
-
-static PyObject *
-crypto_X509_set_serial_number(crypto_X509Obj *self, PyObject *args)
-{
-    long small_serial;
-    PyObject *serial = NULL;
-    PyObject *hex = NULL;
-    ASN1_INTEGER *asn1_i = NULL;
-    BIGNUM *bignum = NULL;
-    char *hexstr;
-
-    if (!PyArg_ParseTuple(args, "O:set_serial_number", &serial)) {
-        return NULL;
-    }
-
-    if (!PyOpenSSL_Integer_Check(serial)) {
-        PyErr_SetString(
-            PyExc_TypeError, "serial number must be integer");
-        goto err;
-    }
-
-    if ((hex = PyOpenSSL_LongToHex(serial)) == NULL) {
-        goto err;
-    }
-
-#ifdef PY3
-    {
-        PyObject *hexbytes = PyUnicode_AsASCIIString(hex);
-        Py_DECREF(hex);
-        hex = hexbytes;
-    }
-#endif
-
-    /**
-     * BN_hex2bn stores the result in &bignum.  Unless it doesn't feel like
-     * it.  If bignum is still NULL after this call, then the return value
-     * is actually the result.  I hope.  -exarkun
-     */
-    hexstr = PyBytes_AsString(hex);
-    if (hexstr[1] == 'x') {
-        /* +2 to skip the "0x" */
-        hexstr += 2;
-    }
-    small_serial = BN_hex2bn(&bignum, hexstr);
-
-    Py_DECREF(hex);
-    hex = NULL;
-
-    if (bignum == NULL) {
-        if (ASN1_INTEGER_set(X509_get_serialNumber(self->x509), small_serial)) {
-            exception_from_error_queue(crypto_Error);
-            goto err;
-        }
-    } else {
-        asn1_i = BN_to_ASN1_INTEGER(bignum, NULL);
-        BN_free(bignum);
-        bignum = NULL;
-        if (asn1_i == NULL) {
-            exception_from_error_queue(crypto_Error);
-            goto err;
-        }
-        if (!X509_set_serialNumber(self->x509, asn1_i)) {
-            exception_from_error_queue(crypto_Error);
-            goto err;
-        }
-        ASN1_INTEGER_free(asn1_i);
-        asn1_i = NULL;
-    }
-
-    Py_INCREF(Py_None);
-    return Py_None;
-
-  err:
-    if (hex) {
-        Py_DECREF(hex);
-    }
-    if (bignum) {
-        BN_free(bignum);
-    }
-    if (asn1_i) {
-        ASN1_INTEGER_free(asn1_i);
-    }
-    return NULL;
-}
-
-static char crypto_X509_get_issuer_doc[] = "\n\
-Create an X509Name object for the issuer of the certificate\n\
-\n\
-@return: An X509Name object\n\
-";
-
-static PyObject *
-crypto_X509_get_issuer(crypto_X509Obj *self, PyObject *args)
-{
-    crypto_X509NameObj *pyname;
-    X509_NAME *name;
-
-    if (!PyArg_ParseTuple(args, ":get_issuer"))
-        return NULL;
-
-    name = X509_get_issuer_name(self->x509);
-    pyname = crypto_X509Name_New(name, 0);
-    if (pyname != NULL)
-    {
-        pyname->parent_cert = (PyObject *)self;
-        Py_INCREF(self);
-    }
-    return (PyObject *)pyname;
-}
-
-static char crypto_X509_set_issuer_doc[] = "\n\
-Set the issuer of the certificate\n\
-\n\
-@param issuer: The issuer name\n\
-@type issuer: L{X509Name}\n\
-@return: None\n\
-";
-
-static PyObject *
-crypto_X509_set_issuer(crypto_X509Obj *self, PyObject *args)
-{
-    crypto_X509NameObj *issuer;
-
-    if (!PyArg_ParseTuple(args, "O!:set_issuer", &crypto_X509Name_Type,
-			  &issuer))
-        return NULL;
-
-    if (!X509_set_issuer_name(self->x509, issuer->x509_name))
-    {
-        exception_from_error_queue(crypto_Error);
-        return NULL;
-    }
-
-    Py_INCREF(Py_None);
-    return Py_None;
-}
-
-static char crypto_X509_get_subject_doc[] = "\n\
-Create an X509Name object for the subject of the certificate\n\
-\n\
-@return: An X509Name object\n\
-";
-
-static PyObject *
-crypto_X509_get_subject(crypto_X509Obj *self, PyObject *args)
-{
-    crypto_X509NameObj *pyname;
-    X509_NAME *name;
-
-    if (!PyArg_ParseTuple(args, ":get_subject"))
-        return NULL;
-
-    name = X509_get_subject_name(self->x509);
-    pyname = crypto_X509Name_New(name, 0);
-    if (pyname != NULL)
-    {
-        pyname->parent_cert = (PyObject *)self;
-        Py_INCREF(self);
-    }
-    return (PyObject *)pyname;
-}
-
-static char crypto_X509_set_subject_doc[] = "\n\
-Set the subject of the certificate\n\
-\n\
-@param subject: The subject name\n\
-@type subject: L{X509Name}\n\
-@return: None\n\
-";
-
-static PyObject *
-crypto_X509_set_subject(crypto_X509Obj *self, PyObject *args)
-{
-    crypto_X509NameObj *subject;
-
-    if (!PyArg_ParseTuple(args, "O!:set_subject", &crypto_X509Name_Type,
-			  &subject))
-        return NULL;
-
-    if (!X509_set_subject_name(self->x509, subject->x509_name))
-    {
-        exception_from_error_queue(crypto_Error);
-        return NULL;
-    }
-
-    Py_INCREF(Py_None);
-    return Py_None;
-}
-
-static char crypto_X509_get_pubkey_doc[] = "\n\
-Get the public key of the certificate\n\
-\n\
-@return: The public key\n\
-";
-
-static PyObject *
-crypto_X509_get_pubkey(crypto_X509Obj *self, PyObject *args)
-{
-    crypto_PKeyObj *crypto_PKey_New(EVP_PKEY *, int);
-    EVP_PKEY *pkey;
-    crypto_PKeyObj *py_pkey;
-
-    if (!PyArg_ParseTuple(args, ":get_pubkey"))
-        return NULL;
-
-    if ((pkey = X509_get_pubkey(self->x509)) == NULL)
-    {
-        exception_from_error_queue(crypto_Error);
-        return NULL;
-    }
-
-    py_pkey = crypto_PKey_New(pkey, 1);
-    if (py_pkey != NULL) {
-        py_pkey->only_public = 1;
-    }
-    return (PyObject *)py_pkey;
-}
-
-static char crypto_X509_set_pubkey_doc[] = "\n\
-Set the public key of the certificate\n\
-\n\
-@param pkey: The public key\n\
-@return: None\n\
-";
-
-static PyObject *
-crypto_X509_set_pubkey(crypto_X509Obj *self, PyObject *args)
-{
-    crypto_PKeyObj *pkey;
-
-    if (!PyArg_ParseTuple(args, "O!:set_pubkey", &crypto_PKey_Type, &pkey))
-        return NULL;
-
-    if (!X509_set_pubkey(self->x509, pkey->pkey))
-    {
-        exception_from_error_queue(crypto_Error);
-        return NULL;
-    }
-
-    Py_INCREF(Py_None);
-    return Py_None;
-}
-
-PyObject*
-_set_asn1_time(char *format, ASN1_TIME* timestamp, PyObject *args)
-{
-	char *when;
-
-	if (!PyArg_ParseTuple(args, format, &when))
-		return NULL;
-
-	if (ASN1_GENERALIZEDTIME_set_string(timestamp, when) == 0) {
-		ASN1_GENERALIZEDTIME dummy;
-		dummy.type = V_ASN1_GENERALIZEDTIME;
-		dummy.length = strlen(when);
-		dummy.data = (unsigned char *)when;
-		if (!ASN1_GENERALIZEDTIME_check(&dummy)) {
-			PyErr_SetString(PyExc_ValueError, "Invalid string");
-		} else {
-			PyErr_SetString(PyExc_RuntimeError, "Unknown ASN1_GENERALIZEDTIME_set_string failure");
-		}
-		return NULL;
-	}
-	Py_INCREF(Py_None);
-	return Py_None;
-}
-
-static char crypto_X509_set_notBefore_doc[] = "\n\
-Set the time stamp for when the certificate starts being valid\n\
-\n\
-@param when: A string giving the timestamp, in the format:\n\
-\n\
-                 YYYYMMDDhhmmssZ\n\
-                 YYYYMMDDhhmmss+hhmm\n\
-                 YYYYMMDDhhmmss-hhmm\n\
-\n\
-@return: None\n\
-";
-
-static PyObject*
-crypto_X509_set_notBefore(crypto_X509Obj *self, PyObject *args)
-{
-	return _set_asn1_time(
-            BYTESTRING_FMT ":set_notBefore",
-            X509_get_notBefore(self->x509), args);
-}
-
-static char crypto_X509_set_notAfter_doc[] = "\n\
-Set the time stamp for when the certificate stops being valid\n\
-\n\
-@param when: A string giving the timestamp, in the format:\n\
-\n\
-                 YYYYMMDDhhmmssZ\n\
-                 YYYYMMDDhhmmss+hhmm\n\
-                 YYYYMMDDhhmmss-hhmm\n\
-\n\
-@return: None\n\
-";
-
-static PyObject*
-crypto_X509_set_notAfter(crypto_X509Obj *self, PyObject *args)
-{
-	return _set_asn1_time(
-            BYTESTRING_FMT ":set_notAfter",
-            X509_get_notAfter(self->x509), args);
-}
-
-PyObject*
-_get_asn1_time(char *format, ASN1_TIME* timestamp, PyObject *args)
-{
-	ASN1_GENERALIZEDTIME *gt_timestamp = NULL;
-	PyObject *py_timestamp = NULL;
-
-	if (!PyArg_ParseTuple(args, format)) {
-		return NULL;
-	}
-
-	/*
-	 * http://www.columbia.edu/~ariel/ssleay/asn1-time.html
-	 */
-	/*
-	 * There must be a way to do this without touching timestamp->data
-	 * directly. -exarkun
-	 */
-	if (timestamp->length == 0) {
-	    Py_INCREF(Py_None);
-	    return Py_None;
-	} else if (timestamp->type == V_ASN1_GENERALIZEDTIME) {
-		return PyBytes_FromString((char *)timestamp->data);
-	} else {
-		ASN1_TIME_to_generalizedtime(timestamp, &gt_timestamp);
-		if (gt_timestamp == NULL) {
-			exception_from_error_queue(crypto_Error);
-			return NULL;
-		} else {
-			py_timestamp = PyBytes_FromString((char *)gt_timestamp->data);
-			ASN1_GENERALIZEDTIME_free(gt_timestamp);
-			return py_timestamp;
-		}
-	}
-}
-
-static char crypto_X509_get_notBefore_doc[] = "\n\
-Retrieve the time stamp for when the certificate starts being valid\n\
-\n\
-@return: A string giving the timestamp, in the format:\n\
-\n\
-                 YYYYMMDDhhmmssZ\n\
-                 YYYYMMDDhhmmss+hhmm\n\
-                 YYYYMMDDhhmmss-hhmm\n\
-           or None if there is no value set.\n\
-";
-
-static PyObject*
-crypto_X509_get_notBefore(crypto_X509Obj *self, PyObject *args)
-{
-	/*
-	 * X509_get_notBefore returns a borrowed reference.
-	 */
-	return _get_asn1_time(
-		":get_notBefore", X509_get_notBefore(self->x509), args);
-}
-
-
-static char crypto_X509_get_notAfter_doc[] = "\n\
-Retrieve the time stamp for when the certificate stops being valid\n\
-\n\
-@return: A string giving the timestamp, in the format:\n\
-\n\
-                 YYYYMMDDhhmmssZ\n\
-                 YYYYMMDDhhmmss+hhmm\n\
-                 YYYYMMDDhhmmss-hhmm\n\
-           or None if there is no value set.\n\
-";
-
-static PyObject*
-crypto_X509_get_notAfter(crypto_X509Obj *self, PyObject *args)
-{
-	/*
-	 * X509_get_notAfter returns a borrowed reference.
-	 */
-	return _get_asn1_time(
-		":get_notAfter", X509_get_notAfter(self->x509), args);
-}
-
-
-static char crypto_X509_gmtime_adj_notBefore_doc[] = "\n\
-Change the timestamp for when the certificate starts being valid to the current\n\
-time plus an offset.\n \
-\n\
-@param amount: The number of seconds by which to adjust the starting validity\n\
-               time.\n\
-@return: None\n\
-";
-
-static PyObject *
-crypto_X509_gmtime_adj_notBefore(crypto_X509Obj *self, PyObject *args)
-{
-    long amount;
-
-    if (!PyArg_ParseTuple(args, "l:gmtime_adj_notBefore", &amount))
-        return NULL;
-
-    X509_gmtime_adj(X509_get_notBefore(self->x509), amount);
-
-    Py_INCREF(Py_None);
-    return Py_None;
-}
-
-static char crypto_X509_gmtime_adj_notAfter_doc[] = "\n\
-Adjust the time stamp for when the certificate stops being valid\n\
-\n\
-@param amount: The number of seconds by which to adjust the ending validity\n\
-               time.\n\
-@return: None\n\
-";
-
-static PyObject *
-crypto_X509_gmtime_adj_notAfter(crypto_X509Obj *self, PyObject *args)
-{
-    long amount;
-
-    if (!PyArg_ParseTuple(args, "l:gmtime_adj_notAfter", &amount))
-        return NULL;
-
-    X509_gmtime_adj(X509_get_notAfter(self->x509), amount);
-
-    Py_INCREF(Py_None);
-    return Py_None;
-}
-
-
-static char crypto_X509_get_signature_algorithm_doc[] = "\n\
-Retrieve the signature algorithm used in the certificate\n\
-\n\
-@return: A byte string giving the name of the signature algorithm used in\n\
-         the certificate.\n\
-@raise ValueError: If the signature algorithm is undefined.\n\
-";
-
-static PyObject *
-crypto_X509_get_signature_algorithm(crypto_X509Obj *self, PyObject *args) {
-    ASN1_OBJECT *alg;
-    int nid;
-
-    if (!PyArg_ParseTuple(args, ":get_signature_algorithm")) {
-        return NULL;
-    }
-
-    alg = self->x509->cert_info->signature->algorithm;
-    nid = OBJ_obj2nid(alg);
-    if (nid == NID_undef) {
-        PyErr_SetString(PyExc_ValueError, "Undefined signature algorithm");
-        return NULL;
-    }
-    return PyBytes_FromString(OBJ_nid2ln(nid));
-}
-
-
-static char crypto_X509_sign_doc[] = "\n\
-Sign the certificate using the supplied key and digest\n\
-\n\
-@param pkey: The key to sign with\n\
-@param digest: The message digest to use\n\
-@return: None\n\
-";
-
-static PyObject *
-crypto_X509_sign(crypto_X509Obj *self, PyObject *args)
-{
-    crypto_PKeyObj *pkey;
-    char *digest_name;
-    const EVP_MD *digest;
-
-    if (!PyArg_ParseTuple(args, "O!s:sign", &crypto_PKey_Type, &pkey,
-			  &digest_name))
-        return NULL;
-
-    if (pkey->only_public) {
-	PyErr_SetString(PyExc_ValueError, "Key has only public part");
-	return NULL;
-    }
-
-    if (!pkey->initialized) {
-	PyErr_SetString(PyExc_ValueError, "Key is uninitialized");
-	return NULL;
-    }
-
-    if ((digest = EVP_get_digestbyname(digest_name)) == NULL)
-    {
-        PyErr_SetString(PyExc_ValueError, "No such digest method");
-        return NULL;
-    }
-
-    if (!X509_sign(self->x509, pkey->pkey, digest))
-    {
-        exception_from_error_queue(crypto_Error);
-        return NULL;
-    }
-
-    Py_INCREF(Py_None);
-    return Py_None;
-}
-
-static char crypto_X509_has_expired_doc[] = "\n\
-Check whether the certificate has expired.\n\
-\n\
-@return: True if the certificate has expired, false otherwise\n\
-";
-
-static PyObject *
-crypto_X509_has_expired(crypto_X509Obj *self, PyObject *args)
-{
-    time_t tnow;
-
-    if (!PyArg_ParseTuple(args, ":has_expired"))
-        return NULL;
-
-    tnow = time(NULL);
-    if (ASN1_UTCTIME_cmp_time_t(X509_get_notAfter(self->x509), tnow) < 0)
-        return PyLong_FromLong(1L);
-    else
-        return PyLong_FromLong(0L);
-}
-
-static char crypto_X509_subject_name_hash_doc[] = "\n\
-Return the hash of the X509 subject.\n\
-\n\
-@return: The hash of the subject\n\
-";
-
-static PyObject *
-crypto_X509_subject_name_hash(crypto_X509Obj *self, PyObject *args)
-{
-    if (!PyArg_ParseTuple(args, ":subject_name_hash"))
-        return NULL;
-
-    return PyLong_FromLongLong(X509_subject_name_hash(self->x509));
-}
-
-static char crypto_X509_digest_doc[] = "\n\
-Return the digest of the X509 object.\n\
-\n\
-@return: The digest of the object\n\
-";
-
-static PyObject *
-crypto_X509_digest(crypto_X509Obj *self, PyObject *args)
-{
-    unsigned char fp[EVP_MAX_MD_SIZE];
-    char *tmp;
-    char *digest_name;
-    unsigned int len,i;
-    PyObject *ret;
-    const EVP_MD *digest;
-
-    if (!PyArg_ParseTuple(args, "s:digest", &digest_name))
-        return NULL;
-
-    if ((digest = EVP_get_digestbyname(digest_name)) == NULL)
-    {
-        PyErr_SetString(PyExc_ValueError, "No such digest method");
-        return NULL;
-    }
-
-    if (!X509_digest(self->x509,digest,fp,&len))
-    {
-        exception_from_error_queue(crypto_Error);
-    }
-    tmp = malloc(3*len+1);
-    memset(tmp, 0, 3*len+1);
-    for (i = 0; i < len; i++) {
-        sprintf(tmp+i*3,"%02X:",fp[i]);
-    }
-    tmp[3*len-1] = 0;
-    ret = PyBytes_FromStringAndSize(tmp,3*len-1);
-    free(tmp);
-    return ret;
-}
-
-
-static char crypto_X509_add_extensions_doc[] = "\n\
-Add extensions to the certificate.\n\
-\n\
-@param extensions: a sequence of X509Extension objects\n\
-@return: None\n\
-";
-
-static PyObject *
-crypto_X509_add_extensions(crypto_X509Obj *self, PyObject *args)
-{   
-    PyObject *extensions, *seq;
-    crypto_X509ExtensionObj *ext;
-    int nr_of_extensions, i;
-
-    if (!PyArg_ParseTuple(args, "O:add_extensions", &extensions))
-        return NULL;
-
-    seq = PySequence_Fast(extensions, "Expected a sequence");
-    if (seq == NULL)
-        return NULL;
-
-    nr_of_extensions = PySequence_Fast_GET_SIZE(seq);
-
-    for (i = 0; i < nr_of_extensions; i++)
-    { 
-        ext = (crypto_X509ExtensionObj *)PySequence_Fast_GET_ITEM(seq, i);
-        if (!crypto_X509Extension_Check(ext))
-        {   
-            Py_DECREF(seq);
-            PyErr_SetString(PyExc_ValueError,
-                            "One of the elements is not an X509Extension");
-            return NULL;
-        }
-        if (!X509_add_ext(self->x509, ext->x509_extension, -1))
-        {
-            Py_DECREF(seq);
-            exception_from_error_queue(crypto_Error);
-            return NULL;
-        }
-    }
-
-    Py_INCREF(Py_None);
-    return Py_None;
-}
-
-static char crypto_X509_get_extension_count_doc[] = "\n\
-Get the number of extensions on the certificate.\n\
-\n\
-@return: Number of extensions as a Python integer\n\
-";
-
-static PyObject *
-crypto_X509_get_extension_count(crypto_X509Obj *self, PyObject *args) {
-    if (!PyArg_ParseTuple(args, ":get_extension_count")) {
-        return NULL;
-    }
-
-    return PyLong_FromLong((long)X509_get_ext_count(self->x509));
-}
-
-static char crypto_X509_get_extension_doc[] = "\n\
-Get a specific extension of the certificate by index.\n\
-\n\
-@param index: The index of the extension to retrieve.\n\
-@return: The X509Extension object at the specified index.\n\
-";
-
-static PyObject *
-crypto_X509_get_extension(crypto_X509Obj *self, PyObject *args) {
-    crypto_X509ExtensionObj *extobj;
-    int loc;
-    X509_EXTENSION *ext;
-
-    if (!PyArg_ParseTuple(args, "i:get_extension", &loc)) {
-        return NULL;
-    }
-
-    /* will return NULL if loc is outside the range of extensions,
-       not registered as an error*/
-    ext = X509_get_ext(self->x509, loc);
-    if (!ext) {
-        PyErr_SetString(PyExc_IndexError, "extension index out of bounds");
-        return NULL; /* Should be reported as an IndexError ? */
-    }
-
-    extobj = PyObject_New(crypto_X509ExtensionObj, &crypto_X509Extension_Type);
-    extobj->x509_extension = X509_EXTENSION_dup(ext);
-
-    return (PyObject*)extobj;
-}
-
-/*
- * ADD_METHOD(name) expands to a correct PyMethodDef declaration
- *   {  'name', (PyCFunction)crypto_X509_name, METH_VARARGS }
- * for convenience
- */
-#define ADD_METHOD(name)        \
-    { #name, (PyCFunction)crypto_X509_##name, METH_VARARGS, crypto_X509_##name##_doc }
-static PyMethodDef crypto_X509_methods[] =
-{
-    ADD_METHOD(get_version),
-    ADD_METHOD(set_version),
-    ADD_METHOD(get_serial_number),
-    ADD_METHOD(set_serial_number),
-    ADD_METHOD(get_issuer),
-    ADD_METHOD(set_issuer),
-    ADD_METHOD(get_subject),
-    ADD_METHOD(set_subject),
-    ADD_METHOD(get_pubkey),
-    ADD_METHOD(set_pubkey),
-    ADD_METHOD(get_notBefore),
-    ADD_METHOD(set_notBefore),
-    ADD_METHOD(get_notAfter),
-    ADD_METHOD(set_notAfter),
-    ADD_METHOD(gmtime_adj_notBefore),
-    ADD_METHOD(gmtime_adj_notAfter),
-    ADD_METHOD(get_signature_algorithm),
-    ADD_METHOD(sign),
-    ADD_METHOD(has_expired),
-    ADD_METHOD(subject_name_hash),
-    ADD_METHOD(digest),
-    ADD_METHOD(add_extensions),
-    ADD_METHOD(get_extension),
-    ADD_METHOD(get_extension_count),
-    { NULL, NULL }
-};
-#undef ADD_METHOD
-
-
-/*
- * Constructor for X509 objects, never called by Python code directly
- *
- * Arguments: cert    - A "real" X509 certificate object
- *            dealloc - Boolean value to specify whether the destructor should
- *                      free the "real" X509 object
- * Returns:   The newly created X509 object
- */
-crypto_X509Obj *
-crypto_X509_New(X509 *cert, int dealloc)
-{
-    crypto_X509Obj *self;
-
-    self = PyObject_New(crypto_X509Obj, &crypto_X509_Type);
-
-    if (self == NULL)
-        return NULL;
-
-    self->x509 = cert;
-    self->dealloc = dealloc;
-
-    return self;
-}
-
-
-static char crypto_X509_doc[] = "\n\
-X509() -> X509 instance\n\
-\n\
-Create a new X509 object.\n\
-\n\
-@returns: The X509 object\n\
-";
-
-static PyObject *
-crypto_X509_new(PyTypeObject *subtype, PyObject *args, PyObject *kwargs)
-{
-    if (!PyArg_ParseTuple(args, ":X509")) {
-        return NULL;
-    }
-
-    return (PyObject *)crypto_X509_New(X509_new(), 1);
-}
-
-
-/*
- * Deallocate the memory used by the X509 object
- *
- * Arguments: self - The X509 object
- * Returns:   None
- */
-static void
-crypto_X509_dealloc(crypto_X509Obj *self)
-{
-    /* Sometimes we don't have to dealloc the "real" X509 pointer ourselves */
-    if (self->dealloc)
-        X509_free(self->x509);
-
-    PyObject_Del(self);
-}
-
-PyTypeObject crypto_X509_Type = {
-    PyOpenSSL_HEAD_INIT(&PyType_Type, 0)
-    "X509",
-    sizeof(crypto_X509Obj),
-    0,
-    (destructor)crypto_X509_dealloc,
-    NULL, /* print */
-    NULL, /* getattr */
-    NULL, /* setattr */
-    NULL, /* compare */
-    NULL, /* repr */
-    NULL, /* as_number */
-    NULL, /* as_sequence */
-    NULL, /* as_mapping */
-    NULL, /* hash */
-    NULL, /* call */
-    NULL, /* str */
-    NULL, /* getattro */
-    NULL, /* setattro */
-    NULL, /* as_buffer */
-    Py_TPFLAGS_DEFAULT,
-    crypto_X509_doc, /* doc */
-    NULL, /* traverse */
-    NULL, /* clear */
-    NULL, /* tp_richcompare */
-    0, /* tp_weaklistoffset */
-    NULL, /* tp_iter */
-    NULL, /* tp_iternext */
-    crypto_X509_methods, /* tp_methods */
-    NULL, /* tp_members */
-    NULL, /* tp_getset */
-    NULL, /* tp_base */
-    NULL, /* tp_dict */
-    NULL, /* tp_descr_get */
-    NULL, /* tp_descr_set */
-    0, /* tp_dictoffset */
-    NULL, /* tp_init */
-    NULL, /* tp_alloc */
-    crypto_X509_new, /* tp_new */
-};
-
-/*
- * Initialize the X509 part of the crypto sub module
- *
- * Arguments: module - The crypto module
- * Returns:   None
- */
-int
-init_crypto_x509(PyObject *module)
-{
-    if (PyType_Ready(&crypto_X509_Type) < 0) {
-        return 0;
-    }
-
-    /* PyModule_AddObject steals a reference.
-     */
-    Py_INCREF((PyObject *)&crypto_X509_Type);
-    if (PyModule_AddObject(module, "X509", (PyObject *)&crypto_X509_Type) != 0) {
-        return 0;
-    }
-
-    Py_INCREF((PyObject *)&crypto_X509_Type);
-    if (PyModule_AddObject(module, "X509Type", (PyObject *)&crypto_X509_Type) != 0) {
-        return 0;
-    }
-
-    return 1;
-}
-
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/x509ext.c hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/x509ext.c
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/x509ext.c	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/x509ext.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,336 +0,0 @@
-/*
- * x509ext.c
- *
- * Copyright (C) Jean-Paul Calderone
- * See LICENSE for details.
- *
- * Export X.509 extension functions and data structures.
- * See the file RATIONALE for a short explanation of why this module was written.
- *
- */
-
-#include <Python.h>
-#define crypto_MODULE
-#include "crypto.h"
-
-static char crypto_X509Extension_get_critical_doc[] = "\n\
-Returns the critical field of the X509Extension\n\
-\n\
-@return: The critical field.\n\
-";
-
-static PyObject *
-crypto_X509Extension_get_critical(crypto_X509ExtensionObj *self, PyObject *args)
-{
-    if (!PyArg_ParseTuple(args, ":get_critical"))
-        return NULL;
-
-    return PyLong_FromLong(X509_EXTENSION_get_critical(self->x509_extension));
-}
-
-static char crypto_X509Extension_get_short_name_doc[] = "\n\
-Returns the short version of the type name of the X509Extension\n\
-\n\
-@return: The short type name.\n\
-";
-
-static PyObject *
-crypto_X509Extension_get_short_name(crypto_X509ExtensionObj *self, PyObject *args) {
-	ASN1_OBJECT *obj;
-	const char *extname;
-
-	if (!PyArg_ParseTuple(args, ":get_short_name")) {
-		return NULL;
-	}
-
-	/* Returns an internal pointer to x509_extension, not a copy */
-	obj = X509_EXTENSION_get_object(self->x509_extension);
-
-	extname = OBJ_nid2sn(OBJ_obj2nid(obj));
-	return PyBytes_FromString(extname);
-}
-
-
-static char crypto_X509Extension_get_data_doc[] = "\n\
-Returns the data of the X509Extension\n\
-\n\
-@return: A C{str} giving the X509Extension's ASN.1 encoded data.\n\
-";
-
-static PyObject *
-crypto_X509Extension_get_data(crypto_X509ExtensionObj *self, PyObject *args) {
-    ASN1_OCTET_STRING *data;
-    PyObject *result;
-
-    if (!PyArg_ParseTuple(args, ":get_data")) {
-        return NULL;
-    }
-
-    data = X509_EXTENSION_get_data(self->x509_extension);
-    result = PyBytes_FromStringAndSize((const char*)data->data, data->length);
-    return result;
-}
-
-/*
- * ADD_METHOD(name) expands to a correct PyMethodDef declaration
- *   {  'name', (PyCFunction)crypto_X509Extension_name, METH_VARARGS }
- * for convenience
- */
-#define ADD_METHOD(name)        \
-{ #name, (PyCFunction)crypto_X509Extension_##name, METH_VARARGS, crypto_X509Extension_##name##_doc }
-static PyMethodDef crypto_X509Extension_methods[] =
-{
-    ADD_METHOD(get_critical),
-    ADD_METHOD(get_short_name),
-    ADD_METHOD(get_data),
-    { NULL, NULL }
-};
-#undef ADD_METHOD
-
-/*
- * Constructor for X509Extension, never called by Python code directly
- *
- * Arguments: type_name - ???
- *            critical  - ???
- *            value     - ???
- *            subject   - An x509v3 certificate which is the subject for this extension.
- *            issuer    - An x509v3 certificate which is the issuer for this extension.
- * Returns:   The newly created X509Extension object
- */
-crypto_X509ExtensionObj *
-crypto_X509Extension_New(char *type_name, int critical, char *value,
-                         crypto_X509Obj *subject, crypto_X509Obj  *issuer) {
-    X509V3_CTX ctx;
-    crypto_X509ExtensionObj *self;
-    char* value_with_critical = NULL;
-
-
-    /*
-     * A context is necessary for any extension which uses the r2i conversion
-     * method.  That is, X509V3_EXT_nconf may segfault if passed a NULL ctx.
-     * Start off by initializing most of the fields to NULL.
-     */
-    X509V3_set_ctx(&ctx, NULL, NULL, NULL, NULL, 0);
-
-    /*
-     * We have no configuration database - but perhaps we should (some
-     * extensions may require it).
-     */
-    X509V3_set_ctx_nodb(&ctx);
-
-    /*
-     * Initialize the subject and issuer, if appropriate.  ctx is a local, and
-     * as far as I can tell none of the X509V3_* APIs invoked here steal any
-     * references, so no need to incref subject or issuer.
-     */
-    if (subject) {
-            ctx.subject_cert = subject->x509;
-    }
-
-    if (issuer) {
-            ctx.issuer_cert = issuer->x509;
-    }
-
-    self = PyObject_New(crypto_X509ExtensionObj, &crypto_X509Extension_Type);
-
-    if (self == NULL) {
-	    goto error;
-    }
-
-    self->dealloc = 0;
-
-    /* There are other OpenSSL APIs which would let us pass in critical
-     * separately, but they're harder to use, and since value is already a pile
-     * of crappy junk smuggling a ton of utterly important structured data,
-     * what's the point of trying to avoid nasty stuff with strings? (However,
-     * X509V3_EXT_i2d in particular seems like it would be a better API to
-     * invoke.  I do not know where to get the ext_struc it desires for its
-     * last parameter, though.) */
-    value_with_critical = malloc(strlen("critical,") + strlen(value) + 1);
-    if (!value_with_critical) {
-	    goto critical_malloc_error;
-    }
-
-    if (critical) {
-	    strcpy(value_with_critical, "critical,");
-	    strcpy(value_with_critical + strlen("critical,"), value);
-    } else {
-	    strcpy(value_with_critical, value);
-    }
-
-    self->x509_extension = X509V3_EXT_nconf(
-	    NULL, &ctx, type_name, value_with_critical);
-
-    free(value_with_critical);
-
-    if (!self->x509_extension) {
-	    goto nconf_error;
-    }
-
-    self->dealloc = 1;
-    return self;
-
-  nconf_error:
-    exception_from_error_queue(crypto_Error);
-
-  critical_malloc_error:
-    Py_XDECREF(self);
-
-  error:
-    return NULL;
-
-}
-
-static char crypto_X509Extension_doc[] = "\n\
-X509Extension(typename, critical, value[, subject][, issuer]) -> \n\
-                X509Extension instance\n\
-\n\
-@param typename: The name of the extension to create.\n\
-@type typename: C{str}\n\
-@param critical: A flag indicating whether this is a critical extension.\n\
-@param value: The value of the extension.\n\
-@type value: C{str}\n\
-@param subject: Optional X509 cert to use as subject.\n\
-@type subject: C{X509}\n\
-@param issuer: Optional X509 cert to use as issuer.\n\
-@type issuer: C{X509}\n\
-@return: The X509Extension object\n\
-";
-
-static PyObject *
-crypto_X509Extension_new(PyTypeObject *subtype, PyObject *args,
-                         PyObject *kwargs) {
-    char *type_name, *value;
-    int critical = 0;
-    crypto_X509Obj * subject = NULL;
-    crypto_X509Obj * issuer = NULL;
-    static char *kwlist[] = {"type_name", "critical", "value", "subject",
-                             "issuer", NULL};
-
-    if (!PyArg_ParseTupleAndKeywords(
-            args, kwargs,
-            BYTESTRING_FMT "i" BYTESTRING_FMT "|O!O!:X509Extension",
-            kwlist, &type_name, &critical, &value,
-            &crypto_X509_Type, &subject,
-            &crypto_X509_Type, &issuer )) {
-        return NULL;
-    }
-
-    return (PyObject *)crypto_X509Extension_New(type_name, critical, value,
-                                                subject, issuer);
-}
-
-/*
- * Deallocate the memory used by the X509Extension object
- *
- * Arguments: self - The X509Extension object
- * Returns:   None
- */
-static void
-crypto_X509Extension_dealloc(crypto_X509ExtensionObj *self)
-{
-    /* Sometimes we don't have to dealloc this */
-    if (self->dealloc)
-        X509_EXTENSION_free(self->x509_extension);
-
-    PyObject_Del(self);
-}
-
-/*
- * Print a nice text representation of the certificate request.
- */
-static PyObject *
-crypto_X509Extension_str(crypto_X509ExtensionObj *self)
-{
-    int str_len;
-    char *tmp_str;
-    PyObject *str;
-    BIO *bio = BIO_new(BIO_s_mem());
-
-    if (!X509V3_EXT_print(bio, self->x509_extension, 0, 0))
-    {
-        BIO_free(bio);
-        exception_from_error_queue(crypto_Error);
-        return NULL;
-    }
-
-    str_len = BIO_get_mem_data(bio, &tmp_str);
-    str = PyText_FromStringAndSize(tmp_str, str_len);
-
-    BIO_free(bio);
-
-    return str;
-}
-
-PyTypeObject crypto_X509Extension_Type = {
-    PyOpenSSL_HEAD_INIT(&PyType_Type, 0)
-    "X509Extension",
-    sizeof(crypto_X509ExtensionObj),
-    0,
-    (destructor)crypto_X509Extension_dealloc, 
-    NULL, /* print */
-    NULL, /* getattr */
-    NULL, /* setattr  (setattrfunc)crypto_X509Name_setattr, */
-    NULL, /* compare */
-    NULL, /* repr */ 
-    NULL, /* as_number */
-    NULL, /* as_sequence */
-    NULL, /* as_mapping */
-    NULL, /* hash */
-    NULL, /* call */
-    (reprfunc)crypto_X509Extension_str, /* str */
-    NULL, /* getattro */
-    NULL, /* setattro */
-    NULL, /* as_buffer */
-    Py_TPFLAGS_DEFAULT,
-    crypto_X509Extension_doc, /* doc */
-    NULL, /* traverse */
-    NULL, /* clear */
-    NULL, /* tp_richcompare */
-    0, /* tp_weaklistoffset */
-    NULL, /* tp_iter */
-    NULL, /* tp_iternext */
-    crypto_X509Extension_methods, /* tp_methods */
-    NULL, /* tp_members */
-    NULL, /* tp_getset */
-    NULL, /* tp_base */
-    NULL, /* tp_dict */
-    NULL, /* tp_descr_get */
-    NULL, /* tp_descr_set */
-    0, /* tp_dictoffset */
-    NULL, /* tp_init */
-    NULL, /* tp_alloc */
-    crypto_X509Extension_new, /* tp_new */
-};
-
-/*
- * Initialize the X509Extension part of the crypto module
- *
- * Arguments: dict - The crypto module
- * Returns:   None
- */
-int
-init_crypto_x509extension(PyObject *module)
-{
-    if (PyType_Ready(&crypto_X509Extension_Type) < 0) {
-        return 0;
-    }
-
-    /* PyModule_AddObject steals a reference.
-     */
-    Py_INCREF((PyObject *)&crypto_X509Extension_Type);
-    if (PyModule_AddObject(module, "X509Extension",
-                           (PyObject *)&crypto_X509Extension_Type) != 0) {
-        return 0;
-    }
-
-    /* PyModule_AddObject steals a reference.
-     */
-    Py_INCREF((PyObject *)&crypto_X509Extension_Type);
-    if (PyModule_AddObject(module, "X509ExtensionType",
-                           (PyObject *)&crypto_X509Extension_Type) != 0) {
-        return 0;
-    }
-
-    return 1;
-}
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/x509ext.h hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/x509ext.h
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/x509ext.h	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/x509ext.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,33 +0,0 @@
-/*
- * x509ext.h
- *
- * Copyright (C) Awanim
- * See LICENSE for details.
- *
- * Export X.509 extension functions and data structures.
- * See the file RATIONALE for a short explanation of why this module was written.
- *
- */
-#ifndef PyOpenSSL_crypto_X509EXTENSION_H_
-#define PyOpenSSL_crypto_X509EXTENSION_H_
-
-#include <Python.h>
-#include <openssl/ssl.h>
-#include <openssl/x509v3.h>
-
-extern  int     init_crypto_x509extension       (PyObject *);
-
-extern  PyTypeObject      crypto_X509Extension_Type;
-
-#define crypto_X509Extension_Check(v) ( \
-        PyObject_TypeCheck((v),         \
-                           &crypto_X509Extension_Type))
-
-typedef struct {
-    PyObject_HEAD
-    X509_EXTENSION       *x509_extension;
-    int                  dealloc;
-} crypto_X509ExtensionObj;
-
-#endif
-
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/x509.h hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/x509.h
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/x509.h	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/x509.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,34 +0,0 @@
-/*
- * x509.h
- *
- * Copyright (C) AB Strakt
- * See LICENSE for details.
- *
- * Export x509 functions and data structure.
- * See the file RATIONALE for a short explanation of why this module was written.
- *
- * Reviewed 2001-07-23
- *
- */
-#ifndef PyOpenSSL_crypto_X509_H_
-#define PyOpenSSL_crypto_X509_H_
-
-#include <Python.h>
-#include <openssl/ssl.h>
-
-extern  PyTypeObject      crypto_X509_Type;
-
-#define crypto_X509_Check(v) ((v)->ob_type == &crypto_X509_Type)
-
-typedef struct {
-    PyObject_HEAD
-    X509                *x509;
-    int                  dealloc;
-} crypto_X509Obj;
-
-PyObject* _set_asn1_time(char *format, ASN1_TIME* timestamp, PyObject *args);
-PyObject* _get_asn1_time(char *format, ASN1_TIME* timestamp, PyObject *args);
-extern  int       init_crypto_x509   (PyObject *);
-
-
-#endif
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/x509name.c hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/x509name.c
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/x509name.c	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/x509name.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,555 +0,0 @@
-/*
- * x509name.c
- *
- * Copyright (C) AB Strakt
- * Copyright (C) Jean-Paul Calderone
- * See LICENSE for details.
- *
- * X.509 Name handling, mostly thin wrapping.
- * See the file RATIONALE for a short explanation of why this module was written.
- *
- * Reviewed 2001-07-23
- */
-#include <Python.h>
-#define crypto_MODULE
-#include "crypto.h"
-
-static PyMethodDef crypto_X509Name_methods[4];
-
-/*
- * Constructor for X509Name, never called by Python code directly
- *
- * Arguments: name    - A "real" X509_NAME object
- *            dealloc - Boolean value to specify whether the destructor should
- *                      free the "real" X509_NAME object
- * Returns:   The newly created X509Name object
- */
-crypto_X509NameObj *
-crypto_X509Name_New(X509_NAME *name, int dealloc)
-{
-    crypto_X509NameObj *self;
-
-    self = PyObject_GC_New(crypto_X509NameObj, &crypto_X509Name_Type);
-
-    if (self == NULL)
-        return NULL;
-
-    self->x509_name = name;
-    self->dealloc = dealloc;
-    self->parent_cert = NULL;
-
-    PyObject_GC_Track(self);
-    return self;
-}
-
-
-static char crypto_X509Name_doc[] = "\n\
-X509Name(name) -> New X509Name object\n\
-\n\
-Create a new X509Name, copying the given X509Name instance.\n\
-\n\
-@param name: An X509Name object to copy\n\
-@return: The X509Name object\n\
-";
-
-static PyObject *
-crypto_X509Name_new(PyTypeObject *subtype, PyObject *args, PyObject *kwargs)
-{
-    crypto_X509NameObj *name;
-
-    if (!PyArg_ParseTuple(args, "O!:X509Name", &crypto_X509Name_Type, &name)) {
-        return NULL;
-    }
-
-    return (PyObject *)crypto_X509Name_New(X509_NAME_dup(name->x509_name), 1);
-}
-
-
-/*
- * Return a name string given a X509_NAME object and a name identifier. Used
- * by the getattr function.
- *
- * Arguments: name - The X509_NAME object
- *            nid  - The name identifier
- * Returns:   The name as a Python string object
- */
-static int
-get_name_by_nid(X509_NAME *name, int nid, char **utf8string)
-{
-    int entry_idx;
-    X509_NAME_ENTRY *entry;
-    ASN1_STRING *data;
-    int len;
-
-    if ((entry_idx = X509_NAME_get_index_by_NID(name, nid, -1)) == -1)
-    {
-        return 0;
-    }
-    entry = X509_NAME_get_entry(name, entry_idx);
-    data = X509_NAME_ENTRY_get_data(entry);
-    if ((len = ASN1_STRING_to_UTF8((unsigned char **)utf8string, data)) < 0)
-    {
-        exception_from_error_queue(crypto_Error);
-        return -1;
-    }
-
-    return len;
-}
-
-/*
- * Given a X509_NAME object and a name identifier, set the corresponding
- * attribute to the given string. Used by the setattr function.
- *
- * Arguments: name  - The X509_NAME object
- *            nid   - The name identifier
- *            value - The string to set
- * Returns:   0 for success, -1 on failure
- */
-static int
-set_name_by_nid(X509_NAME *name, int nid, char *utf8string)
-{
-    X509_NAME_ENTRY *ne;
-    int i, entry_count, temp_nid;
-
-    /* If there's an old entry for this NID, remove it */
-    entry_count = X509_NAME_entry_count(name);
-    for (i = 0; i < entry_count; i++)
-    {
-        ne = X509_NAME_get_entry(name, i);
-        temp_nid = OBJ_obj2nid(X509_NAME_ENTRY_get_object(ne));
-        if (temp_nid == nid)
-        {
-            ne = X509_NAME_delete_entry(name, i);
-            X509_NAME_ENTRY_free(ne);
-            break;
-        }
-    }
-
-    /* Add the new entry */
-    if (!X509_NAME_add_entry_by_NID(name, nid, MBSTRING_UTF8, 
-				    (unsigned char *)utf8string,
-				    -1, -1, 0))
-    {
-        exception_from_error_queue(crypto_Error);
-        return -1;
-    }
-    return 0;
-}
-
-
-/*
- * Find attribute. An X509Name object has the following attributes:
- * countryName (alias C), stateOrProvince (alias ST), locality (alias L),
- * organization (alias O), organizationalUnit (alias OU), commonName (alias
- * CN) and more...
- *
- * Arguments: self - The X509Name object
- *            name - The attribute name
- * Returns:   A Python object for the attribute, or NULL if something went
- *            wrong
- */
-static PyObject *
-crypto_X509Name_getattro(crypto_X509NameObj *self, PyObject *nameobj)
-{
-    int nid, len;
-    char *utf8string;
-    char *name;
-#ifdef PY3
-    name = PyBytes_AsString(PyUnicode_AsASCIIString(nameobj));
-#else
-    name = PyBytes_AsString(nameobj);
-#endif
-
-    if ((nid = OBJ_txt2nid(name)) == NID_undef) {
-        /*
-         * This is a bit weird.  OBJ_txt2nid indicated failure, but it seems
-         * a lower level function, a2d_ASN1_OBJECT, also feels the need to
-         * push something onto the error queue.  If we don't clean that up
-         * now, someone else will bump into it later and be quite confused. 
-         * See lp#314814.
-         */
-        flush_error_queue();
-        return PyObject_GenericGetAttr((PyObject*)self, nameobj);
-    }
-
-    len = get_name_by_nid(self->x509_name, nid, &utf8string);
-    if (len < 0)
-        return NULL;
-    else if (len == 0)
-    {
-        Py_INCREF(Py_None);
-        return Py_None;
-    }
-    else {
-	    PyObject* result = PyUnicode_Decode(utf8string, len, "utf-8", NULL);
-	    OPENSSL_free(utf8string);
-	    return result;
-    }
-}
-
-/*
- * Set attribute
- *
- * Arguments: self  - The X509Name object
- *            name  - The attribute name
- *            value - The value to set
- */
-static int
-crypto_X509Name_setattro(crypto_X509NameObj *self, PyObject *nameobj, PyObject *value)
-{
-    int nid;
-    int result;
-    char *buffer;
-    char *name;
-
-    if (!PyBytes_CheckExact(nameobj) && !PyUnicode_CheckExact(nameobj)) {
-        PyErr_Format(PyExc_TypeError,
-                     "attribute name must be string, not '%.200s'",
-                     Py_TYPE(nameobj)->tp_name);
-        return -1;
-    }
-
-#ifdef PY3
-    name = PyBytes_AsString(PyUnicode_AsASCIIString(nameobj));
-#else
-    name = PyBytes_AsString(nameobj);
-#endif
-
-    if ((nid = OBJ_txt2nid(name)) == NID_undef)
-    {
-        /* Just like the case in the getattr function */
-        flush_error_queue();
-        PyErr_SetString(PyExc_AttributeError, "No such attribute");
-        return -1;
-    }
-
-    /* Something of a hack to get nice unicode behaviour */
-    if (!PyArg_Parse(value, "es:setattr", "utf-8", &buffer))
-        return -1;
-
-    result = set_name_by_nid(self->x509_name, nid, buffer);
-    PyMem_Free(buffer);
-    return result;
-}
-
-/*
- * Compare two X509Name structures.
- *
- * Arguments: n - The first X509Name
- *            m - The second X509Name
- * Returns:   <0 if n < m, 0 if n == m and >0 if n > m
- */
-static PyObject *
-crypto_X509Name_richcompare(PyObject *n, PyObject *m, int op) {
-    int result;
-
-    if (!crypto_X509Name_Check(n) || !crypto_X509Name_Check(m)) {
-        Py_INCREF(Py_NotImplemented);
-        return Py_NotImplemented;
-    }
-
-    result = X509_NAME_cmp(
-        ((crypto_X509NameObj*)n)->x509_name,
-        ((crypto_X509NameObj*)m)->x509_name);
-
-    switch (op) {
-    case Py_EQ:
-        result = (result == 0);
-        break;
-
-    case Py_NE:
-        result = (result != 0);
-        break;
-
-    case Py_LT:
-        result = (result < 0);
-        break;
-
-    case Py_LE:
-        result = (result <= 0);
-        break;
-
-    case Py_GT:
-        result = (result > 0);
-        break;
-
-    case Py_GE:
-        result = (result >= 0);
-        break;
-
-    default:
-        /* Should be impossible */
-        Py_INCREF(Py_NotImplemented);
-        return Py_NotImplemented;
-    }
-
-    if (result) {
-        Py_INCREF(Py_True);
-        return Py_True;
-    } else {
-        Py_INCREF(Py_False);
-        return Py_False;
-    }
-}
-
-/*
- * String representation of an X509Name
- *
- * Arguments: self - The X509Name object
- * Returns:   A string representation of the object
- */
-static PyObject *
-crypto_X509Name_repr(crypto_X509NameObj *self)
-{
-    char tmpbuf[512] = "";
-    char realbuf[512+64];
-
-    if (X509_NAME_oneline(self->x509_name, tmpbuf, 512) == NULL)
-    {
-        exception_from_error_queue(crypto_Error);
-        return NULL;
-    }
-    else
-    {
-        /* This is safe because tmpbuf is max 512 characters */
-        sprintf(realbuf, "<X509Name object '%s'>", tmpbuf);
-        return PyText_FromString(realbuf);
-    }
-}
-
-static char crypto_X509Name_hash_doc[] = "\n\
-Return the hash value of this name\n\
-\n\
-@return: None\n\
-";
-
-/*
- * First four bytes of the MD5 digest of the DER form of an X509Name.
- *
- * Arguments: self - The X509Name object
- * Returns:   An integer giving the hash.
- */
-static PyObject *
-crypto_X509Name_hash(crypto_X509NameObj *self, PyObject* args)
-{
-    unsigned long hash;
-
-    if (!PyArg_ParseTuple(args, ":hash")) {
-        return NULL;
-    }
-    hash = X509_NAME_hash(self->x509_name);
-    return PyLong_FromLong(hash);
-}
-
-static char crypto_X509Name_der_doc[] = "\n\
-Return the DER encoding of this name\n\
-\n\
-@return: None\n\
-";
-
-/*
- * Arguments: self - The X509Name object
- * Returns:   The DER form of an X509Name.
- */
-static PyObject *
-crypto_X509Name_der(crypto_X509NameObj *self, PyObject *args)
-{
-    if (!PyArg_ParseTuple(args, ":der")) {
-	return NULL;
-    }
-
-    i2d_X509_NAME(self->x509_name, 0);
-    return PyBytes_FromStringAndSize(self->x509_name->bytes->data,
-                                     self->x509_name->bytes->length);
-}
-
-
-static char crypto_X509Name_get_components_doc[] = "\n\
-Returns the split-up components of this name.\n\
-\n\
-@return: List of tuples (name, value).\n\
-";
-
-static PyObject *
-crypto_X509Name_get_components(crypto_X509NameObj *self, PyObject *args)
-{
-    int n, i;
-    X509_NAME *name = self->x509_name;
-    PyObject *list;
-
-    if (!PyArg_ParseTuple(args, ":get_components"))
-	return NULL;
-
-    n = X509_NAME_entry_count(name);
-    list = PyList_New(n);
-    for (i = 0; i < n; i++)
-    {
-	X509_NAME_ENTRY *ent;
-	ASN1_OBJECT *fname;
-	ASN1_STRING *fval;
-	int nid;
-	int l;
-	unsigned char *str;
-	PyObject *tuple;
-
-	ent = X509_NAME_get_entry(name, i);
-
-	fname = X509_NAME_ENTRY_get_object(ent);
-	fval = X509_NAME_ENTRY_get_data(ent);
-
-	l = ASN1_STRING_length(fval);
-	str = ASN1_STRING_data(fval);
-
-	nid = OBJ_obj2nid(fname);
-
-	/* printf("fname is %s len=%d str=%s\n", OBJ_nid2sn(nid), l, str); */
-
-	tuple = PyTuple_New(2);
-	PyTuple_SetItem(tuple, 0, PyBytes_FromString(OBJ_nid2sn(nid)));
-	PyTuple_SetItem(tuple, 1, PyBytes_FromStringAndSize((char *)str, l));
-
-	PyList_SetItem(list, i, tuple);
-    }
-
-    return list;
-}
-
-
-/*
- * Call the visitproc on all contained objects.
- *
- * Arguments: self - The Connection object
- *            visit - Function to call
- *            arg - Extra argument to visit
- * Returns:   0 if all goes well, otherwise the return code from the first
- *            call that gave non-zero result.
- */
-static int
-crypto_X509Name_traverse(crypto_X509NameObj *self, visitproc visit, void *arg)
-{
-    int ret = 0;
-
-    if (ret == 0 && self->parent_cert != NULL)
-        ret = visit(self->parent_cert, arg);
-    return ret;
-}
-
-/*
- * Decref all contained objects and zero the pointers.
- *
- * Arguments: self - The Connection object
- * Returns:   Always 0.
- */
-static int
-crypto_X509Name_clear(crypto_X509NameObj *self)
-{
-    Py_XDECREF(self->parent_cert);
-    self->parent_cert = NULL;
-    return 0;
-}
-
-/*
- * Deallocate the memory used by the X509Name object
- *
- * Arguments: self - The X509Name object
- * Returns:   None
- */
-static void
-crypto_X509Name_dealloc(crypto_X509NameObj *self)
-{
-    PyObject_GC_UnTrack(self);
-    /* Sometimes we don't have to dealloc this */
-    if (self->dealloc)
-        X509_NAME_free(self->x509_name);
-
-    crypto_X509Name_clear(self);
-
-    PyObject_GC_Del(self);
-}
-
-/*
- * ADD_METHOD(name) expands to a correct PyMethodDef declaration
- *   {  'name', (PyCFunction)crypto_X509_name, METH_VARARGS }
- * for convenience
- */
-#define ADD_METHOD(name)        \
-    { #name, (PyCFunction)crypto_X509Name_##name, METH_VARARGS, crypto_X509Name_##name##_doc }
-static PyMethodDef crypto_X509Name_methods[] =
-{
-    ADD_METHOD(hash),
-    ADD_METHOD(der),
-    ADD_METHOD(get_components),
-    { NULL, NULL }
-};
-#undef ADD_METHOD
-
-PyTypeObject crypto_X509Name_Type = {
-    PyOpenSSL_HEAD_INIT(&PyType_Type, 0)
-    "X509Name",
-    sizeof(crypto_X509NameObj),
-    0,
-    (destructor)crypto_X509Name_dealloc,
-    NULL, /* print */
-    NULL, /* getattr */
-    NULL, /* setattr */
-    NULL, /* reserved */
-    (reprfunc)crypto_X509Name_repr,
-    NULL, /* as_number */
-    NULL, /* as_sequence */
-    NULL, /* as_mapping */
-    NULL, /* hash */
-    NULL, /* call */
-    NULL, /* str */
-    (getattrofunc)crypto_X509Name_getattro, /* getattro */
-    (setattrofunc)crypto_X509Name_setattro, /* setattro */
-    NULL, /* as_buffer */
-    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC, /* tp_flags */
-    crypto_X509Name_doc, /* tp_doc */
-    (traverseproc)crypto_X509Name_traverse, /* tp_traverse */
-    (inquiry)crypto_X509Name_clear, /* tp_clear */
-    crypto_X509Name_richcompare, /* tp_richcompare */
-    0, /* tp_weaklistoffset */
-    NULL, /* tp_iter */
-    NULL, /* tp_iternext */
-    crypto_X509Name_methods, /* tp_methods */
-    NULL, /* tp_members */
-    NULL, /* tp_getset */
-    NULL, /* tp_base */
-    NULL, /* tp_dict */
-    NULL, /* tp_descr_get */
-    NULL, /* tp_descr_set */
-    0, /* tp_dictoffset */
-    NULL, /* tp_init */
-    NULL, /* tp_alloc */
-    crypto_X509Name_new, /* tp_new */
-};
-
-/*
- * Initialize the X509Name part of the crypto module
- *
- * Arguments: module - The crypto module
- * Returns:   None
- */
-int
-init_crypto_x509name(PyObject *module)
-{
-    if (PyType_Ready(&crypto_X509Name_Type) < 0) {
-        return 0;
-    }
-
-    /* PyModule_AddObject steals a reference.
-     */
-    Py_INCREF((PyObject *)&crypto_X509Name_Type);
-    if (PyModule_AddObject(module, "X509Name", (PyObject *)&crypto_X509Name_Type) != 0) {
-        return 0;
-    }
-
-    /* PyModule_AddObject steals a reference.
-     */
-    Py_INCREF((PyObject *)&crypto_X509Name_Type);
-    if (PyModule_AddObject(module, "X509NameType", (PyObject *)&crypto_X509Name_Type) != 0) {
-        return 0;
-    }
-
-    return 1;
-}
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/x509name.h hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/x509name.h
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/x509name.h	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/x509name.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,33 +0,0 @@
-/*
- * x509name.h
- *
- * Copyright (C) AB Strakt
- * See LICENSE for details.
- *
- * Export X.509 name functions and data structures.
- * See the file RATIONALE for a short explanation of why this module was written.
- *
- * Reviewed 2001-07-23
- *
- */
-#ifndef PyOpenSSL_crypto_X509NAME_H_
-#define PyOpenSSL_crypto_X509NAME_H_
-
-#include <Python.h>
-#include <openssl/ssl.h>
-
-extern  int     init_crypto_x509name       (PyObject *);
-
-extern  PyTypeObject      crypto_X509Name_Type;
-
-#define crypto_X509Name_Check(v) ((v)->ob_type == &crypto_X509Name_Type)
-
-typedef struct {
-    PyObject_HEAD
-    X509_NAME           *x509_name;
-    int                  dealloc;
-    PyObject            *parent_cert;
-} crypto_X509NameObj;
-
-
-#endif
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/x509req.c hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/x509req.c
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/x509req.c	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/x509req.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,431 +0,0 @@
-/*
- * x509req.c
- *
- * Copyright (C) AB Strakt
- * Copyright (C) Jean-Paul Calderone
- * See LICENSE for details.
- *
- * X.509 Request handling, mostly thin wrapping.
- * See the file RATIONALE for a short explanation of why this module was written.
- */
-#include <Python.h>
-#define crypto_MODULE
-#include "crypto.h"
-
-
-static char crypto_X509Req_get_subject_doc[] = "\n\
-Create an X509Name object for the subject of the certificate request\n\
-\n\
-@return: An X509Name object\n\
-";
-
-static PyObject *
-crypto_X509Req_get_subject(crypto_X509ReqObj *self, PyObject *args)
-{
-    crypto_X509NameObj *crypto_X509Name_New(X509_NAME *, int);
-    X509_NAME *name;
-    crypto_X509NameObj* pyname;
-
-    if (!PyArg_ParseTuple(args, ":get_subject"))
-        return NULL;
-
-    if ((name = X509_REQ_get_subject_name(self->x509_req)) == NULL)
-    {
-        exception_from_error_queue(crypto_Error);
-        return NULL;
-    }
-    if ((pyname = crypto_X509Name_New(name, 0)) != NULL) {
-	    pyname->parent_cert = (PyObject *)self;
-	    Py_INCREF(self);
-    }
-    return (PyObject *)pyname;
-}
-
-static char crypto_X509Req_get_pubkey_doc[] = "\n\
-Get the public key from the certificate request\n\
-\n\
-@return: The public key\n\
-";
-
-static PyObject *
-crypto_X509Req_get_pubkey(crypto_X509ReqObj *self, PyObject *args)
-{
-    crypto_PKeyObj *crypto_PKey_New(EVP_PKEY *, int);
-    EVP_PKEY *pkey;
-    crypto_PKeyObj *py_pkey;
-
-    if (!PyArg_ParseTuple(args, ":get_pubkey"))
-        return NULL;
-
-    if ((pkey = X509_REQ_get_pubkey(self->x509_req)) == NULL)
-    {
-        exception_from_error_queue(crypto_Error);
-        return NULL;
-    }
-
-    py_pkey = crypto_PKey_New(pkey, 1);
-    if (py_pkey != NULL) {
-	py_pkey->only_public = 1;
-    }
-    return (PyObject *)py_pkey;
-}
-
-static char crypto_X509Req_set_pubkey_doc[] = "\n\
-Set the public key of the certificate request\n\
-\n\
-@param pkey: The public key to use\n\
-@return: None\n\
-";
-
-static PyObject *
-crypto_X509Req_set_pubkey(crypto_X509ReqObj *self, PyObject *args)
-{
-    crypto_PKeyObj *pkey;
-
-    if (!PyArg_ParseTuple(args, "O!:set_pubkey", &crypto_PKey_Type, &pkey))
-        return NULL;
-
-    if (!X509_REQ_set_pubkey(self->x509_req, pkey->pkey))
-    {
-        exception_from_error_queue(crypto_Error);
-        return NULL;
-    }
-
-    Py_INCREF(Py_None);
-    return Py_None;
-}
-
-static char crypto_X509Req_sign_doc[] = "\n\
-Sign the certificate request using the supplied key and digest\n\
-\n\
-@param pkey: The key to sign with\n\
-@param digest: The message digest to use\n\
-@return: None\n\
-";
-
-static PyObject *
-crypto_X509Req_sign(crypto_X509ReqObj *self, PyObject *args)
-{
-    crypto_PKeyObj *pkey;
-    char *digest_name;
-    const EVP_MD *digest;
-
-    if (!PyArg_ParseTuple(args, "O!s:sign", &crypto_PKey_Type, &pkey,
-			  &digest_name))
-        return NULL;
-
-    if (pkey->only_public) {
-	PyErr_SetString(PyExc_ValueError, "Key has only public part");
-	return NULL;
-    }
-
-    if (!pkey->initialized) {
-	PyErr_SetString(PyExc_ValueError, "Key is uninitialized");
-	return NULL;
-    }
-
-    if ((digest = EVP_get_digestbyname(digest_name)) == NULL)
-    {
-        PyErr_SetString(PyExc_ValueError, "No such digest method");
-        return NULL;
-    }
-
-    if (!X509_REQ_sign(self->x509_req, pkey->pkey, digest))
-    {
-        exception_from_error_queue(crypto_Error);
-        return NULL;
-    }
-
-    Py_INCREF(Py_None);
-    return Py_None;
-}
-
-static char crypto_X509Req_verify_doc[] = "\n\
-Verifies a certificate request using the supplied public key\n\
-\n\
-@param key: a public key\n\
-@return: True if the signature is correct.\n\
-@raise OpenSSL.crypto.Error: If the signature is invalid or there is a\n\
-    problem verifying the signature.\n\
-";
-
-PyObject *
-crypto_X509Req_verify(crypto_X509ReqObj *self, PyObject *args)
-{
-    PyObject *obj;
-    crypto_PKeyObj *key;
-    int answer;
-
-    if (!PyArg_ParseTuple(args, "O!:verify", &crypto_PKey_Type, &obj)) {
-        return NULL;
-    }
-
-    key = (crypto_PKeyObj *)obj;
-
-    if ((answer = X509_REQ_verify(self->x509_req, key->pkey)) <= 0) {
-        exception_from_error_queue(crypto_Error);
-        return NULL;
-    }
-
-    return PyLong_FromLong(answer);
-}
-
-static char crypto_X509Req_add_extensions_doc[] = "\n\
-Add extensions to the request.\n\
-\n\
-@param extensions: a sequence of X509Extension objects\n\
-@return: None\n\
-";
-
-static PyObject *
-crypto_X509Req_add_extensions(crypto_X509ReqObj *self, PyObject *args)
-{
-    PyObject *extensions;
-    crypto_X509ExtensionObj *ext;
-    STACK_OF(X509_EXTENSION) *exts;
-    int nr_of_extensions, i;
-
-    if (!PyArg_ParseTuple(args, "O:add_extensions", &extensions))
-        return NULL;
-
-    if (!PySequence_Check(extensions))
-    {
-        PyErr_SetString(PyExc_TypeError, "Expected a sequence");
-        return NULL;
-    }
-
-    /* Make a STACK_OF(X509_EXTENSION) from sequence */
-    if ((exts = sk_X509_EXTENSION_new_null()) == NULL)
-    {
-        exception_from_error_queue(crypto_Error);
-        return NULL;
-    }
-
-    /* Put the extensions in a stack */
-    nr_of_extensions = PySequence_Length(extensions);
-
-    for (i = 0; i < nr_of_extensions; i++)
-    {
-        ext = (crypto_X509ExtensionObj *)PySequence_GetItem(extensions, i);
-	if (!(crypto_X509Extension_Check(ext)))
-        {
-            PyErr_SetString(PyExc_ValueError,
-                            "One of the elements is not an X509Extension");
-	    sk_X509_EXTENSION_free(exts);
-            return NULL;
-        }
-        sk_X509_EXTENSION_push(exts, ext->x509_extension);
-    }
-
-    if (!X509_REQ_add_extensions(self->x509_req, exts))
-    {
-        sk_X509_EXTENSION_free(exts);
-        exception_from_error_queue(crypto_Error);
-        return NULL;
-    }
-
-    sk_X509_EXTENSION_free(exts);
-
-    Py_INCREF(Py_None);
-    return Py_None;
-}
-
-static char crypto_X509Req_set_version_doc[] = "\n\
-Set the version subfield (RFC 2459, section 4.1.2.1) of the certificate\n\
-request.\n\
-\n\
-@param version: The version number\n\
-@return: None\n\
-";
-
-static PyObject *
-crypto_X509Req_set_version(crypto_X509ReqObj *self, PyObject *args)
-{
-    long version;
-
-    if (!PyArg_ParseTuple(args, "l:set_version", &version)) {
-        return NULL;
-    }
-
-    if (!X509_REQ_set_version(self->x509_req, version)) {
-        return NULL;
-    }
-
-    Py_INCREF(Py_None);
-    return Py_None;
-}
-
-static char crypto_X509Req_get_version_doc[] = "\n\
-Get the version subfield (RFC 2459, section 4.1.2.1) of the certificate\n\
-request.\n\
-\n\
-@return: an integer giving the value of the version subfield\n\
-";
-
-static PyObject *
-crypto_X509Req_get_version(crypto_X509ReqObj *self, PyObject *args)
-{
-    long version;
-
-    if (!PyArg_ParseTuple(args, ":get_version")) {
-        return NULL;
-    }
-
-    version = X509_REQ_get_version(self->x509_req);
-
-    return PyLong_FromLong(version);
-}
-
-/*
- * ADD_METHOD(name) expands to a correct PyMethodDef declaration
- *   {  'name', (PyCFunction)crypto_X509Req_name, METH_VARARGS }
- * for convenience
- */
-#define ADD_METHOD(name)        \
-    { #name, (PyCFunction)crypto_X509Req_##name, METH_VARARGS, crypto_X509Req_##name##_doc }
-static PyMethodDef crypto_X509Req_methods[] =
-{
-    ADD_METHOD(get_subject),
-    ADD_METHOD(get_pubkey),
-    ADD_METHOD(set_pubkey),
-    ADD_METHOD(sign),
-    ADD_METHOD(verify),
-    ADD_METHOD(add_extensions),
-    ADD_METHOD(set_version),
-    ADD_METHOD(get_version),
-    { NULL, NULL }
-};
-#undef ADD_METHOD
-
-
-/*
- * Constructor for X509Req, never called by Python code directly
- *
- * Arguments: name    - A "real" X509_REQ object
- *            dealloc - Boolean value to specify whether the destructor should
- *                      free the "real" X509_REQ object
- * Returns:   The newly created X509Req object
- */
-crypto_X509ReqObj *
-crypto_X509Req_New(X509_REQ *req, int dealloc)
-{
-    crypto_X509ReqObj *self;
-
-    self = PyObject_New(crypto_X509ReqObj, &crypto_X509Req_Type);
-
-    if (self == NULL)
-        return NULL;
-
-    self->x509_req = req;
-    self->dealloc = dealloc;
-
-    return self;
-}
-
-
-static char crypto_X509Req_doc[] = "\n\
-X509Req() -> X509Req instance\n\
-\n\
-Create a new X509Req object.\n\
-\n\
-@return: The X509Req object\n\
-";
-
-static PyObject *
-crypto_X509Req_new(PyTypeObject *subtype, PyObject *args, PyObject *kwargs) {
-    if (!PyArg_ParseTuple(args, ":X509Req")) {
-        return NULL;
-    }
-
-    return (PyObject *)crypto_X509Req_New(X509_REQ_new(), 1);
-}
-
-
-/*
- * Deallocate the memory used by the X509Req object
- *
- * Arguments: self - The X509Req object
- * Returns:   None
- */
-static void
-crypto_X509Req_dealloc(crypto_X509ReqObj *self)
-{
-    /* Sometimes we don't have to dealloc this */
-    if (self->dealloc)
-        X509_REQ_free(self->x509_req);
-
-    PyObject_Del(self);
-}
-
-
-PyTypeObject crypto_X509Req_Type = {
-    PyOpenSSL_HEAD_INIT(&PyType_Type, 0)
-    "X509Req",
-    sizeof(crypto_X509ReqObj),
-    0,
-    (destructor)crypto_X509Req_dealloc,
-    NULL, /* print */
-    NULL, /* getattr */
-    NULL, /* setattr */
-    NULL, /* compare */
-    NULL, /* repr */
-    NULL, /* as_number */
-    NULL, /* as_sequence */
-    NULL, /* as_mapping */
-    NULL, /* hash */
-    NULL, /* call */
-    NULL, /* str */
-    NULL, /* getattro */
-    NULL, /* setattro */
-    NULL, /* as_buffer */
-    Py_TPFLAGS_DEFAULT,
-    crypto_X509Req_doc, /* doc */
-    NULL, /* traverse */
-    NULL, /* clear */
-    NULL, /* tp_richcompare */
-    0, /* tp_weaklistoffset */
-    NULL, /* tp_iter */
-    NULL, /* tp_iternext */
-    crypto_X509Req_methods, /* tp_methods */
-    NULL, /* tp_members */
-    NULL, /* tp_getset */
-    NULL, /* tp_base */
-    NULL, /* tp_dict */
-    NULL, /* tp_descr_get */
-    NULL, /* tp_descr_set */
-    0, /* tp_dictoffset */
-    NULL, /* tp_init */
-    NULL, /* tp_alloc */
-    crypto_X509Req_new, /* tp_new */
-};
-
-
-/*
- * Initialize the X509Req part of the crypto module
- *
- * Arguments: module - The crypto module
- * Returns:   None
- */
-int
-init_crypto_x509req(PyObject *module)
-{
-    if (PyType_Ready(&crypto_X509Req_Type) < 0) {
-        return 0;
-    }
-
-    /* PyModule_AddObject steals a reference.
-     */
-    Py_INCREF((PyObject *)&crypto_X509Req_Type);
-    if (PyModule_AddObject(module, "X509Req", (PyObject *)&crypto_X509Req_Type) != 0) {
-        return 0;
-    }
-
-    /* PyModule_AddObject steals a reference.
-     */
-    Py_INCREF((PyObject *)&crypto_X509Req_Type);
-    if (PyModule_AddObject(module, "X509ReqType", (PyObject *)&crypto_X509Req_Type) != 0) {
-        return 0;
-    }
-
-    return 1;
-}
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/x509req.h hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/x509req.h
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/x509req.h	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/x509req.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,30 +0,0 @@
-/*
- * x509req.h
- *
- * Copyright (C) AB Strakt
- * See LICENSE for details.
- *
- * Export X509 request functions and data structures.
- * See the file RATIONALE for a short explanation of why this module was written.
- *
- */
-#ifndef PyOpenSSL_SSL_X509REQ_H_
-#define PyOpenSSL_SSL_X509REQ_H_
-
-#include <Python.h>
-#include <openssl/ssl.h>
-
-extern  int       init_crypto_x509req   (PyObject *);
-
-extern  PyTypeObject      crypto_X509Req_Type;
-
-#define crypto_X509Req_Check(v) ((v)->ob_type == &crypto_X509Req_Type)
-
-typedef struct {
-    PyObject_HEAD
-    X509_REQ            *x509_req;
-    int                  dealloc;
-} crypto_X509ReqObj;
-
-
-#endif
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/x509store.c hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/x509store.c
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/x509store.c	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/x509store.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,149 +0,0 @@
-/*
- * x509store.c
- *
- * Copyright (C) AB Strakt
- * See LICENSE for details.
- *
- * X.509 Store handling, mostly thin wrapping.
- * See the file RATIONALE for a short explanation of why this module was written.
- */
-#include <Python.h>
-#define crypto_MODULE
-#include "crypto.h"
-
-static char crypto_X509Store_add_cert_doc[] = "\n\
-Add a certificate\n\
-\n\
-@param cert: The certificate to add\n\
-@return: None\n\
-";
-
-static PyObject *
-crypto_X509Store_add_cert(crypto_X509StoreObj *self, PyObject *args)
-{
-    crypto_X509Obj *cert;
-
-    if (!PyArg_ParseTuple(args, "O!:add_cert", &crypto_X509_Type, &cert))
-        return NULL;
-
-    if (!X509_STORE_add_cert(self->x509_store, cert->x509))
-    {
-        exception_from_error_queue(crypto_Error);
-        return NULL;
-    }
-
-    Py_INCREF(Py_None);
-    return Py_None;
-}
-
-
-/*
- * ADD_METHOD(name) expands to a correct PyMethodDef declaration
- *   {  'name', (PyCFunction)crypto_X509Store_name, METH_VARARGS }
- * for convenience
- */
-#define ADD_METHOD(name)        \
-    { #name, (PyCFunction)crypto_X509Store_##name, METH_VARARGS, crypto_X509Store_##name##_doc }
-static PyMethodDef crypto_X509Store_methods[] =
-{
-    ADD_METHOD(add_cert),
-    { NULL, NULL }
-};
-#undef ADD_METHOD
-
-
-/*
- * Constructor for X509Store, never called by Python code directly
- *
- * Arguments: name    - A "real" X509_STORE object
- *            dealloc - Boolean value to specify whether the destructor should
- *                      free the "real" X509_STORE object
- * Returns:   The newly created X509Store object
- */
-crypto_X509StoreObj *
-crypto_X509Store_New(X509_STORE *store, int dealloc)
-{
-    crypto_X509StoreObj *self;
-
-    self = PyObject_New(crypto_X509StoreObj, &crypto_X509Store_Type);
-
-    if (self == NULL)
-        return NULL;
-
-    self->x509_store = store;
-    self->dealloc = dealloc;
-
-    return self;
-}
-
-/*
- * Deallocate the memory used by the X509Store object
- *
- * Arguments: self - The X509Store object
- * Returns:   None
- */
-static void
-crypto_X509Store_dealloc(crypto_X509StoreObj *self)
-{
-    /* Sometimes we don't have to dealloc this */
-    if (self->dealloc)
-        X509_STORE_free(self->x509_store);
-
-    PyObject_Del(self);
-}
-
-
-PyTypeObject crypto_X509Store_Type = {
-    PyOpenSSL_HEAD_INIT(&PyType_Type, 0)
-    "X509Store",
-    sizeof(crypto_X509StoreObj),
-    0,
-    (destructor)crypto_X509Store_dealloc,
-    NULL, /* print */
-    NULL, /* getattr */
-    NULL, /* setattr */
-    NULL, /* compare */
-    NULL, /* repr */
-    NULL, /* as_number */
-    NULL, /* as_sequence */
-    NULL, /* as_mapping */
-    NULL,  /* hash */
-    NULL, /* call */
-    NULL, /* str */
-    NULL, /* getattro */
-    NULL, /* setattro */
-    NULL, /* as_buffer */
-    Py_TPFLAGS_DEFAULT,
-    NULL, /* doc */
-    NULL, /* traverse */
-    NULL, /* clear */
-    NULL, /* tp_richcompare */
-    0, /* tp_weaklistoffset */
-    NULL, /* tp_iter */
-    NULL, /* tp_iternext */
-    crypto_X509Store_methods, /* tp_methods */
-};
-
-
-/*
- * Initialize the X509Store part of the crypto module
- *
- * Arguments: module - The crypto module
- * Returns:   None
- */
-int
-init_crypto_x509store(PyObject *module)
-{
-    if (PyType_Ready(&crypto_X509Store_Type) < 0) {
-        return 0;
-    }
-
-    /* PyModule_AddObject steals a reference.
-     */
-    Py_INCREF((PyObject *)&crypto_X509Store_Type);
-    if (PyModule_AddObject(module, "X509StoreType", (PyObject *)&crypto_X509Store_Type) != 0) {
-        return 0;
-    }
-
-    return 1;
-}
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/x509store.h hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/x509store.h
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/x509store.h	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/crypto/x509store.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,30 +0,0 @@
-/*
- * x509store.h
- *
- * Copyright (C) AB Strakt
- * See LICENSE for details.
- *
- * Export X509 store functions and data structures.
- * See the file RATIONALE for a short explanation of why this module was written.
- *
- */
-#ifndef PyOpenSSL_SSL_X509STORE_H_
-#define PyOpenSSL_SSL_X509STORE_H_
-
-#include <Python.h>
-#include <openssl/ssl.h>
-
-extern  int     init_crypto_x509store       (PyObject *);
-
-extern  PyTypeObject      crypto_X509Store_Type;
-
-#define crypto_X509Store_Check(v) ((v)->ob_type == &crypto_X509Store_Type)
-
-typedef struct {
-    PyObject_HEAD
-    X509_STORE           *x509_store;
-    int                  dealloc;
-} crypto_X509StoreObj;
-
-
-#endif
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/crypto.py hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/crypto.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/crypto.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/crypto.py	2015-04-14 04:50:11.000000000 +0200
@@ -0,0 +1,2639 @@
+from time import time
+from base64 import b16encode
+from functools import partial
+from operator import __eq__, __ne__, __lt__, __le__, __gt__, __ge__
+from warnings import warn as _warn
+
+from six import (
+    integer_types as _integer_types,
+    text_type as _text_type,
+    PY3 as _PY3)
+
+from OpenSSL._util import (
+    ffi as _ffi,
+    lib as _lib,
+    exception_from_error_queue as _exception_from_error_queue,
+    byte_string as _byte_string,
+    native as _native,
+    UNSPECIFIED as _UNSPECIFIED,
+    text_to_bytes_and_warn as _text_to_bytes_and_warn,
+)
+
+FILETYPE_PEM = _lib.SSL_FILETYPE_PEM
+FILETYPE_ASN1 = _lib.SSL_FILETYPE_ASN1
+
+# TODO This was an API mistake.  OpenSSL has no such constant.
+FILETYPE_TEXT = 2 ** 16 - 1
+
+TYPE_RSA = _lib.EVP_PKEY_RSA
+TYPE_DSA = _lib.EVP_PKEY_DSA
+
+
+
+class Error(Exception):
+    """
+    An error occurred in an `OpenSSL.crypto` API.
+    """
+
+
+_raise_current_error = partial(_exception_from_error_queue, Error)
+
+
+
+def _untested_error(where):
+    """
+    An OpenSSL API failed somehow.  Additionally, the failure which was
+    encountered isn't one that's exercised by the test suite so future behavior
+    of pyOpenSSL is now somewhat less predictable.
+    """
+    raise RuntimeError("Unknown %s failure" % (where,))
+
+
+
+def _new_mem_buf(buffer=None):
+    """
+    Allocate a new OpenSSL memory BIO.
+
+    Arrange for the garbage collector to clean it up automatically.
+
+    :param buffer: None or some bytes to use to put into the BIO so that they
+        can be read out.
+    """
+    if buffer is None:
+        bio = _lib.BIO_new(_lib.BIO_s_mem())
+        free = _lib.BIO_free
+    else:
+        data = _ffi.new("char[]", buffer)
+        bio = _lib.BIO_new_mem_buf(data, len(buffer))
+        # Keep the memory alive as long as the bio is alive!
+        def free(bio, ref=data):
+            return _lib.BIO_free(bio)
+
+    if bio == _ffi.NULL:
+        # TODO: This is untested.
+        _raise_current_error()
+
+    bio = _ffi.gc(bio, free)
+    return bio
+
+
+
+def _bio_to_string(bio):
+    """
+    Copy the contents of an OpenSSL BIO object into a Python byte string.
+    """
+    result_buffer = _ffi.new('char**')
+    buffer_length = _lib.BIO_get_mem_data(bio, result_buffer)
+    return _ffi.buffer(result_buffer[0], buffer_length)[:]
+
+
+
+def _set_asn1_time(boundary, when):
+    """
+    The the time value of an ASN1 time object.
+
+    @param boundary: An ASN1_GENERALIZEDTIME pointer (or an object safely
+        castable to that type) which will have its value set.
+    @param when: A string representation of the desired time value.
+
+    @raise TypeError: If C{when} is not a L{bytes} string.
+    @raise ValueError: If C{when} does not represent a time in the required
+        format.
+    @raise RuntimeError: If the time value cannot be set for some other
+        (unspecified) reason.
+    """
+    if not isinstance(when, bytes):
+        raise TypeError("when must be a byte string")
+
+    set_result = _lib.ASN1_GENERALIZEDTIME_set_string(
+        _ffi.cast('ASN1_GENERALIZEDTIME*', boundary), when)
+    if set_result == 0:
+        dummy = _ffi.gc(_lib.ASN1_STRING_new(), _lib.ASN1_STRING_free)
+        _lib.ASN1_STRING_set(dummy, when, len(when))
+        check_result = _lib.ASN1_GENERALIZEDTIME_check(
+            _ffi.cast('ASN1_GENERALIZEDTIME*', dummy))
+        if not check_result:
+            raise ValueError("Invalid string")
+        else:
+            _untested_error()
+
+
+
+def _get_asn1_time(timestamp):
+    """
+    Retrieve the time value of an ASN1 time object.
+
+    @param timestamp: An ASN1_GENERALIZEDTIME* (or an object safely castable to
+        that type) from which the time value will be retrieved.
+
+    @return: The time value from C{timestamp} as a L{bytes} string in a certain
+        format.  Or C{None} if the object contains no time value.
+    """
+    string_timestamp = _ffi.cast('ASN1_STRING*', timestamp)
+    if _lib.ASN1_STRING_length(string_timestamp) == 0:
+        return None
+    elif _lib.ASN1_STRING_type(string_timestamp) == _lib.V_ASN1_GENERALIZEDTIME:
+        return _ffi.string(_lib.ASN1_STRING_data(string_timestamp))
+    else:
+        generalized_timestamp = _ffi.new("ASN1_GENERALIZEDTIME**")
+        _lib.ASN1_TIME_to_generalizedtime(timestamp, generalized_timestamp)
+        if generalized_timestamp[0] == _ffi.NULL:
+            # This may happen:
+            #   - if timestamp was not an ASN1_TIME
+            #   - if allocating memory for the ASN1_GENERALIZEDTIME failed
+            #   - if a copy of the time data from timestamp cannot be made for
+            #     the newly allocated ASN1_GENERALIZEDTIME
+            #
+            # These are difficult to test.  cffi enforces the ASN1_TIME type.
+            # Memory allocation failures are a pain to trigger
+            # deterministically.
+            _untested_error("ASN1_TIME_to_generalizedtime")
+        else:
+            string_timestamp = _ffi.cast(
+                "ASN1_STRING*", generalized_timestamp[0])
+            string_data = _lib.ASN1_STRING_data(string_timestamp)
+            string_result = _ffi.string(string_data)
+            _lib.ASN1_GENERALIZEDTIME_free(generalized_timestamp[0])
+            return string_result
+
+
+
+class PKey(object):
+    _only_public = False
+    _initialized = True
+
+    def __init__(self):
+        pkey = _lib.EVP_PKEY_new()
+        self._pkey = _ffi.gc(pkey, _lib.EVP_PKEY_free)
+        self._initialized = False
+
+
+    def generate_key(self, type, bits):
+        """
+        Generate a key of a given type, with a given number of a bits
+
+        :param type: The key type (TYPE_RSA or TYPE_DSA)
+        :param bits: The number of bits
+
+        :return: None
+        """
+        if not isinstance(type, int):
+            raise TypeError("type must be an integer")
+
+        if not isinstance(bits, int):
+            raise TypeError("bits must be an integer")
+
+        # TODO Check error return
+        exponent = _lib.BN_new()
+        exponent = _ffi.gc(exponent, _lib.BN_free)
+        _lib.BN_set_word(exponent, _lib.RSA_F4)
+
+        if type == TYPE_RSA:
+            if bits <= 0:
+                raise ValueError("Invalid number of bits")
+
+            rsa = _lib.RSA_new()
+
+            result = _lib.RSA_generate_key_ex(rsa, bits, exponent, _ffi.NULL)
+            if result == 0:
+                # TODO: The test for this case is commented out.  Different
+                # builds of OpenSSL appear to have different failure modes that
+                # make it hard to test.  Visual inspection of the OpenSSL
+                # source reveals that a return value of 0 signals an error.
+                # Manual testing on a particular build of OpenSSL suggests that
+                # this is probably the appropriate way to handle those errors.
+                _raise_current_error()
+
+            result = _lib.EVP_PKEY_assign_RSA(self._pkey, rsa)
+            if not result:
+                # TODO: It appears as though this can fail if an engine is in
+                # use which does not support RSA.
+                _raise_current_error()
+
+        elif type == TYPE_DSA:
+            dsa = _lib.DSA_generate_parameters(
+                bits, _ffi.NULL, 0, _ffi.NULL, _ffi.NULL, _ffi.NULL, _ffi.NULL)
+            if dsa == _ffi.NULL:
+                # TODO: This is untested.
+                _raise_current_error()
+            if not _lib.DSA_generate_key(dsa):
+                # TODO: This is untested.
+                _raise_current_error()
+            if not _lib.EVP_PKEY_assign_DSA(self._pkey, dsa):
+                # TODO: This is untested.
+                _raise_current_error()
+        else:
+            raise Error("No such key type")
+
+        self._initialized = True
+
+
+    def check(self):
+        """
+        Check the consistency of an RSA private key.
+
+        :return: True if key is consistent.
+        :raise Error: if the key is inconsistent.
+        :raise TypeError: if the key is of a type which cannot be checked.
+            Only RSA keys can currently be checked.
+        """
+        if self._only_public:
+            raise TypeError("public key only")
+
+        if _lib.EVP_PKEY_type(self._pkey.type) != _lib.EVP_PKEY_RSA:
+            raise TypeError("key type unsupported")
+
+        rsa = _lib.EVP_PKEY_get1_RSA(self._pkey)
+        rsa = _ffi.gc(rsa, _lib.RSA_free)
+        result = _lib.RSA_check_key(rsa)
+        if result:
+            return True
+        _raise_current_error()
+
+
+    def type(self):
+        """
+        Returns the type of the key
+
+        :return: The type of the key.
+        """
+        return self._pkey.type
+
+
+    def bits(self):
+        """
+        Returns the number of bits of the key
+
+        :return: The number of bits of the key.
+        """
+        return _lib.EVP_PKEY_bits(self._pkey)
+PKeyType = PKey
+
+
+
+class _EllipticCurve(object):
+    """
+    A representation of a supported elliptic curve.
+
+    @cvar _curves: :py:obj:`None` until an attempt is made to load the curves.
+        Thereafter, a :py:type:`set` containing :py:type:`_EllipticCurve`
+        instances each of which represents one curve supported by the system.
+    @type _curves: :py:type:`NoneType` or :py:type:`set`
+    """
+    _curves = None
+
+    if _PY3:
+        # This only necessary on Python 3.  Morever, it is broken on Python 2.
+        def __ne__(self, other):
+            """
+            Implement cooperation with the right-hand side argument of ``!=``.
+
+            Python 3 seems to have dropped this cooperation in this very narrow
+            circumstance.
+            """
+            if isinstance(other, _EllipticCurve):
+                return super(_EllipticCurve, self).__ne__(other)
+            return NotImplemented
+
+
+    @classmethod
+    def _load_elliptic_curves(cls, lib):
+        """
+        Get the curves supported by OpenSSL.
+
+        :param lib: The OpenSSL library binding object.
+
+        :return: A :py:type:`set` of ``cls`` instances giving the names of the
+            elliptic curves the underlying library supports.
+        """
+        if lib.Cryptography_HAS_EC:
+            num_curves = lib.EC_get_builtin_curves(_ffi.NULL, 0)
+            builtin_curves = _ffi.new('EC_builtin_curve[]', num_curves)
+            # The return value on this call should be num_curves again.  We could
+            # check it to make sure but if it *isn't* then.. what could we do?
+            # Abort the whole process, I suppose...?  -exarkun
+            lib.EC_get_builtin_curves(builtin_curves, num_curves)
+            return set(
+                cls.from_nid(lib, c.nid)
+                for c in builtin_curves)
+        return set()
+
+
+    @classmethod
+    def _get_elliptic_curves(cls, lib):
+        """
+        Get, cache, and return the curves supported by OpenSSL.
+
+        :param lib: The OpenSSL library binding object.
+
+        :return: A :py:type:`set` of ``cls`` instances giving the names of the
+            elliptic curves the underlying library supports.
+        """
+        if cls._curves is None:
+            cls._curves = cls._load_elliptic_curves(lib)
+        return cls._curves
+
+
+    @classmethod
+    def from_nid(cls, lib, nid):
+        """
+        Instantiate a new :py:class:`_EllipticCurve` associated with the given
+        OpenSSL NID.
+
+        :param lib: The OpenSSL library binding object.
+
+        :param nid: The OpenSSL NID the resulting curve object will represent.
+            This must be a curve NID (and not, for example, a hash NID) or
+            subsequent operations will fail in unpredictable ways.
+        :type nid: :py:class:`int`
+
+        :return: The curve object.
+        """
+        return cls(lib, nid, _ffi.string(lib.OBJ_nid2sn(nid)).decode("ascii"))
+
+
+    def __init__(self, lib, nid, name):
+        """
+        :param _lib: The :py:mod:`cryptography` binding instance used to
+            interface with OpenSSL.
+
+        :param _nid: The OpenSSL NID identifying the curve this object
+            represents.
+        :type _nid: :py:class:`int`
+
+        :param name: The OpenSSL short name identifying the curve this object
+            represents.
+        :type name: :py:class:`unicode`
+        """
+        self._lib = lib
+        self._nid = nid
+        self.name = name
+
+
+    def __repr__(self):
+        return "<Curve %r>" % (self.name,)
+
+
+    def _to_EC_KEY(self):
+        """
+        Create a new OpenSSL EC_KEY structure initialized to use this curve.
+
+        The structure is automatically garbage collected when the Python object
+        is garbage collected.
+        """
+        key = self._lib.EC_KEY_new_by_curve_name(self._nid)
+        return _ffi.gc(key, _lib.EC_KEY_free)
+
+
+
+def get_elliptic_curves():
+    """
+    Return a set of objects representing the elliptic curves supported in the
+    OpenSSL build in use.
+
+    The curve objects have a :py:class:`unicode` ``name`` attribute by which
+    they identify themselves.
+
+    The curve objects are useful as values for the argument accepted by
+    :py:meth:`Context.set_tmp_ecdh` to specify which elliptical curve should be
+    used for ECDHE key exchange.
+    """
+    return _EllipticCurve._get_elliptic_curves(_lib)
+
+
+
+def get_elliptic_curve(name):
+    """
+    Return a single curve object selected by name.
+
+    See :py:func:`get_elliptic_curves` for information about curve objects.
+
+    :param name: The OpenSSL short name identifying the curve object to
+        retrieve.
+    :type name: :py:class:`unicode`
+
+    If the named curve is not supported then :py:class:`ValueError` is raised.
+    """
+    for curve in get_elliptic_curves():
+        if curve.name == name:
+            return curve
+    raise ValueError("unknown curve name", name)
+
+
+
+class X509Name(object):
+    def __init__(self, name):
+        """
+        Create a new X509Name, copying the given X509Name instance.
+
+        :param name: An X509Name object to copy
+        """
+        name = _lib.X509_NAME_dup(name._name)
+        self._name = _ffi.gc(name, _lib.X509_NAME_free)
+
+
+    def __setattr__(self, name, value):
+        if name.startswith('_'):
+            return super(X509Name, self).__setattr__(name, value)
+
+        # Note: we really do not want str subclasses here, so we do not use
+        # isinstance.
+        if type(name) is not str:
+            raise TypeError("attribute name must be string, not '%.200s'" % (
+                    type(value).__name__,))
+
+        nid = _lib.OBJ_txt2nid(_byte_string(name))
+        if nid == _lib.NID_undef:
+            try:
+                _raise_current_error()
+            except Error:
+                pass
+            raise AttributeError("No such attribute")
+
+        # If there's an old entry for this NID, remove it
+        for i in range(_lib.X509_NAME_entry_count(self._name)):
+            ent = _lib.X509_NAME_get_entry(self._name, i)
+            ent_obj = _lib.X509_NAME_ENTRY_get_object(ent)
+            ent_nid = _lib.OBJ_obj2nid(ent_obj)
+            if nid == ent_nid:
+                ent = _lib.X509_NAME_delete_entry(self._name, i)
+                _lib.X509_NAME_ENTRY_free(ent)
+                break
+
+        if isinstance(value, _text_type):
+            value = value.encode('utf-8')
+
+        add_result = _lib.X509_NAME_add_entry_by_NID(
+            self._name, nid, _lib.MBSTRING_UTF8, value, -1, -1, 0)
+        if not add_result:
+            _raise_current_error()
+
+
+    def __getattr__(self, name):
+        """
+        Find attribute. An X509Name object has the following attributes:
+        countryName (alias C), stateOrProvince (alias ST), locality (alias L),
+        organization (alias O), organizationalUnit (alias OU), commonName (alias
+        CN) and more...
+        """
+        nid = _lib.OBJ_txt2nid(_byte_string(name))
+        if nid == _lib.NID_undef:
+            # This is a bit weird.  OBJ_txt2nid indicated failure, but it seems
+            # a lower level function, a2d_ASN1_OBJECT, also feels the need to
+            # push something onto the error queue.  If we don't clean that up
+            # now, someone else will bump into it later and be quite confused.
+            # See lp#314814.
+            try:
+                _raise_current_error()
+            except Error:
+                pass
+            return super(X509Name, self).__getattr__(name)
+
+        entry_index = _lib.X509_NAME_get_index_by_NID(self._name, nid, -1)
+        if entry_index == -1:
+            return None
+
+        entry = _lib.X509_NAME_get_entry(self._name, entry_index)
+        data = _lib.X509_NAME_ENTRY_get_data(entry)
+
+        result_buffer = _ffi.new("unsigned char**")
+        data_length = _lib.ASN1_STRING_to_UTF8(result_buffer, data)
+        if data_length < 0:
+            # TODO: This is untested.
+            _raise_current_error()
+
+        try:
+            result = _ffi.buffer(result_buffer[0], data_length)[:].decode('utf-8')
+        finally:
+            # XXX untested
+            _lib.OPENSSL_free(result_buffer[0])
+        return result
+
+
+    def _cmp(op):
+        def f(self, other):
+            if not isinstance(other, X509Name):
+                return NotImplemented
+            result = _lib.X509_NAME_cmp(self._name, other._name)
+            return op(result, 0)
+        return f
+
+    __eq__ = _cmp(__eq__)
+    __ne__ = _cmp(__ne__)
+
+    __lt__ = _cmp(__lt__)
+    __le__ = _cmp(__le__)
+
+    __gt__ = _cmp(__gt__)
+    __ge__ = _cmp(__ge__)
+
+    def __repr__(self):
+        """
+        String representation of an X509Name
+        """
+        result_buffer = _ffi.new("char[]", 512);
+        format_result = _lib.X509_NAME_oneline(
+            self._name, result_buffer, len(result_buffer))
+
+        if format_result == _ffi.NULL:
+            # TODO: This is untested.
+            _raise_current_error()
+
+        return "<X509Name object '%s'>" % (
+            _native(_ffi.string(result_buffer)),)
+
+
+    def hash(self):
+        """
+        Return the hash value of this name
+
+        :return: None
+        """
+        return _lib.X509_NAME_hash(self._name)
+
+
+    def der(self):
+        """
+        Return the DER encoding of this name
+
+        :return: A :py:class:`bytes` instance giving the DER encoded form of
+            this name.
+        """
+        result_buffer = _ffi.new('unsigned char**')
+        encode_result = _lib.i2d_X509_NAME(self._name, result_buffer)
+        if encode_result < 0:
+            # TODO: This is untested.
+            _raise_current_error()
+
+        string_result = _ffi.buffer(result_buffer[0], encode_result)[:]
+        _lib.OPENSSL_free(result_buffer[0])
+        return string_result
+
+
+    def get_components(self):
+        """
+        Returns the split-up components of this name.
+
+        :return: List of tuples (name, value).
+        """
+        result = []
+        for i in range(_lib.X509_NAME_entry_count(self._name)):
+            ent = _lib.X509_NAME_get_entry(self._name, i)
+
+            fname = _lib.X509_NAME_ENTRY_get_object(ent)
+            fval = _lib.X509_NAME_ENTRY_get_data(ent)
+
+            nid = _lib.OBJ_obj2nid(fname)
+            name = _lib.OBJ_nid2sn(nid)
+
+            result.append((
+                    _ffi.string(name),
+                    _ffi.string(
+                        _lib.ASN1_STRING_data(fval),
+                        _lib.ASN1_STRING_length(fval))))
+
+        return result
+X509NameType = X509Name
+
+
+class X509Extension(object):
+    def __init__(self, type_name, critical, value, subject=None, issuer=None):
+        """
+        :param typename: The name of the extension to create.
+        :type typename: :py:data:`str`
+
+        :param critical: A flag indicating whether this is a critical extension.
+
+        :param value: The value of the extension.
+        :type value: :py:data:`str`
+
+        :param subject: Optional X509 cert to use as subject.
+        :type subject: :py:class:`X509`
+
+        :param issuer: Optional X509 cert to use as issuer.
+        :type issuer: :py:class:`X509`
+
+        :return: The X509Extension object
+        """
+        ctx = _ffi.new("X509V3_CTX*")
+
+        # A context is necessary for any extension which uses the r2i conversion
+        # method.  That is, X509V3_EXT_nconf may segfault if passed a NULL ctx.
+        # Start off by initializing most of the fields to NULL.
+        _lib.X509V3_set_ctx(ctx, _ffi.NULL, _ffi.NULL, _ffi.NULL, _ffi.NULL, 0)
+
+        # We have no configuration database - but perhaps we should (some
+        # extensions may require it).
+        _lib.X509V3_set_ctx_nodb(ctx)
+
+        # Initialize the subject and issuer, if appropriate.  ctx is a local,
+        # and as far as I can tell none of the X509V3_* APIs invoked here steal
+        # any references, so no need to mess with reference counts or duplicates.
+        if issuer is not None:
+            if not isinstance(issuer, X509):
+                raise TypeError("issuer must be an X509 instance")
+            ctx.issuer_cert = issuer._x509
+        if subject is not None:
+            if not isinstance(subject, X509):
+                raise TypeError("subject must be an X509 instance")
+            ctx.subject_cert = subject._x509
+
+        if critical:
+            # There are other OpenSSL APIs which would let us pass in critical
+            # separately, but they're harder to use, and since value is already
+            # a pile of crappy junk smuggling a ton of utterly important
+            # structured data, what's the point of trying to avoid nasty stuff
+            # with strings? (However, X509V3_EXT_i2d in particular seems like it
+            # would be a better API to invoke.  I do not know where to get the
+            # ext_struc it desires for its last parameter, though.)
+            value = b"critical," + value
+
+        extension = _lib.X509V3_EXT_nconf(_ffi.NULL, ctx, type_name, value)
+        if extension == _ffi.NULL:
+            _raise_current_error()
+        self._extension = _ffi.gc(extension, _lib.X509_EXTENSION_free)
+
+
+    @property
+    def _nid(self):
+        return _lib.OBJ_obj2nid(self._extension.object)
+
+    _prefixes = {
+        _lib.GEN_EMAIL: "email",
+        _lib.GEN_DNS: "DNS",
+        _lib.GEN_URI: "URI",
+        }
+
+    def _subjectAltNameString(self):
+        method = _lib.X509V3_EXT_get(self._extension)
+        if method == _ffi.NULL:
+            # TODO: This is untested.
+            _raise_current_error()
+        payload = self._extension.value.data
+        length = self._extension.value.length
+
+        payloadptr = _ffi.new("unsigned char**")
+        payloadptr[0] = payload
+
+        if method.it != _ffi.NULL:
+            ptr = _lib.ASN1_ITEM_ptr(method.it)
+            data = _lib.ASN1_item_d2i(_ffi.NULL, payloadptr, length, ptr)
+            names = _ffi.cast("GENERAL_NAMES*", data)
+        else:
+            names = _ffi.cast(
+                "GENERAL_NAMES*",
+                method.d2i(_ffi.NULL, payloadptr, length))
+
+        parts = []
+        for i in range(_lib.sk_GENERAL_NAME_num(names)):
+            name = _lib.sk_GENERAL_NAME_value(names, i)
+            try:
+                label = self._prefixes[name.type]
+            except KeyError:
+                bio = _new_mem_buf()
+                _lib.GENERAL_NAME_print(bio, name)
+                parts.append(_native(_bio_to_string(bio)))
+            else:
+                value = _native(
+                    _ffi.buffer(name.d.ia5.data, name.d.ia5.length)[:])
+                parts.append(label + ":" + value)
+        return ", ".join(parts)
+
+
+    def __str__(self):
+        """
+        :return: a nice text representation of the extension
+        """
+        if _lib.NID_subject_alt_name == self._nid:
+            return self._subjectAltNameString()
+
+        bio = _new_mem_buf()
+        print_result = _lib.X509V3_EXT_print(bio, self._extension, 0, 0)
+        if not print_result:
+            # TODO: This is untested.
+            _raise_current_error()
+
+        return _native(_bio_to_string(bio))
+
+
+    def get_critical(self):
+        """
+        Returns the critical field of the X509Extension
+
+        :return: The critical field.
+        """
+        return _lib.X509_EXTENSION_get_critical(self._extension)
+
+
+    def get_short_name(self):
+        """
+        Returns the short version of the type name of the X509Extension
+
+        :return: The short type name.
+        """
+        obj = _lib.X509_EXTENSION_get_object(self._extension)
+        nid = _lib.OBJ_obj2nid(obj)
+        return _ffi.string(_lib.OBJ_nid2sn(nid))
+
+
+    def get_data(self):
+        """
+        Returns the data of the X509Extension
+
+        :return: A :py:data:`str` giving the X509Extension's ASN.1 encoded data.
+        """
+        octet_result = _lib.X509_EXTENSION_get_data(self._extension)
+        string_result = _ffi.cast('ASN1_STRING*', octet_result)
+        char_result = _lib.ASN1_STRING_data(string_result)
+        result_length = _lib.ASN1_STRING_length(string_result)
+        return _ffi.buffer(char_result, result_length)[:]
+
+X509ExtensionType = X509Extension
+
+
+class X509Req(object):
+    def __init__(self):
+        req = _lib.X509_REQ_new()
+        self._req = _ffi.gc(req, _lib.X509_REQ_free)
+
+
+    def set_pubkey(self, pkey):
+        """
+        Set the public key of the certificate request
+
+        :param pkey: The public key to use
+        :return: None
+        """
+        set_result = _lib.X509_REQ_set_pubkey(self._req, pkey._pkey)
+        if not set_result:
+            # TODO: This is untested.
+            _raise_current_error()
+
+
+    def get_pubkey(self):
+        """
+        Get the public key from the certificate request
+
+        :return: The public key
+        """
+        pkey = PKey.__new__(PKey)
+        pkey._pkey = _lib.X509_REQ_get_pubkey(self._req)
+        if pkey._pkey == _ffi.NULL:
+            # TODO: This is untested.
+            _raise_current_error()
+        pkey._pkey = _ffi.gc(pkey._pkey, _lib.EVP_PKEY_free)
+        pkey._only_public = True
+        return pkey
+
+
+    def set_version(self, version):
+        """
+        Set the version subfield (RFC 2459, section 4.1.2.1) of the certificate
+        request.
+
+        :param version: The version number
+        :return: None
+        """
+        set_result = _lib.X509_REQ_set_version(self._req, version)
+        if not set_result:
+            _raise_current_error()
+
+
+    def get_version(self):
+        """
+        Get the version subfield (RFC 2459, section 4.1.2.1) of the certificate
+        request.
+
+        :return: an integer giving the value of the version subfield
+        """
+        return _lib.X509_REQ_get_version(self._req)
+
+
+    def get_subject(self):
+        """
+        Create an X509Name object for the subject of the certificate request
+
+        :return: An X509Name object
+        """
+        name = X509Name.__new__(X509Name)
+        name._name = _lib.X509_REQ_get_subject_name(self._req)
+        if name._name == _ffi.NULL:
+            # TODO: This is untested.
+            _raise_current_error()
+
+        # The name is owned by the X509Req structure.  As long as the X509Name
+        # Python object is alive, keep the X509Req Python object alive.
+        name._owner = self
+
+        return name
+
+
+    def add_extensions(self, extensions):
+        """
+        Add extensions to the request.
+
+        :param extensions: a sequence of X509Extension objects
+        :return: None
+        """
+        stack = _lib.sk_X509_EXTENSION_new_null()
+        if stack == _ffi.NULL:
+            # TODO: This is untested.
+            _raise_current_error()
+
+        stack = _ffi.gc(stack, _lib.sk_X509_EXTENSION_free)
+
+        for ext in extensions:
+            if not isinstance(ext, X509Extension):
+                raise ValueError("One of the elements is not an X509Extension")
+
+            # TODO push can fail (here and elsewhere)
+            _lib.sk_X509_EXTENSION_push(stack, ext._extension)
+
+        add_result = _lib.X509_REQ_add_extensions(self._req, stack)
+        if not add_result:
+            # TODO: This is untested.
+            _raise_current_error()
+
+
+    def get_extensions(self):
+        """
+        Get extensions to the request.
+
+        :return: A :py:class:`list` of :py:class:`X509Extension` objects.
+        """
+        exts = []
+        native_exts_obj = _lib.X509_REQ_get_extensions(self._req)
+        for i in range(_lib.sk_X509_EXTENSION_num(native_exts_obj)):
+            ext = X509Extension.__new__(X509Extension)
+            ext._extension = _lib.sk_X509_EXTENSION_value(native_exts_obj, i)
+            exts.append(ext)
+        return exts
+
+
+    def sign(self, pkey, digest):
+        """
+        Sign the certificate request using the supplied key and digest
+
+        :param pkey: The key to sign with
+        :param digest: The message digest to use
+        :return: None
+        """
+        if pkey._only_public:
+            raise ValueError("Key has only public part")
+
+        if not pkey._initialized:
+            raise ValueError("Key is uninitialized")
+
+        digest_obj = _lib.EVP_get_digestbyname(_byte_string(digest))
+        if digest_obj == _ffi.NULL:
+            raise ValueError("No such digest method")
+
+        sign_result = _lib.X509_REQ_sign(self._req, pkey._pkey, digest_obj)
+        if not sign_result:
+            # TODO: This is untested.
+            _raise_current_error()
+
+
+    def verify(self, pkey):
+        """
+        Verifies a certificate request using the supplied public key
+
+        :param key: a public key
+        :return: True if the signature is correct.
+
+        :raise OpenSSL.crypto.Error: If the signature is invalid or there is a
+            problem verifying the signature.
+        """
+        if not isinstance(pkey, PKey):
+            raise TypeError("pkey must be a PKey instance")
+
+        result = _lib.X509_REQ_verify(self._req, pkey._pkey)
+        if result <= 0:
+            _raise_current_error()
+
+        return result
+
+
+X509ReqType = X509Req
+
+
+
+class X509(object):
+    def __init__(self):
+        # TODO Allocation failure?  And why not __new__ instead of __init__?
+        x509 = _lib.X509_new()
+        self._x509 = _ffi.gc(x509, _lib.X509_free)
+
+
+    def set_version(self, version):
+        """
+        Set version number of the certificate
+
+        :param version: The version number
+        :type version: :py:class:`int`
+
+        :return: None
+        """
+        if not isinstance(version, int):
+            raise TypeError("version must be an integer")
+
+        _lib.X509_set_version(self._x509, version)
+
+
+    def get_version(self):
+        """
+        Return version number of the certificate
+
+        :return: Version number as a Python integer
+        """
+        return _lib.X509_get_version(self._x509)
+
+
+    def get_pubkey(self):
+        """
+        Get the public key of the certificate
+
+        :return: The public key
+        """
+        pkey = PKey.__new__(PKey)
+        pkey._pkey = _lib.X509_get_pubkey(self._x509)
+        if pkey._pkey == _ffi.NULL:
+            _raise_current_error()
+        pkey._pkey = _ffi.gc(pkey._pkey, _lib.EVP_PKEY_free)
+        pkey._only_public = True
+        return pkey
+
+
+    def set_pubkey(self, pkey):
+        """
+        Set the public key of the certificate
+
+        :param pkey: The public key
+
+        :return: None
+        """
+        if not isinstance(pkey, PKey):
+            raise TypeError("pkey must be a PKey instance")
+
+        set_result = _lib.X509_set_pubkey(self._x509, pkey._pkey)
+        if not set_result:
+            _raise_current_error()
+
+
+    def sign(self, pkey, digest):
+        """
+        Sign the certificate using the supplied key and digest
+
+        :param pkey: The key to sign with
+        :param digest: The message digest to use
+        :return: None
+        """
+        if not isinstance(pkey, PKey):
+            raise TypeError("pkey must be a PKey instance")
+
+        if pkey._only_public:
+            raise ValueError("Key only has public part")
+
+        if not pkey._initialized:
+            raise ValueError("Key is uninitialized")
+
+        evp_md = _lib.EVP_get_digestbyname(_byte_string(digest))
+        if evp_md == _ffi.NULL:
+            raise ValueError("No such digest method")
+
+        sign_result = _lib.X509_sign(self._x509, pkey._pkey, evp_md)
+        if not sign_result:
+            _raise_current_error()
+
+
+    def get_signature_algorithm(self):
+        """
+        Retrieve the signature algorithm used in the certificate
+
+        :return: A byte string giving the name of the signature algorithm used in
+                 the certificate.
+        :raise ValueError: If the signature algorithm is undefined.
+        """
+        alg = self._x509.cert_info.signature.algorithm
+        nid = _lib.OBJ_obj2nid(alg)
+        if nid == _lib.NID_undef:
+            raise ValueError("Undefined signature algorithm")
+        return _ffi.string(_lib.OBJ_nid2ln(nid))
+
+
+    def digest(self, digest_name):
+        """
+        Return the digest of the X509 object.
+
+        :param digest_name: The name of the digest algorithm to use.
+        :type digest_name: :py:class:`bytes`
+
+        :return: The digest of the object
+        """
+        digest = _lib.EVP_get_digestbyname(_byte_string(digest_name))
+        if digest == _ffi.NULL:
+            raise ValueError("No such digest method")
+
+        result_buffer = _ffi.new("char[]", _lib.EVP_MAX_MD_SIZE)
+        result_length = _ffi.new("unsigned int[]", 1)
+        result_length[0] = len(result_buffer)
+
+        digest_result = _lib.X509_digest(
+            self._x509, digest, result_buffer, result_length)
+
+        if not digest_result:
+            # TODO: This is untested.
+            _raise_current_error()
+
+        return b":".join([
+                b16encode(ch).upper() for ch
+                in _ffi.buffer(result_buffer, result_length[0])])
+
+
+    def subject_name_hash(self):
+        """
+        Return the hash of the X509 subject.
+
+        :return: The hash of the subject.
+        """
+        return _lib.X509_subject_name_hash(self._x509)
+
+
+    def set_serial_number(self, serial):
+        """
+        Set serial number of the certificate
+
+        :param serial: The serial number
+        :type serial: :py:class:`int`
+
+        :return: None
+        """
+        if not isinstance(serial, _integer_types):
+            raise TypeError("serial must be an integer")
+
+        hex_serial = hex(serial)[2:]
+        if not isinstance(hex_serial, bytes):
+            hex_serial = hex_serial.encode('ascii')
+
+        bignum_serial = _ffi.new("BIGNUM**")
+
+        # BN_hex2bn stores the result in &bignum.  Unless it doesn't feel like
+        # it.  If bignum is still NULL after this call, then the return value is
+        # actually the result.  I hope.  -exarkun
+        small_serial = _lib.BN_hex2bn(bignum_serial, hex_serial)
+
+        if bignum_serial[0] == _ffi.NULL:
+            set_result = _lib.ASN1_INTEGER_set(
+                _lib.X509_get_serialNumber(self._x509), small_serial)
+            if set_result:
+                # TODO Not tested
+                _raise_current_error()
+        else:
+            asn1_serial = _lib.BN_to_ASN1_INTEGER(bignum_serial[0], _ffi.NULL)
+            _lib.BN_free(bignum_serial[0])
+            if asn1_serial == _ffi.NULL:
+                # TODO Not tested
+                _raise_current_error()
+            asn1_serial = _ffi.gc(asn1_serial, _lib.ASN1_INTEGER_free)
+            set_result = _lib.X509_set_serialNumber(self._x509, asn1_serial)
+            if not set_result:
+                # TODO Not tested
+                _raise_current_error()
+
+
+    def get_serial_number(self):
+        """
+        Return serial number of the certificate
+
+        :return: Serial number as a Python integer
+        """
+        asn1_serial = _lib.X509_get_serialNumber(self._x509)
+        bignum_serial = _lib.ASN1_INTEGER_to_BN(asn1_serial, _ffi.NULL)
+        try:
+            hex_serial = _lib.BN_bn2hex(bignum_serial)
+            try:
+                hexstring_serial = _ffi.string(hex_serial)
+                serial = int(hexstring_serial, 16)
+                return serial
+            finally:
+                _lib.OPENSSL_free(hex_serial)
+        finally:
+            _lib.BN_free(bignum_serial)
+
+
+    def gmtime_adj_notAfter(self, amount):
+        """
+        Adjust the time stamp for when the certificate stops being valid
+
+        :param amount: The number of seconds by which to adjust the ending
+                       validity time.
+        :type amount: :py:class:`int`
+
+        :return: None
+        """
+        if not isinstance(amount, int):
+            raise TypeError("amount must be an integer")
+
+        notAfter = _lib.X509_get_notAfter(self._x509)
+        _lib.X509_gmtime_adj(notAfter, amount)
+
+
+    def gmtime_adj_notBefore(self, amount):
+        """
+        Change the timestamp for when the certificate starts being valid to the current
+        time plus an offset.
+
+        :param amount: The number of seconds by which to adjust the starting validity
+                       time.
+        :return: None
+        """
+        if not isinstance(amount, int):
+            raise TypeError("amount must be an integer")
+
+        notBefore = _lib.X509_get_notBefore(self._x509)
+        _lib.X509_gmtime_adj(notBefore, amount)
+
+
+    def has_expired(self):
+        """
+        Check whether the certificate has expired.
+
+        :return: True if the certificate has expired, false otherwise
+        """
+        now = int(time())
+        notAfter = _lib.X509_get_notAfter(self._x509)
+        return _lib.ASN1_UTCTIME_cmp_time_t(
+            _ffi.cast('ASN1_UTCTIME*', notAfter), now) < 0
+
+
+    def _get_boundary_time(self, which):
+        return _get_asn1_time(which(self._x509))
+
+
+    def get_notBefore(self):
+        """
+        Retrieve the time stamp for when the certificate starts being valid
+
+        :return: A string giving the timestamp, in the format::
+
+                         YYYYMMDDhhmmssZ
+                         YYYYMMDDhhmmss+hhmm
+                         YYYYMMDDhhmmss-hhmm
+
+                 or None if there is no value set.
+        """
+        return self._get_boundary_time(_lib.X509_get_notBefore)
+
+
+    def _set_boundary_time(self, which, when):
+        return _set_asn1_time(which(self._x509), when)
+
+
+    def set_notBefore(self, when):
+        """
+        Set the time stamp for when the certificate starts being valid
+
+        :param when: A string giving the timestamp, in the format:
+
+                         YYYYMMDDhhmmssZ
+                         YYYYMMDDhhmmss+hhmm
+                         YYYYMMDDhhmmss-hhmm
+        :type when: :py:class:`bytes`
+
+        :return: None
+        """
+        return self._set_boundary_time(_lib.X509_get_notBefore, when)
+
+
+    def get_notAfter(self):
+        """
+        Retrieve the time stamp for when the certificate stops being valid
+
+        :return: A string giving the timestamp, in the format::
+
+                         YYYYMMDDhhmmssZ
+                         YYYYMMDDhhmmss+hhmm
+                         YYYYMMDDhhmmss-hhmm
+
+                 or None if there is no value set.
+        """
+        return self._get_boundary_time(_lib.X509_get_notAfter)
+
+
+    def set_notAfter(self, when):
+        """
+        Set the time stamp for when the certificate stops being valid
+
+        :param when: A string giving the timestamp, in the format:
+
+                         YYYYMMDDhhmmssZ
+                         YYYYMMDDhhmmss+hhmm
+                         YYYYMMDDhhmmss-hhmm
+        :type when: :py:class:`bytes`
+
+        :return: None
+        """
+        return self._set_boundary_time(_lib.X509_get_notAfter, when)
+
+
+    def _get_name(self, which):
+        name = X509Name.__new__(X509Name)
+        name._name = which(self._x509)
+        if name._name == _ffi.NULL:
+            # TODO: This is untested.
+            _raise_current_error()
+
+        # The name is owned by the X509 structure.  As long as the X509Name
+        # Python object is alive, keep the X509 Python object alive.
+        name._owner = self
+
+        return name
+
+
+    def _set_name(self, which, name):
+        if not isinstance(name, X509Name):
+            raise TypeError("name must be an X509Name")
+        set_result = which(self._x509, name._name)
+        if not set_result:
+            # TODO: This is untested.
+            _raise_current_error()
+
+
+    def get_issuer(self):
+        """
+        Create an X509Name object for the issuer of the certificate
+
+        :return: An X509Name object
+        """
+        return self._get_name(_lib.X509_get_issuer_name)
+
+
+    def set_issuer(self, issuer):
+        """
+        Set the issuer of the certificate
+
+        :param issuer: The issuer name
+        :type issuer: :py:class:`X509Name`
+
+        :return: None
+        """
+        return self._set_name(_lib.X509_set_issuer_name, issuer)
+
+
+    def get_subject(self):
+        """
+        Create an X509Name object for the subject of the certificate
+
+        :return: An X509Name object
+        """
+        return self._get_name(_lib.X509_get_subject_name)
+
+
+    def set_subject(self, subject):
+        """
+        Set the subject of the certificate
+
+        :param subject: The subject name
+        :type subject: :py:class:`X509Name`
+        :return: None
+        """
+        return self._set_name(_lib.X509_set_subject_name, subject)
+
+
+    def get_extension_count(self):
+        """
+        Get the number of extensions on the certificate.
+
+        :return: The number of extensions as an integer.
+        """
+        return _lib.X509_get_ext_count(self._x509)
+
+
+    def add_extensions(self, extensions):
+        """
+        Add extensions to the certificate.
+
+        :param extensions: a sequence of X509Extension objects
+        :return: None
+        """
+        for ext in extensions:
+            if not isinstance(ext, X509Extension):
+                raise ValueError("One of the elements is not an X509Extension")
+
+            add_result = _lib.X509_add_ext(self._x509, ext._extension, -1)
+            if not add_result:
+                _raise_current_error()
+
+
+    def get_extension(self, index):
+        """
+        Get a specific extension of the certificate by index.
+
+        :param index: The index of the extension to retrieve.
+        :return: The X509Extension object at the specified index.
+        """
+        ext = X509Extension.__new__(X509Extension)
+        ext._extension = _lib.X509_get_ext(self._x509, index)
+        if ext._extension == _ffi.NULL:
+            raise IndexError("extension index out of bounds")
+
+        extension = _lib.X509_EXTENSION_dup(ext._extension)
+        ext._extension = _ffi.gc(extension, _lib.X509_EXTENSION_free)
+        return ext
+
+X509Type = X509
+
+
+
+class X509Store(object):
+    def __init__(self):
+        store = _lib.X509_STORE_new()
+        self._store = _ffi.gc(store, _lib.X509_STORE_free)
+
+
+    def add_cert(self, cert):
+        if not isinstance(cert, X509):
+            raise TypeError()
+
+        result = _lib.X509_STORE_add_cert(self._store, cert._x509)
+        if not result:
+            _raise_current_error()
+
+
+X509StoreType = X509Store
+
+
+class X509StoreContextError(Exception):
+    """
+    An error occurred while verifying a certificate using
+    `OpenSSL.X509StoreContext.verify_certificate`.
+
+    :ivar certificate: The certificate which caused verificate failure.
+    :type cert: :class:`X509`
+
+    """
+    def __init__(self, message, certificate):
+        super(X509StoreContextError, self).__init__(message)
+        self.certificate = certificate
+
+
+class X509StoreContext(object):
+    """
+    An X.509 store context.
+
+    An :py:class:`X509StoreContext` is used to define some of the criteria for
+    certificate verification.  The information encapsulated in this object
+    includes, but is not limited to, a set of trusted certificates,
+    verification parameters, and revoked certificates.
+
+    Of these, only the set of trusted certificates is currently exposed.
+
+    :ivar _store_ctx: The underlying X509_STORE_CTX structure used by this
+        instance.  It is dynamically allocated and automatically garbage
+        collected.
+
+    :ivar _store: See the ``store`` ``__init__`` parameter.
+
+    :ivar _cert: See the ``certificate`` ``__init__`` parameter.
+    """
+
+    def __init__(self, store, certificate):
+        """
+        :param X509Store store: The certificates which will be trusted for the
+            purposes of any verifications.
+
+        :param X509 certificate: The certificate to be verified.
+        """
+        store_ctx = _lib.X509_STORE_CTX_new()
+        self._store_ctx = _ffi.gc(store_ctx, _lib.X509_STORE_CTX_free)
+        self._store = store
+        self._cert = certificate
+        # Make the store context available for use after instantiating this
+        # class by initializing it now. Per testing, subsequent calls to
+        # :py:meth:`_init` have no adverse affect.
+        self._init()
+
+
+    def _init(self):
+        """
+        Set up the store context for a subsequent verification operation.
+        """
+        ret = _lib.X509_STORE_CTX_init(self._store_ctx, self._store._store, self._cert._x509, _ffi.NULL)
+        if ret <= 0:
+            _raise_current_error()
+
+
+    def _cleanup(self):
+        """
+        Internally cleans up the store context.
+
+        The store context can then be reused with a new call to
+        :py:meth:`_init`.
+        """
+        _lib.X509_STORE_CTX_cleanup(self._store_ctx)
+
+
+    def _exception_from_context(self):
+        """
+        Convert an OpenSSL native context error failure into a Python
+        exception.
+
+        When a call to native OpenSSL X509_verify_cert fails, additonal information
+        about the failure can be obtained from the store context.
+        """
+        errors = [
+            _lib.X509_STORE_CTX_get_error(self._store_ctx),
+            _lib.X509_STORE_CTX_get_error_depth(self._store_ctx),
+            _native(_ffi.string(_lib.X509_verify_cert_error_string(
+                        _lib.X509_STORE_CTX_get_error(self._store_ctx)))),
+        ]
+        # A context error should always be associated with a certificate, so we
+        # expect this call to never return :class:`None`.
+        _x509 = _lib.X509_STORE_CTX_get_current_cert(self._store_ctx)
+        _cert = _lib.X509_dup(_x509)
+        pycert = X509.__new__(X509)
+        pycert._x509 = _ffi.gc(_cert, _lib.X509_free)
+        return X509StoreContextError(errors, pycert)
+
+
+    def set_store(self, store):
+        """
+        Set the context's trust store.
+
+        :param X509Store store: The certificates which will be trusted for the
+            purposes of any *future* verifications.
+        """
+        self._store = store
+
+
+    def verify_certificate(self):
+        """
+        Verify a certificate in a context.
+
+        :param store_ctx: The :py:class:`X509StoreContext` to verify.
+        :raises: Error
+        """
+        # Always re-initialize the store context in case
+        # :py:meth:`verify_certificate` is called multiple times.
+        self._init()
+        ret = _lib.X509_verify_cert(self._store_ctx)
+        self._cleanup()
+        if ret <= 0:
+            raise self._exception_from_context()
+
+
+
+def load_certificate(type, buffer):
+    """
+    Load a certificate from a buffer
+
+    :param type: The file type (one of FILETYPE_PEM, FILETYPE_ASN1)
+
+    :param buffer: The buffer the certificate is stored in
+    :type buffer: :py:class:`bytes`
+
+    :return: The X509 object
+    """
+    if isinstance(buffer, _text_type):
+        buffer = buffer.encode("ascii")
+
+    bio = _new_mem_buf(buffer)
+
+    if type == FILETYPE_PEM:
+        x509 = _lib.PEM_read_bio_X509(bio, _ffi.NULL, _ffi.NULL, _ffi.NULL)
+    elif type == FILETYPE_ASN1:
+        x509 = _lib.d2i_X509_bio(bio, _ffi.NULL);
+    else:
+        raise ValueError(
+            "type argument must be FILETYPE_PEM or FILETYPE_ASN1")
+
+    if x509 == _ffi.NULL:
+        _raise_current_error()
+
+    cert = X509.__new__(X509)
+    cert._x509 = _ffi.gc(x509, _lib.X509_free)
+    return cert
+
+
+def dump_certificate(type, cert):
+    """
+    Dump a certificate to a buffer
+
+    :param type: The file type (one of FILETYPE_PEM, FILETYPE_ASN1, or
+        FILETYPE_TEXT)
+    :param cert: The certificate to dump
+    :return: The buffer with the dumped certificate in
+    """
+    bio = _new_mem_buf()
+
+    if type == FILETYPE_PEM:
+        result_code = _lib.PEM_write_bio_X509(bio, cert._x509)
+    elif type == FILETYPE_ASN1:
+        result_code = _lib.i2d_X509_bio(bio, cert._x509)
+    elif type == FILETYPE_TEXT:
+        result_code = _lib.X509_print_ex(bio, cert._x509, 0, 0)
+    else:
+        raise ValueError(
+            "type argument must be FILETYPE_PEM, FILETYPE_ASN1, or "
+            "FILETYPE_TEXT")
+
+    return _bio_to_string(bio)
+
+
+
+def dump_privatekey(type, pkey, cipher=None, passphrase=None):
+    """
+    Dump a private key to a buffer
+
+    :param type: The file type (one of FILETYPE_PEM, FILETYPE_ASN1, or
+        FILETYPE_TEXT)
+    :param pkey: The PKey to dump
+    :param cipher: (optional) if encrypted PEM format, the cipher to
+                   use
+    :param passphrase: (optional) if encrypted PEM format, this can be either
+                       the passphrase to use, or a callback for providing the
+                       passphrase.
+    :return: The buffer with the dumped key in
+    :rtype: :py:data:`str`
+    """
+    bio = _new_mem_buf()
+
+    if cipher is not None:
+        if passphrase is None:
+            raise TypeError(
+                "if a value is given for cipher "
+                "one must also be given for passphrase")
+        cipher_obj = _lib.EVP_get_cipherbyname(_byte_string(cipher))
+        if cipher_obj == _ffi.NULL:
+            raise ValueError("Invalid cipher name")
+    else:
+        cipher_obj = _ffi.NULL
+
+    helper = _PassphraseHelper(type, passphrase)
+    if type == FILETYPE_PEM:
+        result_code = _lib.PEM_write_bio_PrivateKey(
+            bio, pkey._pkey, cipher_obj, _ffi.NULL, 0,
+            helper.callback, helper.callback_args)
+        helper.raise_if_problem()
+    elif type == FILETYPE_ASN1:
+        result_code = _lib.i2d_PrivateKey_bio(bio, pkey._pkey)
+    elif type == FILETYPE_TEXT:
+        rsa = _lib.EVP_PKEY_get1_RSA(pkey._pkey)
+        result_code = _lib.RSA_print(bio, rsa, 0)
+        # TODO RSA_free(rsa)?
+    else:
+        raise ValueError(
+            "type argument must be FILETYPE_PEM, FILETYPE_ASN1, or "
+            "FILETYPE_TEXT")
+
+    if result_code == 0:
+        _raise_current_error()
+
+    return _bio_to_string(bio)
+
+
+
+def _X509_REVOKED_dup(original):
+    copy = _lib.X509_REVOKED_new()
+    if copy == _ffi.NULL:
+        # TODO: This is untested.
+        _raise_current_error()
+
+    if original.serialNumber != _ffi.NULL:
+        _lib.ASN1_INTEGER_free(copy.serialNumber)
+        copy.serialNumber = _lib.ASN1_INTEGER_dup(original.serialNumber)
+
+    if original.revocationDate != _ffi.NULL:
+        _lib.ASN1_TIME_free(copy.revocationDate)
+        copy.revocationDate = _lib.M_ASN1_TIME_dup(original.revocationDate)
+
+    if original.extensions != _ffi.NULL:
+        extension_stack = _lib.sk_X509_EXTENSION_new_null()
+        for i in range(_lib.sk_X509_EXTENSION_num(original.extensions)):
+            original_ext = _lib.sk_X509_EXTENSION_value(original.extensions, i)
+            copy_ext = _lib.X509_EXTENSION_dup(original_ext)
+            _lib.sk_X509_EXTENSION_push(extension_stack, copy_ext)
+        copy.extensions = extension_stack
+
+    copy.sequence = original.sequence
+    return copy
+
+
+
+class Revoked(object):
+    # http://www.openssl.org/docs/apps/x509v3_config.html#CRL_distribution_points_
+    # which differs from crl_reasons of crypto/x509v3/v3_enum.c that matches
+    # OCSP_crl_reason_str.  We use the latter, just like the command line
+    # program.
+    _crl_reasons = [
+        b"unspecified",
+        b"keyCompromise",
+        b"CACompromise",
+        b"affiliationChanged",
+        b"superseded",
+        b"cessationOfOperation",
+        b"certificateHold",
+        # b"removeFromCRL",
+        ]
+
+    def __init__(self):
+        revoked = _lib.X509_REVOKED_new()
+        self._revoked = _ffi.gc(revoked, _lib.X509_REVOKED_free)
+
+
+    def set_serial(self, hex_str):
+        """
+        Set the serial number of a revoked Revoked structure
+
+        :param hex_str: The new serial number.
+        :type hex_str: :py:data:`str`
+        :return: None
+        """
+        bignum_serial = _ffi.gc(_lib.BN_new(), _lib.BN_free)
+        bignum_ptr = _ffi.new("BIGNUM**")
+        bignum_ptr[0] = bignum_serial
+        bn_result = _lib.BN_hex2bn(bignum_ptr, hex_str)
+        if not bn_result:
+            raise ValueError("bad hex string")
+
+        asn1_serial = _ffi.gc(
+            _lib.BN_to_ASN1_INTEGER(bignum_serial, _ffi.NULL),
+            _lib.ASN1_INTEGER_free)
+        _lib.X509_REVOKED_set_serialNumber(self._revoked, asn1_serial)
+
+
+    def get_serial(self):
+        """
+        Return the serial number of a Revoked structure
+
+        :return: The serial number as a string
+        """
+        bio = _new_mem_buf()
+
+        result = _lib.i2a_ASN1_INTEGER(bio, self._revoked.serialNumber)
+        if result < 0:
+            # TODO: This is untested.
+            _raise_current_error()
+
+        return _bio_to_string(bio)
+
+
+    def _delete_reason(self):
+        stack = self._revoked.extensions
+        for i in range(_lib.sk_X509_EXTENSION_num(stack)):
+            ext = _lib.sk_X509_EXTENSION_value(stack, i)
+            if _lib.OBJ_obj2nid(ext.object) == _lib.NID_crl_reason:
+                _lib.X509_EXTENSION_free(ext)
+                _lib.sk_X509_EXTENSION_delete(stack, i)
+                break
+
+
+    def set_reason(self, reason):
+        """
+        Set the reason of a Revoked object.
+
+        If :py:data:`reason` is :py:data:`None`, delete the reason instead.
+
+        :param reason: The reason string.
+        :type reason: :py:class:`str` or :py:class:`NoneType`
+        :return: None
+        """
+        if reason is None:
+            self._delete_reason()
+        elif not isinstance(reason, bytes):
+            raise TypeError("reason must be None or a byte string")
+        else:
+            reason = reason.lower().replace(b' ', b'')
+            reason_code = [r.lower() for r in self._crl_reasons].index(reason)
+
+            new_reason_ext = _lib.ASN1_ENUMERATED_new()
+            if new_reason_ext == _ffi.NULL:
+                # TODO: This is untested.
+                _raise_current_error()
+            new_reason_ext = _ffi.gc(new_reason_ext, _lib.ASN1_ENUMERATED_free)
+
+            set_result = _lib.ASN1_ENUMERATED_set(new_reason_ext, reason_code)
+            if set_result == _ffi.NULL:
+                # TODO: This is untested.
+                _raise_current_error()
+
+            self._delete_reason()
+            add_result = _lib.X509_REVOKED_add1_ext_i2d(
+                self._revoked, _lib.NID_crl_reason, new_reason_ext, 0, 0)
+
+            if not add_result:
+                # TODO: This is untested.
+                _raise_current_error()
+
+
+    def get_reason(self):
+        """
+        Return the reason of a Revoked object.
+
+        :return: The reason as a string
+        """
+        extensions = self._revoked.extensions
+        for i in range(_lib.sk_X509_EXTENSION_num(extensions)):
+            ext = _lib.sk_X509_EXTENSION_value(extensions, i)
+            if _lib.OBJ_obj2nid(ext.object) == _lib.NID_crl_reason:
+                bio = _new_mem_buf()
+
+                print_result = _lib.X509V3_EXT_print(bio, ext, 0, 0)
+                if not print_result:
+                    print_result = _lib.M_ASN1_OCTET_STRING_print(bio, ext.value)
+                    if print_result == 0:
+                        # TODO: This is untested.
+                        _raise_current_error()
+
+                return _bio_to_string(bio)
+
+
+    def all_reasons(self):
+        """
+        Return a list of all the supported reason strings.
+
+        :return: A list of reason strings.
+        """
+        return self._crl_reasons[:]
+
+
+    def set_rev_date(self, when):
+        """
+        Set the revocation timestamp
+
+        :param when: A string giving the timestamp, in the format:
+
+                         YYYYMMDDhhmmssZ
+                         YYYYMMDDhhmmss+hhmm
+                         YYYYMMDDhhmmss-hhmm
+
+        :return: None
+        """
+        return _set_asn1_time(self._revoked.revocationDate, when)
+
+
+    def get_rev_date(self):
+        """
+        Retrieve the revocation date
+
+        :return: A string giving the timestamp, in the format:
+
+                         YYYYMMDDhhmmssZ
+                         YYYYMMDDhhmmss+hhmm
+                         YYYYMMDDhhmmss-hhmm
+        """
+        return _get_asn1_time(self._revoked.revocationDate)
+
+
+
+class CRL(object):
+    def __init__(self):
+        """
+        Create a new empty CRL object.
+        """
+        crl = _lib.X509_CRL_new()
+        self._crl = _ffi.gc(crl, _lib.X509_CRL_free)
+
+
+    def get_revoked(self):
+        """
+        Return revoked portion of the CRL structure (by value not reference).
+
+        :return: A tuple of Revoked objects.
+        """
+        results = []
+        revoked_stack = self._crl.crl.revoked
+        for i in range(_lib.sk_X509_REVOKED_num(revoked_stack)):
+            revoked = _lib.sk_X509_REVOKED_value(revoked_stack, i)
+            revoked_copy = _X509_REVOKED_dup(revoked)
+            pyrev = Revoked.__new__(Revoked)
+            pyrev._revoked = _ffi.gc(revoked_copy, _lib.X509_REVOKED_free)
+            results.append(pyrev)
+        if results:
+            return tuple(results)
+
+
+    def add_revoked(self, revoked):
+        """
+        Add a revoked (by value not reference) to the CRL structure
+
+        :param revoked: The new revoked.
+        :type revoked: :class:`X509`
+
+        :return: None
+        """
+        copy = _X509_REVOKED_dup(revoked._revoked)
+        if copy == _ffi.NULL:
+            # TODO: This is untested.
+            _raise_current_error()
+
+        add_result = _lib.X509_CRL_add0_revoked(self._crl, copy)
+        if add_result == 0:
+            # TODO: This is untested.
+            _raise_current_error()
+
+
+    def export(self, cert, key, type=FILETYPE_PEM, days=100,
+               digest=_UNSPECIFIED):
+        """
+        export a CRL as a string
+
+        :param cert: Used to sign CRL.
+        :type cert: :class:`X509`
+
+        :param key: Used to sign CRL.
+        :type key: :class:`PKey`
+
+        :param type: The export format, either :py:data:`FILETYPE_PEM`,
+            :py:data:`FILETYPE_ASN1`, or :py:data:`FILETYPE_TEXT`.
+
+        :param int days: The number of days until the next update of this CRL.
+
+        :param bytes digest: The name of the message digest to use (eg
+            ``b"sha1"``).
+
+        :return: :py:data:`bytes`
+        """
+        if not isinstance(cert, X509):
+            raise TypeError("cert must be an X509 instance")
+        if not isinstance(key, PKey):
+            raise TypeError("key must be a PKey instance")
+        if not isinstance(type, int):
+            raise TypeError("type must be an integer")
+
+        if digest is _UNSPECIFIED:
+            _warn(
+                "The default message digest (md5) is deprecated.  "
+                "Pass the name of a message digest explicitly.",
+                category=DeprecationWarning,
+                stacklevel=2,
+            )
+            digest = b"md5"
+
+        digest_obj = _lib.EVP_get_digestbyname(digest)
+        if digest_obj == _ffi.NULL:
+            raise ValueError("No such digest method")
+
+        bio = _lib.BIO_new(_lib.BIO_s_mem())
+        if bio == _ffi.NULL:
+            # TODO: This is untested.
+            _raise_current_error()
+
+        # A scratch time object to give different values to different CRL fields
+        sometime = _lib.ASN1_TIME_new()
+        if sometime == _ffi.NULL:
+            # TODO: This is untested.
+            _raise_current_error()
+
+        _lib.X509_gmtime_adj(sometime, 0)
+        _lib.X509_CRL_set_lastUpdate(self._crl, sometime)
+
+        _lib.X509_gmtime_adj(sometime, days * 24 * 60 * 60)
+        _lib.X509_CRL_set_nextUpdate(self._crl, sometime)
+
+        _lib.X509_CRL_set_issuer_name(self._crl, _lib.X509_get_subject_name(cert._x509))
+
+        sign_result = _lib.X509_CRL_sign(self._crl, key._pkey, digest_obj)
+        if not sign_result:
+            _raise_current_error()
+
+        if type == FILETYPE_PEM:
+            ret = _lib.PEM_write_bio_X509_CRL(bio, self._crl)
+        elif type == FILETYPE_ASN1:
+            ret = _lib.i2d_X509_CRL_bio(bio, self._crl)
+        elif type == FILETYPE_TEXT:
+            ret = _lib.X509_CRL_print(bio, self._crl)
+        else:
+            raise ValueError(
+                "type argument must be FILETYPE_PEM, FILETYPE_ASN1, or FILETYPE_TEXT")
+
+        if not ret:
+            # TODO: This is untested.
+            _raise_current_error()
+
+        return _bio_to_string(bio)
+CRLType = CRL
+
+
+
+class PKCS7(object):
+    def type_is_signed(self):
+        """
+        Check if this NID_pkcs7_signed object
+
+        :return: True if the PKCS7 is of type signed
+        """
+        if _lib.PKCS7_type_is_signed(self._pkcs7):
+            return True
+        return False
+
+
+    def type_is_enveloped(self):
+        """
+        Check if this NID_pkcs7_enveloped object
+
+        :returns: True if the PKCS7 is of type enveloped
+        """
+        if _lib.PKCS7_type_is_enveloped(self._pkcs7):
+            return True
+        return False
+
+
+    def type_is_signedAndEnveloped(self):
+        """
+        Check if this NID_pkcs7_signedAndEnveloped object
+
+        :returns: True if the PKCS7 is of type signedAndEnveloped
+        """
+        if _lib.PKCS7_type_is_signedAndEnveloped(self._pkcs7):
+            return True
+        return False
+
+
+    def type_is_data(self):
+        """
+        Check if this NID_pkcs7_data object
+
+        :return: True if the PKCS7 is of type data
+        """
+        if _lib.PKCS7_type_is_data(self._pkcs7):
+            return True
+        return False
+
+
+    def get_type_name(self):
+        """
+        Returns the type name of the PKCS7 structure
+
+        :return: A string with the typename
+        """
+        nid = _lib.OBJ_obj2nid(self._pkcs7.type)
+        string_type = _lib.OBJ_nid2sn(nid)
+        return _ffi.string(string_type)
+
+PKCS7Type = PKCS7
+
+
+
+class PKCS12(object):
+    def __init__(self):
+        self._pkey = None
+        self._cert = None
+        self._cacerts = None
+        self._friendlyname = None
+
+
+    def get_certificate(self):
+        """
+        Return certificate portion of the PKCS12 structure
+
+        :return: X509 object containing the certificate
+        """
+        return self._cert
+
+
+    def set_certificate(self, cert):
+        """
+        Replace the certificate portion of the PKCS12 structure
+
+        :param cert: The new certificate.
+        :type cert: :py:class:`X509` or :py:data:`None`
+        :return: None
+        """
+        if not isinstance(cert, X509):
+            raise TypeError("cert must be an X509 instance")
+        self._cert = cert
+
+
+    def get_privatekey(self):
+        """
+        Return private key portion of the PKCS12 structure
+
+        :returns: PKey object containing the private key
+        """
+        return self._pkey
+
+
+    def set_privatekey(self, pkey):
+        """
+        Replace or set the certificate portion of the PKCS12 structure
+
+        :param pkey: The new private key.
+        :type pkey: :py:class:`PKey`
+        :return: None
+        """
+        if not isinstance(pkey, PKey):
+            raise TypeError("pkey must be a PKey instance")
+        self._pkey = pkey
+
+
+    def get_ca_certificates(self):
+        """
+        Return CA certificates within of the PKCS12 object
+
+        :return: A newly created tuple containing the CA certificates in the chain,
+                 if any are present, or None if no CA certificates are present.
+        """
+        if self._cacerts is not None:
+            return tuple(self._cacerts)
+
+
+    def set_ca_certificates(self, cacerts):
+        """
+        Replace or set the CA certificates within the PKCS12 object.
+
+        :param cacerts: The new CA certificates.
+        :type cacerts: :py:data:`None` or an iterable of :py:class:`X509`
+        :return: None
+        """
+        if cacerts is None:
+            self._cacerts = None
+        else:
+            cacerts = list(cacerts)
+            for cert in cacerts:
+                if not isinstance(cert, X509):
+                    raise TypeError("iterable must only contain X509 instances")
+            self._cacerts = cacerts
+
+
+    def set_friendlyname(self, name):
+        """
+        Replace or set the certificate portion of the PKCS12 structure
+
+        :param name: The new friendly name.
+        :type name: :py:class:`bytes`
+        :return: None
+        """
+        if name is None:
+            self._friendlyname = None
+        elif not isinstance(name, bytes):
+            raise TypeError("name must be a byte string or None (not %r)" % (name,))
+        self._friendlyname = name
+
+
+    def get_friendlyname(self):
+        """
+        Return friendly name portion of the PKCS12 structure
+
+        :returns: String containing the friendlyname
+        """
+        return self._friendlyname
+
+
+    def export(self, passphrase=None, iter=2048, maciter=1):
+        """
+        Dump a PKCS12 object as a string.  See also "man PKCS12_create".
+
+        :param passphrase: used to encrypt the PKCS12
+        :type passphrase: :py:data:`bytes`
+
+        :param iter: How many times to repeat the encryption
+        :type iter: :py:data:`int`
+
+        :param maciter: How many times to repeat the MAC
+        :type maciter: :py:data:`int`
+
+        :return: The string containing the PKCS12
+        """
+        passphrase = _text_to_bytes_and_warn("passphrase", passphrase)
+
+        if self._cacerts is None:
+            cacerts = _ffi.NULL
+        else:
+            cacerts = _lib.sk_X509_new_null()
+            cacerts = _ffi.gc(cacerts, _lib.sk_X509_free)
+            for cert in self._cacerts:
+                _lib.sk_X509_push(cacerts, cert._x509)
+
+        if passphrase is None:
+            passphrase = _ffi.NULL
+
+        friendlyname = self._friendlyname
+        if friendlyname is None:
+            friendlyname = _ffi.NULL
+
+        if self._pkey is None:
+            pkey = _ffi.NULL
+        else:
+            pkey = self._pkey._pkey
+
+        if self._cert is None:
+            cert = _ffi.NULL
+        else:
+            cert = self._cert._x509
+
+        pkcs12 = _lib.PKCS12_create(
+            passphrase, friendlyname, pkey, cert, cacerts,
+            _lib.NID_pbe_WithSHA1And3_Key_TripleDES_CBC,
+            _lib.NID_pbe_WithSHA1And3_Key_TripleDES_CBC,
+            iter, maciter, 0)
+        if pkcs12 == _ffi.NULL:
+            _raise_current_error()
+        pkcs12 = _ffi.gc(pkcs12, _lib.PKCS12_free)
+
+        bio = _new_mem_buf()
+        _lib.i2d_PKCS12_bio(bio, pkcs12)
+        return _bio_to_string(bio)
+
+PKCS12Type = PKCS12
+
+
+
+class NetscapeSPKI(object):
+    def __init__(self):
+        spki = _lib.NETSCAPE_SPKI_new()
+        self._spki = _ffi.gc(spki, _lib.NETSCAPE_SPKI_free)
+
+
+    def sign(self, pkey, digest):
+        """
+        Sign the certificate request using the supplied key and digest
+
+        :param pkey: The key to sign with
+        :param digest: The message digest to use
+        :return: None
+        """
+        if pkey._only_public:
+            raise ValueError("Key has only public part")
+
+        if not pkey._initialized:
+            raise ValueError("Key is uninitialized")
+
+        digest_obj = _lib.EVP_get_digestbyname(_byte_string(digest))
+        if digest_obj == _ffi.NULL:
+            raise ValueError("No such digest method")
+
+        sign_result = _lib.NETSCAPE_SPKI_sign(self._spki, pkey._pkey, digest_obj)
+        if not sign_result:
+            # TODO: This is untested.
+            _raise_current_error()
+
+
+    def verify(self, key):
+        """
+        Verifies a certificate request using the supplied public key
+
+        :param key: a public key
+        :return: True if the signature is correct.
+        :raise OpenSSL.crypto.Error: If the signature is invalid or there is a
+            problem verifying the signature.
+        """
+        answer = _lib.NETSCAPE_SPKI_verify(self._spki, key._pkey)
+        if answer <= 0:
+            _raise_current_error()
+        return True
+
+
+    def b64_encode(self):
+        """
+        Generate a base64 encoded string from an SPKI
+
+        :return: The base64 encoded string
+        """
+        encoded = _lib.NETSCAPE_SPKI_b64_encode(self._spki)
+        result = _ffi.string(encoded)
+        _lib.CRYPTO_free(encoded)
+        return result
+
+
+    def get_pubkey(self):
+        """
+        Get the public key of the certificate
+
+        :return: The public key
+        """
+        pkey = PKey.__new__(PKey)
+        pkey._pkey = _lib.NETSCAPE_SPKI_get_pubkey(self._spki)
+        if pkey._pkey == _ffi.NULL:
+            # TODO: This is untested.
+            _raise_current_error()
+        pkey._pkey = _ffi.gc(pkey._pkey, _lib.EVP_PKEY_free)
+        pkey._only_public = True
+        return pkey
+
+
+    def set_pubkey(self, pkey):
+        """
+        Set the public key of the certificate
+
+        :param pkey: The public key
+        :return: None
+        """
+        set_result = _lib.NETSCAPE_SPKI_set_pubkey(self._spki, pkey._pkey)
+        if not set_result:
+            # TODO: This is untested.
+            _raise_current_error()
+NetscapeSPKIType = NetscapeSPKI
+
+
+class _PassphraseHelper(object):
+    def __init__(self, type, passphrase, more_args=False, truncate=False):
+        if type != FILETYPE_PEM and passphrase is not None:
+            raise ValueError("only FILETYPE_PEM key format supports encryption")
+        self._passphrase = passphrase
+        self._more_args = more_args
+        self._truncate = truncate
+        self._problems = []
+
+
+    @property
+    def callback(self):
+        if self._passphrase is None:
+            return _ffi.NULL
+        elif isinstance(self._passphrase, bytes):
+            return _ffi.NULL
+        elif callable(self._passphrase):
+            return _ffi.callback("pem_password_cb", self._read_passphrase)
+        else:
+            raise TypeError("Last argument must be string or callable")
+
+
+    @property
+    def callback_args(self):
+        if self._passphrase is None:
+            return _ffi.NULL
+        elif isinstance(self._passphrase, bytes):
+            return self._passphrase
+        elif callable(self._passphrase):
+            return _ffi.NULL
+        else:
+            raise TypeError("Last argument must be string or callable")
+
+
+    def raise_if_problem(self, exceptionType=Error):
+        try:
+            _exception_from_error_queue(exceptionType)
+        except exceptionType as e:
+            from_queue = e
+        if self._problems:
+            raise self._problems[0]
+        return from_queue
+
+
+    def _read_passphrase(self, buf, size, rwflag, userdata):
+        try:
+            if self._more_args:
+                result = self._passphrase(size, rwflag, userdata)
+            else:
+                result = self._passphrase(rwflag)
+            if not isinstance(result, bytes):
+                raise ValueError("String expected")
+            if len(result) > size:
+                if self._truncate:
+                    result = result[:size]
+                else:
+                    raise ValueError("passphrase returned by callback is too long")
+            for i in range(len(result)):
+                buf[i] = result[i:i + 1]
+            return len(result)
+        except Exception as e:
+            self._problems.append(e)
+            return 0
+
+
+
+def load_privatekey(type, buffer, passphrase=None):
+    """
+    Load a private key from a buffer
+
+    :param type: The file type (one of FILETYPE_PEM, FILETYPE_ASN1)
+    :param buffer: The buffer the key is stored in
+    :param passphrase: (optional) if encrypted PEM format, this can be
+                       either the passphrase to use, or a callback for
+                       providing the passphrase.
+
+    :return: The PKey object
+    """
+    if isinstance(buffer, _text_type):
+        buffer = buffer.encode("ascii")
+
+    bio = _new_mem_buf(buffer)
+
+    helper = _PassphraseHelper(type, passphrase)
+    if type == FILETYPE_PEM:
+        evp_pkey = _lib.PEM_read_bio_PrivateKey(
+            bio, _ffi.NULL, helper.callback, helper.callback_args)
+        helper.raise_if_problem()
+    elif type == FILETYPE_ASN1:
+        evp_pkey = _lib.d2i_PrivateKey_bio(bio, _ffi.NULL)
+    else:
+        raise ValueError("type argument must be FILETYPE_PEM or FILETYPE_ASN1")
+
+    if evp_pkey == _ffi.NULL:
+        _raise_current_error()
+
+    pkey = PKey.__new__(PKey)
+    pkey._pkey = _ffi.gc(evp_pkey, _lib.EVP_PKEY_free)
+    return pkey
+
+
+
+def dump_certificate_request(type, req):
+    """
+    Dump a certificate request to a buffer
+
+    :param type: The file type (one of FILETYPE_PEM, FILETYPE_ASN1)
+    :param req: The certificate request to dump
+    :return: The buffer with the dumped certificate request in
+    """
+    bio = _new_mem_buf()
+
+    if type == FILETYPE_PEM:
+        result_code = _lib.PEM_write_bio_X509_REQ(bio, req._req)
+    elif type == FILETYPE_ASN1:
+        result_code = _lib.i2d_X509_REQ_bio(bio, req._req)
+    elif type == FILETYPE_TEXT:
+        result_code = _lib.X509_REQ_print_ex(bio, req._req, 0, 0)
+    else:
+        raise ValueError("type argument must be FILETYPE_PEM, FILETYPE_ASN1, or FILETYPE_TEXT")
+
+    if result_code == 0:
+        # TODO: This is untested.
+        _raise_current_error()
+
+    return _bio_to_string(bio)
+
+
+
+def load_certificate_request(type, buffer):
+    """
+    Load a certificate request from a buffer
+
+    :param type: The file type (one of FILETYPE_PEM, FILETYPE_ASN1)
+    :param buffer: The buffer the certificate request is stored in
+    :return: The X509Req object
+    """
+    if isinstance(buffer, _text_type):
+        buffer = buffer.encode("ascii")
+
+    bio = _new_mem_buf(buffer)
+
+    if type == FILETYPE_PEM:
+        req = _lib.PEM_read_bio_X509_REQ(bio, _ffi.NULL, _ffi.NULL, _ffi.NULL)
+    elif type == FILETYPE_ASN1:
+        req = _lib.d2i_X509_REQ_bio(bio, _ffi.NULL)
+    else:
+        raise ValueError("type argument must be FILETYPE_PEM or FILETYPE_ASN1")
+
+    if req == _ffi.NULL:
+        # TODO: This is untested.
+        _raise_current_error()
+
+    x509req = X509Req.__new__(X509Req)
+    x509req._req = _ffi.gc(req, _lib.X509_REQ_free)
+    return x509req
+
+
+
+def sign(pkey, data, digest):
+    """
+    Sign data with a digest
+
+    :param pkey: Pkey to sign with
+    :param data: data to be signed
+    :param digest: message digest to use
+    :return: signature
+    """
+    data = _text_to_bytes_and_warn("data", data)
+
+    digest_obj = _lib.EVP_get_digestbyname(_byte_string(digest))
+    if digest_obj == _ffi.NULL:
+        raise ValueError("No such digest method")
+
+    md_ctx = _ffi.new("EVP_MD_CTX*")
+    md_ctx = _ffi.gc(md_ctx, _lib.EVP_MD_CTX_cleanup)
+
+    _lib.EVP_SignInit(md_ctx, digest_obj)
+    _lib.EVP_SignUpdate(md_ctx, data, len(data))
+
+    signature_buffer = _ffi.new("unsigned char[]", 512)
+    signature_length = _ffi.new("unsigned int*")
+    signature_length[0] = len(signature_buffer)
+    final_result = _lib.EVP_SignFinal(
+        md_ctx, signature_buffer, signature_length, pkey._pkey)
+
+    if final_result != 1:
+        # TODO: This is untested.
+        _raise_current_error()
+
+    return _ffi.buffer(signature_buffer, signature_length[0])[:]
+
+
+
+def verify(cert, signature, data, digest):
+    """
+    Verify a signature
+
+    :param cert: signing certificate (X509 object)
+    :param signature: signature returned by sign function
+    :param data: data to be verified
+    :param digest: message digest to use
+    :return: None if the signature is correct, raise exception otherwise
+    """
+    data = _text_to_bytes_and_warn("data", data)
+
+    digest_obj = _lib.EVP_get_digestbyname(_byte_string(digest))
+    if digest_obj == _ffi.NULL:
+        raise ValueError("No such digest method")
+
+    pkey = _lib.X509_get_pubkey(cert._x509)
+    if pkey == _ffi.NULL:
+        # TODO: This is untested.
+        _raise_current_error()
+    pkey = _ffi.gc(pkey, _lib.EVP_PKEY_free)
+
+    md_ctx = _ffi.new("EVP_MD_CTX*")
+    md_ctx = _ffi.gc(md_ctx, _lib.EVP_MD_CTX_cleanup)
+
+    _lib.EVP_VerifyInit(md_ctx, digest_obj)
+    _lib.EVP_VerifyUpdate(md_ctx, data, len(data))
+    verify_result = _lib.EVP_VerifyFinal(md_ctx, signature, len(signature), pkey)
+
+    if verify_result != 1:
+        _raise_current_error()
+
+
+def load_crl(type, buffer):
+    """
+    Load a certificate revocation list from a buffer
+
+    :param type: The file type (one of FILETYPE_PEM, FILETYPE_ASN1)
+    :param buffer: The buffer the CRL is stored in
+
+    :return: The PKey object
+    """
+    if isinstance(buffer, _text_type):
+        buffer = buffer.encode("ascii")
+
+    bio = _new_mem_buf(buffer)
+
+    if type == FILETYPE_PEM:
+        crl = _lib.PEM_read_bio_X509_CRL(bio, _ffi.NULL, _ffi.NULL, _ffi.NULL)
+    elif type == FILETYPE_ASN1:
+        crl = _lib.d2i_X509_CRL_bio(bio, _ffi.NULL)
+    else:
+        raise ValueError("type argument must be FILETYPE_PEM or FILETYPE_ASN1")
+
+    if crl == _ffi.NULL:
+        _raise_current_error()
+
+    result = CRL.__new__(CRL)
+    result._crl = crl
+    return result
+
+
+
+def load_pkcs7_data(type, buffer):
+    """
+    Load pkcs7 data from a buffer
+
+    :param type: The file type (one of FILETYPE_PEM or FILETYPE_ASN1)
+    :param buffer: The buffer with the pkcs7 data.
+    :return: The PKCS7 object
+    """
+    if isinstance(buffer, _text_type):
+        buffer = buffer.encode("ascii")
+
+    bio = _new_mem_buf(buffer)
+
+    if type == FILETYPE_PEM:
+        pkcs7 = _lib.PEM_read_bio_PKCS7(bio, _ffi.NULL, _ffi.NULL, _ffi.NULL)
+    elif type == FILETYPE_ASN1:
+        pkcs7 = _lib.d2i_PKCS7_bio(bio, _ffi.NULL)
+    else:
+        # TODO: This is untested.
+        _raise_current_error()
+        raise ValueError("type argument must be FILETYPE_PEM or FILETYPE_ASN1")
+
+    if pkcs7 == _ffi.NULL:
+        _raise_current_error()
+
+    pypkcs7 = PKCS7.__new__(PKCS7)
+    pypkcs7._pkcs7 = _ffi.gc(pkcs7, _lib.PKCS7_free)
+    return pypkcs7
+
+
+
+def load_pkcs12(buffer, passphrase=None):
+    """
+    Load a PKCS12 object from a buffer
+
+    :param buffer: The buffer the certificate is stored in
+    :param passphrase: (Optional) The password to decrypt the PKCS12 lump
+    :returns: The PKCS12 object
+    """
+    passphrase = _text_to_bytes_and_warn("passphrase", passphrase)
+
+    if isinstance(buffer, _text_type):
+        buffer = buffer.encode("ascii")
+
+    bio = _new_mem_buf(buffer)
+
+    # Use null passphrase if passphrase is None or empty string. With PKCS#12
+    # password based encryption no password and a zero length password are two
+    # different things, but OpenSSL implementation will try both to figure out
+    # which one works.
+    if not passphrase:
+        passphrase = _ffi.NULL
+
+    p12 = _lib.d2i_PKCS12_bio(bio, _ffi.NULL)
+    if p12 == _ffi.NULL:
+        _raise_current_error()
+    p12 = _ffi.gc(p12, _lib.PKCS12_free)
+
+    pkey = _ffi.new("EVP_PKEY**")
+    cert = _ffi.new("X509**")
+    cacerts = _ffi.new("Cryptography_STACK_OF_X509**")
+
+    parse_result = _lib.PKCS12_parse(p12, passphrase, pkey, cert, cacerts)
+    if not parse_result:
+        _raise_current_error()
+
+    cacerts = _ffi.gc(cacerts[0], _lib.sk_X509_free)
+
+    # openssl 1.0.0 sometimes leaves an X509_check_private_key error in the
+    # queue for no particular reason.  This error isn't interesting to anyone
+    # outside this function.  It's not even interesting to us.  Get rid of it.
+    try:
+        _raise_current_error()
+    except Error:
+        pass
+
+    if pkey[0] == _ffi.NULL:
+        pykey = None
+    else:
+        pykey = PKey.__new__(PKey)
+        pykey._pkey = _ffi.gc(pkey[0], _lib.EVP_PKEY_free)
+
+    if cert[0] == _ffi.NULL:
+        pycert = None
+        friendlyname = None
+    else:
+        pycert = X509.__new__(X509)
+        pycert._x509 = _ffi.gc(cert[0], _lib.X509_free)
+
+        friendlyname_length = _ffi.new("int*")
+        friendlyname_buffer = _lib.X509_alias_get0(cert[0], friendlyname_length)
+        friendlyname = _ffi.buffer(friendlyname_buffer, friendlyname_length[0])[:]
+        if friendlyname_buffer == _ffi.NULL:
+            friendlyname = None
+
+    pycacerts = []
+    for i in range(_lib.sk_X509_num(cacerts)):
+        pycacert = X509.__new__(X509)
+        pycacert._x509 = _lib.sk_X509_value(cacerts, i)
+        pycacerts.append(pycacert)
+    if not pycacerts:
+        pycacerts = None
+
+    pkcs12 = PKCS12.__new__(PKCS12)
+    pkcs12._pkey = pykey
+    pkcs12._cert = pycert
+    pkcs12._cacerts = pycacerts
+    pkcs12._friendlyname = friendlyname
+    return pkcs12
+
+
+def _initialize_openssl_threads(get_ident, Lock):
+    import _ssl
+    return
+
+    locks = list(Lock() for n in range(_lib.CRYPTO_num_locks()))
+
+    def locking_function(mode, index, filename, line):
+        if mode & _lib.CRYPTO_LOCK:
+            locks[index].acquire()
+        else:
+            locks[index].release()
+
+    _lib.CRYPTO_set_id_callback(
+        _ffi.callback("unsigned long (*)(void)", get_ident))
+
+    _lib.CRYPTO_set_locking_callback(
+        _ffi.callback(
+            "void (*)(int, int, const char*, int)", locking_function))
+
+
+try:
+    from thread import get_ident
+    from threading import Lock
+except ImportError:
+    pass
+else:
+    _initialize_openssl_threads(get_ident, Lock)
+    del get_ident, Lock
+
+# There are no direct unit tests for this initialization.  It is tested
+# indirectly since it is necessary for functions like dump_privatekey when
+# using encryption.
+#
+# Thus OpenSSL.test.test_crypto.FunctionTests.test_dump_privatekey_passphrase
+# and some other similar tests may fail without this (though they may not if
+# the Python runtime has already done some initialization of the underlying
+# OpenSSL library (and is linked against the same one that cryptography is
+# using)).
+_lib.OpenSSL_add_all_algorithms()
+
+# This is similar but exercised mainly by exception_from_error_queue.  It calls
+# both ERR_load_crypto_strings() and ERR_load_SSL_strings().
+_lib.SSL_load_error_strings()
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/__init__.py hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/__init__.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/__init__.py	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/__init__.py	2014-02-02 16:24:09.000000000 +0100
@@ -5,40 +5,7 @@
 pyOpenSSL - A simple wrapper around the OpenSSL library
 """
 
-import sys
-
-try:
-    orig = sys.getdlopenflags()
-except AttributeError:
-    from OpenSSL import crypto
-else:
-    try:
-        import DLFCN
-    except ImportError:
-        try:
-            import dl
-        except ImportError:
-            try:
-                import ctypes
-            except ImportError:
-                flags = 2 | 256
-            else:
-                flags = 2 | ctypes.RTLD_GLOBAL
-                del ctypes
-        else:
-            flags = dl.RTLD_NOW | dl.RTLD_GLOBAL
-            del dl
-    else:
-        flags = DLFCN.RTLD_NOW | DLFCN.RTLD_GLOBAL
-        del DLFCN
-
-    sys.setdlopenflags(flags)
-    from OpenSSL import crypto
-    sys.setdlopenflags(orig)
-    del orig, flags
-del sys
-
-from OpenSSL import rand, SSL
+from OpenSSL import rand, crypto, SSL
 from OpenSSL.version import __version__
 
 __all__ = [
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/py3k.h hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/py3k.h
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/py3k.h	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/py3k.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,55 +0,0 @@
-#ifndef PyOpenSSL_PY3K_H_
-#define PyOpenSSL_PY3K_H_
-
-#if (PY_VERSION_HEX >= 0x03000000)
-
-#define PY3
-
-#define PyOpenSSL_MODINIT(name) \
-PyMODINIT_FUNC \
-PyInit_##name(void)
-
-#define PyText_CheckExact PyUnicode_CheckExact
-#define PyText_FromString PyUnicode_FromString
-#define PyText_FromStringAndSize PyUnicode_FromStringAndSize
-
-#define PyOpenSSL_HEAD_INIT(type, size) PyVarObject_HEAD_INIT(NULL, size)
-
-#define PyOpenSSL_Integer_Check(o) PyLong_Check(o)
-
-#define PyOpenSSL_MODRETURN(module) { return module; }
-
-#define BYTESTRING_FMT "y"
-
-#else /* (PY_VERSION_HEX >= 0x03000000) */
-
-#define PyOpenSSL_MODRETURN(module) { return; }
-
-#define PyOpenSSL_HEAD_INIT(type, size) PyObject_HEAD_INIT(NULL) 0,
-
-#define PyBytes_FromStringAndSize PyString_FromStringAndSize
-
-#define PyOpenSSL_Integer_Check(o) (PyInt_Check(o) || PyLong_Check(o))
-
-#define PyBytes_Size PyString_Size
-#define PyBytes_Check PyString_Check
-#define PyBytes_CheckExact PyString_CheckExact
-#define PyBytes_AsString PyString_AsString
-#define PyBytes_FromString PyString_FromString
-#define PyBytes_FromStringAndSize PyString_FromStringAndSize
-#define _PyBytes_Resize _PyString_Resize
-
-#define PyText_CheckExact PyString_CheckExact
-#define PyText_FromString PyString_FromString
-#define PyText_FromStringAndSize PyString_FromStringAndSize
-
-#define PyOpenSSL_MODINIT(name) \
-void \
-init##name(void)
-
-#define BYTESTRING_FMT "s"
-
-#endif /* (PY_VERSION_HEX >= 0x03000000) */
-
-#endif /* PyOpenSSL_PY3K_H_ */
-
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/pymemcompat.h hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/pymemcompat.h
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/pymemcompat.h	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/pymemcompat.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,86 +0,0 @@
-/* The idea of this file is that you bundle it with your extension,
-   #include it, program to Python 2.3's memory API and have your
-   extension build with any version of Python from 1.5.2 through to
-   2.3 (and hopefully beyond). */
-
-#ifndef Py_PYMEMCOMPAT_H
-#define Py_PYMEMCOMPAT_H
-
-#include "Python.h"
-
-/* There are three "families" of memory API: the "raw memory", "object
-   memory" and "object" families.  (This is ignoring the matter of the
-   cycle collector, about which more is said below).
-
-   Raw Memory:
-
-       PyMem_Malloc, PyMem_Realloc, PyMem_Free
-
-   Object Memory:
-
-       PyObject_Malloc, PyObject_Realloc, PyObject_Free
-
-   Object:
-
-       PyObject_New, PyObject_NewVar, PyObject_Del
-
-   The raw memory and object memory allocators both mimic the
-   malloc/realloc/free interface from ANSI C, but the object memory
-   allocator can (and, since 2.3, does by default) use a different
-   allocation strategy biased towards lots of lots of "small"
-   allocations.
-
-   The object family is used for allocating Python objects, and the
-   initializers take care of some basic initialization (setting the
-   refcount to 1 and filling out the ob_type field) as well as having
-   a somewhat different interface.
-
-   Do not mix the families!  E.g. do not allocate memory with
-   PyMem_Malloc and free it with PyObject_Free.  You may get away with
-   it quite a lot of the time, but there *are* scenarios where this
-   will break.  You Have Been Warned. 
-
-   Also, in many versions of Python there are an insane amount of
-   memory interfaces to choose from.  Use the ones described above. */
-
-#if PY_VERSION_HEX < 0x01060000
-/* raw memory interface already present */
-
-/* there is no object memory interface in 1.5.2 */
-#define PyObject_Malloc		PyMem_Malloc
-#define PyObject_Realloc	PyMem_Realloc
-#define PyObject_Free		PyMem_Free
-
-/* the object interface is there, but the names have changed */
-#define PyObject_New		PyObject_NEW
-#define PyObject_NewVar		PyObject_NEW_VAR
-#define PyObject_Del		PyMem_Free
-#endif
-
-/* If your object is a container you probably want to support the
-   cycle collector, which was new in Python 2.0.
-
-   Unfortunately, the interface to the collector that was present in
-   Python 2.0 and 2.1 proved to be tricky to use, and so changed in
-   2.2 -- in a way that can't easily be papered over with macros.
-
-   This file contains macros that let you program to the 2.2 GC API.
-   Your module will compile against any Python since version 1.5.2,
-   but the type will only participate in the GC in versions 2.2 and
-   up.  Some work is still necessary on your part to only fill out the
-   tp_traverse and tp_clear fields when they exist and set tp_flags
-   appropriately.
-
-   It is possible to support both the 2.0 and 2.2 GC APIs, but it's
-   not pretty and this comment block is too narrow to contain a
-   desciption of what's required... */
-
-#if PY_VERSION_HEX < 0x020200B1
-#define PyObject_GC_New         PyObject_New
-#define PyObject_GC_NewVar      PyObject_NewVar
-#define PyObject_GC_Del         PyObject_Del
-#define PyObject_GC_Track(op)
-#define PyObject_GC_UnTrack(op)
-#endif
-
-#endif /* !Py_PYMEMCOMPAT_H */
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/rand/rand.c hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/rand/rand.c
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/rand/rand.c	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/rand/rand.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,306 +0,0 @@
-/*
- * rand.c
- *
- * Copyright (C) AB Strakt
- * See LICENSE file for details.
- *
- * PRNG management routines, thin wrappers.
- * See the file RATIONALE for a short explanation of why this module was written.
- *
- */
-#include <Python.h>
-
-/* 
- * In order to get the RAND_screen definition from the rand.h
- * WIN32 or WINDOWS needs to be defined, otherwise we get a
- * warning.
- */
-#ifdef MS_WINDOWS
-#  ifndef WIN32
-#      define WIN32
-#  endif
-#endif
-#include <openssl/rand.h>
-#include "../util.h"
-
-PyObject *rand_Error;
-
-static char rand_doc[] = "\n\
-PRNG management routines, thin wrappers.\n\
-See the file RATIONALE for a short explanation of why this module was written.\n\
-";
-
-static char rand_add_doc[] = "\n\
-Add data with a given entropy to the PRNG\n\
-\n\
-@param buffer: Buffer with random data\n\
-@param entropy: The entropy (in bytes) measurement of the buffer\n\
-@return: None\n\
-";
-
-static PyObject *
-rand_add(PyObject *spam, PyObject *args)
-{
-    char *buf;
-    int size;
-    double entropy;
-
-    if (!PyArg_ParseTuple(args, BYTESTRING_FMT "#d:add", &buf, &size, &entropy))
-        return NULL;
-
-    RAND_add(buf, size, entropy);
-
-    Py_INCREF(Py_None);
-    return Py_None;
-}
-
-static char rand_seed_doc[] = "\n\
-Alias for rand_add, with entropy equal to length\n\
-\n\
-@param buffer: Buffer with random data\n\
-@return: None\n\
-";
-
-static PyObject *
-rand_seed(PyObject *spam, PyObject *args)
-{
-    char *buf;
-    int size;
-
-    if (!PyArg_ParseTuple(args, BYTESTRING_FMT "#:seed", &buf, &size))
-        return NULL;
-
-    RAND_seed(buf, size);
-
-    Py_INCREF(Py_None);
-    return Py_None;
-}
-
-static char rand_status_doc[] = "\n\
-Retrieve the status of the PRNG\n\
-\n\
-@return: True if the PRNG is seeded enough, false otherwise\n\
-";
-
-static PyObject *
-rand_status(PyObject *spam, PyObject *args)
-{
-    if (!PyArg_ParseTuple(args, ":status"))
-        return NULL;
-
-    return PyLong_FromLong((long)RAND_status());
-}
-
-#ifdef MS_WINDOWS
-static char rand_screen_doc[] = "\n\
-Add the current contents of the screen to the PRNG state. Availability:\n\
-Windows.\n\
-\n\
-@return: None\n\
-";
-
-static PyObject *
-rand_screen(PyObject *spam, PyObject *args)
-{
-    if (!PyArg_ParseTuple(args, ":screen"))
-        return NULL;
-
-    RAND_screen();
-    Py_INCREF(Py_None);
-    return Py_None;
-}
-#endif
-
-static char rand_egd_doc[] = "\n\
-Query an entropy gathering daemon (EGD) for random data and add it to the\n\
-PRNG. I haven't found any problems when the socket is missing, the function\n\
-just returns 0.\n\
-\n\
-@param path: The path to the EGD socket\n\
-@param bytes: (optional) The number of bytes to read, default is 255\n\
-@returns: The number of bytes read (NB: a value of 0 isn't necessarily an\n\
-          error, check rand.status())\n\
-";
-
-static PyObject *
-rand_egd(PyObject *spam, PyObject *args)
-{
-    char *path;
-    int bytes = 255;
-
-    if (!PyArg_ParseTuple(args, "s|i:egd", &path, &bytes))
-        return NULL;
-
-    return PyLong_FromLong((long)RAND_egd_bytes(path, bytes));
-}
-
-static char rand_cleanup_doc[] = "\n\
-Erase the memory used by the PRNG.\n\
-\n\
-@return: None\n\
-";
-
-static PyObject *
-rand_cleanup(PyObject *spam, PyObject *args)
-{
-    if (!PyArg_ParseTuple(args, ":cleanup"))
-        return NULL;
-
-    RAND_cleanup();
-
-    Py_INCREF(Py_None);
-    return Py_None;
-}
-
-static char rand_load_file_doc[] = "\n\
-Seed the PRNG with data from a file\n\
-\n\
-@param filename: The file to read data from\n\
-@param maxbytes: (optional) The number of bytes to read, default is\n\
-                 to read the entire file\n\
-@return: The number of bytes read\n\
-";
-
-static PyObject *
-rand_load_file(PyObject *spam, PyObject *args)
-{
-    char *filename;
-    int maxbytes = -1;
-
-    if (!PyArg_ParseTuple(args, "s|i:load_file", &filename, &maxbytes))
-        return NULL;
-
-    return PyLong_FromLong((long)RAND_load_file(filename, maxbytes));
-}
-
-static char rand_write_file_doc[] = "\n\
-Save PRNG state to a file\n\
-\n\
-@param filename: The file to write data to\n\
-@return: The number of bytes written\n\
-";
-
-static PyObject *
-rand_write_file(PyObject *spam, PyObject *args)
-{
-    char *filename;
-
-    if (!PyArg_ParseTuple(args, "s:write_file", &filename))
-        return NULL;
-
-    return PyLong_FromLong((long)RAND_write_file(filename));
-}
-
-static char rand_bytes_doc[] = "\n\
-Get some randomm bytes as a string.\n\
-\n\
-@param num_bytes: The number of bytes to fetch\n\
-@return: A string of random bytes\n\
-";
-
-#if PY_VERSION_HEX < 0x02050000
-#define Py_ssize_t int
-#define PY_SSIZE_FMT "i"
-#else
-#define PY_SSIZE_FMT "n"
-#endif
-
-static PyObject *
-rand_bytes(PyObject *spam, PyObject *args, PyObject *keywds) {
-    Py_ssize_t num_bytes;
-    static char *kwlist[] = {"num_bytes", NULL};
-    char *buf;
-    unsigned int rc;
-    PyObject *obj = NULL;
-
-    if (!PyArg_ParseTupleAndKeywords(
-            args, keywds, PY_SSIZE_FMT ":bytes", kwlist, &num_bytes)) {
-        return NULL;
-    }
-
-    if(num_bytes < 0) {
-        PyErr_SetString(PyExc_ValueError, "num_bytes must not be negative");
-        return NULL;
-    }
-    buf = malloc(num_bytes);
-    if (buf == NULL)   /* out of memory  */
-        return NULL;
-    rc = RAND_bytes((unsigned char *) buf, num_bytes);
-    if(rc != 1) {  /* if unsuccessful */
-        exception_from_error_queue(rand_Error);
-        goto done;
-    }
-    obj = PyBytes_FromStringAndSize(buf, (unsigned) num_bytes);
- done:
-    free(buf);
-    return obj;
-}
-
-
-/* Methods in the OpenSSL.rand module */
-static PyMethodDef rand_methods[] = {
-    { "add",       (PyCFunction)rand_add,          METH_VARARGS, rand_add_doc },
-    { "seed",      (PyCFunction)rand_seed,         METH_VARARGS, rand_seed_doc },
-    { "status",    (PyCFunction)rand_status,       METH_VARARGS, rand_status_doc },
-#ifdef MS_WINDOWS
-    { "screen",    (PyCFunction)rand_screen,       METH_VARARGS, rand_screen_doc },
-#endif
-    { "egd",       (PyCFunction)rand_egd,          METH_VARARGS, rand_egd_doc },
-    { "cleanup",   (PyCFunction)rand_cleanup,      METH_VARARGS, rand_cleanup_doc },
-    { "load_file", (PyCFunction)rand_load_file,    METH_VARARGS, rand_load_file_doc },
-    { "write_file",(PyCFunction)rand_write_file,   METH_VARARGS, rand_write_file_doc },
-    { "bytes",     (PyCFunction)rand_bytes,        METH_VARARGS|METH_KEYWORDS, rand_bytes_doc },
-    { NULL, NULL }
-};
-
-
-#ifdef PY3
-static struct PyModuleDef randmodule = {
-    PyModuleDef_HEAD_INIT,
-    "rand",
-    rand_doc,
-    -1,
-    rand_methods
-};
-#endif
-
-/*
- * Initialize the rand sub module
- *
- * Arguments: None
- * Returns:   None
- */
-PyOpenSSL_MODINIT(rand) {
-    PyObject *module;
-
-#ifdef PY3
-    module = PyModule_Create(&randmodule);
-#else
-    module = Py_InitModule3("rand", rand_methods, rand_doc);
-#endif
-    if (module == NULL) {
-        PyOpenSSL_MODRETURN(NULL);
-    }
-
-    rand_Error = PyErr_NewException("OpenSSL.rand.Error", NULL, NULL);
-
-    if (rand_Error == NULL) {
-        goto error;
-    }
-
-    /* PyModule_AddObject steals a reference.
-     */
-    Py_INCREF(rand_Error);
-    if (PyModule_AddObject(module, "Error", rand_Error) != 0) {
-        goto error;
-    }
-
-    ERR_load_RAND_strings();
-
-    PyOpenSSL_MODRETURN(module);
-
-error:
-    PyOpenSSL_MODRETURN(NULL);
-    ;
-}
-
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/rand.py hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/rand.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/rand.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/rand.py	2015-04-13 23:58:06.000000000 +0200
@@ -0,0 +1,180 @@
+"""
+PRNG management routines, thin wrappers.
+
+See the file RATIONALE for a short explanation of why this module was written.
+"""
+
+from functools import partial
+
+from six import integer_types as _integer_types
+
+from OpenSSL._util import (
+    ffi as _ffi,
+    lib as _lib,
+    exception_from_error_queue as _exception_from_error_queue,
+    path_string as _path_string)
+
+
+class Error(Exception):
+    """
+    An error occurred in an `OpenSSL.rand` API.
+    """
+
+_raise_current_error = partial(_exception_from_error_queue, Error)
+
+_unspecified = object()
+
+_builtin_bytes = bytes
+
+def bytes(num_bytes):
+    """
+    Get some random bytes as a string.
+
+    :param num_bytes: The number of bytes to fetch
+    :return: A string of random bytes
+    """
+    if not isinstance(num_bytes, _integer_types):
+        raise TypeError("num_bytes must be an integer")
+
+    if num_bytes < 0:
+        raise ValueError("num_bytes must not be negative")
+
+    result_buffer = _ffi.new("char[]", num_bytes)
+    result_code = _lib.RAND_bytes(result_buffer, num_bytes)
+    if result_code == -1:
+        # TODO: No tests for this code path.  Triggering a RAND_bytes failure
+        # might involve supplying a custom ENGINE?  That's hard.
+        _raise_current_error()
+
+    return _ffi.buffer(result_buffer)[:]
+
+
+
+def add(buffer, entropy):
+    """
+    Add data with a given entropy to the PRNG
+
+    :param buffer: Buffer with random data
+    :param entropy: The entropy (in bytes) measurement of the buffer
+    :return: None
+    """
+    if not isinstance(buffer, _builtin_bytes):
+        raise TypeError("buffer must be a byte string")
+
+    if not isinstance(entropy, int):
+        raise TypeError("entropy must be an integer")
+
+    # TODO Nothing tests this call actually being made, or made properly.
+    _lib.RAND_add(buffer, len(buffer), entropy)
+
+
+
+def seed(buffer):
+    """
+    Alias for rand_add, with entropy equal to length
+
+    :param buffer: Buffer with random data
+    :return: None
+    """
+    if not isinstance(buffer, _builtin_bytes):
+        raise TypeError("buffer must be a byte string")
+
+    # TODO Nothing tests this call actually being made, or made properly.
+    _lib.RAND_seed(buffer, len(buffer))
+
+
+
+def status():
+    """
+    Retrieve the status of the PRNG
+
+    :return: True if the PRNG is seeded enough, false otherwise
+    """
+    return _lib.RAND_status()
+
+
+
+def egd(path, bytes=_unspecified):
+    """
+    Query an entropy gathering daemon (EGD) for random data and add it to the
+    PRNG. I haven't found any problems when the socket is missing, the function
+    just returns 0.
+
+    :param path: The path to the EGD socket
+    :param bytes: (optional) The number of bytes to read, default is 255
+    :returns: The number of bytes read (NB: a value of 0 isn't necessarily an
+              error, check rand.status())
+    """
+    if not isinstance(path, _builtin_bytes):
+        raise TypeError("path must be a byte string")
+
+    if bytes is _unspecified:
+        bytes = 255
+    elif not isinstance(bytes, int):
+        raise TypeError("bytes must be an integer")
+
+    return _lib.RAND_egd_bytes(path, bytes)
+
+
+
+def cleanup():
+    """
+    Erase the memory used by the PRNG.
+
+    :return: None
+    """
+    # TODO Nothing tests this call actually being made, or made properly.
+    _lib.RAND_cleanup()
+
+
+
+def load_file(filename, maxbytes=_unspecified):
+    """
+    Seed the PRNG with data from a file
+
+    :param filename: The file to read data from (``bytes`` or ``unicode``).
+    :param maxbytes: (optional) The number of bytes to read, default is to read
+        the entire file
+
+    :return: The number of bytes read
+    """
+    filename = _path_string(filename)
+
+    if maxbytes is _unspecified:
+        maxbytes = -1
+    elif not isinstance(maxbytes, int):
+        raise TypeError("maxbytes must be an integer")
+
+    return _lib.RAND_load_file(filename, maxbytes)
+
+
+
+def write_file(filename):
+    """
+    Save PRNG state to a file
+
+    :param filename: The file to write data to (``bytes`` or ``unicode``).
+
+    :return: The number of bytes written
+    """
+    filename = _path_string(filename)
+    return _lib.RAND_write_file(filename)
+
+
+# TODO There are no tests for screen at all
+def screen():
+    """
+    Add the current contents of the screen to the PRNG state. Availability:
+    Windows.
+
+    :return: None
+    """
+    _lib.RAND_screen()
+
+if getattr(_lib, 'RAND_screen', None) is None:
+    del screen
+
+
+# TODO There are no tests for the RAND strings being loaded, whatever that
+# means.
+_lib.ERR_load_RAND_strings()
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/RATIONALE hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/RATIONALE
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/RATIONALE	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/RATIONALE	1970-01-01 01:00:00.000000000 +0100
@@ -1,61 +0,0 @@
-  RATIONALE
-
-The reason this module exists at all is that the SSL support in the socket
-module in the Python 2.1 distribution (which is what we used, of course I
-cannot speak for later versions) is severely limited.
-
-<FIXME> Update this list whenever needed! The communications module isn't
-written yet, so we don't know exactly how this'll work! </FIXME>
-This is a list of things we need from an OpenSSL module:
- + Context objects (in OpenSSL called SSL_CTX) that can be manipulated from
-   Python modules.  They must support a number of operations:
-     - Loading certificates from file and memory, both the client
-       certificate and the certificates used for the verification chain.
-     - Loading private keys from file and memory.
-     - Setting the verification mode (basically VERIFY_NONE and
-       VERIFY_PEER).
-     - Callbacks mechanism for prompting for pass phrases and verifying
-       certificates.  The callbacks have to work under a multi-threaded
-       environment (see the comment in ssl/context.c).  Of course the
-       callbacks will have to be written in Python!
- + The Connection objects (in OpenSSL called SSL) have to support a few
-   things:
-     - Renegotiation, this is really important, especially for connections
-       that are up and running for a long time, since renegotiation
-       generates new encryption keys.
-     - Server-side SSL must work!  As far as I know this doesn't work in
-       the SSL support of the socket module as of Python 2.1.
-     - Wrapping the methods of the underlying transport object is nice, so
-       you don't have to keep track of more than one object per connection.
-       This could of course be done a lot better than the way it works now,
-       so more transport layers than sockets are possible!
- + A well-organized error system that mimics OpenSSL's error system is
-   desireable.  Specifically there has to be a way to find out wether the
-   operation was successful, or if it failed, why it failed, so some sort
-   of interface to OpenSSL's error queue mechanism is needed.
- + Certificate objects (X509) and certificate name objects (X509_NAME) are
-   needed, especially for verification purposes.  Certificates will
-   probably also be generated by the server which is another reason for
-   them to exist. The same thing goes for key objects (EVP_PKEY)
- + Since this is an OpenSSL module, there has to be an interface to the
-   OpenSSL PRNG, so it can be seeded in a good way.
-
-When asking about SSL on the comp.lang.python newsgroup (or on
-python-list@python.org) people usually pointed you to the M2Crypto package.
-The M2Crypto.SSL module does implement a lot of OpenSSL's functionality but
-unfortunately its error handling system does not seem to be finished,
-especially for non-blocking I/O.  I think that much of the reason for this
-is that M2Crypto is developed using SWIG.  This makes it awkward to create
-functions that e.g. can return both an integer and NULL since (as far as I
-know) you basically write C functions and SWIG makes wrapper functions that
-parses the Python argument list and calls your C function, and finally
-transforms your return value to a Python object.
-
-Finally, a good book on the topic of SSL (that I read and learned a lot
-from) is "SSL and TLS - Designing and Building Secure Systems" (ISBN
-0201615983) by Eric Rescorla. A good mailinglist to subscribe to is the
-openssl-users@openssl.org list.
-
-This comment was written July 2001, discussing Python 2.1.  Feel free to
-modify it as the SSL support in the socket module changes.
-
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/ssl/connection.c hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/ssl/connection.c
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/ssl/connection.c	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/ssl/connection.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1589 +0,0 @@
-/*
- * connection.c
- *
- * Copyright (C) AB Strakt
- * Copyright (C) Jean-Paul Calderone
- * See LICENSE for details.
- *
- * SSL Connection objects and methods.
- * See the file RATIONALE for a short explanation of why this module was written.
- *
- * Reviewed 2001-07-23
- */
-#include <Python.h>
-
-#ifndef MS_WINDOWS
-#  include <sys/socket.h>
-#  include <netinet/in.h>
-#  if !(defined(__BEOS__) || defined(__CYGWIN__))
-#    include <netinet/tcp.h>
-#  endif
-#else
-#  include <winsock.h>
-#  include <wincrypt.h>
-#endif
-
-#define SSL_MODULE
-#include <openssl/bio.h>
-#include <openssl/err.h>
-#include "ssl.h"
-
-/**
- * If we are on UNIX, fine, just use PyErr_SetFromErrno. If we are on Windows,
- * apply some black winsock voodoo. This is basically just copied from Python's
- * socketmodule.c
- *
- * Arguments: None
- * Returns:   None
- */
-static void
-syscall_from_errno(void)
-{
-#ifdef MS_WINDOWS
-    int errnum = WSAGetLastError();
-    if (errnum)
-    {
-        static struct { int num; const char *msg; } *msgp, msgs[] = {
-            { WSAEINTR, "Interrupted system call" },
-            { WSAEBADF, "Bad file descriptor" },
-            { WSAEACCES, "Permission denied" },
-            { WSAEFAULT, "Bad address" },
-            { WSAEINVAL, "Invalid argument" },
-            { WSAEMFILE, "Too many open files" },
-            { WSAEWOULDBLOCK, "The socket operation could not complete "
-                    "without blocking" },
-            { WSAEINPROGRESS, "Operation now in progress" },
-            { WSAEALREADY, "Operation already in progress" },
-            { WSAENOTSOCK, "Socket operation on non-socket" },
-            { WSAEDESTADDRREQ, "Destination address required" },
-            { WSAEMSGSIZE, "Message too long" },
-            { WSAEPROTOTYPE, "Protocol wrong type for socket" },
-            { WSAENOPROTOOPT, "Protocol not available" },
-            { WSAEPROTONOSUPPORT, "Protocol not supported" },
-            { WSAESOCKTNOSUPPORT, "Socket type not supported" },
-            { WSAEOPNOTSUPP, "Operation not supported" },
-            { WSAEPFNOSUPPORT, "Protocol family not supported" },
-            { WSAEAFNOSUPPORT, "Address family not supported" },
-            { WSAEADDRINUSE, "Address already in use" },
-            { WSAEADDRNOTAVAIL, "Can't assign requested address" },
-            { WSAENETDOWN, "Network is down" },
-            { WSAENETUNREACH, "Network is unreachable" },
-            { WSAENETRESET, "Network dropped connection on reset" },
-            { WSAECONNABORTED, "Software caused connection abort" },
-            { WSAECONNRESET, "Connection reset by peer" },
-            { WSAENOBUFS, "No buffer space available" },
-            { WSAEISCONN, "Socket is already connected" },
-            { WSAENOTCONN, "Socket is not connected" },
-            { WSAESHUTDOWN, "Can't send after socket shutdown" },
-            { WSAETOOMANYREFS, "Too many references: can't splice" },
-            { WSAETIMEDOUT, "Operation timed out" },
-            { WSAECONNREFUSED, "Connection refused" },
-            { WSAELOOP, "Too many levels of symbolic links" },
-            { WSAENAMETOOLONG, "File name too long" },
-            { WSAEHOSTDOWN, "Host is down" },
-            { WSAEHOSTUNREACH, "No route to host" },
-            { WSAENOTEMPTY, "Directory not empty" },
-            { WSAEPROCLIM, "Too many processes" },
-            { WSAEUSERS, "Too many users" },
-            { WSAEDQUOT, "Disc quota exceeded" },
-            { WSAESTALE, "Stale NFS file handle" },
-            { WSAEREMOTE, "Too many levels of remote in path" },
-            { WSASYSNOTREADY, "Network subsystem is unvailable" },
-            { WSAVERNOTSUPPORTED, "WinSock version is not supported" },
-            { WSANOTINITIALISED, "Successful WSAStartup() not yet performed" },
-            { WSAEDISCON, "Graceful shutdown in progress" },
-            /* Resolver errors */
-            { WSAHOST_NOT_FOUND, "No such host is known" },
-            { WSATRY_AGAIN, "Host not found, or server failed" },
-            { WSANO_RECOVERY, "Unexpected server error encountered" },
-            { WSANO_DATA, "Valid name without requested data" },
-            { WSANO_ADDRESS, "No address, look for MX record" },
-            { 0, NULL }
-        };
-        PyObject *v;
-        const char *msg = "winsock error";
-
-        for (msgp = msgs; msgp->msg; msgp++)
-        {
-            if (errnum == msgp->num)
-            {
-                msg = msgp->msg;
-                break;
-            }
-        }
-
-        v = Py_BuildValue("(is)", errnum, msg);
-        if (v != NULL)
-        {
-            PyErr_SetObject(ssl_SysCallError, v);
-            Py_DECREF(v);
-        }
-        return;
-    }
-#else
-    PyErr_SetFromErrno(ssl_SysCallError);
-#endif
-}
-
-/*
- * Handle errors raised by BIO functions.
- *
- * Arguments: bio - The BIO object
- *            ret - The return value of the BIO_ function.
- * Returns: None, the calling function should return NULL;
- */
-static void
-handle_bio_errors(BIO* bio, int ret)
-{
-    if (BIO_should_retry(bio)) {
-        if (BIO_should_read(bio)) {
-            PyErr_SetNone(ssl_WantReadError);
-        } else if (BIO_should_write(bio)) {
-            PyErr_SetNone(ssl_WantWriteError);
-        } else if (BIO_should_io_special(bio)) {
-            /*
-             * It's somewhat unclear what this means.  From the OpenSSL source,
-             * it seems like it should not be triggered by the memory BIO, so
-             * for the time being, this case shouldn't come up.  The SSL BIO
-             * (which I think should be named the socket BIO) may trigger this
-             * case if its socket is not yet connected or it is busy doing
-             * something related to x509.
-             */
-            PyErr_SetString(PyExc_ValueError, "BIO_should_io_special");
-        } else {
-            /*
-             * I hope this is dead code.  The BIO documentation suggests that
-             * one of the above three checks should always be true.
-             */
-            PyErr_SetString(PyExc_ValueError, "unknown bio failure");
-        }
-    } else {
-        /*
-         * If we aren't to retry, it's really an error, so fall back to the
-         * normal error reporting code.  However, the BIO interface does not
-         * specify a uniform error reporting mechanism.  We can only hope that
-         * the code which triggered the error also kindly pushed something onto
-         * the error stack.
-         */
-        exception_from_error_queue(ssl_Error);
-    }
-}
-
-/*
- * Handle errors raised by SSL I/O functions. NOTE: Not SSL_shutdown ;)
- *
- * Arguments: ssl - The SSL object
- *            err - The return code from SSL_get_error
- *            ret - The return code from the SSL I/O function
- * Returns:   None, the calling function should return NULL
- */
-static void
-handle_ssl_errors(SSL *ssl, int err, int ret)
-{
-    switch (err)
-    {
-	/*
-         * Strange as it may seem, ZeroReturn is not an error per se. It means
-         * that the SSL Connection has been closed correctly (note, not the
-         * transport layer!), i.e. closure alerts have been exchanged. This is
-         * an exception since
-         *  + There's an SSL "error" code for it
-         *  + You have to deal with it in any case, close the transport layer
-         *    etc
-         */
-        case SSL_ERROR_ZERO_RETURN:
-            PyErr_SetNone(ssl_ZeroReturnError);
-            break;
-
-        /*
-         * The WantXYZ exceptions don't mean that there's an error, just that
-         * nothing could be read/written just now, maybe because the transport
-         * layer would block on the operation, or that there's not enough data
-         * available to fill an entire SSL record.
-         */
-        case SSL_ERROR_WANT_READ:
-            PyErr_SetNone(ssl_WantReadError);
-            break;
-
-        case SSL_ERROR_WANT_WRITE:
-            PyErr_SetNone(ssl_WantWriteError);
-            break;
-
-        case SSL_ERROR_WANT_X509_LOOKUP:
-            PyErr_SetNone(ssl_WantX509LookupError);
-            break;
-
-        case SSL_ERROR_SYSCALL:
-            if (ERR_peek_error() == 0)
-            {
-                if (ret < 0)
-                {
-                    syscall_from_errno();
-                }
-                else
-                {
-                    PyObject *v;
-
-                    v = Py_BuildValue("(is)", -1, "Unexpected EOF");
-                    if (v != NULL)
-                    {
-                        PyErr_SetObject(ssl_SysCallError, v);
-                        Py_DECREF(v);
-                    }
-                }
-                break;
-            }
-
-	/* NOTE: Fall-through here, we don't want to duplicate code, right? */
-
-        case SSL_ERROR_SSL:
-            ;
-        default:
-	    exception_from_error_queue(ssl_Error);
-            break;
-    }
-}
-
-/*
- * Here be member methods of the Connection "class"
- */
-
-static char ssl_Connection_get_context_doc[] = "\n\
-Get session context\n\
-\n\
-@return: A Context object\n\
-";
-static PyObject *
-ssl_Connection_get_context(ssl_ConnectionObj *self, PyObject *args) {
-    if (!PyArg_ParseTuple(args, ":get_context")) {
-        return NULL;
-    }
-
-    Py_INCREF(self->context);
-    return (PyObject *)self->context;
-}
-
-// Only provide a TLS servername extension host name value
-// when it is actually installed.
-// This is used to get around the deficiencies of openSSL 0.9.8e and older.
-#if SNI_EXTENSION_SUPPORT
-
-static char ssl_Connection_set_context_doc[] = "\n\
-Switch this connection to a new session context\n\
-\n\
-@param context: A L{Context} instance giving the new session context to use.\n\
-\n\
-";
-static PyObject *
-ssl_Connection_set_context(ssl_ConnectionObj *self, PyObject *args) {
-    ssl_ContextObj *ctx;
-    ssl_ContextObj *old;
-
-    if (!PyArg_ParseTuple(args, "O!:set_context", &ssl_Context_Type, &ctx)) {
-        return NULL;
-    }
-
-    /* This Connection will hold on to this context now.  Make sure it stays
-     * alive.
-     */
-    Py_INCREF(ctx);
-
-    /* XXX The unit tests don't actually verify that this call is made.
-     * They're satisfied if self->context gets updated.
-     */
-    SSL_set_SSL_CTX(self->ssl, ctx->ctx);
-
-    /* Swap the old out and the new in.
-     */
-    old = self->context;
-    self->context = ctx;
-
-    /* XXX The unit tests don't verify that this reference is dropped.
-     */
-    Py_DECREF(old);
-
-    Py_INCREF(Py_None);
-    return Py_None;
-}
-
-static char ssl_Connection_get_servername_doc[] = "\n\
-Retrieve the servername extension value if provided in the client hello\n\
-message, or None if there wasn't one.\n\
-\n\
-@return: A byte string giving the server name or C{None}.\n\
-\n\
-";
-static PyObject *
-ssl_Connection_get_servername(ssl_ConnectionObj *self, PyObject *args) {
-    int type = TLSEXT_NAMETYPE_host_name;
-    const char *name;
-
-    if (!PyArg_ParseTuple(args, ":get_servername")) {
-        return NULL;
-    }
-
-    name = SSL_get_servername(self->ssl, type);
-
-    if (name == NULL) {
-        Py_INCREF(Py_None);
-        return Py_None;
-    } else {
-        return PyBytes_FromString(name);
-    }
-}
-
-
-static char ssl_Connection_set_tlsext_host_name_doc[] = "\n\
-Set the value of the servername extension to send in the client hello.\n\
-\n\
-@param name: A byte string giving the name.\n\
-\n\
-";
-static PyObject *
-ssl_Connection_set_tlsext_host_name(ssl_ConnectionObj *self, PyObject *args) {
-    char *buf;
-
-    if (!PyArg_ParseTuple(args, BYTESTRING_FMT ":set_tlsext_host_name", &buf)) {
-        return NULL;
-    }
-
-    /* XXX I guess this can fail sometimes? */
-    SSL_set_tlsext_host_name(self->ssl, buf);
-
-    Py_INCREF(Py_None);
-    return Py_None;
-}
-
-#endif
-
-
-static char ssl_Connection_pending_doc[] = "\n\
-Get the number of bytes that can be safely read from the connection\n\
-\n\
-@return: The number of bytes available in the receive buffer.\n\
-";
-static PyObject *
-ssl_Connection_pending(ssl_ConnectionObj *self, PyObject *args) {
-    int ret;
-
-    if (!PyArg_ParseTuple(args, ":pending")) {
-        return NULL;
-    }
-
-    ret = SSL_pending(self->ssl);
-    return PyLong_FromLong((long)ret);
-}
-
-static char ssl_Connection_bio_write_doc[] = "\n\
-When using non-socket connections this function sends\n\
-\"dirty\" data that would have traveled in on the network.\n\
-\n\
-@param buf: The string to put into the memory BIO.\n\
-@return: The number of bytes written\n\
-";
-static PyObject *
-ssl_Connection_bio_write(ssl_ConnectionObj *self, PyObject *args)
-{
-    char *buf;
-    int len, ret;
-
-    if (self->into_ssl == NULL) 
-    {
-            PyErr_SetString(PyExc_TypeError, "Connection sock was not None");
-            return NULL;
-    }
-
-    if (!PyArg_ParseTuple(args, "s#|i:bio_write", &buf, &len))
-        return NULL;
-
-    ret = BIO_write(self->into_ssl, buf, len);
-
-    if (PyErr_Occurred())
-    {
-        flush_error_queue();
-        return NULL;
-    }
-
-    if (ret <= 0) {
-        /*
-         * There was a problem with the BIO_write of some sort.
-         */
-        handle_bio_errors(self->into_ssl, ret);
-        return NULL;
-    }
-
-    return PyLong_FromLong((long)ret);
-}
-
-static char ssl_Connection_send_doc[] = "\n\
-Send data on the connection. NOTE: If you get one of the WantRead,\n\
-WantWrite or WantX509Lookup exceptions on this, you have to call the\n\
-method again with the SAME buffer.\n\
-\n\
-@param buf: The string to send\n\
-@param flags: (optional) Included for compatibility with the socket\n\
-              API, the value is ignored\n\
-@return: The number of bytes written\n\
-";
-static PyObject *
-ssl_Connection_send(ssl_ConnectionObj *self, PyObject *args) {
-    int len, ret, err, flags;
-    char *buf;
-
-#if PY_VERSION_HEX >= 0x02060000
-    Py_buffer pbuf;
-
-    if (!PyArg_ParseTuple(args, "s*|i:send", &pbuf, &flags))
-        return NULL;
-
-    buf = pbuf.buf;
-    len = pbuf.len;
-#else
-
-    if (!PyArg_ParseTuple(args, "s#|i:send", &buf, &len, &flags))
-        return NULL;
-#endif
-
-    MY_BEGIN_ALLOW_THREADS(self->tstate)
-    ret = SSL_write(self->ssl, buf, len);
-    MY_END_ALLOW_THREADS(self->tstate)
-
-#if PY_VERSION_HEX >= 0x02060000
-    PyBuffer_Release(&pbuf);
-#endif
-
-    if (PyErr_Occurred())
-    {
-        flush_error_queue();
-        return NULL;
-    }
-
-    err = SSL_get_error(self->ssl, ret);
-    if (err == SSL_ERROR_NONE)
-    {
-        return PyLong_FromLong((long)ret);
-    }
-    else
-    {
-        handle_ssl_errors(self->ssl, err, ret);
-        return NULL;
-    }
-}
-
-static char ssl_Connection_sendall_doc[] = "\n\
-Send \"all\" data on the connection. This calls send() repeatedly until\n\
-all data is sent. If an error occurs, it's impossible to tell how much data\n\
-has been sent.\n\
-\n\
-@param buf: The string to send\n\
-@param flags: (optional) Included for compatibility with the socket\n\
-              API, the value is ignored\n\
-@return: The number of bytes written\n\
-";
-static PyObject *
-ssl_Connection_sendall(ssl_ConnectionObj *self, PyObject *args)
-{
-    char *buf;
-    int len, ret, err, flags;
-    PyObject *pyret = Py_None;
-
-#if PY_VERSION_HEX >= 0x02060000
-    Py_buffer pbuf;
-
-    if (!PyArg_ParseTuple(args, "s*|i:sendall", &pbuf, &flags))
-        return NULL;
-
-    buf = pbuf.buf;
-    len = pbuf.len;
-#else
-    if (!PyArg_ParseTuple(args, "s#|i:sendall", &buf, &len, &flags))
-        return NULL;
-#endif
-
-    do {
-        MY_BEGIN_ALLOW_THREADS(self->tstate)
-        ret = SSL_write(self->ssl, buf, len);
-        MY_END_ALLOW_THREADS(self->tstate)
-        if (PyErr_Occurred())
-        {
-            flush_error_queue();
-            pyret = NULL;
-            break;
-        }
-        err = SSL_get_error(self->ssl, ret);
-        if (err == SSL_ERROR_NONE)
-        {
-            buf += ret;
-            len -= ret;
-        }
-        else if (err == SSL_ERROR_SSL || err == SSL_ERROR_SYSCALL ||
-                 err == SSL_ERROR_ZERO_RETURN)
-        {
-            handle_ssl_errors(self->ssl, err, ret);
-            pyret = NULL;
-            break;
-        }
-    } while (len > 0);
-
-#if PY_VERSION_HEX >= 0x02060000
-    PyBuffer_Release(&pbuf);
-#endif
-
-    Py_XINCREF(pyret);
-    return pyret;
-}
-
-static char ssl_Connection_recv_doc[] = "\n\
-Receive data on the connection. NOTE: If you get one of the WantRead,\n\
-WantWrite or WantX509Lookup exceptions on this, you have to call the\n\
-method again with the SAME buffer.\n\
-\n\
-@param bufsiz: The maximum number of bytes to read\n\
-@param flags: (optional) Included for compatibility with the socket\n\
-              API, the value is ignored\n\
-@return: The string read from the Connection\n\
-";
-static PyObject *
-ssl_Connection_recv(ssl_ConnectionObj *self, PyObject *args)
-{
-    int bufsiz, ret, err, flags;
-    PyObject *buf;
-
-    if (!PyArg_ParseTuple(args, "i|i:recv", &bufsiz, &flags))
-        return NULL;
-
-    buf = PyBytes_FromStringAndSize(NULL, bufsiz);
-    if (buf == NULL)
-        return NULL;
-
-    MY_BEGIN_ALLOW_THREADS(self->tstate)
-    ret = SSL_read(self->ssl, PyBytes_AsString(buf), bufsiz);
-    MY_END_ALLOW_THREADS(self->tstate)
-
-    if (PyErr_Occurred())
-    {
-        Py_DECREF(buf);
-        flush_error_queue();
-        return NULL;
-    }
-
-    err = SSL_get_error(self->ssl, ret);
-    if (err == SSL_ERROR_NONE)
-    {
-        if (ret != bufsiz && _PyBytes_Resize(&buf, ret) < 0)
-            return NULL;
-        return buf;
-    }
-    else
-    {
-        handle_ssl_errors(self->ssl, err, ret);
-        Py_DECREF(buf);
-        return NULL;
-    }
-}
-
-static char ssl_Connection_bio_read_doc[] = "\n\
-When using non-socket connections this function reads\n\
-the \"dirty\" data that would have traveled away on the network.\n\
-\n\
-@param bufsiz: The maximum number of bytes to read\n\
-@return: The string read.\n\
-";
-static PyObject *
-ssl_Connection_bio_read(ssl_ConnectionObj *self, PyObject *args)
-{
-    int bufsiz, ret;
-    PyObject *buf;
-
-    if (self->from_ssl == NULL) 
-    {
-            PyErr_SetString(PyExc_TypeError, "Connection sock was not None");
-            return NULL;
-    }
-
-    if (!PyArg_ParseTuple(args, "i:bio_read", &bufsiz))
-        return NULL;
-
-    buf = PyBytes_FromStringAndSize(NULL, bufsiz);
-    if (buf == NULL)
-        return NULL;
-
-    ret = BIO_read(self->from_ssl, PyBytes_AsString(buf), bufsiz);
-
-    if (PyErr_Occurred())
-    {
-        Py_DECREF(buf);
-        flush_error_queue();
-        return NULL;
-    }
-
-    if (ret <= 0) {
-        /*
-         * There was a problem with the BIO_read of some sort.
-         */
-        handle_bio_errors(self->from_ssl, ret);
-        Py_DECREF(buf);
-        return NULL;
-    }
-
-    /*
-     * Shrink the string to match the number of bytes we actually read.
-     */
-    if (ret != bufsiz && _PyBytes_Resize(&buf, ret) < 0)
-    {
-        Py_DECREF(buf);
-        return NULL;
-    }
-    return buf;
-}
-
-static char ssl_Connection_renegotiate_doc[] = "\n\
-Renegotiate the session\n\
-\n\
-@return: True if the renegotiation can be started, false otherwise\n\
-";
-static PyObject *
-ssl_Connection_renegotiate(ssl_ConnectionObj *self, PyObject *args) {
-    int ret;
-
-    if (!PyArg_ParseTuple(args, ":renegotiate")) {
-        return NULL;
-    }
-
-    MY_BEGIN_ALLOW_THREADS(self->tstate);
-    ret = SSL_renegotiate(self->ssl);
-    MY_END_ALLOW_THREADS(self->tstate);
-
-    if (PyErr_Occurred()) {
-        flush_error_queue();
-        return NULL;
-    }
-
-    return PyLong_FromLong((long)ret);
-}
-
-static char ssl_Connection_do_handshake_doc[] = "\n\
-Perform an SSL handshake (usually called after renegotiate() or one of\n\
-set_*_state()). This can raise the same exceptions as send and recv.\n\
-\n\
-@return: None.\n\
-";
-static PyObject *
-ssl_Connection_do_handshake(ssl_ConnectionObj *self, PyObject *args)
-{
-    int ret, err;
-
-    if (!PyArg_ParseTuple(args, ":do_handshake"))
-        return NULL;
-
-    MY_BEGIN_ALLOW_THREADS(self->tstate);
-    ret = SSL_do_handshake(self->ssl);
-    MY_END_ALLOW_THREADS(self->tstate);
-
-    if (PyErr_Occurred())
-    {
-        flush_error_queue();
-        return NULL;
-    }
-
-    err = SSL_get_error(self->ssl, ret);
-    if (err == SSL_ERROR_NONE)
-    {
-        Py_INCREF(Py_None);
-        return Py_None;
-    }
-    else
-    {
-        handle_ssl_errors(self->ssl, err, ret);
-        return NULL;
-    }
-}
-
-#if defined(OPENSSL_VERSION_NUMBER) && OPENSSL_VERSION_NUMBER >= 0x00907000L
-static char ssl_Connection_renegotiate_pending_doc[] = "\n\
-Check if there's a renegotiation in progress, it will return false once\n\
-a renegotiation is finished.\n\
-\n\
-@return: Whether there's a renegotiation in progress\n\
-";
-static PyObject *
-ssl_Connection_renegotiate_pending(ssl_ConnectionObj *self, PyObject *args)
-{
-    if (!PyArg_ParseTuple(args, ":renegotiate_pending"))
-        return NULL;
-
-    return PyLong_FromLong((long)SSL_renegotiate_pending(self->ssl));
-}
-#endif
-
-static char ssl_Connection_total_renegotiations_doc[] = "\n\
-Find out the total number of renegotiations.\n\
-\n\
-@return: The number of renegotiations.\n\
-";
-static PyObject *
-ssl_Connection_total_renegotiations(ssl_ConnectionObj *self, PyObject *args)
-{
-    if (!PyArg_ParseTuple(args, ":total_renegotiations"))
-        return NULL;
-
-    return PyLong_FromLong(SSL_total_renegotiations(self->ssl));
-}
-
-static char ssl_Connection_set_accept_state_doc[] = "\n\
-Set the connection to work in server mode. The handshake will be handled\n\
-automatically by read/write.\n\
-\n\
-@return: None\n\
-";
-static PyObject *
-ssl_Connection_set_accept_state(ssl_ConnectionObj *self, PyObject *args)
-{
-    if (!PyArg_ParseTuple(args, ":set_accept_state"))
-        return NULL;
-
-    SSL_set_accept_state(self->ssl);
-
-    Py_INCREF(Py_None);
-    return Py_None;
-}
-
-static char ssl_Connection_set_connect_state_doc[] = "\n\
-Set the connection to work in client mode. The handshake will be handled\n\
-automatically by read/write.\n\
-\n\
-@return: None\n\
-";
-static PyObject *
-ssl_Connection_set_connect_state(ssl_ConnectionObj *self, PyObject *args)
-{
-    if (!PyArg_ParseTuple(args, ":set_connect_state"))
-        return NULL;
-
-    SSL_set_connect_state(self->ssl);
-
-    Py_INCREF(Py_None);
-    return Py_None;
-}
-
-static char ssl_Connection_connect_doc[] = "\n\
-Connect to remote host and set up client-side SSL\n\
-\n\
-@param addr: A remote address\n\
-@return: What the socket's connect method returns\n\
-";
-static PyObject *
-ssl_Connection_connect(ssl_ConnectionObj *self, PyObject *args)
-{
-    PyObject *meth, *ret;
-
-    if ((meth = PyObject_GetAttrString(self->socket, "connect")) == NULL)
-        return NULL;
-
-    SSL_set_connect_state(self->ssl);
-
-    ret = PyEval_CallObject(meth, args);
-    Py_DECREF(meth);
-    if (ret == NULL)
-        return NULL;
-
-    return ret;
-}
-
-static char ssl_Connection_connect_ex_doc[] = "\n\
-Connect to remote host and set up client-side SSL. Note that if the socket's\n\
-connect_ex method doesn't return 0, SSL won't be initialized.\n\
-\n\
-@param addr: A remove address\n\
-@return: What the socket's connect_ex method returns\n\
-";
-static PyObject *
-ssl_Connection_connect_ex(ssl_ConnectionObj *self, PyObject *args)
-{
-    PyObject *meth, *ret;
-
-    if ((meth = PyObject_GetAttrString(self->socket, "connect_ex")) == NULL)
-        return NULL;
-
-    SSL_set_connect_state(self->ssl);
-
-    ret = PyEval_CallObject(meth, args);
-    Py_DECREF(meth);
-    return ret;
-}
-
-static char ssl_Connection_accept_doc[] = "\n\
-Accept incoming connection and set up SSL on it\n\
-\n\
-@return: A (conn,addr) pair where conn is a Connection and addr is an\n\
-         address\n\
-";
-static PyObject *
-ssl_Connection_accept(ssl_ConnectionObj *self, PyObject *args)
-{
-    PyObject *tuple, *socket, *address, *meth;
-    ssl_ConnectionObj *conn;
-
-    if ((meth = PyObject_GetAttrString(self->socket, "accept")) == NULL)
-        return NULL;
-    tuple = PyEval_CallObject(meth, args);
-    Py_DECREF(meth);
-    if (tuple == NULL)
-        return NULL;
-
-    socket  = PyTuple_GetItem(tuple, 0);
-    Py_INCREF(socket);
-    address = PyTuple_GetItem(tuple, 1);
-    Py_INCREF(address);
-    Py_DECREF(tuple);
-
-    conn = ssl_Connection_New(self->context, socket);
-    Py_DECREF(socket);
-    if (conn == NULL)
-    {
-        Py_DECREF(address);
-        return NULL;
-    }
-
-    SSL_set_accept_state(conn->ssl);
-
-    tuple = Py_BuildValue("(OO)", conn, address);
-
-    Py_DECREF(conn);
-    Py_DECREF(address);
-
-    return tuple;
-}
-
-static char ssl_Connection_bio_shutdown_doc[] = "\n\
-When using non-socket connections this function signals end of\n\
-data on the input for this connection.\n\
-\n\
-@return: None\n\
-";
-
-static PyObject *
-ssl_Connection_bio_shutdown(ssl_ConnectionObj *self, PyObject *args)
-{
-    if (self->from_ssl == NULL) 
-    {
-            PyErr_SetString(PyExc_TypeError, "Connection sock was not None");
-            return NULL;
-    }
-
-    BIO_set_mem_eof_return(self->into_ssl, 0);
-    Py_INCREF(Py_None);
-    return Py_None;
-}
-
-
-
-static char ssl_Connection_shutdown_doc[] = "\n\
-Send closure alert\n\
-\n\
-@return: True if the shutdown completed successfully (i.e. both sides\n\
-         have sent closure alerts), false otherwise (i.e. you have to\n\
-         wait for a ZeroReturnError on a recv() method call\n\
-";
-static PyObject *
-ssl_Connection_shutdown(ssl_ConnectionObj *self, PyObject *args)
-{
-    int ret;
-
-    if (!PyArg_ParseTuple(args, ":shutdown"))
-        return NULL;
-
-    MY_BEGIN_ALLOW_THREADS(self->tstate)
-    ret = SSL_shutdown(self->ssl);
-    MY_END_ALLOW_THREADS(self->tstate)
-
-    if (PyErr_Occurred())
-    {
-        flush_error_queue();
-        return NULL;
-    }
-
-    if (ret < 0)
-    {
-        exception_from_error_queue(ssl_Error);
-        return NULL;
-    }
-    else if (ret > 0)
-    {
-        Py_INCREF(Py_True);
-        return Py_True;
-    }
-    else
-    {
-        Py_INCREF(Py_False);
-        return Py_False;
-    }
-}
-
-static char ssl_Connection_get_cipher_list_doc[] = "\n\
-Get the session cipher list\n\
-\n\
-@return: A list of cipher strings\n\
-";
-static PyObject *
-ssl_Connection_get_cipher_list(ssl_ConnectionObj *self, PyObject *args)
-{
-    int idx = 0;
-    const char *ret;
-    PyObject *lst, *item;
-
-    if (!PyArg_ParseTuple(args, ":get_cipher_list"))
-        return NULL;
-
-    lst = PyList_New(0);
-    while ((ret = SSL_get_cipher_list(self->ssl, idx)) != NULL)
-    {
-        item = PyText_FromString(ret);
-        PyList_Append(lst, item);
-        Py_DECREF(item);
-        idx++;
-    }
-    return lst;
-}
-
-static char ssl_Connection_get_client_ca_list_doc[] = "\n\
-Get CAs whose certificates are suggested for client authentication.\n\
-\n\
-@return: If this is a server connection, a list of X509Names representing\n\
-    the acceptable CAs as set by L{OpenSSL.SSL.Context.set_client_ca_list} or\n\
-    L{OpenSSL.SSL.Context.add_client_ca}.  If this is a client connection,\n\
-    the list of such X509Names sent by the server, or an empty list if that\n\
-    has not yet happened.\n\
-";
-
-static PyObject *
-ssl_Connection_get_client_ca_list(ssl_ConnectionObj *self, PyObject *args) {
-    STACK_OF(X509_NAME) *CANames;
-    PyObject *CAList;
-    int i, n;
-
-    if (!PyArg_ParseTuple(args, ":get_client_ca_list")) {
-        return NULL;
-    }
-    CANames = SSL_get_client_CA_list(self->ssl);
-    if (CANames == NULL) {
-        return PyList_New(0);
-    }
-    n = sk_X509_NAME_num(CANames);
-    CAList = PyList_New(n);
-    if (CAList == NULL) {
-        return NULL;
-    }
-    for (i = 0; i < n; i++) {
-        X509_NAME *CAName;
-        PyObject *CA;
-
-        CAName = X509_NAME_dup(sk_X509_NAME_value(CANames, i));
-        if (CAName == NULL) {
-            Py_DECREF(CAList);
-            exception_from_error_queue(ssl_Error);
-            return NULL;
-        }
-        CA = (PyObject *)new_x509name(CAName, 1);
-        if (CA == NULL) {
-            X509_NAME_free(CAName);
-            Py_DECREF(CAList);
-            return NULL;
-        }
-        if (PyList_SetItem(CAList, i, CA)) {
-            Py_DECREF(CA);
-            Py_DECREF(CAList);
-            return NULL;
-        }
-    }
-    return CAList;
-}
-
-static char ssl_Connection_makefile_doc[] = "\n\
-The makefile() method is not implemented, since there is no dup semantics\n\
-for SSL connections\n\
-\n\
-@raise NotImplementedError\n\
-";
-static PyObject *
-ssl_Connection_makefile(ssl_ConnectionObj *self, PyObject *args)
-{
-    PyErr_SetString(PyExc_NotImplementedError, "Cannot make file object of SSL.Connection");
-    return NULL;
-}
-
-static char ssl_Connection_get_app_data_doc[] = "\n\
-Get application data\n\
-\n\
-@return: The application data\n\
-";
-static PyObject *
-ssl_Connection_get_app_data(ssl_ConnectionObj *self, PyObject *args)
-{
-    if (!PyArg_ParseTuple(args, ":get_app_data"))
-        return NULL;
-
-    Py_INCREF(self->app_data);
-    return self->app_data;
-}
-
-static char ssl_Connection_set_app_data_doc[] = "\n\
-Set application data\n\
-\n\
-@param data - The application data\n\
-@return: None\n\
-";
-static PyObject *
-ssl_Connection_set_app_data(ssl_ConnectionObj *self, PyObject *args)
-{
-    PyObject *data;
-
-    if (!PyArg_ParseTuple(args, "O:set_app_data", &data))
-        return NULL;
-
-    Py_DECREF(self->app_data);
-    Py_INCREF(data);
-    self->app_data = data;
-
-    Py_INCREF(Py_None);
-    return Py_None;
-}
-
-static char ssl_Connection_get_shutdown_doc[] = "\n\
-Get shutdown state\n\
-\n\
-@return: The shutdown state, a bitvector of SENT_SHUTDOWN, RECEIVED_SHUTDOWN.\n\
-";
-static PyObject *
-ssl_Connection_get_shutdown(ssl_ConnectionObj *self, PyObject *args)
-{
-    if (!PyArg_ParseTuple(args, ":get_shutdown"))
-        return NULL;
-
-    return PyLong_FromLong((long)SSL_get_shutdown(self->ssl));
-}
-
-static char ssl_Connection_set_shutdown_doc[] = "\n\
-Set shutdown state\n\
-\n\
-@param state - bitvector of SENT_SHUTDOWN, RECEIVED_SHUTDOWN.\n\
-@return: None\n\
-";
-static PyObject *
-ssl_Connection_set_shutdown(ssl_ConnectionObj *self, PyObject *args)
-{
-    int shutdown;
-
-    if (!PyArg_ParseTuple(args, "i:set_shutdown", &shutdown))
-        return NULL;
-
-    SSL_set_shutdown(self->ssl, shutdown);
-    Py_INCREF(Py_None);
-    return Py_None;
-}
-
-static char ssl_Connection_state_string_doc[] = "\n\
-Get a verbose state description\n\
-\n\
-@return: A string representing the state\n\
-";
-static PyObject *
-ssl_Connection_state_string(ssl_ConnectionObj *self, PyObject *args)
-{
-    if (!PyArg_ParseTuple(args, ":state_string"))
-        return NULL;
-
-    return PyText_FromString(SSL_state_string_long(self->ssl));
-}
-
-static char ssl_Connection_client_random_doc[] = "\n\
-Get a copy of the client hello nonce.\n\
-\n\
-@return: A string representing the state\n\
-";
-static PyObject *
-ssl_Connection_client_random(ssl_ConnectionObj *self, PyObject *args)
-{
-    if (!PyArg_ParseTuple(args, ":client_random"))
-        return NULL;
-
-    if (self->ssl->session == NULL) {
-        Py_INCREF(Py_None);
-        return Py_None;
-    }
-    return PyBytes_FromStringAndSize( (const char *) self->ssl->s3->client_random, SSL3_RANDOM_SIZE);
-}
-
-static char ssl_Connection_server_random_doc[] = "\n\
-Get a copy of the server hello nonce.\n\
-\n\
-@return: A string representing the state\n\
-";
-static PyObject *
-ssl_Connection_server_random(ssl_ConnectionObj *self, PyObject *args)
-{
-    if (!PyArg_ParseTuple(args, ":server_random"))
-        return NULL;
-
-    if (self->ssl->session == NULL) {
-        Py_INCREF(Py_None);
-        return Py_None;
-    }
-    return PyBytes_FromStringAndSize( (const char *) self->ssl->s3->server_random, SSL3_RANDOM_SIZE);
-}
-
-static char ssl_Connection_master_key_doc[] = "\n\
-Get a copy of the master key.\n\
-\n\
-@return: A string representing the state\n\
-";
-static PyObject *
-ssl_Connection_master_key(ssl_ConnectionObj *self, PyObject *args)
-{
-    if (!PyArg_ParseTuple(args, ":master_key"))
-        return NULL;
-
-    if (self->ssl->session == NULL) {
-        Py_INCREF(Py_None);
-        return Py_None;
-    }
-    return PyBytes_FromStringAndSize( (const char *) self->ssl->session->master_key, self->ssl->session->master_key_length);
-}
-
-static char ssl_Connection_sock_shutdown_doc[] = "\n\
-See shutdown(2)\n\
-\n\
-@return: What the socket's shutdown() method returns\n\
-";
-static PyObject *
-ssl_Connection_sock_shutdown(ssl_ConnectionObj *self, PyObject *args)
-{
-    PyObject *meth, *ret;
-
-    if ((meth = PyObject_GetAttrString(self->socket, "shutdown")) == NULL)
-        return NULL;
-    ret = PyEval_CallObject(meth, args);
-    Py_DECREF(meth);
-    return ret;
-}
-
-static char ssl_Connection_get_peer_certificate_doc[] = "\n\
-Retrieve the other side's certificate (if any)\n\
-\n\
-@return: The peer's certificate\n\
-";
-static PyObject *
-ssl_Connection_get_peer_certificate(ssl_ConnectionObj *self, PyObject *args)
-{
-    X509 *cert;
-
-    if (!PyArg_ParseTuple(args, ":get_peer_certificate"))
-        return NULL;
-
-    cert = SSL_get_peer_certificate(self->ssl);
-    if (cert != NULL)
-    {
-        return (PyObject *)new_x509(cert, 1);
-    }
-    else
-    {
-        Py_INCREF(Py_None);
-        return Py_None;
-    }
-}
-
-static char ssl_Connection_get_peer_cert_chain_doc[] = "\n\
-Retrieve the other side's certificate (if any)\n\
-\n\
-@return: A list of X509 instances giving the peer's certificate chain,\n\
-         or None if it does not have one.\n\
-";
-static PyObject *
-ssl_Connection_get_peer_cert_chain(ssl_ConnectionObj *self, PyObject *args) {
-    STACK_OF(X509) *sk;
-    PyObject *chain;
-    crypto_X509Obj *cert;
-    Py_ssize_t i;
-
-    if (!PyArg_ParseTuple(args, ":get_peer_cert_chain")) {
-        return NULL;
-    }
-
-    sk = SSL_get_peer_cert_chain(self->ssl);
-    if (sk != NULL) {
-        chain = PyList_New(sk_X509_num(sk));
-        for (i = 0; i < sk_X509_num(sk); i++) {
-            cert = new_x509(sk_X509_value(sk, i), 1);
-            if (!cert) {
-                /* XXX Untested */
-                Py_DECREF(chain);
-                return NULL;
-            }
-            CRYPTO_add(&cert->x509->references, 1, CRYPTO_LOCK_X509);
-            PyList_SET_ITEM(chain, i, (PyObject *)cert);
-        }
-        return chain;
-    } else {
-        Py_INCREF(Py_None);
-        return Py_None;
-    }
-
-}
-
-static char ssl_Connection_want_read_doc[] = "\n\
-Checks if more data has to be read from the transport layer to complete an\n\
-operation.\n\
-\n\
-@return: True iff more data has to be read\n\
-";
-static PyObject *
-ssl_Connection_want_read(ssl_ConnectionObj *self, PyObject *args)
-{
-    if (!PyArg_ParseTuple(args, ":want_read"))
-        return NULL;
-
-    return PyLong_FromLong((long)SSL_want_read(self->ssl));
-}
-
-static char ssl_Connection_want_write_doc[] = "\n\
-Checks if there is data to write to the transport layer to complete an\n\
-operation.\n\
-\n\
-@return: True iff there is data to write\n\
-";
-static PyObject *
-ssl_Connection_want_write(ssl_ConnectionObj *self, PyObject *args)
-{
-    if (!PyArg_ParseTuple(args, ":want_write"))
-        return NULL;
-
-    return PyLong_FromLong((long)SSL_want_write(self->ssl));
-}
-
-/*
- * Member methods in the Connection object
- * ADD_METHOD(name) expands to a correct PyMethodDef declaration
- *   {  'name', (PyCFunction)ssl_Connection_name, METH_VARARGS }
- * for convenience
- * ADD_ALIAS(name,real) creates an "alias" of the ssl_Connection_real
- * function with the name 'name'
- */
-#define ADD_METHOD(name)        \
-    { #name, (PyCFunction)ssl_Connection_##name, METH_VARARGS, ssl_Connection_##name##_doc }
-#define ADD_ALIAS(name,real)    \
-    { #name, (PyCFunction)ssl_Connection_##real, METH_VARARGS, ssl_Connection_##real##_doc }
-static PyMethodDef ssl_Connection_methods[] =
-{
-    ADD_METHOD(get_context),
-#if SNI_EXTENSION_SUPPORT
-    ADD_METHOD(set_context),
-    ADD_METHOD(get_servername),
-    ADD_METHOD(set_tlsext_host_name),
-#endif
-    ADD_METHOD(pending),
-    ADD_METHOD(send),
-    ADD_ALIAS (write, send),
-    ADD_METHOD(sendall),
-    ADD_METHOD(recv),
-    ADD_ALIAS (read, recv),
-    ADD_METHOD(bio_read),
-    ADD_METHOD(bio_write),
-    ADD_METHOD(renegotiate),
-    ADD_METHOD(do_handshake),
-#if defined(OPENSSL_VERSION_NUMBER) && OPENSSL_VERSION_NUMBER >= 0x00907000L
-    ADD_METHOD(renegotiate_pending),
-#endif
-    ADD_METHOD(total_renegotiations),
-    ADD_METHOD(connect),
-    ADD_METHOD(connect_ex),
-    ADD_METHOD(accept),
-    ADD_METHOD(bio_shutdown),
-    ADD_METHOD(shutdown),
-    ADD_METHOD(get_cipher_list),
-    ADD_METHOD(get_client_ca_list),
-    ADD_METHOD(makefile),
-    ADD_METHOD(get_app_data),
-    ADD_METHOD(set_app_data),
-    ADD_METHOD(get_shutdown),
-    ADD_METHOD(set_shutdown),
-    ADD_METHOD(state_string),
-    ADD_METHOD(server_random),
-    ADD_METHOD(client_random),
-    ADD_METHOD(master_key),
-    ADD_METHOD(sock_shutdown),
-    ADD_METHOD(get_peer_certificate),
-    ADD_METHOD(get_peer_cert_chain),
-    ADD_METHOD(want_read),
-    ADD_METHOD(want_write),
-    ADD_METHOD(set_accept_state),
-    ADD_METHOD(set_connect_state),
-    { NULL, NULL }
-};
-#undef ADD_ALIAS
-#undef ADD_METHOD
-
-static char ssl_Connection_doc[] = "\n\
-Connection(context, socket) -> Connection instance\n\
-\n\
-Create a new Connection object, using the given OpenSSL.SSL.Context instance\n\
-and socket.\n\
-\n\
-@param context: An SSL Context to use for this connection\n\
-@param socket: The socket to use for transport layer\n\
-";
-
-/*
- * Initializer used by ssl_Connection_new and ssl_Connection_New.  *Not*
- * tp_init.  This takes an already allocated ssl_ConnectionObj, a context, and
- * a optionally a socket, and glues them all together.
- */
-static ssl_ConnectionObj*
-ssl_Connection_init(ssl_ConnectionObj *self, ssl_ContextObj *ctx, PyObject *sock) {
-    int fd;
-
-    Py_INCREF(ctx);
-    self->context = ctx;
-
-    Py_INCREF(sock);
-    self->socket = sock;
-
-    self->ssl = NULL;
-    self->from_ssl = NULL;
-    self->into_ssl = NULL;
-
-    Py_INCREF(Py_None);
-    self->app_data = Py_None;
-
-    self->tstate = NULL;
-
-    self->ssl = SSL_new(self->context->ctx);
-    SSL_set_app_data(self->ssl, self);
-
-    if (self->socket == Py_None)
-    {
-        /* If it's not a socket or file, treat it like a memory buffer, 
-         * so crazy people can do things like EAP-TLS. */
-        self->into_ssl = BIO_new(BIO_s_mem());
-        self->from_ssl = BIO_new(BIO_s_mem());
-        if (self->into_ssl == NULL || self->from_ssl == NULL)
-            goto error;
-        SSL_set_bio(self->ssl, self->into_ssl, self->from_ssl);
-    } 
-    else 
-    {
-        fd = PyObject_AsFileDescriptor(self->socket);
-        if (fd < 0)
-        {
-            Py_DECREF(self);
-            return NULL;
-        } 
-        else 
-        {
-            SSL_set_fd(self->ssl, (SOCKET_T)fd);
-        }
-    }
-    return self;
-
-error:
-    BIO_free(self->into_ssl);  /* NULL safe */
-    BIO_free(self->from_ssl);  /* NULL safe */
-    Py_DECREF(self);
-    return NULL;
-}
-
-/*
- * Constructor for Connection objects
- *
- * Arguments: ctx  - An SSL Context to use for this connection
- *            sock - The socket to use for transport layer
- * Returns:   The newly created Connection object
- */
-ssl_ConnectionObj *
-ssl_Connection_New(ssl_ContextObj *ctx, PyObject *sock) {
-    ssl_ConnectionObj *self;
-
-    self = PyObject_GC_New(ssl_ConnectionObj, &ssl_Connection_Type);
-    if (self == NULL) {
-        return NULL;
-    }
-    self = ssl_Connection_init(self, ctx, sock);
-    if (self == NULL) {
-        return NULL;
-    }
-    PyObject_GC_Track((PyObject *)self);
-    return self;
-}
-
-static PyObject*
-ssl_Connection_new(PyTypeObject *subtype, PyObject *args, PyObject *kwargs) {
-    ssl_ConnectionObj *self;
-    ssl_ContextObj *ctx;
-    PyObject *sock;
-    static char *kwlist[] = {"context", "socket", NULL};
-
-    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!O:Connection", kwlist,
-                                     &ssl_Context_Type, &ctx, &sock)) {
-        return NULL;
-    }
-
-    self = (ssl_ConnectionObj *)subtype->tp_alloc(subtype, 1);
-    if (self == NULL) {
-        return NULL;
-    }
-
-    return (PyObject *)ssl_Connection_init(self, ctx, sock);
-}
-
-/*
- * Find attribute
- *
- * Arguments: self - The Connection object
- *            name - The attribute name
- * Returns:   A Python object for the attribute, or NULL if something went
- *            wrong
- */
-static PyObject *
-ssl_Connection_getattro(ssl_ConnectionObj *self, PyObject *nameobj) {
-    PyObject *meth;
-
-    meth = PyObject_GenericGetAttr((PyObject*)self, nameobj);
-    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_AttributeError)) {
-        PyErr_Clear();
-        /* Try looking it up in the "socket" instead. */
-        meth = PyObject_GenericGetAttr(self->socket, nameobj);
-    }
-
-    return meth;
-}
-
-/*
- * Call the visitproc on all contained objects.
- *
- * Arguments: self - The Connection object
- *            visit - Function to call
- *            arg - Extra argument to visit
- * Returns:   0 if all goes well, otherwise the return code from the first
- *            call that gave non-zero result.
- */
-static int
-ssl_Connection_traverse(ssl_ConnectionObj *self, visitproc visit, void *arg)
-{
-    int ret = 0;
-
-    if (ret == 0 && self->context != NULL)
-        ret = visit((PyObject *)self->context, arg);
-    if (ret == 0 && self->socket != NULL)
-        ret = visit(self->socket, arg);
-    if (ret == 0 && self->app_data != NULL)
-        ret = visit(self->app_data, arg);
-    return ret;
-}
-
-/*
- * Decref all contained objects and zero the pointers.
- *
- * Arguments: self - The Connection object
- * Returns:   Always 0.
- */
-static int
-ssl_Connection_clear(ssl_ConnectionObj *self)
-{
-    Py_XDECREF(self->context);
-    self->context = NULL;
-    Py_XDECREF(self->socket);
-    self->socket = NULL;
-    Py_XDECREF(self->app_data);
-    self->app_data = NULL;
-    self->into_ssl = NULL; /* was cleaned up by SSL_free() */
-    self->from_ssl = NULL; /* was cleaned up by SSL_free() */
-    return 0;
-}
-
-/*
- * Deallocate the memory used by the Connection object
- *
- * Arguments: self - The Connection object
- * Returns:   None
- */
-static void
-ssl_Connection_dealloc(ssl_ConnectionObj *self)
-{
-    PyObject_GC_UnTrack(self);
-    if (self->ssl != NULL)
-        SSL_free(self->ssl);
-    ssl_Connection_clear(self);
-    PyObject_GC_Del(self);
-}
-
-PyTypeObject ssl_Connection_Type = {
-    PyOpenSSL_HEAD_INIT(&PyType_Type, 0)
-    "OpenSSL.SSL.Connection",
-    sizeof(ssl_ConnectionObj),
-    0,
-    (destructor)ssl_Connection_dealloc,
-    NULL, /* print */
-    NULL, /* tp_getattr */
-    NULL, /* setattr */
-    NULL, /* compare */
-    NULL, /* repr */
-    NULL, /* as_number */
-    NULL, /* as_sequence */
-    NULL, /* as_mapping */
-    NULL, /* hash */
-    NULL, /* call */
-    NULL, /* str */
-    (getattrofunc)ssl_Connection_getattro, /* getattro */
-    NULL, /* setattro */
-    NULL, /* as_buffer */
-    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC,
-    ssl_Connection_doc, /* doc */
-    (traverseproc)ssl_Connection_traverse,
-    (inquiry)ssl_Connection_clear,
-    NULL, /* tp_richcompare */
-    0, /* tp_weaklistoffset */
-    NULL, /* tp_iter */
-    NULL, /* tp_iternext */
-    ssl_Connection_methods, /* tp_methods */
-    NULL, /* tp_members */
-    NULL, /* tp_getset */
-    NULL, /* tp_base */
-    NULL, /* tp_dict */
-    NULL, /* tp_descr_get */
-    NULL, /* tp_descr_set */
-    0, /* tp_dictoffset */
-    NULL, /* tp_init */
-    NULL, /* tp_alloc */
-    ssl_Connection_new, /* tp_new */
-};
-
-
-/*
- * Initiailze the Connection part of the SSL sub module
- *
- * Arguments: dict - The OpenSSL.SSL module
- * Returns:   1 for success, 0 otherwise
- */
-int
-init_ssl_connection(PyObject *module) {
-
-    if (PyType_Ready(&ssl_Connection_Type) < 0) {
-        return 0;
-    }
-
-    /* PyModule_AddObject steals a reference.
-     */
-    Py_INCREF((PyObject *)&ssl_Connection_Type);
-    if (PyModule_AddObject(module, "Connection", (PyObject *)&ssl_Connection_Type) != 0) {
-        return 0;
-    }
-
-    /* PyModule_AddObject steals a reference.
-     */
-    Py_INCREF((PyObject *)&ssl_Connection_Type);
-    if (PyModule_AddObject(module, "ConnectionType", (PyObject *)&ssl_Connection_Type) != 0) {
-        return 0;
-    }
-
-    return 1;
-}
-
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/ssl/connection.h hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/ssl/connection.h
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/ssl/connection.h	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/ssl/connection.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,53 +0,0 @@
-/*
- * connection.h
- *
- * Copyright (C) AB Strakt
- * See LICENSE for details.
- *
- * Export SSL Connection data structures and functions.
- * See the file RATIONALE for a short explanation of why this module was written.
- *
- * Reviewed 2001-07-23
- *
- */
-#ifndef PyOpenSSL_SSL_CONNECTION_H_
-#define PyOpenSSL_SSL_CONNECTION_H_
-
-#include <Python.h>
-#include <openssl/ssl.h>
-
-/* shamelessly stolen from socketmodule.c */
-#ifdef MS_WINDOWS
-#  include <winsock.h>
-typedef SOCKET SOCKET_T;
-#  ifdef MS_WIN64
-#    define SIZEOF_SOCKET_T 8
-#  else
-#    define SIZEOF_SOCKET_T 4
-#  endif
-#else
-typedef int SOCKET_T;
-#  define SIZEOF_SOCKET_T SIZEOF_INT
-#endif
-
-
-extern  int                      init_ssl_connection      (PyObject *);
-
-extern  PyTypeObject      ssl_Connection_Type;
-
-#define ssl_Connection_Check(v) ((v)->ob_type == &ssl_Connection_Type)
-
-typedef struct {
-    PyObject_HEAD
-    SSL                 *ssl;
-    ssl_ContextObj      *context;
-    PyObject            *socket;
-    PyThreadState       *tstate; /* This field is no longer used. */
-    PyObject            *app_data;
-    BIO                 *into_ssl, *from_ssl;  /* for connections without file descriptors */
-} ssl_ConnectionObj;
-
-
-
-#endif
-
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/ssl/context.c hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/ssl/context.c
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/ssl/context.c	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/ssl/context.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1427 +0,0 @@
-/*
- * context.c
- *
- * Copyright (C) AB Strakt
- * Copyright (C) Jean-Paul Calderone
- * See LICENSE for details.
- *
- * SSL Context objects and their methods.
- * See the file RATIONALE for a short explanation of why this module was written.
- *
- * Reviewed 2001-07-23
- */
-#include <Python.h>
-
-#if PY_VERSION_HEX >= 0x02050000
-# define PYARG_PARSETUPLE_FORMAT const char
-# define PYOBJECT_GETATTRSTRING_TYPE const char*
-#else
-# define PYARG_PARSETUPLE_FORMAT char
-# define PYOBJECT_GETATTRSTRING_TYPE char*
-#endif
-
-#ifndef MS_WINDOWS
-#  include <sys/socket.h>
-#  include <netinet/in.h>
-#  if !(defined(__BEOS__) || defined(__CYGWIN__))
-#    include <netinet/tcp.h>
-#  endif
-#else
-#  include <winsock.h>
-#  include <wincrypt.h>
-#endif
-
-#define SSL_MODULE
-#include "ssl.h"
-
-/*
- * CALLBACKS
- *
- * Callbacks work like this: We provide a "global" callback in C which
- * transforms the arguments into a Python argument tuple and calls the
- * corresponding Python callback, and then parsing the return value back into
- * things the C function can return.
- *
- * Three caveats:
- *  + How do we find the Context object where the Python callbacks are stored?
- *  + What about multithreading and execution frames?
- *  + What about Python callbacks that raise exceptions?
- *
- * The solution to the first issue is trivial if the callback provides
- * "userdata" functionality. Since the only callbacks that don't provide
- * userdata do provide a pointer to an SSL structure, we can associate an SSL
- * object and a Connection one-to-one via the SSL_set/get_app_data()
- * functions.
- *
- * The solution to the other issue is to rewrite the Py_BEGIN_ALLOW_THREADS
- * macro allowing it (or rather a new macro) to specify where to save the
- * thread state (in our case, as a member of the Connection/Context object) so
- * we can retrieve it again before calling the Python callback.
- */
-
-/*
- * Globally defined passphrase callback.  This is called from OpenSSL
- * internally.  The GIL will not be held when this function is invoked.  It
- * must not be held when the function returns.
- *
- * Arguments: buf    - Buffer to store the returned passphrase in
- *            maxlen - Maximum length of the passphrase
- *            verify - If true, the passphrase callback should ask for a
- *                     password twice and verify they're equal. If false, only
- *                     ask once.
- *            arg    - User data, always a Context object
- * Returns:   The length of the password if successful, 0 otherwise
- */
-static int
-global_passphrase_callback(char *buf, int maxlen, int verify, void *arg)
-{
-    /*
-     * Initialize len here because we're always going to return it, and we
-     * might jump to the return before it gets initialized in any other way.
-     */
-    int len = 0;
-    char *str;
-    PyObject *argv, *ret = NULL;
-    ssl_ContextObj *ctx = (ssl_ContextObj *)arg;
-
-    /*
-     * GIL isn't held yet.  First things first - acquire it, or any Python API
-     * we invoke might segfault or blow up the sun.  The reverse will be done
-     * before returning.
-     */
-    MY_END_ALLOW_THREADS(ctx->tstate);
-
-    /* The Python callback is called with a (maxlen,verify,userdata) tuple */
-    argv = Py_BuildValue("(iiO)", maxlen, verify, ctx->passphrase_userdata);
-
-    /*
-     * XXX Didn't check argv to see if it was NULL. -exarkun
-     */
-    ret = PyEval_CallObject(ctx->passphrase_callback, argv);
-    Py_DECREF(argv);
-
-    if (ret == NULL) {
-        /*
-         * The callback raised an exception.  It will be raised by whatever
-         * Python API triggered this callback.
-         */
-        goto out;
-    }
-
-    if (!PyObject_IsTrue(ret)) {
-        /*
-         * Returned "", or None, or something.  Treat it as no passphrase.
-         */
-        Py_DECREF(ret);
-	goto out;
-    }
-
-    if (!PyBytes_Check(ret)) {
-        /*
-         * XXX Returned something that wasn't a string.  This is bogus.  We'll
-         * return 0 and OpenSSL will treat it as an error, resulting in an
-         * exception from whatever Python API triggered this callback.
-         */
-        Py_DECREF(ret);
-        goto out;
-    }
-
-    len = PyBytes_Size(ret);
-    if (len > maxlen) {
-        /*
-         * Returned more than we said they were allowed to return.  Just
-         * truncate it.  Might be better to raise an exception,
-         * instead. -exarkun
-         */
-        len = maxlen;
-    }
-
-    str = PyBytes_AsString(ret);
-    strncpy(buf, str, len);
-    Py_XDECREF(ret);
-
-  out:
-    /*
-     * This function is returning into OpenSSL.  Release the GIL again.
-     */
-    MY_BEGIN_ALLOW_THREADS(ctx->tstate);
-    return len;
-}
-
-/*
- * Globally defined verify callback
- *
- * Arguments: ok       - True everything is OK "so far", false otherwise
- *            x509_ctx - Contains the certificate being checked, the current
- *                       error number and depth, and the Connection we're
- *                       dealing with
- * Returns:   True if everything is okay, false otherwise
- */
-static int
-global_verify_callback(int ok, X509_STORE_CTX *x509_ctx)
-{
-    PyObject *argv, *ret;
-    SSL *ssl;
-    ssl_ConnectionObj *conn;
-    crypto_X509Obj *cert;
-    int errnum, errdepth, c_ret;
-
-    // Get Connection object to check thread state
-    ssl = (SSL *)X509_STORE_CTX_get_app_data(x509_ctx);
-    conn = (ssl_ConnectionObj *)SSL_get_app_data(ssl);
-
-    MY_END_ALLOW_THREADS(conn->tstate);
-
-    cert = new_x509(X509_STORE_CTX_get_current_cert(x509_ctx), 0);
-    errnum = X509_STORE_CTX_get_error(x509_ctx);
-    errdepth = X509_STORE_CTX_get_error_depth(x509_ctx);
-
-    argv = Py_BuildValue("(OOiii)", (PyObject *)conn, (PyObject *)cert,
-                                    errnum, errdepth, ok);
-    Py_DECREF(cert);
-    ret = PyEval_CallObject(conn->context->verify_callback, argv);
-    Py_DECREF(argv);
-
-    if (ret != NULL && PyObject_IsTrue(ret)) {
-        X509_STORE_CTX_set_error(x509_ctx, X509_V_OK);
-        Py_DECREF(ret);
-        c_ret = 1;
-    } else {
-        c_ret = 0;
-    }
-
-    MY_BEGIN_ALLOW_THREADS(conn->tstate);
-    return c_ret;
-}
-
-/*
- * Globally defined info callback.  This is called from OpenSSL internally.
- * The GIL will not be held when this function is invoked.  It must not be held
- * when the function returns.
- *
- * Arguments: ssl   - The Connection
- *            where - The part of the SSL code that called us
- *            _ret  - The return code of the SSL function that called us
- * Returns:   None
- */
-static void
-global_info_callback(const SSL *ssl, int where, int _ret)
-{
-    ssl_ConnectionObj *conn = (ssl_ConnectionObj *)SSL_get_app_data(ssl);
-    PyObject *argv, *ret;
-
-    /*
-     * GIL isn't held yet.  First things first - acquire it, or any Python API
-     * we invoke might segfault or blow up the sun.  The reverse will be done
-     * before returning.
-     */
-    MY_END_ALLOW_THREADS(conn->tstate);
-
-    argv = Py_BuildValue("(Oii)", (PyObject *)conn, where, _ret);
-    ret = PyEval_CallObject(conn->context->info_callback, argv);
-    Py_DECREF(argv);
-
-    if (ret == NULL) {
-        /*
-         * XXX - This should be reported somehow. -exarkun
-         */
-        PyErr_Clear();
-    } else {
-        Py_DECREF(ret);
-    }
-
-    /*
-     * This function is returning into OpenSSL.  Release the GIL again.
-     */
-    MY_BEGIN_ALLOW_THREADS(conn->tstate);
-    return;
-}
-
-#if SNI_EXTENSION_SUPPORT
-/*
- * Globally defined TLS extension server name callback.  This is called from
- * OpenSSL internally.  The GIL will not be held when this function is invoked.
- * It must not be held when the function returns.
- *
- * ssl represents the connection this callback is for
- *
- * alert is a pointer to the alert value which maybe will be emitted to the
- * client if there is an error handling the client hello (which contains the
- * server name).  This is an out parameter, maybe.
- *
- * arg is an arbitrary pointer specified by SSL_CTX_set_tlsext_servername_arg.
- * It will be NULL for all pyOpenSSL uses.
- */
-static int
-global_tlsext_servername_callback(const SSL *ssl, int *alert, void *arg) {
-    int result = 0;
-    PyObject *argv, *ret;
-    ssl_ConnectionObj *conn = (ssl_ConnectionObj *)SSL_get_app_data(ssl);
-
-    /*
-     * GIL isn't held yet.  First things first - acquire it, or any Python API
-     * we invoke might segfault or blow up the sun.  The reverse will be done
-     * before returning.
-     */
-    MY_END_ALLOW_THREADS(conn->tstate);
-
-    argv = Py_BuildValue("(O)", (PyObject *)conn);
-    ret = PyEval_CallObject(conn->context->tlsext_servername_callback, argv);
-    Py_DECREF(argv);
-    Py_DECREF(ret);
-
-    /*
-     * This function is returning into OpenSSL.  Release the GIL again.
-     */
-    MY_BEGIN_ALLOW_THREADS(conn->tstate);
-    return result;
-}
-#endif
-
-/*
- * More recent builds of OpenSSL may have SSLv2 completely disabled.
- */
-#ifdef OPENSSL_NO_SSL2
-#define SSLv2_METHOD_TEXT ""
-#else
-#define SSLv2_METHOD_TEXT "SSLv2_METHOD, "
-#endif
-
-
-static char ssl_Context_doc[] = "\n\
-Context(method) -> Context instance\n\
-\n\
-OpenSSL.SSL.Context instances define the parameters for setting up new SSL\n\
-connections.\n\
-\n\
-@param method: One of " SSLv2_METHOD_TEXT "SSLv3_METHOD, SSLv23_METHOD, or\n\
-               TLSv1_METHOD.\n\
-";
-
-#undef SSLv2_METHOD_TEXT
-
-static char ssl_Context_load_verify_locations_doc[] = "\n\
-Let SSL know where we can find trusted certificates for the certificate\n\
-chain\n\
-\n\
-@param cafile: In which file we can find the certificates\n\
-@param capath: In which directory we can find the certificates\n\
-@return: None\n\
-";
-static PyObject *
-ssl_Context_load_verify_locations(ssl_ContextObj *self, PyObject *args) {
-    char *cafile = NULL;
-    char *capath = NULL;
-
-    if (!PyArg_ParseTuple(args, "z|z:load_verify_locations", &cafile, &capath)) {
-        return NULL;
-    }
-
-    if (!SSL_CTX_load_verify_locations(self->ctx, cafile, capath))
-    {
-        exception_from_error_queue(ssl_Error);
-        return NULL;
-    }
-    else
-    {
-        Py_INCREF(Py_None);
-        return Py_None;
-    }
-}
-
-static char ssl_Context_set_default_verify_paths_doc[] = "\n\
-Use the platform-specific CA certificate locations\n\
-\n\
-@return: None\n\
-";
-static PyObject *
-ssl_Context_set_default_verify_paths(ssl_ContextObj *self, PyObject *args) {
-    if (!PyArg_ParseTuple(args, ":set_default_verify_paths")) {
-        return NULL;
-    }
-
-    /*
-     * XXX Error handling for SSL_CTX_set_default_verify_paths is untested.
-     * -exarkun
-     */
-    if (!SSL_CTX_set_default_verify_paths(self->ctx)) {
-        exception_from_error_queue(ssl_Error);
-        return NULL;
-    }
-    Py_INCREF(Py_None);
-    return Py_None;
-};
-
-
-static char ssl_Context_set_passwd_cb_doc[] = "\n\
-Set the passphrase callback\n\
-\n\
-@param callback: The Python callback to use\n\
-@param userdata: (optional) A Python object which will be given as\n\
-                 argument to the callback\n\
-@return: None\n\
-";
-static PyObject *
-ssl_Context_set_passwd_cb(ssl_ContextObj *self, PyObject *args)
-{
-    PyObject *callback = NULL, *userdata = Py_None;
-
-    if (!PyArg_ParseTuple(args, "O|O:set_passwd_cb", &callback, &userdata))
-        return NULL;
-
-    if (!PyCallable_Check(callback))
-    {
-        PyErr_SetString(PyExc_TypeError, "expected PyCallable");
-        return NULL;
-    }
-
-    Py_DECREF(self->passphrase_callback);
-    Py_INCREF(callback);
-    self->passphrase_callback = callback;
-    SSL_CTX_set_default_passwd_cb(self->ctx, global_passphrase_callback);
-
-    Py_DECREF(self->passphrase_userdata);
-    Py_INCREF(userdata);
-    self->passphrase_userdata = userdata;
-    SSL_CTX_set_default_passwd_cb_userdata(self->ctx, (void *)self);
-
-    Py_INCREF(Py_None);
-    return Py_None;
-}
-
-static PyTypeObject *
-type_modified_error(const char *name) {
-    PyErr_Format(PyExc_RuntimeError,
-                 "OpenSSL.crypto's '%s' attribute has been modified",
-                 name);
-    return NULL;
-}
-
-static PyTypeObject *
-import_crypto_type(const char *name, size_t objsize) {
-    PyObject *module, *type, *name_attr;
-    PyTypeObject *res;
-    int right_name;
-
-    module = PyImport_ImportModule("OpenSSL.crypto");
-    if (module == NULL) {
-        return NULL;
-    }
-    type = PyObject_GetAttrString(module, (PYOBJECT_GETATTRSTRING_TYPE)name);
-    Py_DECREF(module);
-    if (type == NULL) {
-        return NULL;
-    }
-    if (!(PyType_Check(type))) {
-        Py_DECREF(type);
-        return type_modified_error(name);
-    }
-    name_attr = PyObject_GetAttrString(type, "__name__");
-    if (name_attr == NULL) {
-        Py_DECREF(type);
-        return NULL;
-    }
-
-#ifdef PY3
-    {
-        PyObject* asciiname = PyUnicode_AsASCIIString(name_attr);
-        Py_DECREF(name_attr);
-        name_attr = asciiname;
-    }
-#endif
-    right_name = (PyBytes_CheckExact(name_attr) &&
-                  strcmp(name, PyBytes_AsString(name_attr)) == 0);
-    Py_DECREF(name_attr);
-    res = (PyTypeObject *)type;
-    if (!right_name || res->tp_basicsize != objsize) {
-        Py_DECREF(type);
-        return type_modified_error(name);
-    }
-    return res;
-}
-
-static crypto_X509Obj *
-parse_certificate_argument(const char* format, PyObject* args) {
-    static PyTypeObject *crypto_X509_type = NULL;
-    crypto_X509Obj *cert;
-
-    if (!crypto_X509_type) {
-        crypto_X509_type = import_crypto_type("X509", sizeof(crypto_X509Obj));
-        if (!crypto_X509_type) {
-            return NULL;
-        }
-    }
-    if (!PyArg_ParseTuple(args, (PYARG_PARSETUPLE_FORMAT *)format,
-                          crypto_X509_type, &cert)) {
-        return NULL;
-    }
-    return cert;
-}
-
-static char ssl_Context_add_extra_chain_cert_doc[] = "\n\
-Add certificate to chain\n\
-\n\
-@param certobj: The X509 certificate object to add to the chain\n\
-@return: None\n\
-";
-
-static PyObject *
-ssl_Context_add_extra_chain_cert(ssl_ContextObj *self, PyObject *args)
-{
-    X509* cert_original;
-    crypto_X509Obj *cert = parse_certificate_argument(
-        "O!:add_extra_chain_cert", args);
-    if (cert == NULL)
-    {
-        return NULL;
-    }
-    if (!(cert_original = X509_dup(cert->x509)))
-    {
-        /* exception_from_error_queue(ssl_Error); */
-        PyErr_SetString(PyExc_RuntimeError, "X509_dup failed");
-        return NULL;
-    }
-    if (!SSL_CTX_add_extra_chain_cert(self->ctx, cert_original))
-    {
-        X509_free(cert_original);
-        exception_from_error_queue(ssl_Error);
-        return NULL;
-    }
-    else
-    {
-        Py_INCREF(Py_None);
-        return Py_None;
-    }
-}
-
-
-static char ssl_Context_use_certificate_chain_file_doc[] = "\n\
-Load a certificate chain from a file\n\
-\n\
-@param certfile: The name of the certificate chain file\n\
-@return: None\n\
-";
-static PyObject *
-ssl_Context_use_certificate_chain_file(ssl_ContextObj *self, PyObject *args)
-{
-    char *certfile;
-
-    if (!PyArg_ParseTuple(args, "s:use_certificate_chain_file", &certfile))
-        return NULL;
-
-    if (!SSL_CTX_use_certificate_chain_file(self->ctx, certfile))
-    {
-        exception_from_error_queue(ssl_Error);
-        return NULL;
-    }
-    else
-    {
-        Py_INCREF(Py_None);
-        return Py_None;
-    }
-}
-
-
-static char ssl_Context_use_certificate_file_doc[] = "\n\
-Load a certificate from a file\n\
-\n\
-@param certfile: The name of the certificate file\n\
-@param filetype: (optional) The encoding of the file, default is PEM\n\
-@return: None\n\
-";
-static PyObject *
-ssl_Context_use_certificate_file(ssl_ContextObj *self, PyObject *args)
-{
-    char *certfile;
-    int filetype = SSL_FILETYPE_PEM;
-
-    if (!PyArg_ParseTuple(args, "s|i:use_certificate_file", &certfile, &filetype))
-        return NULL;
-
-    if (!SSL_CTX_use_certificate_file(self->ctx, certfile, filetype))
-    {
-        exception_from_error_queue(ssl_Error);
-        return NULL;
-    }
-    else
-    {
-        Py_INCREF(Py_None);
-        return Py_None;
-    }
-}
-
-static char ssl_Context_use_certificate_doc[] = "\n\
-Load a certificate from a X509 object\n\
-\n\
-@param cert: The X509 object\n\
-@return: None\n\
-";
-static PyObject *
-ssl_Context_use_certificate(ssl_ContextObj *self, PyObject *args)
-{
-    crypto_X509Obj *cert = parse_certificate_argument(
-        "O!:use_certificate", args);
-    if (cert == NULL) {
-        return NULL;
-    }
-    
-    if (!SSL_CTX_use_certificate(self->ctx, cert->x509))
-    {
-        exception_from_error_queue(ssl_Error);
-        return NULL;
-    }
-    else
-    {
-        Py_INCREF(Py_None);
-        return Py_None;
-    }
-}
-
-static char ssl_Context_use_privatekey_file_doc[] = "\n\
-Load a private key from a file\n\
-\n\
-@param keyfile: The name of the key file\n\
-@param filetype: (optional) The encoding of the file, default is PEM\n\
-@return: None\n\
-";
-static PyObject *
-ssl_Context_use_privatekey_file(ssl_ContextObj *self, PyObject *args)
-{
-    char *keyfile;
-    int filetype = SSL_FILETYPE_PEM, ret;
-
-    if (!PyArg_ParseTuple(args, "s|i:use_privatekey_file", &keyfile, &filetype))
-        return NULL;
-
-    MY_BEGIN_ALLOW_THREADS(self->tstate);
-    ret = SSL_CTX_use_PrivateKey_file(self->ctx, keyfile, filetype);
-    MY_END_ALLOW_THREADS(self->tstate);
-
-    if (PyErr_Occurred())
-    {
-        flush_error_queue();
-        return NULL;
-    }
-
-    if (!ret)
-    {
-        exception_from_error_queue(ssl_Error);
-        return NULL;
-    }
-    else
-    {
-        Py_INCREF(Py_None);
-        return Py_None;
-    }
-}
-
-static char ssl_Context_use_privatekey_doc[] = "\n\
-Load a private key from a PKey object\n\
-\n\
-@param pkey: The PKey object\n\
-@return: None\n\
-";
-static PyObject *
-ssl_Context_use_privatekey(ssl_ContextObj *self, PyObject *args) {
-    static PyTypeObject *crypto_PKey_type = NULL;
-    crypto_PKeyObj *pkey;
-
-    if (!crypto_PKey_type) {
-        crypto_PKey_type = import_crypto_type("PKey", sizeof(crypto_PKeyObj));
-        if (!crypto_PKey_type) {
-            return NULL;
-        }
-    }
-    if (!PyArg_ParseTuple(args, "O!:use_privatekey", crypto_PKey_type, &pkey)) {
-        return NULL;
-    }
-
-    if (!SSL_CTX_use_PrivateKey(self->ctx, pkey->pkey)) {
-        exception_from_error_queue(ssl_Error);
-        return NULL;
-    } else {
-        Py_INCREF(Py_None);
-        return Py_None;
-    }
-}
-
-static char ssl_Context_check_privatekey_doc[] = "\n\
-Check that the private key and certificate match up\n\
-\n\
-@return: None (raises an exception if something's wrong)\n\
-";
-static PyObject *
-ssl_Context_check_privatekey(ssl_ContextObj *self, PyObject *args)
-{
-    if (!PyArg_ParseTuple(args, ":check_privatekey"))
-        return NULL;
-
-    if (!SSL_CTX_check_private_key(self->ctx))
-    {
-        exception_from_error_queue(ssl_Error);
-        return NULL;
-    }
-    else
-    {
-        Py_INCREF(Py_None);
-        return Py_None;
-    }
-}
-
-static char ssl_Context_load_client_ca_doc[] = "\n\
-Load the trusted certificates that will be sent to the client (basically\n \
-telling the client \"These are the guys I trust\").  Does not actually\n\
-imply any of the certificates are trusted; that must be configured\n\
-separately.\n\
-\n\
-@param cafile: The name of the certificates file\n\
-@return: None\n\
-";
-static PyObject *
-ssl_Context_load_client_ca(ssl_ContextObj *self, PyObject *args)
-{
-    char *cafile;
-
-    if (!PyArg_ParseTuple(args, "s:load_client_ca", &cafile))
-        return NULL;
-
-    SSL_CTX_set_client_CA_list(self->ctx, SSL_load_client_CA_file(cafile));
-
-    Py_INCREF(Py_None);
-    return Py_None;
-}
-
-static char ssl_Context_set_session_id_doc[] = "\n\
-Set the session identifier, this is needed if you want to do session\n\
-resumption (which, ironically, isn't implemented yet)\n\
-\n\
-@param buf: A Python object that can be safely converted to a string\n\
-@returns: None\n\
-";
-static PyObject *
-ssl_Context_set_session_id(ssl_ContextObj *self, PyObject *args)
-{
-    unsigned char *buf;
-    unsigned int len;
-
-    if (!PyArg_ParseTuple(args, "s#:set_session_id", &buf, &len))
-        return NULL;
-
-    if (!SSL_CTX_set_session_id_context(self->ctx, buf, len))
-    {
-        exception_from_error_queue(ssl_Error);
-        return NULL;
-    }
-    else
-    {
-        Py_INCREF(Py_None);
-        return Py_None;
-    }
-}
-
-static char ssl_Context_set_verify_doc[] = "\n\
-Set the verify mode and verify callback\n\
-\n\
-@param mode: The verify mode, this is either VERIFY_NONE or\n\
-             VERIFY_PEER combined with possible other flags\n\
-@param callback: The Python callback to use\n\
-@return: None\n\
-\n\
-See SSL_CTX_set_verify(3SSL) for further details.\n\
-";
-static PyObject *
-ssl_Context_set_verify(ssl_ContextObj *self, PyObject *args)
-{
-    int mode;
-    PyObject *callback = NULL;
-
-    if (!PyArg_ParseTuple(args, "iO:set_verify", &mode, &callback))
-        return NULL;
-
-    if (!PyCallable_Check(callback))
-    {
-        PyErr_SetString(PyExc_TypeError, "expected PyCallable");
-        return NULL;
-    }
-
-    Py_DECREF(self->verify_callback);
-    Py_INCREF(callback);
-    self->verify_callback = callback;
-    SSL_CTX_set_verify(self->ctx, mode, global_verify_callback);
-
-    Py_INCREF(Py_None);
-    return Py_None;
-}
-
-static char ssl_Context_set_verify_depth_doc[] = "\n\
-Set the verify depth\n\
-\n\
-@param depth: An integer specifying the verify depth\n\
-@return: None\n\
-";
-static PyObject *
-ssl_Context_set_verify_depth(ssl_ContextObj *self, PyObject *args)
-{
-    int depth;
-
-    if (!PyArg_ParseTuple(args, "i:set_verify_depth", &depth))
-        return NULL;
-
-    SSL_CTX_set_verify_depth(self->ctx, depth);
-    Py_INCREF(Py_None);
-    return Py_None;
-}
-
-static char ssl_Context_get_verify_mode_doc[] = "\n\
-Get the verify mode\n\
-\n\
-@return: The verify mode\n\
-";
-static PyObject *
-ssl_Context_get_verify_mode(ssl_ContextObj *self, PyObject *args)
-{
-    int mode;
-
-    if (!PyArg_ParseTuple(args, ":get_verify_mode"))
-        return NULL;
-
-    mode = SSL_CTX_get_verify_mode(self->ctx);
-    return PyLong_FromLong((long)mode);
-}
-
-static char ssl_Context_get_verify_depth_doc[] = "\n\
-Get the verify depth\n\
-\n\
-@return: The verify depth\n\
-";
-static PyObject *
-ssl_Context_get_verify_depth(ssl_ContextObj *self, PyObject *args)
-{
-    int depth;
-
-    if (!PyArg_ParseTuple(args, ":get_verify_depth"))
-        return NULL;
-
-    depth = SSL_CTX_get_verify_depth(self->ctx);
-    return PyLong_FromLong((long)depth);
-}
-
-static char ssl_Context_load_tmp_dh_doc[] = "\n\
-Load parameters for Ephemeral Diffie-Hellman\n\
-\n\
-@param dhfile: The file to load EDH parameters from\n\
-@return: None\n\
-";
-static PyObject *
-ssl_Context_load_tmp_dh(ssl_ContextObj *self, PyObject *args)
-{
-    char *dhfile;
-    BIO *bio;
-    DH *dh;
-
-    if (!PyArg_ParseTuple(args, "s:load_tmp_dh", &dhfile))
-        return NULL;
-
-    bio = BIO_new_file(dhfile, "r");
-    if (bio == NULL) {
-        exception_from_error_queue(ssl_Error);
-        return NULL;
-    }
-
-    dh = PEM_read_bio_DHparams(bio, NULL, NULL, NULL);
-    SSL_CTX_set_tmp_dh(self->ctx, dh);
-    DH_free(dh);
-    BIO_free(bio);
-
-    Py_INCREF(Py_None);
-    return Py_None;
-}
-
-static char ssl_Context_set_cipher_list_doc[] = "\n\
-Change the cipher list\n\
-\n\
-@param cipher_list: A cipher list, see ciphers(1)\n\
-@return: None\n\
-";
-static PyObject *
-ssl_Context_set_cipher_list(ssl_ContextObj *self, PyObject *args)
-{
-    char *cipher_list;
-
-    if (!PyArg_ParseTuple(args, "s:set_cipher_list", &cipher_list))
-        return NULL;
-
-    if (!SSL_CTX_set_cipher_list(self->ctx, cipher_list))
-    {
-        exception_from_error_queue(ssl_Error);
-        return NULL;
-    }
-    else
-    {
-        Py_INCREF(Py_None);
-        return Py_None;
-    }
-}
-
-static char ssl_Context_set_client_ca_list_doc[] = "\n\
-Set the list of preferred client certificate signers for this server context.\n\
-\n\
-This list of certificate authorities will be sent to the client when the\n\
-server requests a client certificate.\n\
-\n\
-@param certificate_authorities: a sequence of X509Names.\n\
-@return: None\n\
-";
-
-static PyObject *
-ssl_Context_set_client_ca_list(ssl_ContextObj *self, PyObject *args)
-{
-    static PyTypeObject *X509NameType;
-    PyObject *sequence, *tuple, *item;
-    crypto_X509NameObj *name;
-    X509_NAME *sslname;
-    STACK_OF(X509_NAME) *CANames;
-    Py_ssize_t length;
-    int i;
-
-    if (X509NameType == NULL) {
-        X509NameType = import_crypto_type("X509Name", sizeof(crypto_X509NameObj));
-        if (X509NameType == NULL) {
-            return NULL;
-        }
-    }
-    if (!PyArg_ParseTuple(args, "O:set_client_ca_list", &sequence)) {
-        return NULL;
-    }
-    tuple = PySequence_Tuple(sequence);
-    if (tuple == NULL) {
-        return NULL;
-    }
-    length = PyTuple_Size(tuple);
-    if (length >= INT_MAX) {
-        PyErr_SetString(PyExc_ValueError, "client CA list is too long");
-        Py_DECREF(tuple);
-        return NULL;
-    }
-    CANames = sk_X509_NAME_new_null();
-    if (CANames == NULL) {
-        Py_DECREF(tuple);
-        exception_from_error_queue(ssl_Error);
-        return NULL;
-    }
-    for (i = 0; i < length; i++) {
-        item = PyTuple_GetItem(tuple, i);
-        if (item->ob_type != X509NameType) {
-            PyErr_Format(PyExc_TypeError,
-                         "client CAs must be X509Name objects, not %s objects",
-                         item->ob_type->tp_name);
-            sk_X509_NAME_free(CANames);
-            Py_DECREF(tuple);
-            return NULL;
-        }
-        name = (crypto_X509NameObj *)item;
-        sslname = X509_NAME_dup(name->x509_name);
-        if (sslname == NULL) {
-            sk_X509_NAME_free(CANames);
-            Py_DECREF(tuple);
-            exception_from_error_queue(ssl_Error);
-            return NULL;
-        }
-        if (!sk_X509_NAME_push(CANames, sslname)) {
-            X509_NAME_free(sslname);
-            sk_X509_NAME_free(CANames);
-            Py_DECREF(tuple);
-            exception_from_error_queue(ssl_Error);
-            return NULL;
-        }
-    }
-    Py_DECREF(tuple);
-    SSL_CTX_set_client_CA_list(self->ctx, CANames);
-    Py_INCREF(Py_None);
-    return Py_None;
-}
-
-static char ssl_Context_add_client_ca_doc[] = "\n\
-Add the CA certificate to the list of preferred signers for this context.\n\
-\n\
-The list of certificate authorities will be sent to the client when the\n\
-server requests a client certificate.\n\
-\n\
-@param certificate_authority: certificate authority's X509 certificate.\n\
-@return: None\n\
-";
-
-static PyObject *
-ssl_Context_add_client_ca(ssl_ContextObj *self, PyObject *args)
-{
-    crypto_X509Obj *cert;
-
-    cert = parse_certificate_argument("O!:add_client_ca", args);
-    if (cert == NULL) {
-        return NULL;
-    }
-    if (!SSL_CTX_add_client_CA(self->ctx, cert->x509)) {
-        exception_from_error_queue(ssl_Error);
-        return NULL;
-    }
-    Py_INCREF(Py_None);
-    return Py_None;
-}
-
-static char ssl_Context_set_timeout_doc[] = "\n\
-Set session timeout\n\
-\n\
-@param timeout: The timeout in seconds\n\
-@return: The previous session timeout\n\
-";
-static PyObject *
-ssl_Context_set_timeout(ssl_ContextObj *self, PyObject *args)
-{
-    long t, ret;
-
-    if (!PyArg_ParseTuple(args, "l:set_timeout", &t))
-        return NULL;
-
-    ret = SSL_CTX_set_timeout(self->ctx, t);
-    return PyLong_FromLong(ret);
-}
-
-static char ssl_Context_get_timeout_doc[] = "\n\
-Get the session timeout\n\
-\n\
-@return: The session timeout\n\
-";
-static PyObject *
-ssl_Context_get_timeout(ssl_ContextObj *self, PyObject *args)
-{
-    long ret;
-
-    if (!PyArg_ParseTuple(args, ":get_timeout"))
-        return NULL;
-
-    ret = SSL_CTX_get_timeout(self->ctx);
-    return PyLong_FromLong(ret);
-}
-
-static char ssl_Context_set_info_callback_doc[] = "\n\
-Set the info callback\n\
-\n\
-@param callback: The Python callback to use\n\
-@return: None\n\
-";
-static PyObject *
-ssl_Context_set_info_callback(ssl_ContextObj *self, PyObject *args)
-{
-    PyObject *callback;
-
-    if (!PyArg_ParseTuple(args, "O:set_info_callback", &callback))
-        return NULL;
-
-    if (!PyCallable_Check(callback))
-    {
-        PyErr_SetString(PyExc_TypeError, "expected PyCallable");
-        return NULL;
-    }
-
-    Py_DECREF(self->info_callback);
-    Py_INCREF(callback);
-    self->info_callback = callback;
-    SSL_CTX_set_info_callback(self->ctx, global_info_callback);
-
-    Py_INCREF(Py_None);
-    return Py_None;
-}
-
-static char ssl_Context_get_app_data_doc[] = "\n\
-Get the application data (supplied via set_app_data())\n\
-\n\
-@return: The application data\n\
-";
-static PyObject *
-ssl_Context_get_app_data(ssl_ContextObj *self, PyObject *args)
-{
-    if (!PyArg_ParseTuple(args, ":get_app_data"))
-        return NULL;
-
-    Py_INCREF(self->app_data);
-    return self->app_data;
-}
-
-static char ssl_Context_set_app_data_doc[] = "\n\
-Set the application data (will be returned from get_app_data())\n\
-\n\
-@param data: Any Python object\n\
-@return: None\n\
-";
-static PyObject *
-ssl_Context_set_app_data(ssl_ContextObj *self, PyObject *args)
-{
-    PyObject *data;
-
-    if (!PyArg_ParseTuple(args, "O:set_app_data", &data))
-        return NULL;
-
-    Py_DECREF(self->app_data);
-    Py_INCREF(data);
-    self->app_data = data;
-
-    Py_INCREF(Py_None);
-    return Py_None;
-}
-
-static char ssl_Context_get_cert_store_doc[] = "\n\
-Get the certificate store for the context\n\
-\n\
-@return: A X509Store object\n\
-";
-static PyObject *
-ssl_Context_get_cert_store(ssl_ContextObj *self, PyObject *args)
-{
-    X509_STORE *store;
-
-    if (!PyArg_ParseTuple(args, ":get_cert_store"))
-        return NULL;
-
-    if ((store = SSL_CTX_get_cert_store(self->ctx)) == NULL)
-    {
-        Py_INCREF(Py_None);
-        return Py_None;
-    }
-    else
-    {
-        return (PyObject *)new_x509store(store, 0);
-    }
-}
-
-static char ssl_Context_set_options_doc[] = "\n\
-Add options. Options set before are not cleared!\n\
-\n\
-@param options: The options to add.\n\
-@return: The new option bitmask.\n\
-";
-static PyObject *
-ssl_Context_set_options(ssl_ContextObj *self, PyObject *args)
-{
-    long options;
-
-    if (!PyArg_ParseTuple(args, "l:set_options", &options))
-        return NULL;
-
-    return PyLong_FromLong(SSL_CTX_set_options(self->ctx, options));
-}
-
-#if SNI_EXTENSION_SUPPORT
-static char ssl_Context_set_tlsext_servername_callback_doc[] = "\n\
-Specify a callback function to be called when clients specify a server name.\n\
-\n\
-@param callback: The callback function.  It will be invoked with one\n\
-    argument, the Connection instance.\n\
-\n\
-";
-static PyObject *
-ssl_Context_set_tlsext_servername_callback(ssl_ContextObj *self, PyObject *args) {
-    PyObject *callback;
-    PyObject *old;
-
-    if (!PyArg_ParseTuple(args, "O:set_tlsext_servername_callback", &callback)) {
-        return NULL;
-    }
-
-    Py_INCREF(callback);
-    old = self->tlsext_servername_callback;
-    self->tlsext_servername_callback = callback;
-    Py_DECREF(old);
-
-    SSL_CTX_set_tlsext_servername_callback(self->ctx, global_tlsext_servername_callback);
-    SSL_CTX_set_tlsext_servername_arg(self->ctx, NULL);
-
-    Py_INCREF(Py_None);
-    return Py_None;
-}
-#endif
-
-
-/*
- * Member methods in the Context object
- * ADD_METHOD(name) expands to a correct PyMethodDef declaration
- *   {  'name', (PyCFunction)ssl_Context_name, METH_VARARGS }
- * for convenience
- * ADD_ALIAS(name,real) creates an "alias" of the ssl_Context_real
- * function with the name 'name'
- */
-#define ADD_METHOD(name) { #name, (PyCFunction)ssl_Context_##name, METH_VARARGS, ssl_Context_##name##_doc }
-static PyMethodDef ssl_Context_methods[] = {
-    ADD_METHOD(load_verify_locations),
-    ADD_METHOD(set_passwd_cb),
-    ADD_METHOD(set_default_verify_paths),
-    ADD_METHOD(use_certificate_chain_file),
-    ADD_METHOD(use_certificate_file),
-    ADD_METHOD(use_certificate),
-    ADD_METHOD(add_extra_chain_cert),
-    ADD_METHOD(use_privatekey_file),
-    ADD_METHOD(use_privatekey),
-    ADD_METHOD(check_privatekey),
-    ADD_METHOD(load_client_ca),
-    ADD_METHOD(set_session_id),
-    ADD_METHOD(set_verify),
-    ADD_METHOD(set_verify_depth),
-    ADD_METHOD(get_verify_mode),
-    ADD_METHOD(get_verify_depth),
-    ADD_METHOD(load_tmp_dh),
-    ADD_METHOD(set_cipher_list),
-    ADD_METHOD(set_client_ca_list),
-    ADD_METHOD(add_client_ca),
-    ADD_METHOD(set_timeout),
-    ADD_METHOD(get_timeout),
-    ADD_METHOD(set_info_callback),
-    ADD_METHOD(get_app_data),
-    ADD_METHOD(set_app_data),
-    ADD_METHOD(get_cert_store),
-    ADD_METHOD(set_options),
-#if SNI_EXTENSION_SUPPORT
-    ADD_METHOD(set_tlsext_servername_callback),
-#endif
-    { NULL, NULL }
-};
-#undef ADD_METHOD
-
-/*
- * Despite the name which might suggest otherwise, this is not the tp_init for
- * the Context type.  It's just the common initialization code shared by the
- * two _{Nn}ew functions below.
- */
-static ssl_ContextObj*
-ssl_Context_init(ssl_ContextObj *self, int i_method) {
-#if (OPENSSL_VERSION_NUMBER >> 28) == 0x01
-    const
-#endif
-    SSL_METHOD *method;
-
-    switch (i_method) {
-        case ssl_SSLv2_METHOD:
-#ifdef OPENSSL_NO_SSL2
-            PyErr_SetString(PyExc_ValueError, "SSLv2_METHOD not supported by this version of OpenSSL");
-            return NULL;
-#else      
-            method = SSLv2_method();
-#endif
-            break;
-        case ssl_SSLv23_METHOD:
-            method = SSLv23_method();
-            break;
-        case ssl_SSLv3_METHOD:
-            method = SSLv3_method();
-            break;
-        case ssl_TLSv1_METHOD:
-            method = TLSv1_method();
-            break;
-        default:
-            PyErr_SetString(PyExc_ValueError, "No such protocol");
-            return NULL;
-    }
-
-    self->ctx = SSL_CTX_new(method);
-    Py_INCREF(Py_None);
-    self->passphrase_callback = Py_None;
-    Py_INCREF(Py_None);
-    self->verify_callback = Py_None;
-    Py_INCREF(Py_None);
-    self->info_callback = Py_None;
-
-#if SNI_EXTENSION_SUPPORT
-    Py_INCREF(Py_None);
-    self->tlsext_servername_callback = Py_None;
-#endif
-
-    Py_INCREF(Py_None);
-    self->passphrase_userdata = Py_None;
-
-    Py_INCREF(Py_None);
-    self->app_data = Py_None;
-
-    /* Some initialization that's required to operate smoothly in Python */
-    SSL_CTX_set_app_data(self->ctx, self);
-    SSL_CTX_set_mode(self->ctx, SSL_MODE_ENABLE_PARTIAL_WRITE |
-                                SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER |
-                                SSL_MODE_AUTO_RETRY);
-
-    self->tstate = NULL;
-
-    return self;
-}
-
-/*
- * This one is exposed in the CObject API.  I want to deprecate it.
- */
-ssl_ContextObj*
-ssl_Context_New(int i_method) {
-    ssl_ContextObj *self;
-
-    self = PyObject_GC_New(ssl_ContextObj, &ssl_Context_Type);
-    if (self == NULL) {
-       return (ssl_ContextObj *)PyErr_NoMemory();
-    }
-    self = ssl_Context_init(self, i_method);
-    PyObject_GC_Track((PyObject *)self);
-    return self;
-}
-
-
-/*
- * This one is the tp_new of the Context type.  It's great.
- */
-static PyObject*
-ssl_Context_new(PyTypeObject *subtype, PyObject *args, PyObject *kwargs) {
-    int i_method;
-    ssl_ContextObj *self;
-    static char *kwlist[] = {"method", NULL};
-
-    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "i:Context", kwlist, &i_method)) {
-        return NULL;
-    }
-
-    self = (ssl_ContextObj *)subtype->tp_alloc(subtype, 1);
-    if (self == NULL) {
-        return NULL;
-    }
-
-    return (PyObject *)ssl_Context_init(self, i_method);
-}
-
-/*
- * Call the visitproc on all contained objects.
- *
- * Arguments: self - The Context object
- *            visit - Function to call
- *            arg - Extra argument to visit
- * Returns:   0 if all goes well, otherwise the return code from the first
- *            call that gave non-zero result.
- */
-static int
-ssl_Context_traverse(ssl_ContextObj *self, visitproc visit, void *arg)
-{
-    int ret = 0;
-
-    if (ret == 0 && self->passphrase_callback != NULL)
-        ret = visit((PyObject *)self->passphrase_callback, arg);
-    if (ret == 0 && self->passphrase_userdata != NULL)
-        ret = visit((PyObject *)self->passphrase_userdata, arg);
-    if (ret == 0 && self->verify_callback != NULL)
-        ret = visit((PyObject *)self->verify_callback, arg);
-    if (ret == 0 && self->info_callback != NULL)
-        ret = visit((PyObject *)self->info_callback, arg);
-    if (ret == 0 && self->app_data != NULL)
-        ret = visit(self->app_data, arg);
-    return ret;
-}
-
-/*
- * Decref all contained objects and zero the pointers.
- *
- * Arguments: self - The Context object
- * Returns:   Always 0.
- */
-static int
-ssl_Context_clear(ssl_ContextObj *self)
-{
-    Py_XDECREF(self->passphrase_callback);
-    self->passphrase_callback = NULL;
-    Py_XDECREF(self->passphrase_userdata);
-    self->passphrase_userdata = NULL;
-    Py_XDECREF(self->verify_callback);
-    self->verify_callback = NULL;
-    Py_XDECREF(self->info_callback);
-    self->info_callback = NULL;
-    Py_XDECREF(self->app_data);
-    self->app_data = NULL;
-    return 0;
-}
-
-/*
- * Deallocate the memory used by the Context object
- *
- * Arguments: self - The Context object
- * Returns:   None
- */
-static void
-ssl_Context_dealloc(ssl_ContextObj *self)
-{
-    PyObject_GC_UnTrack((PyObject *)self);
-    SSL_CTX_free(self->ctx);
-    ssl_Context_clear(self);
-    PyObject_GC_Del(self);
-}
-
-
-PyTypeObject ssl_Context_Type = {
-    PyOpenSSL_HEAD_INIT(&PyType_Type, 0)
-    "OpenSSL.SSL.Context",
-    sizeof(ssl_ContextObj),
-    0,
-    (destructor)ssl_Context_dealloc, /* tp_dealloc */
-    NULL, /* print */
-    NULL, /* tp_getattr */
-    NULL, /* setattr */
-    NULL, /* compare */
-    NULL, /* repr */
-    NULL, /* as_number */
-    NULL, /* as_sequence */
-    NULL, /* as_mapping */
-    NULL, /* hash */
-    NULL, /* call */
-    NULL, /* str */
-    NULL, /* getattro */
-    NULL, /* setattro */
-    NULL, /* as_buffer */
-    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_BASETYPE, /* tp_flags */
-    ssl_Context_doc, /* tp_doc */
-    (traverseproc)ssl_Context_traverse, /* tp_traverse */
-    (inquiry)ssl_Context_clear, /* tp_clear */
-    NULL, /* tp_richcompare */
-    0, /* tp_weaklistoffset */
-    NULL, /* tp_iter */
-    NULL, /* tp_iternext */
-    ssl_Context_methods, /* tp_methods */
-    NULL, /* tp_members */
-    NULL, /* tp_getset */
-    NULL, /* tp_base */
-    NULL, /* tp_dict */
-    NULL, /* tp_descr_get */
-    NULL, /* tp_descr_set */
-    0, /* tp_dictoffset */
-    NULL, /* tp_init */
-    NULL, /* tp_alloc */
-    ssl_Context_new, /* tp_new */
-};
-
-
-/*
- * Initialize the Context part of the SSL sub module
- *
- * Arguments: dict - The OpenSSL.SSL module
- * Returns:   1 for success, 0 otherwise
- */
-int
-init_ssl_context(PyObject *module) {
-
-    if (PyType_Ready(&ssl_Context_Type) < 0) {
-        return 0;
-    }
-
-    /* PyModule_AddObject steals a reference.
-     */
-    Py_INCREF((PyObject *)&ssl_Context_Type);
-    if (PyModule_AddObject(module, "Context", (PyObject *)&ssl_Context_Type) < 0) {
-        return 0;
-    }
-
-    /* PyModule_AddObject steals a reference.
-     */
-    Py_INCREF((PyObject *)&ssl_Context_Type);
-    if (PyModule_AddObject(module, "ContextType", (PyObject *)&ssl_Context_Type) < 0) {
-        return 0;
-    }
-
-    return 1;
-}
-
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/ssl/context.h hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/ssl/context.h
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/ssl/context.h	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/ssl/context.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,45 +0,0 @@
-/*
- * context.h
- *
- * Copyright (C) AB Strakt
- * See LICENSE for details.
- *
- * Export SSL Context object data structures and functions.
- * See the file RATIONALE for a short explanation of why this module was written.
- *
- * Reviewed 2001-07-23
- *
- */
-#ifndef PyOpenSSL_SSL_CONTEXT_H_
-#define PyOpenSSL_SSL_CONTEXT_H_
-
-#include <Python.h>
-#include <openssl/ssl.h>
-
-extern  int                   init_ssl_context      (PyObject *);
-
-extern  PyTypeObject      ssl_Context_Type;
-
-#define ssl_Context_Check(v) ((v)->ob_type == &ssl_Context_Type)
-
-typedef struct {
-    PyObject_HEAD
-    SSL_CTX             *ctx;
-    PyObject            *passphrase_callback,
-                        *passphrase_userdata,
-                        *verify_callback,
-                        *info_callback,
-#if SNI_EXTENSION_SUPPORT
-                        *tlsext_servername_callback,
-#endif
-                        *app_data;
-    PyThreadState       *tstate;
-} ssl_ContextObj;
-
-#define ssl_SSLv2_METHOD      (1)
-#define ssl_SSLv3_METHOD      (2)
-#define ssl_SSLv23_METHOD     (3)
-#define ssl_TLSv1_METHOD      (4)
-
-
-#endif
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/ssl/ssl.c hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/ssl/ssl.c
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/ssl/ssl.c	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/ssl/ssl.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,293 +0,0 @@
-/*
- * ssl.c
- *
- * Copyright (C) AB Strakt
- * Copyright (C) Jean-Paul Calderone
- * See LICENSE for details.
- *
- * Main file of the SSL sub module.
- * See the file RATIONALE for a short explanation of why this module was written.
- *
- * Reviewed 2001-07-23
- */
-#include <Python.h>
-
-#ifndef MS_WINDOWS
-#  include <sys/socket.h>
-#  include <netinet/in.h>
-#  if !(defined(__BEOS__) || defined(__CYGWIN__))
-#    include <netinet/tcp.h>
-#  endif
-#else
-#  include <winsock.h>
-#  include <wincrypt.h>
-#endif
-
-#define SSL_MODULE
-#include "ssl.h"
-
-static char ssl_doc[] = "\n\
-Main file of the SSL sub module.\n\
-See the file RATIONALE for a short explanation of why this module was written.\n\
-";
-
-crypto_X509Obj* (*new_x509)(X509*, int);
-crypto_X509NameObj* (*new_x509name)(X509_NAME*, int);
-crypto_X509StoreObj* (*new_x509store)(X509_STORE*, int);
-
-
-#ifndef PY3
-void **crypto_API;
-#endif
-
-int _pyOpenSSL_tstate_key;
-
-/* Exceptions defined by the SSL submodule */
-PyObject *ssl_Error,                   /* Base class              */
-         *ssl_ZeroReturnError,         /* Used with SSL_get_error */
-         *ssl_WantReadError,           /* ...                     */
-         *ssl_WantWriteError,          /* ...                     */
-         *ssl_WantX509LookupError,     /* ...                     */
-         *ssl_SysCallError;            /* Uses (errno,errstr)     */
-
-static char ssl_SSLeay_version_doc[] = "\n\
-Return a string describing the version of OpenSSL in use.\n\
-\n\
-@param type: One of the SSLEAY_ constants defined in this module.\n\
-";
-
-static PyObject *
-ssl_SSLeay_version(PyObject *spam, PyObject *args) {
-    int t;
-    const char *version;
-
-    if (!PyArg_ParseTuple(args, "i:SSLeay_version", &t)) {
-        return NULL;
-    }
-
-    version = SSLeay_version(t);
-    return PyBytes_FromStringAndSize(version, strlen(version));
-}
-
-
-
-/* Methods in the OpenSSL.SSL module */
-static PyMethodDef ssl_methods[] = {
-    { "SSLeay_version", ssl_SSLeay_version, METH_VARARGS, ssl_SSLeay_version_doc },
-    { NULL, NULL }
-};
-
-#ifdef PY3
-static struct PyModuleDef sslmodule = {
-    PyModuleDef_HEAD_INIT,
-    "SSL",
-    ssl_doc,
-    -1,
-    ssl_methods
-};
-#endif
-
-/*
- * Initialize SSL sub module
- *
- * Arguments: None
- * Returns:   None
- */
-PyOpenSSL_MODINIT(SSL) {
-    PyObject *module;
-#ifndef PY3
-    static void *ssl_API[ssl_API_pointers];
-    PyObject *ssl_api_object;
-
-    import_crypto();
-
-    new_x509 = crypto_X509_New;
-    new_x509name = crypto_X509Name_New;
-    new_x509store = crypto_X509Store_New;
-#else
-#   ifdef _WIN32
-    HMODULE crypto = GetModuleHandle("crypto.pyd");
-    if (crypto == NULL) {
-        PyErr_SetString(PyExc_RuntimeError, "Unable to get crypto module");
-        PyOpenSSL_MODRETURN(NULL);
-    }
-
-    new_x509 = (crypto_X509Obj* (*)(X509*, int))GetProcAddress(crypto, "crypto_X509_New");
-    new_x509name = (crypto_X509NameObj* (*)(X509_NAME*, int))GetProcAddress(crypto, "crypto_X509Name_New");
-    new_x509store = (crypto_X509StoreObj* (*)(X509_STORE*, int))GetProcAddress(crypto, "crypto_X509Store_New");
-#   else
-    new_x509 = crypto_X509_New;
-    new_x509name = crypto_X509Name_New;
-    new_x509store = crypto_X509Store_New;
-#   endif
-#endif
-
-    SSL_library_init();
-    ERR_load_SSL_strings();
-
-#ifdef PY3
-    module = PyModule_Create(&sslmodule);
-#else
-    module = Py_InitModule3("SSL", ssl_methods, ssl_doc);
-#endif
-    if (module == NULL) {
-        PyOpenSSL_MODRETURN(NULL);
-    }
-
-#ifndef PY3
-    /* Initialize the C API pointer array */
-    ssl_API[ssl_Context_New_NUM]    = (void *)ssl_Context_New;
-    ssl_API[ssl_Connection_New_NUM] = (void *)ssl_Connection_New;
-    ssl_api_object = PyCObject_FromVoidPtr((void *)ssl_API, NULL);
-    if (ssl_api_object != NULL) {
-        /* PyModule_AddObject steals a reference.
-         */
-        Py_INCREF(ssl_api_object);
-        PyModule_AddObject(module, "_C_API", ssl_api_object);
-    }
-#endif
-
-    /* Exceptions */
-/*
- * ADD_EXCEPTION(dict,name,base) expands to a correct Exception declaration,
- * inserting OpenSSL.SSL.name into dict, derviving the exception from base.
- */
-#define ADD_EXCEPTION(_name, _base)                                     \
-do {                                                                    \
-    ssl_##_name = PyErr_NewException("OpenSSL.SSL."#_name, _base, NULL);\
-    if (ssl_##_name == NULL)                                            \
-        goto error;                                                     \
-    /* PyModule_AddObject steals a reference. */                        \
-    Py_INCREF(ssl_##_name);                                             \
-    if (PyModule_AddObject(module, #_name, ssl_##_name) != 0)           \
-        goto error;                                                     \
-} while (0)
-
-    ssl_Error = PyErr_NewException("OpenSSL.SSL.Error", NULL, NULL);
-    if (ssl_Error == NULL) {
-        goto error;
-    }
-
-    /* PyModule_AddObject steals a reference. */
-    Py_INCREF(ssl_Error);
-    if (PyModule_AddObject(module, "Error", ssl_Error) != 0)
-        goto error;
-
-    ADD_EXCEPTION(ZeroReturnError,     ssl_Error);
-    ADD_EXCEPTION(WantReadError,       ssl_Error);
-    ADD_EXCEPTION(WantWriteError,      ssl_Error);
-    ADD_EXCEPTION(WantX509LookupError, ssl_Error);
-    ADD_EXCEPTION(SysCallError,        ssl_Error);
-#undef ADD_EXCEPTION
-
-    /* Method constants */
-    PyModule_AddIntConstant(module, "SSLv2_METHOD",  ssl_SSLv2_METHOD);
-    PyModule_AddIntConstant(module, "SSLv3_METHOD",  ssl_SSLv3_METHOD);
-    PyModule_AddIntConstant(module, "SSLv23_METHOD", ssl_SSLv23_METHOD);
-    PyModule_AddIntConstant(module, "TLSv1_METHOD",  ssl_TLSv1_METHOD);
-
-    /* Verify constants */
-    PyModule_AddIntConstant(module, "VERIFY_NONE", SSL_VERIFY_NONE);
-    PyModule_AddIntConstant(module, "VERIFY_PEER", SSL_VERIFY_PEER);
-    PyModule_AddIntConstant(module, "VERIFY_FAIL_IF_NO_PEER_CERT",
-                            SSL_VERIFY_FAIL_IF_NO_PEER_CERT);
-    PyModule_AddIntConstant(module, "VERIFY_CLIENT_ONCE",
-                            SSL_VERIFY_CLIENT_ONCE);
-
-    /* File type constants */
-    PyModule_AddIntConstant(module, "FILETYPE_PEM",  SSL_FILETYPE_PEM);
-    PyModule_AddIntConstant(module, "FILETYPE_ASN1", SSL_FILETYPE_ASN1);
-
-    /* SSL option constants */
-    PyModule_AddIntConstant(module, "OP_SINGLE_DH_USE", SSL_OP_SINGLE_DH_USE);
-    PyModule_AddIntConstant(module, "OP_EPHEMERAL_RSA", SSL_OP_EPHEMERAL_RSA);
-    PyModule_AddIntConstant(module, "OP_NO_SSLv2", SSL_OP_NO_SSLv2);
-    PyModule_AddIntConstant(module, "OP_NO_SSLv3", SSL_OP_NO_SSLv3);
-    PyModule_AddIntConstant(module, "OP_NO_TLSv1", SSL_OP_NO_TLSv1);
-
-    /* More SSL option constants */
-    PyModule_AddIntConstant(module, "OP_MICROSOFT_SESS_ID_BUG", SSL_OP_MICROSOFT_SESS_ID_BUG);
-    PyModule_AddIntConstant(module, "OP_NETSCAPE_CHALLENGE_BUG", SSL_OP_NETSCAPE_CHALLENGE_BUG);
-    PyModule_AddIntConstant(module, "OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG", SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG);
-    PyModule_AddIntConstant(module, "OP_SSLREF2_REUSE_CERT_TYPE_BUG", SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG);
-    PyModule_AddIntConstant(module, "OP_MICROSOFT_BIG_SSLV3_BUFFER", SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER);
-    PyModule_AddIntConstant(module, "OP_MSIE_SSLV2_RSA_PADDING", SSL_OP_MSIE_SSLV2_RSA_PADDING);
-    PyModule_AddIntConstant(module, "OP_SSLEAY_080_CLIENT_DH_BUG", SSL_OP_SSLEAY_080_CLIENT_DH_BUG);
-    PyModule_AddIntConstant(module, "OP_TLS_D5_BUG", SSL_OP_TLS_D5_BUG);
-    PyModule_AddIntConstant(module, "OP_TLS_BLOCK_PADDING_BUG", SSL_OP_TLS_BLOCK_PADDING_BUG);
-    PyModule_AddIntConstant(module, "OP_DONT_INSERT_EMPTY_FRAGMENTS", SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS);
-    PyModule_AddIntConstant(module, "OP_ALL", SSL_OP_ALL);
-    PyModule_AddIntConstant(module, "OP_CIPHER_SERVER_PREFERENCE", SSL_OP_CIPHER_SERVER_PREFERENCE);
-    PyModule_AddIntConstant(module, "OP_TLS_ROLLBACK_BUG", SSL_OP_TLS_ROLLBACK_BUG);
-    PyModule_AddIntConstant(module, "OP_PKCS1_CHECK_1", SSL_OP_PKCS1_CHECK_1);
-    PyModule_AddIntConstant(module, "OP_PKCS1_CHECK_2", SSL_OP_PKCS1_CHECK_2);
-    PyModule_AddIntConstant(module, "OP_NETSCAPE_CA_DN_BUG", SSL_OP_NETSCAPE_CA_DN_BUG);
-    PyModule_AddIntConstant(module, "OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG", SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG);
-
-    /* DTLS related options.  The first two of these were introduced in
-     * 2005, the third in 2007.  To accomodate systems which are still using
-     * older versions, make them optional. */
-#ifdef SSL_OP_NO_QUERY_MTU
-    PyModule_AddIntConstant(module, "OP_NO_QUERY_MTU", SSL_OP_NO_QUERY_MTU);
-#endif
-#ifdef SSL_OP_COOKIE_EXCHANGE
-    PyModule_AddIntConstant(module, "OP_COOKIE_EXCHANGE", SSL_OP_COOKIE_EXCHANGE);
-#endif
-#ifdef SSL_OP_NO_TICKET
-    PyModule_AddIntConstant(module, "OP_NO_TICKET", SSL_OP_NO_TICKET);
-#endif
-
-    /* For SSL_set_shutdown */
-    PyModule_AddIntConstant(module, "SENT_SHUTDOWN", SSL_SENT_SHUTDOWN);
-    PyModule_AddIntConstant(module, "RECEIVED_SHUTDOWN", SSL_RECEIVED_SHUTDOWN);
-
-    /* For set_info_callback */
-    PyModule_AddIntConstant(module, "SSL_ST_CONNECT", SSL_ST_CONNECT);
-    PyModule_AddIntConstant(module, "SSL_ST_ACCEPT", SSL_ST_ACCEPT);
-    PyModule_AddIntConstant(module, "SSL_ST_MASK", SSL_ST_MASK);
-    PyModule_AddIntConstant(module, "SSL_ST_INIT", SSL_ST_INIT);
-    PyModule_AddIntConstant(module, "SSL_ST_BEFORE", SSL_ST_BEFORE);
-    PyModule_AddIntConstant(module, "SSL_ST_OK", SSL_ST_OK);
-    PyModule_AddIntConstant(module, "SSL_ST_RENEGOTIATE", SSL_ST_RENEGOTIATE);
-    PyModule_AddIntConstant(module, "SSL_CB_LOOP", SSL_CB_LOOP);
-    PyModule_AddIntConstant(module, "SSL_CB_EXIT", SSL_CB_EXIT);
-    PyModule_AddIntConstant(module, "SSL_CB_READ", SSL_CB_READ);
-    PyModule_AddIntConstant(module, "SSL_CB_WRITE", SSL_CB_WRITE);
-    PyModule_AddIntConstant(module, "SSL_CB_ALERT", SSL_CB_ALERT);
-    PyModule_AddIntConstant(module, "SSL_CB_READ_ALERT", SSL_CB_READ_ALERT);
-    PyModule_AddIntConstant(module, "SSL_CB_WRITE_ALERT", SSL_CB_WRITE_ALERT);
-    PyModule_AddIntConstant(module, "SSL_CB_ACCEPT_LOOP", SSL_CB_ACCEPT_LOOP);
-    PyModule_AddIntConstant(module, "SSL_CB_ACCEPT_EXIT", SSL_CB_ACCEPT_EXIT);
-    PyModule_AddIntConstant(module, "SSL_CB_CONNECT_LOOP", SSL_CB_CONNECT_LOOP);
-    PyModule_AddIntConstant(module, "SSL_CB_CONNECT_EXIT", SSL_CB_CONNECT_EXIT);
-    PyModule_AddIntConstant(module, "SSL_CB_HANDSHAKE_START", SSL_CB_HANDSHAKE_START);
-    PyModule_AddIntConstant(module, "SSL_CB_HANDSHAKE_DONE", SSL_CB_HANDSHAKE_DONE);
-
-    /* Version information indicators, used with SSLeay_version */
-    PyModule_AddIntConstant(module, "SSLEAY_VERSION", SSLEAY_VERSION);
-    PyModule_AddIntConstant(module, "SSLEAY_CFLAGS", SSLEAY_CFLAGS);
-    PyModule_AddIntConstant(module, "SSLEAY_BUILT_ON", SSLEAY_BUILT_ON);
-    PyModule_AddIntConstant(module, "SSLEAY_PLATFORM", SSLEAY_PLATFORM);
-    PyModule_AddIntConstant(module, "SSLEAY_DIR", SSLEAY_DIR);
-
-    /* Straight up version number */
-    PyModule_AddIntConstant(module, "OPENSSL_VERSION_NUMBER", OPENSSL_VERSION_NUMBER);
-
-    if (!init_ssl_context(module))
-        goto error;
-    if (!init_ssl_connection(module))
-        goto error;
-
-#ifdef WITH_THREAD
-    /*
-     * Initialize this module's threading support structures.
-     */
-    _pyOpenSSL_tstate_key = PyThread_create_key();
-#endif
-
-    PyOpenSSL_MODRETURN(module);
-
-error:
-    PyOpenSSL_MODRETURN(NULL);
-    ;
-}
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/ssl/ssl.h hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/ssl/ssl.h
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/ssl/ssl.h	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/ssl/ssl.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,82 +0,0 @@
-/*
- * ssl.h
- *
- * Copyright (C) AB Strakt
- * See LICENSE for details.
- *
- * Export functions and exceptions from the SSL sub module.
- * See the file RATIONALE for a short explanation of why this module was written.
- *
- * Reviewed 2001-07-23
- *
- */
-#ifndef PyOpenSSL_SSL_H_
-#define PyOpenSSL_SSL_H_
-
-#include <Python.h>
-#include <openssl/ssl.h>
-
-#if defined(OPENSSL_VERSION_NUMBER) && OPENSSL_VERSION_NUMBER > 0x009080efL
-  #define SNI_EXTENSION_SUPPORT 1
-#endif
-
-#include <pythread.h>
-#include "context.h"
-#include "connection.h"
-#include "../util.h"
-#include "../crypto/crypto.h"
-
-extern PyObject *ssl_Error,               /* Base class              */
-                *ssl_ZeroReturnError,     /* Used with SSL_get_erorr */
-                *ssl_WantReadError,       /* ...                     */
-                *ssl_WantWriteError,      /* ...                     */
-                *ssl_WantX509LookupError, /* ...                     */
-                *ssl_SysCallError;        /* Uses (errno,errstr)     */
-
-#define ssl_Context_New_NUM       0
-#define ssl_Context_New_RETURN    ssl_ContextObj *
-#define ssl_Context_New_PROTO     (int method)
-
-#define ssl_Connection_New_NUM    1
-#define ssl_Connection_New_RETURN ssl_ConnectionObj *
-#define ssl_Connection_New_PROTO  (ssl_ContextObj *ctx, PyObject *sock)
-
-#define ssl_API_pointers          2
-
-#ifdef WITH_THREAD
-extern int _pyOpenSSL_tstate_key;
-#endif /* WITH_THREAD */
-
-#ifdef SSL_MODULE
-
-extern ssl_Context_New_RETURN    ssl_Context_New    ssl_Context_New_PROTO;
-extern ssl_Connection_New_RETURN ssl_Connection_New ssl_Connection_New_PROTO;
-
-extern crypto_X509Obj* (*new_x509)(X509*, int);
-extern crypto_X509NameObj* (*new_x509name)(X509_NAME*, int);
-extern crypto_X509StoreObj* (*new_x509store)(X509_STORE*, int);
-
-#else /* SSL_MODULE */
-
-extern void **ssl_API;
-
-#define ssl_Context_New \
- (*(ssl_Context_New_RETURN (*)ssl_Context_New_PROTO) ssl_API[ssl_Context_New_NUM])
-#define ssl_Connection_New \
- (*(ssl_Connection_New_RETURN (*)ssl_Connection_New_PROTO) ssl_API[ssl_Connection_New_NUM])
-
-#define import_SSL() \
-{ \
-  PyObject *module = PyImport_ImportModule("OpenSSL.SSL"); \
-  if (module != NULL) { \
-    PyObject *module_dict = PyModule_GetDict(module); \
-    PyObject *c_api_object = PyDict_GetItemString(module_dict, "_C_API"); \
-    if (PyCObject_Check(c_api_object)) { \
-      ssl_API = (void **)PyCObject_AsVoidPtr(c_api_object); \
-    } \
-  } \
-}
-
-#endif /* SSL_MODULE */
-
-#endif /* PyOpenSSL_SSL_H_ */
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/SSL.py hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/SSL.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/SSL.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/SSL.py	2015-04-15 00:43:59.000000000 +0200
@@ -0,0 +1,1948 @@
+from sys import platform
+from functools import wraps, partial
+from itertools import count, chain
+from weakref import WeakValueDictionary
+from errno import errorcode
+
+from six import text_type as _text_type
+from six import binary_type as _binary_type
+from six import integer_types as integer_types
+from six import int2byte, indexbytes
+
+from OpenSSL._util import (
+    ffi as _ffi,
+    lib as _lib,
+    exception_from_error_queue as _exception_from_error_queue,
+    native as _native,
+    text_to_bytes_and_warn as _text_to_bytes_and_warn,
+    path_string as _path_string,
+    UNSPECIFIED as _UNSPECIFIED,
+)
+
+from OpenSSL.crypto import (
+    FILETYPE_PEM, _PassphraseHelper, PKey, X509Name, X509, X509Store)
+
+try:
+    _memoryview = memoryview
+except NameError:
+    class _memoryview(object):
+        pass
+
+try:
+    _buffer = buffer
+except NameError:
+    class _buffer(object):
+        pass
+
+OPENSSL_VERSION_NUMBER = _lib.OPENSSL_VERSION_NUMBER
+SSLEAY_VERSION = _lib.SSLEAY_VERSION
+SSLEAY_CFLAGS = _lib.SSLEAY_CFLAGS
+SSLEAY_PLATFORM = _lib.SSLEAY_PLATFORM
+SSLEAY_DIR = _lib.SSLEAY_DIR
+SSLEAY_BUILT_ON = _lib.SSLEAY_BUILT_ON
+
+SENT_SHUTDOWN = _lib.SSL_SENT_SHUTDOWN
+RECEIVED_SHUTDOWN = _lib.SSL_RECEIVED_SHUTDOWN
+
+SSLv2_METHOD = 1
+SSLv3_METHOD = 2
+SSLv23_METHOD = 3
+TLSv1_METHOD = 4
+TLSv1_1_METHOD = 5
+TLSv1_2_METHOD = 6
+
+OP_NO_SSLv2 = _lib.SSL_OP_NO_SSLv2
+OP_NO_SSLv3 = _lib.SSL_OP_NO_SSLv3
+OP_NO_TLSv1 = _lib.SSL_OP_NO_TLSv1
+
+OP_NO_TLSv1_1 = getattr(_lib, "SSL_OP_NO_TLSv1_1", 0)
+OP_NO_TLSv1_2 = getattr(_lib, "SSL_OP_NO_TLSv1_2", 0)
+
+try:
+    MODE_RELEASE_BUFFERS = _lib.SSL_MODE_RELEASE_BUFFERS
+except AttributeError:
+    pass
+
+OP_SINGLE_DH_USE = _lib.SSL_OP_SINGLE_DH_USE
+OP_EPHEMERAL_RSA = _lib.SSL_OP_EPHEMERAL_RSA
+OP_MICROSOFT_SESS_ID_BUG = _lib.SSL_OP_MICROSOFT_SESS_ID_BUG
+OP_NETSCAPE_CHALLENGE_BUG = _lib.SSL_OP_NETSCAPE_CHALLENGE_BUG
+OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG = _lib.SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG
+OP_SSLREF2_REUSE_CERT_TYPE_BUG = _lib.SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG
+OP_MICROSOFT_BIG_SSLV3_BUFFER = _lib.SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER
+try:
+    OP_MSIE_SSLV2_RSA_PADDING = _lib.SSL_OP_MSIE_SSLV2_RSA_PADDING
+except AttributeError:
+    pass
+OP_SSLEAY_080_CLIENT_DH_BUG = _lib.SSL_OP_SSLEAY_080_CLIENT_DH_BUG
+OP_TLS_D5_BUG = _lib.SSL_OP_TLS_D5_BUG
+OP_TLS_BLOCK_PADDING_BUG = _lib.SSL_OP_TLS_BLOCK_PADDING_BUG
+OP_DONT_INSERT_EMPTY_FRAGMENTS = _lib.SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS
+OP_CIPHER_SERVER_PREFERENCE = _lib.SSL_OP_CIPHER_SERVER_PREFERENCE
+OP_TLS_ROLLBACK_BUG = _lib.SSL_OP_TLS_ROLLBACK_BUG
+OP_PKCS1_CHECK_1 = _lib.SSL_OP_PKCS1_CHECK_1
+OP_PKCS1_CHECK_2 = _lib.SSL_OP_PKCS1_CHECK_2
+OP_NETSCAPE_CA_DN_BUG = _lib.SSL_OP_NETSCAPE_CA_DN_BUG
+OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG= _lib.SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG
+try:
+    OP_NO_COMPRESSION = _lib.SSL_OP_NO_COMPRESSION
+except AttributeError:
+    pass
+
+OP_NO_QUERY_MTU = _lib.SSL_OP_NO_QUERY_MTU
+OP_COOKIE_EXCHANGE = _lib.SSL_OP_COOKIE_EXCHANGE
+try:
+    OP_NO_TICKET = _lib.SSL_OP_NO_TICKET
+except AttributeError:
+    pass
+
+OP_ALL   = _lib.SSL_OP_ALL
+
+VERIFY_PEER = _lib.SSL_VERIFY_PEER
+VERIFY_FAIL_IF_NO_PEER_CERT = _lib.SSL_VERIFY_FAIL_IF_NO_PEER_CERT
+VERIFY_CLIENT_ONCE = _lib.SSL_VERIFY_CLIENT_ONCE
+VERIFY_NONE = _lib.SSL_VERIFY_NONE
+
+SESS_CACHE_OFF = _lib.SSL_SESS_CACHE_OFF
+SESS_CACHE_CLIENT = _lib.SSL_SESS_CACHE_CLIENT
+SESS_CACHE_SERVER = _lib.SSL_SESS_CACHE_SERVER
+SESS_CACHE_BOTH = _lib.SSL_SESS_CACHE_BOTH
+SESS_CACHE_NO_AUTO_CLEAR = _lib.SSL_SESS_CACHE_NO_AUTO_CLEAR
+SESS_CACHE_NO_INTERNAL_LOOKUP = _lib.SSL_SESS_CACHE_NO_INTERNAL_LOOKUP
+SESS_CACHE_NO_INTERNAL_STORE = _lib.SSL_SESS_CACHE_NO_INTERNAL_STORE
+SESS_CACHE_NO_INTERNAL = _lib.SSL_SESS_CACHE_NO_INTERNAL
+
+SSL_ST_CONNECT = _lib.SSL_ST_CONNECT
+SSL_ST_ACCEPT = _lib.SSL_ST_ACCEPT
+SSL_ST_MASK = _lib.SSL_ST_MASK
+SSL_ST_INIT = _lib.SSL_ST_INIT
+SSL_ST_BEFORE = _lib.SSL_ST_BEFORE
+SSL_ST_OK = _lib.SSL_ST_OK
+SSL_ST_RENEGOTIATE = _lib.SSL_ST_RENEGOTIATE
+
+SSL_CB_LOOP = _lib.SSL_CB_LOOP
+SSL_CB_EXIT = _lib.SSL_CB_EXIT
+SSL_CB_READ = _lib.SSL_CB_READ
+SSL_CB_WRITE = _lib.SSL_CB_WRITE
+SSL_CB_ALERT = _lib.SSL_CB_ALERT
+SSL_CB_READ_ALERT = _lib.SSL_CB_READ_ALERT
+SSL_CB_WRITE_ALERT = _lib.SSL_CB_WRITE_ALERT
+SSL_CB_ACCEPT_LOOP = _lib.SSL_CB_ACCEPT_LOOP
+SSL_CB_ACCEPT_EXIT = _lib.SSL_CB_ACCEPT_EXIT
+SSL_CB_CONNECT_LOOP = _lib.SSL_CB_CONNECT_LOOP
+SSL_CB_CONNECT_EXIT = _lib.SSL_CB_CONNECT_EXIT
+SSL_CB_HANDSHAKE_START = _lib.SSL_CB_HANDSHAKE_START
+SSL_CB_HANDSHAKE_DONE = _lib.SSL_CB_HANDSHAKE_DONE
+
+class Error(Exception):
+    """
+    An error occurred in an `OpenSSL.SSL` API.
+    """
+
+
+
+_raise_current_error = partial(_exception_from_error_queue, Error)
+
+
+class WantReadError(Error):
+    pass
+
+
+
+class WantWriteError(Error):
+    pass
+
+
+
+class WantX509LookupError(Error):
+    pass
+
+
+
+class ZeroReturnError(Error):
+    pass
+
+
+
+class SysCallError(Error):
+    pass
+
+
+class _CallbackExceptionHelper(object):
+    """
+    A base class for wrapper classes that allow for intelligent exception
+    handling in OpenSSL callbacks.
+
+    :ivar list _problems: Any exceptions that occurred while executing in a
+        context where they could not be raised in the normal way.  Typically
+        this is because OpenSSL has called into some Python code and requires a
+        return value.  The exceptions are saved to be raised later when it is
+        possible to do so.
+    """
+    def __init__(self):
+        self._problems = []
+
+
+    def raise_if_problem(self):
+        """
+        Raise an exception from the OpenSSL error queue or that was previously
+        captured whe running a callback.
+        """
+        if self._problems:
+            try:
+                _raise_current_error()
+            except Error:
+                pass
+            raise self._problems.pop(0)
+
+
+class _VerifyHelper(_CallbackExceptionHelper):
+    """
+    Wrap a callback such that it can be used as a certificate verification
+    callback.
+    """
+    def __init__(self, callback):
+        _CallbackExceptionHelper.__init__(self)
+
+        @wraps(callback)
+        def wrapper(ok, store_ctx):
+            cert = X509.__new__(X509)
+            cert._x509 = _lib.X509_STORE_CTX_get_current_cert(store_ctx)
+            error_number = _lib.X509_STORE_CTX_get_error(store_ctx)
+            error_depth = _lib.X509_STORE_CTX_get_error_depth(store_ctx)
+
+            index = _lib.SSL_get_ex_data_X509_STORE_CTX_idx()
+            ssl = _lib.X509_STORE_CTX_get_ex_data(store_ctx, index)
+            connection = Connection._reverse_mapping[ssl]
+
+            try:
+                result = callback(connection, cert, error_number, error_depth, ok)
+            except Exception as e:
+                self._problems.append(e)
+                return 0
+            else:
+                if result:
+                    _lib.X509_STORE_CTX_set_error(store_ctx, _lib.X509_V_OK)
+                    return 1
+                else:
+                    return 0
+
+        self.callback = _ffi.callback(
+            "int (*)(int, X509_STORE_CTX *)", wrapper)
+
+
+class _NpnAdvertiseHelper(_CallbackExceptionHelper):
+    """
+    Wrap a callback such that it can be used as an NPN advertisement callback.
+    """
+    def __init__(self, callback):
+        _CallbackExceptionHelper.__init__(self)
+
+        @wraps(callback)
+        def wrapper(ssl, out, outlen, arg):
+            try:
+                conn = Connection._reverse_mapping[ssl]
+                protos = callback(conn)
+
+                # Join the protocols into a Python bytestring, length-prefixing
+                # each element.
+                protostr = b''.join(
+                    chain.from_iterable((int2byte(len(p)), p) for p in protos)
+                )
+
+                # Save our callback arguments on the connection object. This is
+                # done to make sure that they don't get freed before OpenSSL
+                # uses them. Then, return them appropriately in the output
+                # parameters.
+                conn._npn_advertise_callback_args = [
+                    _ffi.new("unsigned int *", len(protostr)),
+                    _ffi.new("unsigned char[]", protostr),
+                ]
+                outlen[0] = conn._npn_advertise_callback_args[0][0]
+                out[0] = conn._npn_advertise_callback_args[1]
+                return 0
+            except Exception as e:
+                self._problems.append(e)
+                return 2  # SSL_TLSEXT_ERR_ALERT_FATAL
+
+        self.callback = _ffi.callback(
+            "int (*)(SSL *, const unsigned char **, unsigned int *, void *)",
+            wrapper
+        )
+
+
+class _NpnSelectHelper(_CallbackExceptionHelper):
+    """
+    Wrap a callback such that it can be used as an NPN selection callback.
+    """
+    def __init__(self, callback):
+        _CallbackExceptionHelper.__init__(self)
+
+        @wraps(callback)
+        def wrapper(ssl, out, outlen, in_, inlen, arg):
+            try:
+                conn = Connection._reverse_mapping[ssl]
+
+                # The string passed to us is actually made up of multiple
+                # length-prefixed bytestrings. We need to split that into a
+                # list.
+                instr = _ffi.buffer(in_, inlen)[:]
+                protolist = []
+                while instr:
+                    l = indexbytes(instr, 0)
+                    proto = instr[1:l+1]
+                    protolist.append(proto)
+                    instr = instr[l+1:]
+
+                # Call the callback
+                outstr = callback(conn, protolist)
+
+                # Save our callback arguments on the connection object. This is
+                # done to make sure that they don't get freed before OpenSSL
+                # uses them. Then, return them appropriately in the output
+                # parameters.
+                conn._npn_select_callback_args = [
+                    _ffi.new("unsigned char *", len(outstr)),
+                    _ffi.new("unsigned char[]", outstr),
+                ]
+                outlen[0] = conn._npn_select_callback_args[0][0]
+                out[0] = conn._npn_select_callback_args[1]
+                return 0
+            except Exception as e:
+                self._problems.append(e)
+                return 2  # SSL_TLSEXT_ERR_ALERT_FATAL
+
+        self.callback = _ffi.callback(
+            "int (*)(SSL *, unsigned char **, unsigned char *, "
+                    "const unsigned char *, unsigned int, void *)",
+            wrapper
+        )
+
+
+class _ALPNSelectHelper(_CallbackExceptionHelper):
+    """
+    Wrap a callback such that it can be used as an ALPN selection callback.
+    """
+    def __init__(self, callback):
+        _CallbackExceptionHelper.__init__(self)
+
+        @wraps(callback)
+        def wrapper(ssl, out, outlen, in_, inlen, arg):
+            try:
+                conn = Connection._reverse_mapping[ssl]
+
+                # The string passed to us is made up of multiple
+                # length-prefixed bytestrings. We need to split that into a
+                # list.
+                instr = _ffi.buffer(in_, inlen)[:]
+                protolist = []
+                while instr:
+                    encoded_len = indexbytes(instr, 0)
+                    proto = instr[1:encoded_len + 1]
+                    protolist.append(proto)
+                    instr = instr[encoded_len + 1:]
+
+                # Call the callback
+                outstr = callback(conn, protolist)
+
+                if not isinstance(outstr, _binary_type):
+                    raise TypeError("ALPN callback must return a bytestring.")
+
+                # Save our callback arguments on the connection object to make
+                # sure that they don't get freed before OpenSSL can use them.
+                # Then, return them in the appropriate output parameters.
+                conn._alpn_select_callback_args = [
+                    _ffi.new("unsigned char *", len(outstr)),
+                    _ffi.new("unsigned char[]", outstr),
+                ]
+                outlen[0] = conn._alpn_select_callback_args[0][0]
+                out[0] = conn._alpn_select_callback_args[1]
+                return 0
+            except Exception as e:
+                self._problems.append(e)
+                return 2  # SSL_TLSEXT_ERR_ALERT_FATAL
+
+        self.callback = _ffi.callback(
+            "int (*)(SSL *, unsigned char **, unsigned char *, "
+                    "const unsigned char *, unsigned int, void *)",
+            wrapper
+        )
+
+
+def _asFileDescriptor(obj):
+    fd = None
+    if not isinstance(obj, integer_types):
+        meth = getattr(obj, "fileno", None)
+        if meth is not None:
+            obj = meth()
+
+    if isinstance(obj, integer_types):
+        fd = obj
+
+    if not isinstance(fd, integer_types):
+        raise TypeError("argument must be an int, or have a fileno() method.")
+    elif fd < 0:
+        raise ValueError(
+            "file descriptor cannot be a negative integer (%i)" % (fd,))
+
+    return fd
+
+
+
+def SSLeay_version(type):
+    """
+    Return a string describing the version of OpenSSL in use.
+
+    :param type: One of the SSLEAY_ constants defined in this module.
+    """
+    return _ffi.string(_lib.SSLeay_version(type))
+
+
+def _requires_npn(func):
+    """
+    Wraps any function that requires NPN support in OpenSSL, ensuring that
+    NotImplementedError is raised if NPN is not present.
+    """
+    @wraps(func)
+    def wrapper(*args, **kwargs):
+        if not _lib.Cryptography_HAS_NEXTPROTONEG:
+            raise NotImplementedError("NPN not available.")
+
+        return func(*args, **kwargs)
+
+    return wrapper
+
+
+
+def _requires_alpn(func):
+    """
+    Wraps any function that requires ALPN support in OpenSSL, ensuring that
+    NotImplementedError is raised if ALPN support is not present.
+    """
+    @wraps(func)
+    def wrapper(*args, **kwargs):
+        if not _lib.Cryptography_HAS_ALPN:
+            raise NotImplementedError("ALPN not available.")
+
+        return func(*args, **kwargs)
+
+    return wrapper
+
+
+
+class Session(object):
+    pass
+
+
+
+class Context(object):
+    """
+    :py:obj:`OpenSSL.SSL.Context` instances define the parameters for setting up
+    new SSL connections.
+    """
+    _methods = {
+        SSLv2_METHOD: "SSLv2_method",
+        SSLv3_METHOD: "SSLv3_method",
+        SSLv23_METHOD: "SSLv23_method",
+        TLSv1_METHOD: "TLSv1_method",
+        TLSv1_1_METHOD: "TLSv1_1_method",
+        TLSv1_2_METHOD: "TLSv1_2_method",
+        }
+    _methods = dict(
+        (identifier, getattr(_lib, name))
+        for (identifier, name) in _methods.items()
+        if getattr(_lib, name, None) is not None)
+
+
+    def __init__(self, method):
+        """
+        :param method: One of SSLv2_METHOD, SSLv3_METHOD, SSLv23_METHOD, or
+            TLSv1_METHOD.
+        """
+        if not isinstance(method, integer_types):
+            raise TypeError("method must be an integer")
+
+        try:
+            method_func = self._methods[method]
+        except KeyError:
+            raise ValueError("No such protocol")
+
+        method_obj = method_func()
+        if method_obj == _ffi.NULL:
+            # TODO: This is untested.
+            _raise_current_error()
+
+        context = _lib.SSL_CTX_new(method_obj)
+        if context == _ffi.NULL:
+            # TODO: This is untested.
+            _raise_current_error()
+        context = _ffi.gc(context, _lib.SSL_CTX_free)
+
+        self._context = context
+        self._passphrase_helper = None
+        self._passphrase_callback = None
+        self._passphrase_userdata = None
+        self._verify_helper = None
+        self._verify_callback = None
+        self._info_callback = None
+        self._tlsext_servername_callback = None
+        self._app_data = None
+        self._npn_advertise_helper = None
+        self._npn_advertise_callback = None
+        self._npn_select_helper = None
+        self._npn_select_callback = None
+        self._alpn_select_helper = None
+        self._alpn_select_callback = None
+
+        # SSL_CTX_set_app_data(self->ctx, self);
+        # SSL_CTX_set_mode(self->ctx, SSL_MODE_ENABLE_PARTIAL_WRITE |
+        #                             SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER |
+        #                             SSL_MODE_AUTO_RETRY);
+        self.set_mode(_lib.SSL_MODE_ENABLE_PARTIAL_WRITE)
+
+
+    def load_verify_locations(self, cafile, capath=None):
+        """
+        Let SSL know where we can find trusted certificates for the certificate
+        chain
+
+        :param cafile: In which file we can find the certificates (``bytes`` or
+            ``unicode``).
+        :param capath: In which directory we can find the certificates
+            (``bytes`` or ``unicode``).
+
+        :return: None
+        """
+        if cafile is None:
+            cafile = _ffi.NULL
+        else:
+            cafile = _path_string(cafile)
+
+        if capath is None:
+            capath = _ffi.NULL
+        else:
+            capath = _path_string(capath)
+
+        load_result = _lib.SSL_CTX_load_verify_locations(self._context, cafile, capath)
+        if not load_result:
+            _raise_current_error()
+
+
+    def _wrap_callback(self, callback):
+        @wraps(callback)
+        def wrapper(size, verify, userdata):
+            return callback(size, verify, self._passphrase_userdata)
+        return _PassphraseHelper(
+            FILETYPE_PEM, wrapper, more_args=True, truncate=True)
+
+
+    def set_passwd_cb(self, callback, userdata=None):
+        """
+        Set the passphrase callback
+
+        :param callback: The Python callback to use
+        :param userdata: (optional) A Python object which will be given as
+                         argument to the callback
+        :return: None
+        """
+        if not callable(callback):
+            raise TypeError("callback must be callable")
+
+        self._passphrase_helper = self._wrap_callback(callback)
+        self._passphrase_callback = self._passphrase_helper.callback
+        _lib.SSL_CTX_set_default_passwd_cb(
+            self._context, self._passphrase_callback)
+        self._passphrase_userdata = userdata
+
+
+    def set_default_verify_paths(self):
+        """
+        Use the platform-specific CA certificate locations
+
+        :return: None
+        """
+        set_result = _lib.SSL_CTX_set_default_verify_paths(self._context)
+        if not set_result:
+            # TODO: This is untested.
+            _raise_current_error()
+
+
+    def use_certificate_chain_file(self, certfile):
+        """
+        Load a certificate chain from a file
+
+        :param certfile: The name of the certificate chain file (``bytes`` or
+            ``unicode``).
+
+        :return: None
+        """
+        certfile = _path_string(certfile)
+
+        result = _lib.SSL_CTX_use_certificate_chain_file(self._context, certfile)
+        if not result:
+            _raise_current_error()
+
+
+    def use_certificate_file(self, certfile, filetype=FILETYPE_PEM):
+        """
+        Load a certificate from a file
+
+        :param certfile: The name of the certificate file (``bytes`` or
+            ``unicode``).
+        :param filetype: (optional) The encoding of the file, default is PEM
+
+        :return: None
+        """
+        certfile = _path_string(certfile)
+        if not isinstance(filetype, integer_types):
+            raise TypeError("filetype must be an integer")
+
+        use_result = _lib.SSL_CTX_use_certificate_file(self._context, certfile, filetype)
+        if not use_result:
+            _raise_current_error()
+
+
+    def use_certificate(self, cert):
+        """
+        Load a certificate from a X509 object
+
+        :param cert: The X509 object
+        :return: None
+        """
+        if not isinstance(cert, X509):
+            raise TypeError("cert must be an X509 instance")
+
+        use_result = _lib.SSL_CTX_use_certificate(self._context, cert._x509)
+        if not use_result:
+            _raise_current_error()
+
+
+    def add_extra_chain_cert(self, certobj):
+        """
+        Add certificate to chain
+
+        :param certobj: The X509 certificate object to add to the chain
+        :return: None
+        """
+        if not isinstance(certobj, X509):
+            raise TypeError("certobj must be an X509 instance")
+
+        copy = _lib.X509_dup(certobj._x509)
+        add_result = _lib.SSL_CTX_add_extra_chain_cert(self._context, copy)
+        if not add_result:
+            # TODO: This is untested.
+            _lib.X509_free(copy)
+            _raise_current_error()
+
+
+    def _raise_passphrase_exception(self):
+        if self._passphrase_helper is None:
+            _raise_current_error()
+        exception = self._passphrase_helper.raise_if_problem(Error)
+        if exception is not None:
+            raise exception
+
+
+    def use_privatekey_file(self, keyfile, filetype=_UNSPECIFIED):
+        """
+        Load a private key from a file
+
+        :param keyfile: The name of the key file (``bytes`` or ``unicode``)
+        :param filetype: (optional) The encoding of the file, default is PEM
+
+        :return: None
+        """
+        keyfile = _path_string(keyfile)
+
+        if filetype is _UNSPECIFIED:
+            filetype = FILETYPE_PEM
+        elif not isinstance(filetype, integer_types):
+            raise TypeError("filetype must be an integer")
+
+        use_result = _lib.SSL_CTX_use_PrivateKey_file(
+            self._context, keyfile, filetype)
+        if not use_result:
+            self._raise_passphrase_exception()
+
+
+    def use_privatekey(self, pkey):
+        """
+        Load a private key from a PKey object
+
+        :param pkey: The PKey object
+        :return: None
+        """
+        if not isinstance(pkey, PKey):
+            raise TypeError("pkey must be a PKey instance")
+
+        use_result = _lib.SSL_CTX_use_PrivateKey(self._context, pkey._pkey)
+        if not use_result:
+            self._raise_passphrase_exception()
+
+
+    def check_privatekey(self):
+        """
+        Check that the private key and certificate match up
+
+        :return: None (raises an exception if something's wrong)
+        """
+        if not _lib.SSL_CTX_check_private_key(self._context):
+            _raise_current_error()
+
+
+    def load_client_ca(self, cafile):
+        """
+        Load the trusted certificates that will be sent to the client (basically
+        telling the client "These are the guys I trust").  Does not actually
+        imply any of the certificates are trusted; that must be configured
+        separately.
+
+        :param cafile: The name of the certificates file
+        :return: None
+        """
+
+    def set_session_id(self, buf):
+        """
+        Set the session identifier.  This is needed if you want to do session
+        resumption.
+
+        :param buf: A Python object that can be safely converted to a string
+        :returns: None
+        """
+
+    def set_session_cache_mode(self, mode):
+        """
+        Enable/disable session caching and specify the mode used.
+
+        :param mode: One or more of the SESS_CACHE_* flags (combine using
+            bitwise or)
+        :returns: The previously set caching mode.
+        """
+        if not isinstance(mode, integer_types):
+            raise TypeError("mode must be an integer")
+
+        return _lib.SSL_CTX_set_session_cache_mode(self._context, mode)
+
+
+    def get_session_cache_mode(self):
+        """
+        :returns: The currently used cache mode.
+        """
+        return _lib.SSL_CTX_get_session_cache_mode(self._context)
+
+
+    def set_verify(self, mode, callback):
+        """
+        Set the verify mode and verify callback
+
+        :param mode: The verify mode, this is either VERIFY_NONE or
+                     VERIFY_PEER combined with possible other flags
+        :param callback: The Python callback to use
+        :return: None
+
+        See SSL_CTX_set_verify(3SSL) for further details.
+        """
+        if not isinstance(mode, integer_types):
+            raise TypeError("mode must be an integer")
+
+        if not callable(callback):
+            raise TypeError("callback must be callable")
+
+        self._verify_helper = _VerifyHelper(callback)
+        self._verify_callback = self._verify_helper.callback
+        _lib.SSL_CTX_set_verify(self._context, mode, self._verify_callback)
+
+
+    def set_verify_depth(self, depth):
+        """
+        Set the verify depth
+
+        :param depth: An integer specifying the verify depth
+        :return: None
+        """
+        if not isinstance(depth, integer_types):
+            raise TypeError("depth must be an integer")
+
+        _lib.SSL_CTX_set_verify_depth(self._context, depth)
+
+
+    def get_verify_mode(self):
+        """
+        Get the verify mode
+
+        :return: The verify mode
+        """
+        return _lib.SSL_CTX_get_verify_mode(self._context)
+
+
+    def get_verify_depth(self):
+        """
+        Get the verify depth
+
+        :return: The verify depth
+        """
+        return _lib.SSL_CTX_get_verify_depth(self._context)
+
+
+    def load_tmp_dh(self, dhfile):
+        """
+        Load parameters for Ephemeral Diffie-Hellman
+
+        :param dhfile: The file to load EDH parameters from (``bytes`` or
+            ``unicode``).
+
+        :return: None
+        """
+        dhfile = _path_string(dhfile)
+
+        bio = _lib.BIO_new_file(dhfile, b"r")
+        if bio == _ffi.NULL:
+            _raise_current_error()
+        bio = _ffi.gc(bio, _lib.BIO_free)
+
+        dh = _lib.PEM_read_bio_DHparams(bio, _ffi.NULL, _ffi.NULL, _ffi.NULL)
+        dh = _ffi.gc(dh, _lib.DH_free)
+        _lib.SSL_CTX_set_tmp_dh(self._context, dh)
+
+
+    def set_tmp_ecdh(self, curve):
+        """
+        Select a curve to use for ECDHE key exchange.
+
+        :param curve: A curve object to use as returned by either
+            :py:meth:`OpenSSL.crypto.get_elliptic_curve` or
+            :py:meth:`OpenSSL.crypto.get_elliptic_curves`.
+
+        :return: None
+        """
+        _lib.SSL_CTX_set_tmp_ecdh(self._context, curve._to_EC_KEY())
+
+
+    def set_cipher_list(self, cipher_list):
+        """
+        Change the cipher list
+
+        :param cipher_list: A cipher list, see ciphers(1)
+        :return: None
+        """
+        if isinstance(cipher_list, _text_type):
+            cipher_list = cipher_list.encode("ascii")
+
+        if not isinstance(cipher_list, bytes):
+            raise TypeError("cipher_list must be bytes or unicode")
+
+        result = _lib.SSL_CTX_set_cipher_list(self._context, cipher_list)
+        if not result:
+            _raise_current_error()
+
+
+    def set_client_ca_list(self, certificate_authorities):
+        """
+        Set the list of preferred client certificate signers for this server context.
+
+        This list of certificate authorities will be sent to the client when the
+        server requests a client certificate.
+
+        :param certificate_authorities: a sequence of X509Names.
+        :return: None
+        """
+        name_stack = _lib.sk_X509_NAME_new_null()
+        if name_stack == _ffi.NULL:
+            # TODO: This is untested.
+            _raise_current_error()
+
+        try:
+            for ca_name in certificate_authorities:
+                if not isinstance(ca_name, X509Name):
+                    raise TypeError(
+                        "client CAs must be X509Name objects, not %s objects" % (
+                            type(ca_name).__name__,))
+                copy = _lib.X509_NAME_dup(ca_name._name)
+                if copy == _ffi.NULL:
+                    # TODO: This is untested.
+                    _raise_current_error()
+                push_result = _lib.sk_X509_NAME_push(name_stack, copy)
+                if not push_result:
+                    _lib.X509_NAME_free(copy)
+                    _raise_current_error()
+        except:
+            _lib.sk_X509_NAME_free(name_stack)
+            raise
+
+        _lib.SSL_CTX_set_client_CA_list(self._context, name_stack)
+
+
+    def add_client_ca(self, certificate_authority):
+        """
+        Add the CA certificate to the list of preferred signers for this context.
+
+        The list of certificate authorities will be sent to the client when the
+        server requests a client certificate.
+
+        :param certificate_authority: certificate authority's X509 certificate.
+        :return: None
+        """
+        if not isinstance(certificate_authority, X509):
+            raise TypeError("certificate_authority must be an X509 instance")
+
+        add_result = _lib.SSL_CTX_add_client_CA(
+            self._context, certificate_authority._x509)
+        if not add_result:
+            # TODO: This is untested.
+            _raise_current_error()
+
+
+    def set_timeout(self, timeout):
+        """
+        Set session timeout
+
+        :param timeout: The timeout in seconds
+        :return: The previous session timeout
+        """
+        if not isinstance(timeout, integer_types):
+            raise TypeError("timeout must be an integer")
+
+        return _lib.SSL_CTX_set_timeout(self._context, timeout)
+
+
+    def get_timeout(self):
+        """
+        Get the session timeout
+
+        :return: The session timeout
+        """
+        return _lib.SSL_CTX_get_timeout(self._context)
+
+
+    def set_info_callback(self, callback):
+        """
+        Set the info callback
+
+        :param callback: The Python callback to use
+        :return: None
+        """
+        @wraps(callback)
+        def wrapper(ssl, where, return_code):
+            callback(Connection._reverse_mapping[ssl], where, return_code)
+        self._info_callback = _ffi.callback(
+            "void (*)(const SSL *, int, int)", wrapper)
+        _lib.SSL_CTX_set_info_callback(self._context, self._info_callback)
+
+
+    def get_app_data(self):
+        """
+        Get the application data (supplied via set_app_data())
+
+        :return: The application data
+        """
+        return self._app_data
+
+
+    def set_app_data(self, data):
+        """
+        Set the application data (will be returned from get_app_data())
+
+        :param data: Any Python object
+        :return: None
+        """
+        self._app_data = data
+
+
+    def get_cert_store(self):
+        """
+        Get the certificate store for the context.
+
+        :return: A X509Store object or None if it does not have one.
+        """
+        store = _lib.SSL_CTX_get_cert_store(self._context)
+        if store == _ffi.NULL:
+            # TODO: This is untested.
+            return None
+
+        pystore = X509Store.__new__(X509Store)
+        pystore._store = store
+        return pystore
+
+
+    def set_options(self, options):
+        """
+        Add options. Options set before are not cleared!
+
+        :param options: The options to add.
+        :return: The new option bitmask.
+        """
+        if not isinstance(options, integer_types):
+            raise TypeError("options must be an integer")
+
+        return _lib.SSL_CTX_set_options(self._context, options)
+
+
+    def set_mode(self, mode):
+        """
+        Add modes via bitmask. Modes set before are not cleared!
+
+        :param mode: The mode to add.
+        :return: The new mode bitmask.
+        """
+        if not isinstance(mode, integer_types):
+            raise TypeError("mode must be an integer")
+
+        return _lib.SSL_CTX_set_mode(self._context, mode)
+
+
+    def set_tlsext_servername_callback(self, callback):
+        """
+        Specify a callback function to be called when clients specify a server name.
+
+        :param callback: The callback function.  It will be invoked with one
+            argument, the Connection instance.
+        """
+        @wraps(callback)
+        def wrapper(ssl, alert, arg):
+            callback(Connection._reverse_mapping[ssl])
+            return 0
+
+        self._tlsext_servername_callback = _ffi.callback(
+            "int (*)(const SSL *, int *, void *)", wrapper)
+        _lib.SSL_CTX_set_tlsext_servername_callback(
+            self._context, self._tlsext_servername_callback)
+
+
+    @_requires_npn
+    def set_npn_advertise_callback(self, callback):
+        """
+        Specify a callback function that will be called when offering `Next
+        Protocol Negotiation
+        <https://technotes.googlecode.com/git/nextprotoneg.html>`_ as a server.
+
+        :param callback: The callback function.  It will be invoked with one
+            argument, the Connection instance.  It should return a list of
+            bytestrings representing the advertised protocols, like
+            ``[b'http/1.1', b'spdy/2']``.
+        """
+        self._npn_advertise_helper = _NpnAdvertiseHelper(callback)
+        self._npn_advertise_callback = self._npn_advertise_helper.callback
+        _lib.SSL_CTX_set_next_protos_advertised_cb(
+            self._context, self._npn_advertise_callback, _ffi.NULL)
+
+
+    @_requires_npn
+    def set_npn_select_callback(self, callback):
+        """
+        Specify a callback function that will be called when a server offers
+        Next Protocol Negotiation options.
+
+        :param callback: The callback function.  It will be invoked with two
+            arguments: the Connection, and a list of offered protocols as
+            bytestrings, e.g. ``[b'http/1.1', b'spdy/2']``.  It should return
+            one of those bytestrings, the chosen protocol.
+        """
+        self._npn_select_helper = _NpnSelectHelper(callback)
+        self._npn_select_callback = self._npn_select_helper.callback
+        _lib.SSL_CTX_set_next_proto_select_cb(
+            self._context, self._npn_select_callback, _ffi.NULL)
+
+    @_requires_alpn
+    def set_alpn_protos(self, protos):
+        """
+        Specify the clients ALPN protocol list.
+
+        These protocols are offered to the server during protocol negotiation.
+
+        :param protos: A list of the protocols to be offered to the server.
+            This list should be a Python list of bytestrings representing the
+            protocols to offer, e.g. ``[b'http/1.1', b'spdy/2']``.
+        """
+        # Take the list of protocols and join them together, prefixing them
+        # with their lengths.
+        protostr = b''.join(
+            chain.from_iterable((int2byte(len(p)), p) for p in protos)
+        )
+
+        # Build a C string from the list. We don't need to save this off
+        # because OpenSSL immediately copies the data out.
+        input_str = _ffi.new("unsigned char[]", protostr)
+        input_str_len = _ffi.cast("unsigned", len(protostr))
+        _lib.SSL_CTX_set_alpn_protos(self._context, input_str, input_str_len)
+
+    @_requires_alpn
+    def set_alpn_select_callback(self, callback):
+        """
+        Set the callback to handle ALPN protocol choice.
+
+        :param callback: The callback function.  It will be invoked with two
+            arguments: the Connection, and a list of offered protocols as
+            bytestrings, e.g ``[b'http/1.1', b'spdy/2']``.  It should return
+            one of those bytestrings, the chosen protocol.
+        """
+        self._alpn_select_helper = _ALPNSelectHelper(callback)
+        self._alpn_select_callback = self._alpn_select_helper.callback
+        _lib.SSL_CTX_set_alpn_select_cb(
+            self._context, self._alpn_select_callback, _ffi.NULL)
+
+ContextType = Context
+
+
+
+class Connection(object):
+    """
+    """
+    _reverse_mapping = WeakValueDictionary()
+
+    def __init__(self, context, socket=None):
+        """
+        Create a new Connection object, using the given OpenSSL.SSL.Context
+        instance and socket.
+
+        :param context: An SSL Context to use for this connection
+        :param socket: The socket to use for transport layer
+        """
+        if not isinstance(context, Context):
+            raise TypeError("context must be a Context instance")
+
+        ssl = _lib.SSL_new(context._context)
+        self._ssl = _ffi.gc(ssl, _lib.SSL_free)
+        self._context = context
+
+        # References to strings used for Next Protocol Negotiation. OpenSSL's
+        # header files suggest that these might get copied at some point, but
+        # doesn't specify when, so we store them here to make sure they don't
+        # get freed before OpenSSL uses them.
+        self._npn_advertise_callback_args = None
+        self._npn_select_callback_args = None
+
+        # References to strings used for Application Layer Protocol
+        # Negotiation. These strings get copied at some point but it's well
+        # after the callback returns, so we have to hang them somewhere to
+        # avoid them getting freed.
+        self._alpn_select_callback_args = None
+
+        self._reverse_mapping[self._ssl] = self
+
+        if socket is None:
+            self._socket = None
+            # Don't set up any gc for these, SSL_free will take care of them.
+            self._into_ssl = _lib.BIO_new(_lib.BIO_s_mem())
+            self._from_ssl = _lib.BIO_new(_lib.BIO_s_mem())
+
+            if self._into_ssl == _ffi.NULL or self._from_ssl == _ffi.NULL:
+                # TODO: This is untested.
+                _raise_current_error()
+
+            _lib.SSL_set_bio(self._ssl, self._into_ssl, self._from_ssl)
+        else:
+            self._into_ssl = None
+            self._from_ssl = None
+            self._socket = socket
+            set_result = _lib.SSL_set_fd(self._ssl, _asFileDescriptor(self._socket))
+            if not set_result:
+                # TODO: This is untested.
+                _raise_current_error()
+
+
+    def __getattr__(self, name):
+        """
+        Look up attributes on the wrapped socket object if they are not found on
+        the Connection object.
+        """
+        return getattr(self._socket, name)
+
+
+    def _raise_ssl_error(self, ssl, result):
+        if self._context._verify_helper is not None:
+            self._context._verify_helper.raise_if_problem()
+        if self._context._npn_advertise_helper is not None:
+            self._context._npn_advertise_helper.raise_if_problem()
+        if self._context._npn_select_helper is not None:
+            self._context._npn_select_helper.raise_if_problem()
+        if self._context._alpn_select_helper is not None:
+            self._context._alpn_select_helper.raise_if_problem()
+
+        error = _lib.SSL_get_error(ssl, result)
+        if error == _lib.SSL_ERROR_WANT_READ:
+            raise WantReadError()
+        elif error == _lib.SSL_ERROR_WANT_WRITE:
+            raise WantWriteError()
+        elif error == _lib.SSL_ERROR_ZERO_RETURN:
+            raise ZeroReturnError()
+        elif error == _lib.SSL_ERROR_WANT_X509_LOOKUP:
+            # TODO: This is untested.
+            raise WantX509LookupError()
+        elif error == _lib.SSL_ERROR_SYSCALL:
+            if _lib.ERR_peek_error() == 0:
+                if result < 0:
+                    if platform == "win32":
+                        errno = _ffi.getwinerror()[0]
+                    else:
+                        errno = _ffi.errno
+                    raise SysCallError(errno, errorcode.get(errno))
+                else:
+                    raise SysCallError(-1, "Unexpected EOF")
+            else:
+                # TODO: This is untested.
+                _raise_current_error()
+        elif error == _lib.SSL_ERROR_NONE:
+            pass
+        else:
+            _raise_current_error()
+
+
+    def get_context(self):
+        """
+        Get session context
+        """
+        return self._context
+
+
+    def set_context(self, context):
+        """
+        Switch this connection to a new session context
+
+        :param context: A :py:class:`Context` instance giving the new session
+            context to use.
+        """
+        if not isinstance(context, Context):
+            raise TypeError("context must be a Context instance")
+
+        _lib.SSL_set_SSL_CTX(self._ssl, context._context)
+        self._context = context
+
+
+    def get_servername(self):
+        """
+        Retrieve the servername extension value if provided in the client hello
+        message, or None if there wasn't one.
+
+        :return: A byte string giving the server name or :py:data:`None`.
+        """
+        name = _lib.SSL_get_servername(self._ssl, _lib.TLSEXT_NAMETYPE_host_name)
+        if name == _ffi.NULL:
+            return None
+
+        return _ffi.string(name)
+
+
+    def set_tlsext_host_name(self, name):
+        """
+        Set the value of the servername extension to send in the client hello.
+
+        :param name: A byte string giving the name.
+        """
+        if not isinstance(name, bytes):
+            raise TypeError("name must be a byte string")
+        elif b"\0" in name:
+            raise TypeError("name must not contain NUL byte")
+
+        # XXX I guess this can fail sometimes?
+        _lib.SSL_set_tlsext_host_name(self._ssl, name)
+
+
+    def pending(self):
+        """
+        Get the number of bytes that can be safely read from the connection
+
+        :return: The number of bytes available in the receive buffer.
+        """
+        return _lib.SSL_pending(self._ssl)
+
+
+    def send(self, buf, flags=0):
+        """
+        Send data on the connection. NOTE: If you get one of the WantRead,
+        WantWrite or WantX509Lookup exceptions on this, you have to call the
+        method again with the SAME buffer.
+
+        :param buf: The string, buffer or memoryview to send
+        :param flags: (optional) Included for compatibility with the socket
+                      API, the value is ignored
+        :return: The number of bytes written
+        """
+        # Backward compatibility
+        buf = _text_to_bytes_and_warn("buf", buf)
+
+        if isinstance(buf, _memoryview):
+            buf = buf.tobytes()
+        if isinstance(buf, _buffer):
+            buf = str(buf)
+        if not isinstance(buf, bytes):
+            raise TypeError("data must be a memoryview, buffer or byte string")
+
+        result = _lib.SSL_write(self._ssl, buf, len(buf))
+        self._raise_ssl_error(self._ssl, result)
+        return result
+    write = send
+
+
+    def sendall(self, buf, flags=0):
+        """
+        Send "all" data on the connection. This calls send() repeatedly until
+        all data is sent. If an error occurs, it's impossible to tell how much
+        data has been sent.
+
+        :param buf: The string, buffer or memoryview to send
+        :param flags: (optional) Included for compatibility with the socket
+                      API, the value is ignored
+        :return: The number of bytes written
+        """
+        buf = _text_to_bytes_and_warn("buf", buf)
+
+        if isinstance(buf, _memoryview):
+            buf = buf.tobytes()
+        if isinstance(buf, _buffer):
+            buf = str(buf)
+        if not isinstance(buf, bytes):
+            raise TypeError("buf must be a memoryview, buffer or byte string")
+
+        left_to_send = len(buf)
+        total_sent = 0
+        data = _ffi.new("char[]", buf)
+
+        while left_to_send:
+            result = _lib.SSL_write(self._ssl, data + total_sent, left_to_send)
+            self._raise_ssl_error(self._ssl, result)
+            total_sent += result
+            left_to_send -= result
+
+
+    def recv(self, bufsiz, flags=None):
+        """
+        Receive data on the connection. NOTE: If you get one of the WantRead,
+        WantWrite or WantX509Lookup exceptions on this, you have to call the
+        method again with the SAME buffer.
+
+        :param bufsiz: The maximum number of bytes to read
+        :param flags: (optional) Included for compatibility with the socket
+                      API, the value is ignored
+        :return: The string read from the Connection
+        """
+        buf = _ffi.new("char[]", bufsiz)
+        result = _lib.SSL_read(self._ssl, buf, bufsiz)
+        self._raise_ssl_error(self._ssl, result)
+        return _ffi.buffer(buf, result)[:]
+    read = recv
+
+
+    def recv_into(self, buffer, nbytes=None, flags=None):
+        """
+        Receive data on the connection and store the data into a buffer rather
+        than creating a new string.
+
+        :param buffer: The buffer to copy into.
+        :param nbytes: (optional) The maximum number of bytes to read into the
+            buffer. If not present, defaults to the size of the buffer. If
+            larger than the size of the buffer, is reduced to the size of the
+            buffer.
+        :param flags: (optional) Included for compatibility with the socket
+            API, the value is ignored.
+        :return: The number of bytes read into the buffer.
+        """
+        if nbytes is None:
+            nbytes = len(buffer)
+        else:
+            nbytes = min(nbytes, len(buffer))
+
+        # We need to create a temporary buffer. This is annoying, it would be
+        # better if we could pass memoryviews straight into the SSL_read call,
+        # but right now we can't. Revisit this if CFFI gets that ability.
+        buf = _ffi.new("char[]", nbytes)
+        result = _lib.SSL_read(self._ssl, buf, nbytes)
+        self._raise_ssl_error(self._ssl, result)
+
+        # This strange line is all to avoid a memory copy. The buffer protocol
+        # should allow us to assign a CFFI buffer to the LHS of this line, but
+        # on CPython 3.3+ that segfaults. As a workaround, we can temporarily
+        # wrap it in a memoryview, except on Python 2.6 which doesn't have a
+        # memoryview type.
+        try:
+            buffer[:result] = memoryview(_ffi.buffer(buf, result))
+        except NameError:
+            buffer[:result] = _ffi.buffer(buf, result)
+
+        return result
+
+
+    def _handle_bio_errors(self, bio, result):
+        if _lib.BIO_should_retry(bio):
+            if _lib.BIO_should_read(bio):
+                raise WantReadError()
+            elif _lib.BIO_should_write(bio):
+                # TODO: This is untested.
+                raise WantWriteError()
+            elif _lib.BIO_should_io_special(bio):
+                # TODO: This is untested.  I think io_special means the socket
+                # BIO has a not-yet connected socket.
+                raise ValueError("BIO_should_io_special")
+            else:
+                # TODO: This is untested.
+                raise ValueError("unknown bio failure")
+        else:
+            # TODO: This is untested.
+            _raise_current_error()
+
+
+    def bio_read(self, bufsiz):
+        """
+        When using non-socket connections this function reads the "dirty" data
+        that would have traveled away on the network.
+
+        :param bufsiz: The maximum number of bytes to read
+        :return: The string read.
+        """
+        if self._from_ssl is None:
+            raise TypeError("Connection sock was not None")
+
+        if not isinstance(bufsiz, integer_types):
+            raise TypeError("bufsiz must be an integer")
+
+        buf = _ffi.new("char[]", bufsiz)
+        result = _lib.BIO_read(self._from_ssl, buf, bufsiz)
+        if result <= 0:
+            self._handle_bio_errors(self._from_ssl, result)
+
+        return _ffi.buffer(buf, result)[:]
+
+
+    def bio_write(self, buf):
+        """
+        When using non-socket connections this function sends "dirty" data that
+        would have traveled in on the network.
+
+        :param buf: The string to put into the memory BIO.
+        :return: The number of bytes written
+        """
+        buf = _text_to_bytes_and_warn("buf", buf)
+
+        if self._into_ssl is None:
+            raise TypeError("Connection sock was not None")
+
+        if not isinstance(buf, bytes):
+            raise TypeError("buf must be a byte string")
+
+        result = _lib.BIO_write(self._into_ssl, buf, len(buf))
+        if result <= 0:
+            self._handle_bio_errors(self._into_ssl, result)
+        return result
+
+
+    def renegotiate(self):
+        """
+        Renegotiate the session
+
+        :return: True if the renegotiation can be started, false otherwise
+        """
+
+    def do_handshake(self):
+        """
+        Perform an SSL handshake (usually called after renegotiate() or one of
+        set_*_state()). This can raise the same exceptions as send and recv.
+
+        :return: None.
+        """
+        result = _lib.SSL_do_handshake(self._ssl)
+        self._raise_ssl_error(self._ssl, result)
+
+
+    def renegotiate_pending(self):
+        """
+        Check if there's a renegotiation in progress, it will return false once
+        a renegotiation is finished.
+
+        :return: Whether there's a renegotiation in progress
+        """
+
+    def total_renegotiations(self):
+        """
+        Find out the total number of renegotiations.
+
+        :return: The number of renegotiations.
+        """
+        return _lib.SSL_total_renegotiations(self._ssl)
+
+
+    def connect(self, addr):
+        """
+        Connect to remote host and set up client-side SSL
+
+        :param addr: A remote address
+        :return: What the socket's connect method returns
+        """
+        _lib.SSL_set_connect_state(self._ssl)
+        return self._socket.connect(addr)
+
+
+    def connect_ex(self, addr):
+        """
+        Connect to remote host and set up client-side SSL. Note that if the socket's
+        connect_ex method doesn't return 0, SSL won't be initialized.
+
+        :param addr: A remove address
+        :return: What the socket's connect_ex method returns
+        """
+        connect_ex = self._socket.connect_ex
+        self.set_connect_state()
+        return connect_ex(addr)
+
+
+    def accept(self):
+        """
+        Accept incoming connection and set up SSL on it
+
+        :return: A (conn,addr) pair where conn is a Connection and addr is an
+                 address
+        """
+        client, addr = self._socket.accept()
+        conn = Connection(self._context, client)
+        conn.set_accept_state()
+        return (conn, addr)
+
+
+    def bio_shutdown(self):
+        """
+        When using non-socket connections this function signals end of
+        data on the input for this connection.
+
+        :return: None
+        """
+        if self._from_ssl is None:
+            raise TypeError("Connection sock was not None")
+
+        _lib.BIO_set_mem_eof_return(self._into_ssl, 0)
+
+
+    def shutdown(self):
+        """
+        Send closure alert
+
+        :return: True if the shutdown completed successfully (i.e. both sides
+                 have sent closure alerts), false otherwise (i.e. you have to
+                 wait for a ZeroReturnError on a recv() method call
+        """
+        result = _lib.SSL_shutdown(self._ssl)
+        if result < 0:
+            self._raise_ssl_error(self._ssl, result)
+        elif result > 0:
+            return True
+        else:
+            return False
+
+
+    def get_cipher_list(self):
+        """
+        Get the session cipher list
+
+        :return: A list of cipher strings
+        """
+        ciphers = []
+        for i in count():
+            result = _lib.SSL_get_cipher_list(self._ssl, i)
+            if result == _ffi.NULL:
+                break
+            ciphers.append(_native(_ffi.string(result)))
+        return ciphers
+
+
+    def get_client_ca_list(self):
+        """
+        Get CAs whose certificates are suggested for client authentication.
+
+        :return: If this is a server connection, a list of X509Names representing
+            the acceptable CAs as set by :py:meth:`OpenSSL.SSL.Context.set_client_ca_list` or
+            :py:meth:`OpenSSL.SSL.Context.add_client_ca`.  If this is a client connection,
+            the list of such X509Names sent by the server, or an empty list if that
+            has not yet happened.
+        """
+        ca_names = _lib.SSL_get_client_CA_list(self._ssl)
+        if ca_names == _ffi.NULL:
+            # TODO: This is untested.
+            return []
+
+        result = []
+        for i in range(_lib.sk_X509_NAME_num(ca_names)):
+            name = _lib.sk_X509_NAME_value(ca_names, i)
+            copy = _lib.X509_NAME_dup(name)
+            if copy == _ffi.NULL:
+                # TODO: This is untested.
+                _raise_current_error()
+
+            pyname = X509Name.__new__(X509Name)
+            pyname._name = _ffi.gc(copy, _lib.X509_NAME_free)
+            result.append(pyname)
+        return result
+
+
+    def makefile(self):
+        """
+        The makefile() method is not implemented, since there is no dup semantics
+        for SSL connections
+
+        :raise: NotImplementedError
+        """
+        raise NotImplementedError("Cannot make file object of OpenSSL.SSL.Connection")
+
+
+    def get_app_data(self):
+        """
+        Get application data
+
+        :return: The application data
+        """
+        return self._app_data
+
+
+    def set_app_data(self, data):
+        """
+        Set application data
+
+        :param data - The application data
+        :return: None
+        """
+        self._app_data = data
+
+
+    def get_shutdown(self):
+        """
+        Get shutdown state
+
+        :return: The shutdown state, a bitvector of SENT_SHUTDOWN, RECEIVED_SHUTDOWN.
+        """
+        return _lib.SSL_get_shutdown(self._ssl)
+
+
+    def set_shutdown(self, state):
+        """
+        Set shutdown state
+
+        :param state - bitvector of SENT_SHUTDOWN, RECEIVED_SHUTDOWN.
+        :return: None
+        """
+        if not isinstance(state, integer_types):
+            raise TypeError("state must be an integer")
+
+        _lib.SSL_set_shutdown(self._ssl, state)
+
+
+    def state_string(self):
+        """
+        Get a verbose state description
+
+        :return: A string representing the state
+        """
+
+    def server_random(self):
+        """
+        Get a copy of the server hello nonce.
+
+        :return: A string representing the state
+        """
+        if self._ssl.session == _ffi.NULL:
+            return None
+        return _ffi.buffer(
+            self._ssl.s3.server_random,
+            _lib.SSL3_RANDOM_SIZE)[:]
+
+
+    def client_random(self):
+        """
+        Get a copy of the client hello nonce.
+
+        :return: A string representing the state
+        """
+        if self._ssl.session == _ffi.NULL:
+            return None
+        return _ffi.buffer(
+            self._ssl.s3.client_random,
+            _lib.SSL3_RANDOM_SIZE)[:]
+
+
+    def master_key(self):
+        """
+        Get a copy of the master key.
+
+        :return: A string representing the state
+        """
+        if self._ssl.session == _ffi.NULL:
+            return None
+        return _ffi.buffer(
+            self._ssl.session.master_key,
+            self._ssl.session.master_key_length)[:]
+
+
+    def sock_shutdown(self, *args, **kwargs):
+        """
+        See shutdown(2)
+
+        :return: What the socket's shutdown() method returns
+        """
+        return self._socket.shutdown(*args, **kwargs)
+
+
+    def get_peer_certificate(self):
+        """
+        Retrieve the other side's certificate (if any)
+
+        :return: The peer's certificate
+        """
+        cert = _lib.SSL_get_peer_certificate(self._ssl)
+        if cert != _ffi.NULL:
+            pycert = X509.__new__(X509)
+            pycert._x509 = _ffi.gc(cert, _lib.X509_free)
+            return pycert
+        return None
+
+
+    def get_peer_cert_chain(self):
+        """
+        Retrieve the other side's certificate (if any)
+
+        :return: A list of X509 instances giving the peer's certificate chain,
+                 or None if it does not have one.
+        """
+        cert_stack = _lib.SSL_get_peer_cert_chain(self._ssl)
+        if cert_stack == _ffi.NULL:
+            return None
+
+        result = []
+        for i in range(_lib.sk_X509_num(cert_stack)):
+            # TODO could incref instead of dup here
+            cert = _lib.X509_dup(_lib.sk_X509_value(cert_stack, i))
+            pycert = X509.__new__(X509)
+            pycert._x509 = _ffi.gc(cert, _lib.X509_free)
+            result.append(pycert)
+        return result
+
+
+    def want_read(self):
+        """
+        Checks if more data has to be read from the transport layer to complete an
+        operation.
+
+        :return: True iff more data has to be read
+        """
+        return _lib.SSL_want_read(self._ssl)
+
+
+    def want_write(self):
+        """
+        Checks if there is data to write to the transport layer to complete an
+        operation.
+
+        :return: True iff there is data to write
+        """
+        return _lib.SSL_want_write(self._ssl)
+
+
+    def set_accept_state(self):
+        """
+        Set the connection to work in server mode. The handshake will be handled
+        automatically by read/write.
+
+        :return: None
+        """
+        _lib.SSL_set_accept_state(self._ssl)
+
+
+    def set_connect_state(self):
+        """
+        Set the connection to work in client mode. The handshake will be handled
+        automatically by read/write.
+
+        :return: None
+        """
+        _lib.SSL_set_connect_state(self._ssl)
+
+
+    def get_session(self):
+        """
+        Returns the Session currently used.
+
+        @return: An instance of :py:class:`OpenSSL.SSL.Session` or :py:obj:`None` if
+            no session exists.
+        """
+        session = _lib.SSL_get1_session(self._ssl)
+        if session == _ffi.NULL:
+            return None
+
+        pysession = Session.__new__(Session)
+        pysession._session = _ffi.gc(session, _lib.SSL_SESSION_free)
+        return pysession
+
+
+    def set_session(self, session):
+        """
+        Set the session to be used when the TLS/SSL connection is established.
+
+        :param session: A Session instance representing the session to use.
+        :returns: None
+        """
+        if not isinstance(session, Session):
+            raise TypeError("session must be a Session instance")
+
+        result = _lib.SSL_set_session(self._ssl, session._session)
+        if not result:
+            _raise_current_error()
+
+
+    def _get_finished_message(self, function):
+        """
+        Helper to implement :py:meth:`get_finished` and
+        :py:meth:`get_peer_finished`.
+
+        :param function: Either :py:data:`SSL_get_finished`: or
+            :py:data:`SSL_get_peer_finished`.
+
+        :return: :py:data:`None` if the desired message has not yet been
+            received, otherwise the contents of the message.
+        :rtype: :py:class:`bytes` or :py:class:`NoneType`
+        """
+        # The OpenSSL documentation says nothing about what might happen if the
+        # count argument given is zero.  Specifically, it doesn't say whether
+        # the output buffer may be NULL in that case or not.  Inspection of the
+        # implementation reveals that it calls memcpy() unconditionally.
+        # Section 7.1.4, paragraph 1 of the C standard suggests that
+        # memcpy(NULL, source, 0) is not guaranteed to produce defined (let
+        # alone desirable) behavior (though it probably does on just about
+        # every implementation...)
+        #
+        # Allocate a tiny buffer to pass in (instead of just passing NULL as
+        # one might expect) for the initial call so as to be safe against this
+        # potentially undefined behavior.
+        empty = _ffi.new("char[]", 0)
+        size = function(self._ssl, empty, 0)
+        if size == 0:
+            # No Finished message so far.
+            return None
+
+        buf = _ffi.new("char[]", size)
+        function(self._ssl, buf, size)
+        return _ffi.buffer(buf, size)[:]
+
+
+    def get_finished(self):
+        """
+        Obtain the latest `handshake finished` message sent to the peer.
+
+        :return: The contents of the message or :py:obj:`None` if the TLS
+            handshake has not yet completed.
+        :rtype: :py:class:`bytes` or :py:class:`NoneType`
+        """
+        return self._get_finished_message(_lib.SSL_get_finished)
+
+
+    def get_peer_finished(self):
+        """
+        Obtain the latest `handshake finished` message received from the peer.
+
+        :return: The contents of the message or :py:obj:`None` if the TLS
+            handshake has not yet completed.
+        :rtype: :py:class:`bytes` or :py:class:`NoneType`
+        """
+        return self._get_finished_message(_lib.SSL_get_peer_finished)
+
+
+    def get_cipher_name(self):
+        """
+        Obtain the name of the currently used cipher.
+
+        :returns: The name of the currently used cipher or :py:obj:`None`
+            if no connection has been established.
+        :rtype: :py:class:`unicode` or :py:class:`NoneType`
+        """
+        cipher = _lib.SSL_get_current_cipher(self._ssl)
+        if cipher == _ffi.NULL:
+            return None
+        else:
+            name = _ffi.string(_lib.SSL_CIPHER_get_name(cipher))
+            return name.decode("utf-8")
+
+
+    def get_cipher_bits(self):
+        """
+        Obtain the number of secret bits of the currently used cipher.
+
+        :returns: The number of secret bits of the currently used cipher
+            or :py:obj:`None` if no connection has been established.
+        :rtype: :py:class:`int` or :py:class:`NoneType`
+        """
+        cipher = _lib.SSL_get_current_cipher(self._ssl)
+        if cipher == _ffi.NULL:
+            return None
+        else:
+            return _lib.SSL_CIPHER_get_bits(cipher, _ffi.NULL)
+
+
+    def get_cipher_version(self):
+        """
+        Obtain the protocol version of the currently used cipher.
+
+        :returns: The protocol name of the currently used cipher
+            or :py:obj:`None` if no connection has been established.
+        :rtype: :py:class:`unicode` or :py:class:`NoneType`
+        """
+        cipher = _lib.SSL_get_current_cipher(self._ssl)
+        if cipher == _ffi.NULL:
+            return None
+        else:
+            version =_ffi.string(_lib.SSL_CIPHER_get_version(cipher))
+            return version.decode("utf-8")
+
+
+    @_requires_npn
+    def get_next_proto_negotiated(self):
+        """
+        Get the protocol that was negotiated by NPN.
+        """
+        data = _ffi.new("unsigned char **")
+        data_len = _ffi.new("unsigned int *")
+
+        _lib.SSL_get0_next_proto_negotiated(self._ssl, data, data_len)
+
+        return _ffi.buffer(data[0], data_len[0])[:]
+
+    @_requires_alpn
+    def set_alpn_protos(self, protos):
+        """
+        Specify the client's ALPN protocol list.
+
+        These protocols are offered to the server during protocol negotiation.
+
+        :param protos: A list of the protocols to be offered to the server.
+            This list should be a Python list of bytestrings representing the
+            protocols to offer, e.g. ``[b'http/1.1', b'spdy/2']``.
+        """
+        # Take the list of protocols and join them together, prefixing them
+        # with their lengths.
+        protostr = b''.join(
+            chain.from_iterable((int2byte(len(p)), p) for p in protos)
+        )
+
+        # Build a C string from the list. We don't need to save this off
+        # because OpenSSL immediately copies the data out.
+        input_str = _ffi.new("unsigned char[]", protostr)
+        input_str_len = _ffi.cast("unsigned", len(protostr))
+        _lib.SSL_set_alpn_protos(self._ssl, input_str, input_str_len)
+
+
+    def get_alpn_proto_negotiated(self):
+        """
+        Get the protocol that was negotiated by ALPN.
+        """
+        if not _lib.Cryptography_HAS_ALPN:
+            raise NotImplementedError("ALPN not available")
+
+        data = _ffi.new("unsigned char **")
+        data_len = _ffi.new("unsigned int *")
+
+        _lib.SSL_get0_alpn_selected(self._ssl, data, data_len)
+
+        if not data_len:
+            return b''
+
+        return _ffi.buffer(data[0], data_len[0])[:]
+
+
+
+ConnectionType = Connection
+
+# This is similar to the initialization calls at the end of OpenSSL/crypto.py
+# but is exercised mostly by the Context initializer.
+_lib.SSL_library_init()
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/test/__init__.py hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/test/__init__.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/test/__init__.py	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/test/__init__.py	2014-01-10 11:06:42.000000000 +0100
@@ -2,5 +2,5 @@
 # See LICENSE for details.
 
 """
-Package containing unit tests for L{OpenSSL}.
+Package containing unit tests for :py:mod:`OpenSSL`.
 """
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/test/README hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/test/README
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/test/README	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/test/README	2014-01-10 11:06:42.000000000 +0100
@@ -0,0 +1,8 @@
+These tests are meant to be run using twisted's "trial" command.
+
+See http://twistedmatrix.com/trac/wiki/TwistedTrial
+
+For example...
+
+$ sudo python ./setup install
+$ trial OpenSSL
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/test/test_crypto.py hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/test/test_crypto.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/test/test_crypto.py	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/test/test_crypto.py	2015-04-14 04:50:11.000000000 +0200
@@ -2,17 +2,25 @@
 # See LICENSE file for details.
 
 """
-Unit tests for L{OpenSSL.crypto}.
+Unit tests for :py:mod:`OpenSSL.crypto`.
 """
 
 from unittest import main
+from warnings import catch_warnings, simplefilter
 
-import os, re
+import base64
+import os
+import re
 from subprocess import PIPE, Popen
 from datetime import datetime, timedelta
 
+from six import u, b, binary_type, PY3
+from warnings import simplefilter
+from warnings import catch_warnings
+
 from OpenSSL.crypto import TYPE_RSA, TYPE_DSA, Error, PKey, PKeyType
 from OpenSSL.crypto import X509, X509Type, X509Name, X509NameType
+from OpenSSL.crypto import X509Store, X509StoreType, X509StoreContext, X509StoreContextError
 from OpenSSL.crypto import X509Req, X509ReqType
 from OpenSSL.crypto import X509Extension, X509ExtensionType
 from OpenSSL.crypto import load_certificate, load_privatekey
@@ -23,8 +31,12 @@
 from OpenSSL.crypto import PKCS12, PKCS12Type, load_pkcs12
 from OpenSSL.crypto import CRL, Revoked, load_crl
 from OpenSSL.crypto import NetscapeSPKI, NetscapeSPKIType
-from OpenSSL.crypto import sign, verify
-from OpenSSL.test.util import TestCase, bytes, b
+from OpenSSL.crypto import (
+    sign, verify, get_elliptic_curve, get_elliptic_curves)
+from OpenSSL.test.util import (
+    EqualityTestsMixin, TestCase, WARNING_TYPE_EXPECTED
+)
+from OpenSSL._util import native, lib
 
 def normalize_certificate_pem(pem):
     return dump_certificate(FILETYPE_PEM, load_certificate(FILETYPE_PEM, pem))
@@ -34,6 +46,12 @@
     return dump_privatekey(FILETYPE_PEM, load_privatekey(FILETYPE_PEM, pem))
 
 
+GOOD_CIPHER = "blowfish"
+BAD_CIPHER = "zippers"
+
+GOOD_DIGEST = "MD5"
+BAD_DIGEST = "monkeys"
+
 root_cert_pem = b("""-----BEGIN CERTIFICATE-----
 MIIC7TCCAlagAwIBAgIIPQzE4MbeufQwDQYJKoZIhvcNAQEFBQAwWDELMAkGA1UE
 BhMCVVMxCzAJBgNVBAgTAklMMRAwDgYDVQQHEwdDaGljYWdvMRAwDgYDVQQKEwdU
@@ -71,6 +89,40 @@
 -----END RSA PRIVATE KEY-----
 """)
 
+intermediate_cert_pem = b("""-----BEGIN CERTIFICATE-----
+MIICVzCCAcCgAwIBAgIRAMPzhm6//0Y/g2pmnHR2C4cwDQYJKoZIhvcNAQENBQAw
+WDELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAklMMRAwDgYDVQQHEwdDaGljYWdvMRAw
+DgYDVQQKEwdUZXN0aW5nMRgwFgYDVQQDEw9UZXN0aW5nIFJvb3QgQ0EwHhcNMTQw
+ODI4MDIwNDA4WhcNMjQwODI1MDIwNDA4WjBmMRUwEwYDVQQDEwxpbnRlcm1lZGlh
+dGUxDDAKBgNVBAoTA29yZzERMA8GA1UECxMIb3JnLXVuaXQxCzAJBgNVBAYTAlVT
+MQswCQYDVQQIEwJDQTESMBAGA1UEBxMJU2FuIERpZWdvMIGfMA0GCSqGSIb3DQEB
+AQUAA4GNADCBiQKBgQDYcEQw5lfbEQRjr5Yy4yxAHGV0b9Al+Lmu7wLHMkZ/ZMmK
+FGIbljbviiD1Nz97Oh2cpB91YwOXOTN2vXHq26S+A5xe8z/QJbBsyghMur88CjdT
+21H2qwMa+r5dCQwEhuGIiZ3KbzB/n4DTMYI5zy4IYPv0pjxShZn4aZTCCK2IUwID
+AQABoxMwETAPBgNVHRMBAf8EBTADAQH/MA0GCSqGSIb3DQEBDQUAA4GBAPIWSkLX
+QRMApOjjyC+tMxumT5e2pMqChHmxobQK4NMdrf2VCx+cRT6EmY8sK3/Xl/X8UBQ+
+9n5zXb1ZwhW/sTWgUvmOceJ4/XVs9FkdWOOn1J0XBch9ZIiFe/s5ASIgG7fUdcUF
+9mAWS6FK2ca3xIh5kIupCXOFa0dPvlw/YUFT
+-----END CERTIFICATE-----
+""")
+
+intermediate_key_pem = b("""-----BEGIN RSA PRIVATE KEY-----
+MIICWwIBAAKBgQDYcEQw5lfbEQRjr5Yy4yxAHGV0b9Al+Lmu7wLHMkZ/ZMmKFGIb
+ljbviiD1Nz97Oh2cpB91YwOXOTN2vXHq26S+A5xe8z/QJbBsyghMur88CjdT21H2
+qwMa+r5dCQwEhuGIiZ3KbzB/n4DTMYI5zy4IYPv0pjxShZn4aZTCCK2IUwIDAQAB
+AoGAfSZVV80pSeOKHTYfbGdNY/jHdU9eFUa/33YWriXU+77EhpIItJjkRRgivIfo
+rhFJpBSGmDLblaqepm8emsXMeH4+2QzOYIf0QGGP6E6scjTt1PLqdqKfVJ1a2REN
+147cujNcmFJb/5VQHHMpaPTgttEjlzuww4+BCDPsVRABWrkCQQD3loH36nLoQTtf
++kQq0T6Bs9/UWkTAGo0ND81ALj0F8Ie1oeZg6RNT96RxZ3aVuFTESTv6/TbjWywO
+wdzlmV1vAkEA38rTJ6PTwaJlw5OttdDzAXGPB9tDmzh9oSi7cHwQQXizYd8MBYx4
+sjHUKD3dCQnb1dxJFhd3BT5HsnkRMbVZXQJAbXduH17ZTzcIOXc9jHDXYiFVZV5D
+52vV0WCbLzVCZc3jMrtSUKa8lPN5EWrdU3UchWybyG0MR5mX8S5lrF4SoQJAIyUD
+DBKaSqpqONCUUx1BTFS9FYrFjzbL4+c1qHCTTPTblt8kUCrDOZjBrKAqeiTmNSum
+/qUot9YUBF8m6BuGsQJATHHmdFy/fG1VLkyBp49CAa8tN3Z5r/CgTznI4DfMTf4C
+NbRHn2UmYlwQBa+L5lg9phewNe8aEwpPyPLoV85U8Q==
+-----END RSA PRIVATE KEY-----
+""")
+
 server_cert_pem = b("""-----BEGIN CERTIFICATE-----
 MIICKDCCAZGgAwIBAgIJAJn/HpR21r/8MA0GCSqGSIb3DQEBBQUAMFgxCzAJBgNV
 BAYTAlVTMQswCQYDVQQIEwJJTDEQMA4GA1UEBxMHQ2hpY2FnbzEQMA4GA1UEChMH
@@ -104,6 +156,40 @@
 -----END RSA PRIVATE KEY-----
 """))
 
+intermediate_server_cert_pem = b("""-----BEGIN CERTIFICATE-----
+MIICWDCCAcGgAwIBAgIRAPQFY9jfskSihdiNSNdt6GswDQYJKoZIhvcNAQENBQAw
+ZjEVMBMGA1UEAxMMaW50ZXJtZWRpYXRlMQwwCgYDVQQKEwNvcmcxETAPBgNVBAsT
+CG9yZy11bml0MQswCQYDVQQGEwJVUzELMAkGA1UECBMCQ0ExEjAQBgNVBAcTCVNh
+biBEaWVnbzAeFw0xNDA4MjgwMjEwNDhaFw0yNDA4MjUwMjEwNDhaMG4xHTAbBgNV
+BAMTFGludGVybWVkaWF0ZS1zZXJ2aWNlMQwwCgYDVQQKEwNvcmcxETAPBgNVBAsT
+CG9yZy11bml0MQswCQYDVQQGEwJVUzELMAkGA1UECBMCQ0ExEjAQBgNVBAcTCVNh
+biBEaWVnbzCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEAqpJZygd+w1faLOr1
+iOAmbBhx5SZWcTCZ/ZjHQTJM7GuPT624QkqsixFghRKdDROwpwnAP7gMRukLqiy4
++kRuGT5OfyGggL95i2xqA+zehjj08lSTlvGHpePJgCyTavIy5+Ljsj4DKnKyuhxm
+biXTRrH83NDgixVkObTEmh/OVK0CAwEAATANBgkqhkiG9w0BAQ0FAAOBgQBa0Npw
+UkzjaYEo1OUE1sTI6Mm4riTIHMak4/nswKh9hYup//WVOlr/RBSBtZ7Q/BwbjobN
+3bfAtV7eSAqBsfxYXyof7G1ALANQERkq3+oyLP1iVt08W1WOUlIMPhdCF/QuCwy6
+x9MJLhUCGLJPM+O2rAPWVD9wCmvq10ALsiH3yA==
+-----END CERTIFICATE-----
+""")
+
+intermediate_server_key_pem = b("""-----BEGIN RSA PRIVATE KEY-----
+MIICXAIBAAKBgQCqklnKB37DV9os6vWI4CZsGHHlJlZxMJn9mMdBMkzsa49PrbhC
+SqyLEWCFEp0NE7CnCcA/uAxG6QuqLLj6RG4ZPk5/IaCAv3mLbGoD7N6GOPTyVJOW
+8Yel48mALJNq8jLn4uOyPgMqcrK6HGZuJdNGsfzc0OCLFWQ5tMSaH85UrQIDAQAB
+AoGAIQ594j5zna3/9WaPsTgnmhlesVctt4AAx/n827DA4ayyuHFlXUuVhtoWR5Pk
+5ezj9mtYW8DyeCegABnsu2vZni/CdvU6uiS1Hv6qM1GyYDm9KWgovIP9rQCDSGaz
+d57IWVGxx7ODFkm3gN5nxnSBOFVHytuW1J7FBRnEsehRroECQQDXHFOv82JuXDcz
+z3+4c74IEURdOHcbycxlppmK9kFqm5lsUdydnnGW+mvwDk0APOB7Wg7vyFyr393e
+dpmBDCzNAkEAyv6tVbTKUYhSjW+QhabJo896/EqQEYUmtMXxk4cQnKeR/Ao84Rkf
+EqD5IykMUfUI0jJU4DGX+gWZ10a7kNbHYQJAVFCuHNFxS4Cpwo0aqtnzKoZaHY/8
+X9ABZfafSHCtw3Op92M+7ikkrOELXdS9KdKyyqbKJAKNEHF3LbOfB44WIQJAA2N4
+9UNNVUsXRbElEnYUS529CdUczo4QdVgQjkvk5RiPAUwSdBd9Q0xYnFOlFwEmIowg
+ipWJWe0aAlP18ZcEQQJBAL+5lekZ/GUdQoZ4HAsN5a9syrzavJ9VvU1KOOPorPZK
+nMRZbbQgP+aSB7yl6K0gaLaZ8XaK0pjxNBh6ASqg9f4=
+-----END RSA PRIVATE KEY-----
+""")
+
 client_cert_pem = b("""-----BEGIN CERTIFICATE-----
 MIICJjCCAY+gAwIBAgIJAKxpFI5lODkjMA0GCSqGSIb3DQEBBQUAMFgxCzAJBgNV
 BAYTAlVTMQswCQYDVQQIEwJJTDEQMA4GA1UEBxMHQ2hpY2FnbzEQMA4GA1UEChMH
@@ -238,6 +324,27 @@
 -----END PKCS7-----
 """)
 
+pkcs7DataASN1 = base64.b64decode(b"""
+MIIDNwYJKoZIhvcNAQcCoIIDKDCCAyQCAQExADALBgkqhkiG9w0BBwGgggMKMIID
+BjCCAm+gAwIBAgIBATANBgkqhkiG9w0BAQQFADB7MQswCQYDVQQGEwJTRzERMA8G
+A1UEChMITTJDcnlwdG8xFDASBgNVBAsTC00yQ3J5cHRvIENBMSQwIgYDVQQDExtN
+MkNyeXB0byBDZXJ0aWZpY2F0ZSBNYXN0ZXIxHTAbBgkqhkiG9w0BCQEWDm5ncHNA
+cG9zdDEuY29tMB4XDTAwMDkxMDA5NTEzMFoXDTAyMDkxMDA5NTEzMFowUzELMAkG
+A1UEBhMCU0cxETAPBgNVBAoTCE0yQ3J5cHRvMRIwEAYDVQQDEwlsb2NhbGhvc3Qx
+HTAbBgkqhkiG9w0BCQEWDm5ncHNAcG9zdDEuY29tMFwwDQYJKoZIhvcNAQEBBQAD
+SwAwSAJBAKy+e3dulvXzV7zoTZWc5TzgApr8DmeQHTYC8ydfzH7EECe4R1Xh5kwI
+zOuuFfn178FBiS84gngaNcrFi0Z5fAkCAwEAAaOCAQQwggEAMAkGA1UdEwQCMAAw
+LAYJYIZIAYb4QgENBB8WHU9wZW5TU0wgR2VuZXJhdGVkIENlcnRpZmljYXRlMB0G
+A1UdDgQWBBTPhIKSvnsmYsBVNWjj0m3M2z0qVTCBpQYDVR0jBIGdMIGagBT7hyNp
+65w6kxXlxb8pUU/+7Sg4AaF/pH0wezELMAkGA1UEBhMCU0cxETAPBgNVBAoTCE0y
+Q3J5cHRvMRQwEgYDVQQLEwtNMkNyeXB0byBDQTEkMCIGA1UEAxMbTTJDcnlwdG8g
+Q2VydGlmaWNhdGUgTWFzdGVyMR0wGwYJKoZIhvcNAQkBFg5uZ3BzQHBvc3QxLmNv
+bYIBADANBgkqhkiG9w0BAQQFAAOBgQA7/CqT6PoHycTdhEStWNZde7M/2Yc6BoJu
+VwnW8YxGO8Sn6UJ4FeffZNcYZddSDKosw8LtPOeWoK3JINjAk5jiPQ2cww++7QGG
+/g5NDjxFZNDJP1dGiLAxPW6JXwov4v0FmdzfLOZ01jDcgQQZqEpYlgpuI5JEWUQ9
+Ho4EzbYCOaEAMQA=
+""")
+
 crlData = b("""\
 -----BEGIN X509 CRL-----
 MIIBWzCBxTANBgkqhkiG9w0BAQQFADBYMQswCQYDVQQGEwJVUzELMAkGA1UECBMC
@@ -265,10 +372,41 @@
 -----END RSA PRIVATE KEY-----
 """)
 
+# certificate with NULL bytes in subjectAltName and common name
+
+nulbyteSubjectAltNamePEM = b("""-----BEGIN CERTIFICATE-----
+MIIE2DCCA8CgAwIBAgIBADANBgkqhkiG9w0BAQUFADCBxTELMAkGA1UEBhMCVVMx
+DzANBgNVBAgMBk9yZWdvbjESMBAGA1UEBwwJQmVhdmVydG9uMSMwIQYDVQQKDBpQ
+eXRob24gU29mdHdhcmUgRm91bmRhdGlvbjEgMB4GA1UECwwXUHl0aG9uIENvcmUg
+RGV2ZWxvcG1lbnQxJDAiBgNVBAMMG251bGwucHl0aG9uLm9yZwBleGFtcGxlLm9y
+ZzEkMCIGCSqGSIb3DQEJARYVcHl0aG9uLWRldkBweXRob24ub3JnMB4XDTEzMDgw
+NzEzMTE1MloXDTEzMDgwNzEzMTI1MlowgcUxCzAJBgNVBAYTAlVTMQ8wDQYDVQQI
+DAZPcmVnb24xEjAQBgNVBAcMCUJlYXZlcnRvbjEjMCEGA1UECgwaUHl0aG9uIFNv
+ZnR3YXJlIEZvdW5kYXRpb24xIDAeBgNVBAsMF1B5dGhvbiBDb3JlIERldmVsb3Bt
+ZW50MSQwIgYDVQQDDBtudWxsLnB5dGhvbi5vcmcAZXhhbXBsZS5vcmcxJDAiBgkq
+hkiG9w0BCQEWFXB5dGhvbi1kZXZAcHl0aG9uLm9yZzCCASIwDQYJKoZIhvcNAQEB
+BQADggEPADCCAQoCggEBALXq7cn7Rn1vO3aA3TrzA5QLp6bb7B3f/yN0CJ2XFj+j
+pHs+Gw6WWSUDpybiiKnPec33BFawq3kyblnBMjBU61ioy5HwQqVkJ8vUVjGIUq3P
+vX/wBmQfzCe4o4uM89gpHyUL9UYGG8oCRa17dgqcv7u5rg0Wq2B1rgY+nHwx3JIv
+KRrgSwyRkGzpN8WQ1yrXlxWjgI9de0mPVDDUlywcWze1q2kwaEPTM3hLAmD1PESA
+oY/n8A/RXoeeRs9i/Pm/DGUS8ZPINXk/yOzsR/XvvkTVroIeLZqfmFpnZeF0cHzL
+08LODkVJJ9zjLdT7SA4vnne4FEbAxDbKAq5qkYzaL4UCAwEAAaOB0DCBzTAMBgNV
+HRMBAf8EAjAAMB0GA1UdDgQWBBSIWlXAUv9hzVKjNQ/qWpwkOCL3XDALBgNVHQ8E
+BAMCBeAwgZAGA1UdEQSBiDCBhYIeYWx0bnVsbC5weXRob24ub3JnAGV4YW1wbGUu
+Y29tgSBudWxsQHB5dGhvbi5vcmcAdXNlckBleGFtcGxlLm9yZ4YpaHR0cDovL251
+bGwucHl0aG9uLm9yZwBodHRwOi8vZXhhbXBsZS5vcmeHBMAAAgGHECABDbgAAAAA
+AAAAAAAAAAEwDQYJKoZIhvcNAQEFBQADggEBAKxPRe99SaghcI6IWT7UNkJw9aO9
+i9eo0Fj2MUqxpKbdb9noRDy2CnHWf7EIYZ1gznXPdwzSN4YCjV5d+Q9xtBaowT0j
+HPERs1ZuytCNNJTmhyqZ8q6uzMLoht4IqH/FBfpvgaeC5tBTnTT0rD5A/olXeimk
+kX4LxlEx5RAvpGB2zZVRGr6LobD9rVK91xuHYNIxxxfEGE8tCCWjp0+3ksri9SXx
+VHWBnbM9YaL32u3hxm8sYB/Yb8WSBavJCWJJqRStVRHM1koZlJmXNx2BX4vPo6iW
+RFEIPQsFZRLrtnCAiEhyT8bC2s/Njlu6ly9gtJZWSV46Q3ZjBL4q9sHKqZQ=
+-----END CERTIFICATE-----""")
+
 
 class X509ExtTests(TestCase):
     """
-    Tests for L{OpenSSL.crypto.X509Extension}.
+    Tests for :py:class:`OpenSSL.crypto.X509Extension`.
     """
 
     def setUp(self):
@@ -276,6 +414,7 @@
         Create a new private key and start a certificate request (for a test
         method to finish in one way or another).
         """
+        super(X509ExtTests, self).setUp()
         # Basic setup stuff to generate a certificate
         self.pkey = PKey()
         self.pkey.generate_key(TYPE_RSA, 384)
@@ -294,10 +433,19 @@
         self.x509.set_notAfter(expire)
 
 
+    def tearDown(self):
+        """
+        Forget all of the pyOpenSSL objects so they can be garbage collected,
+        their memory released, and not interfere with the leak detection code.
+        """
+        self.pkey = self.req = self.x509 = self.subject = None
+        super(X509ExtTests, self).tearDown()
+
+
     def test_str(self):
         """
-        The string representation of L{X509Extension} instances as returned by
-        C{str} includes stuff.
+        The string representation of :py:class:`X509Extension` instances as returned by
+        :py:data:`str` includes stuff.
         """
         # This isn't necessarily the best string representation.  Perhaps it
         # will be changed/improved in the future.
@@ -308,7 +456,7 @@
 
     def test_type(self):
         """
-        L{X509Extension} and L{X509ExtensionType} refer to the same type object
+        :py:class:`X509Extension` and :py:class:`X509ExtensionType` refer to the same type object
         and can be used to create instances of that type.
         """
         self.assertIdentical(X509Extension, X509ExtensionType)
@@ -319,8 +467,8 @@
 
     def test_construction(self):
         """
-        L{X509Extension} accepts an extension type name, a critical flag,
-        and an extension value and returns an L{X509ExtensionType} instance.
+        :py:class:`X509Extension` accepts an extension type name, a critical flag,
+        and an extension value and returns an :py:class:`X509ExtensionType` instance.
         """
         basic = X509Extension(b('basicConstraints'), True, b('CA:true'))
         self.assertTrue(
@@ -338,7 +486,7 @@
 
     def test_invalid_extension(self):
         """
-        L{X509Extension} raises something if it is passed a bad extension
+        :py:class:`X509Extension` raises something if it is passed a bad extension
         name or value.
         """
         self.assertRaises(
@@ -357,7 +505,7 @@
 
     def test_get_critical(self):
         """
-        L{X509ExtensionType.get_critical} returns the value of the
+        :py:meth:`X509ExtensionType.get_critical` returns the value of the
         extension's critical flag.
         """
         ext = X509Extension(b('basicConstraints'), True, b('CA:true'))
@@ -368,7 +516,7 @@
 
     def test_get_short_name(self):
         """
-        L{X509ExtensionType.get_short_name} returns a string giving the short
+        :py:meth:`X509ExtensionType.get_short_name` returns a string giving the short
         type name of the extension.
         """
         ext = X509Extension(b('basicConstraints'), True, b('CA:true'))
@@ -379,7 +527,7 @@
 
     def test_get_data(self):
         """
-        L{X509Extension.get_data} returns a string giving the data of the
+        :py:meth:`X509Extension.get_data` returns a string giving the data of the
         extension.
         """
         ext = X509Extension(b('basicConstraints'), True, b('CA:true'))
@@ -389,7 +537,7 @@
 
     def test_get_data_wrong_args(self):
         """
-        L{X509Extension.get_data} raises L{TypeError} if passed any arguments.
+        :py:meth:`X509Extension.get_data` raises :py:exc:`TypeError` if passed any arguments.
         """
         ext = X509Extension(b('basicConstraints'), True, b('CA:true'))
         self.assertRaises(TypeError, ext.get_data, None)
@@ -399,7 +547,7 @@
 
     def test_unused_subject(self):
         """
-        The C{subject} parameter to L{X509Extension} may be provided for an
+        The :py:data:`subject` parameter to :py:class:`X509Extension` may be provided for an
         extension which does not use it and is ignored in this case.
         """
         ext1 = X509Extension(
@@ -414,8 +562,8 @@
 
     def test_subject(self):
         """
-        If an extension requires a subject, the C{subject} parameter to
-        L{X509Extension} provides its value.
+        If an extension requires a subject, the :py:data:`subject` parameter to
+        :py:class:`X509Extension` provides its value.
         """
         ext3 = X509Extension(
             b('subjectKeyIdentifier'), False, b('hash'), subject=self.x509)
@@ -427,7 +575,7 @@
 
     def test_missing_subject(self):
         """
-        If an extension requires a subject and the C{subject} parameter is
+        If an extension requires a subject and the :py:data:`subject` parameter is
         given no value, something happens.
         """
         self.assertRaises(
@@ -436,8 +584,8 @@
 
     def test_invalid_subject(self):
         """
-        If the C{subject} parameter is given a value which is not an L{X509}
-        instance, L{TypeError} is raised.
+        If the :py:data:`subject` parameter is given a value which is not an
+        :py:class:`X509` instance, :py:exc:`TypeError` is raised.
         """
         for badObj in [True, object(), "hello", [], self]:
             self.assertRaises(
@@ -448,7 +596,7 @@
 
     def test_unused_issuer(self):
         """
-        The C{issuer} parameter to L{X509Extension} may be provided for an
+        The :py:data:`issuer` parameter to :py:class:`X509Extension` may be provided for an
         extension which does not use it and is ignored in this case.
         """
         ext1 = X509Extension(
@@ -462,8 +610,8 @@
 
     def test_issuer(self):
         """
-        If an extension requires a issuer, the C{issuer} parameter to
-        L{X509Extension} provides its value.
+        If an extension requires an issuer, the :py:data:`issuer` parameter to
+        :py:class:`X509Extension` provides its value.
         """
         ext2 = X509Extension(
             b('authorityKeyIdentifier'), False, b('issuer:always'),
@@ -477,7 +625,7 @@
 
     def test_missing_issuer(self):
         """
-        If an extension requires an issue and the C{issuer} parameter is given
+        If an extension requires an issue and the :py:data:`issuer` parameter is given
         no value, something happens.
         """
         self.assertRaises(
@@ -489,8 +637,8 @@
 
     def test_invalid_issuer(self):
         """
-        If the C{issuer} parameter is given a value which is not an L{X509}
-        instance, L{TypeError} is raised.
+        If the :py:data:`issuer` parameter is given a value which is not an
+        :py:class:`X509` instance, :py:exc:`TypeError` is raised.
         """
         for badObj in [True, object(), "hello", [], self]:
             self.assertRaises(
@@ -503,12 +651,12 @@
 
 class PKeyTests(TestCase):
     """
-    Unit tests for L{OpenSSL.crypto.PKey}.
+    Unit tests for :py:class:`OpenSSL.crypto.PKey`.
     """
     def test_type(self):
         """
-        L{PKey} and L{PKeyType} refer to the same type object and can be used
-        to create instances of that type.
+        :py:class:`PKey` and :py:class:`PKeyType` refer to the same type object
+        and can be used to create instances of that type.
         """
         self.assertIdentical(PKey, PKeyType)
         self.assertConsistentType(PKey, 'PKey')
@@ -516,7 +664,7 @@
 
     def test_construction(self):
         """
-        L{PKey} takes no arguments and returns a new L{PKey} instance.
+        :py:class:`PKey` takes no arguments and returns a new :py:class:`PKey` instance.
         """
         self.assertRaises(TypeError, PKey, None)
         key = PKey()
@@ -527,8 +675,8 @@
 
     def test_pregeneration(self):
         """
-        L{PKeyType.bits} and L{PKeyType.type} return C{0} before the key is
-        generated.  L{PKeyType.check} raises L{TypeError} before the key is
+        :py:attr:`PKeyType.bits` and :py:attr:`PKeyType.type` return :py:data:`0` before the key is
+        generated.  :py:attr:`PKeyType.check` raises :py:exc:`TypeError` before the key is
         generated.
         """
         key = PKey()
@@ -539,11 +687,11 @@
 
     def test_failedGeneration(self):
         """
-        L{PKeyType.generate_key} takes two arguments, the first giving the key
-        type as one of L{TYPE_RSA} or L{TYPE_DSA} and the second giving the
+        :py:meth:`PKeyType.generate_key` takes two arguments, the first giving the key
+        type as one of :py:data:`TYPE_RSA` or :py:data:`TYPE_DSA` and the second giving the
         number of bits to generate.  If an invalid type is specified or
-        generation fails, L{Error} is raised.  If an invalid number of bits is
-        specified, L{ValueError} or L{Error} is raised.
+        generation fails, :py:exc:`Error` is raised.  If an invalid number of bits is
+        specified, :py:exc:`ValueError` or :py:exc:`Error` is raised.
         """
         key = PKey()
         self.assertRaises(TypeError, key.generate_key)
@@ -574,8 +722,8 @@
 
     def test_rsaGeneration(self):
         """
-        L{PKeyType.generate_key} generates an RSA key when passed
-        L{TYPE_RSA} as a type and a reasonable number of bits.
+        :py:meth:`PKeyType.generate_key` generates an RSA key when passed
+        :py:data:`TYPE_RSA` as a type and a reasonable number of bits.
         """
         bits = 128
         key = PKey()
@@ -587,8 +735,8 @@
 
     def test_dsaGeneration(self):
         """
-        L{PKeyType.generate_key} generates a DSA key when passed
-        L{TYPE_DSA} as a type and a reasonable number of bits.
+        :py:meth:`PKeyType.generate_key` generates a DSA key when passed
+        :py:data:`TYPE_DSA` as a type and a reasonable number of bits.
         """
         # 512 is a magic number.  The DSS (Digital Signature Standard)
         # allows a minimum of 512 bits for DSA.  DSA_generate_parameters
@@ -596,14 +744,14 @@
         bits = 512
         key = PKey()
         key.generate_key(TYPE_DSA, bits)
-        self.assertEqual(key.type(), TYPE_DSA)
-        self.assertEqual(key.bits(), bits)
-        self.assertRaises(TypeError, key.check)
+        # self.assertEqual(key.type(), TYPE_DSA)
+        # self.assertEqual(key.bits(), bits)
+        # self.assertRaises(TypeError, key.check)
 
 
     def test_regeneration(self):
         """
-        L{PKeyType.generate_key} can be called multiple times on the same
+        :py:meth:`PKeyType.generate_key` can be called multiple times on the same
         key to generate new keys.
         """
         key = PKey()
@@ -615,7 +763,7 @@
 
     def test_inconsistentKey(self):
         """
-        L{PKeyType.check} returns C{False} if the key is not consistent.
+        :py:`PKeyType.check` returns :py:exc:`Error` if the key is not consistent.
         """
         key = load_privatekey(FILETYPE_PEM, inconsistentPrivateKeyPEM)
         self.assertRaises(Error, key.check)
@@ -623,17 +771,31 @@
 
     def test_check_wrong_args(self):
         """
-        L{PKeyType.check} raises L{TypeError} if called with any arguments.
+        :py:meth:`PKeyType.check` raises :py:exc:`TypeError` if called with any arguments.
         """
         self.assertRaises(TypeError, PKey().check, None)
         self.assertRaises(TypeError, PKey().check, object())
         self.assertRaises(TypeError, PKey().check, 1)
 
 
+    def test_check_public_key(self):
+        """
+        :py:meth:`PKeyType.check` raises :py:exc:`TypeError` if only the public
+        part of the key is available.
+        """
+        # A trick to get a public-only key
+        key = PKey()
+        key.generate_key(TYPE_RSA, 512)
+        cert = X509()
+        cert.set_pubkey(key)
+        pub = cert.get_pubkey()
+        self.assertRaises(TypeError, pub.check)
+
+
 
 class X509NameTests(TestCase):
     """
-    Unit tests for L{OpenSSL.crypto.X509Name}.
+    Unit tests for :py:class:`OpenSSL.crypto.X509Name`.
     """
     def _x509name(self, **attrs):
         # XXX There's no other way to get a new X509Name yet.
@@ -650,7 +812,7 @@
 
     def test_type(self):
         """
-        The type of X509Name objects is L{X509NameType}.
+        The type of X509Name objects is :py:class:`X509NameType`.
         """
         self.assertIdentical(X509Name, X509NameType)
         self.assertEqual(X509NameType.__name__, 'X509Name')
@@ -665,25 +827,28 @@
 
     def test_onlyStringAttributes(self):
         """
-        Attempting to set a non-L{str} attribute name on an L{X509NameType}
-        instance causes L{TypeError} to be raised.
+        Attempting to set a non-:py:data:`str` attribute name on an :py:class:`X509NameType`
+        instance causes :py:exc:`TypeError` to be raised.
         """
         name = self._x509name()
         # Beyond these cases, you may also think that unicode should be
         # rejected.  Sorry, you're wrong.  unicode is automatically converted to
         # str outside of the control of X509Name, so there's no way to reject
         # it.
+
+        # Also, this used to test str subclasses, but that test is less relevant
+        # now that the implementation is in Python instead of C.  Also PyPy
+        # automatically converts str subclasses to str when they are passed to
+        # setattr, so we can't test it on PyPy.  Apparently CPython does this
+        # sometimes as well.
         self.assertRaises(TypeError, setattr, name, None, "hello")
         self.assertRaises(TypeError, setattr, name, 30, "hello")
-        class evil(str):
-            pass
-        self.assertRaises(TypeError, setattr, name, evil(), "hello")
 
 
     def test_setInvalidAttribute(self):
         """
-        Attempting to set any attribute name on an L{X509NameType} instance for
-        which no corresponding NID is defined causes L{AttributeError} to be
+        Attempting to set any attribute name on an :py:class:`X509NameType` instance for
+        which no corresponding NID is defined causes :py:exc:`AttributeError` to be
         raised.
         """
         name = self._x509name()
@@ -692,7 +857,7 @@
 
     def test_attributes(self):
         """
-        L{X509NameType} instances have attributes for each standard (?)
+        :py:class:`X509NameType` instances have attributes for each standard (?)
         X509Name field.
         """
         name = self._x509name()
@@ -712,8 +877,8 @@
 
     def test_copy(self):
         """
-        L{X509Name} creates a new L{X509NameType} instance with all the same
-        attributes as an existing L{X509NameType} instance when called with
+        :py:class:`X509Name` creates a new :py:class:`X509NameType` instance with all the same
+        attributes as an existing :py:class:`X509NameType` instance when called with
         one.
         """
         name = self._x509name(commonName="foo", emailAddress="bar@example.com")
@@ -733,7 +898,7 @@
 
     def test_repr(self):
         """
-        L{repr} passed an L{X509NameType} instance should return a string
+        :py:func:`repr` passed an :py:class:`X509NameType` instance should return a string
         containing a description of the type and the NIDs which have been set
         on it.
         """
@@ -745,7 +910,7 @@
 
     def test_comparison(self):
         """
-        L{X509NameType} instances should compare based on their NIDs.
+        :py:class:`X509NameType` instances should compare based on their NIDs.
         """
         def _equality(a, b, assertTrue, assertFalse):
             assertTrue(a == b, "(%r == %r) --> False" % (a, b))
@@ -820,7 +985,7 @@
 
     def test_hash(self):
         """
-        L{X509Name.hash} returns an integer hash based on the value of the
+        :py:meth:`X509Name.hash` returns an integer hash based on the value of the
         name.
         """
         a = self._x509name(CN="foo")
@@ -832,7 +997,7 @@
 
     def test_der(self):
         """
-        L{X509Name.der} returns the DER encoded form of the name.
+        :py:meth:`X509Name.der` returns the DER encoded form of the name.
         """
         a = self._x509name(CN="foo", C="US")
         self.assertEqual(
@@ -843,7 +1008,8 @@
 
     def test_get_components(self):
         """
-        L{X509Name.get_components} returns a C{list} of two-tuples of C{str}
+        :py:meth:`X509Name.get_components` returns a :py:data:`list` of
+        two-tuples of :py:data:`str`
         giving the NIDs and associated values which make up the name.
         """
         a = self._x509name()
@@ -856,60 +1022,85 @@
             [(b("CN"), b("foo")), (b("OU"), b("bar"))])
 
 
+    def test_load_nul_byte_attribute(self):
+        """
+        An :py:class:`OpenSSL.crypto.X509Name` from an
+        :py:class:`OpenSSL.crypto.X509` instance loaded from a file can have a
+        NUL byte in the value of one of its attributes.
+        """
+        cert = load_certificate(FILETYPE_PEM, nulbyteSubjectAltNamePEM)
+        subject = cert.get_subject()
+        self.assertEqual(
+            "null.python.org\x00example.org", subject.commonName)
+
+
+    def test_setAttributeFailure(self):
+        """
+        If the value of an attribute cannot be set for some reason then
+        :py:class:`OpenSSL.crypto.Error` is raised.
+        """
+        name = self._x509name()
+        # This value is too long
+        self.assertRaises(Error, setattr, name, "O", b"x" * 512)
+
+
+
 class _PKeyInteractionTestsMixin:
     """
     Tests which involve another thing and a PKey.
     """
     def signable(self):
         """
-        Return something with a C{set_pubkey}, C{set_pubkey}, and C{sign} method.
+        Return something with a :py:meth:`set_pubkey`, :py:meth:`set_pubkey`,
+        and :py:meth:`sign` method.
         """
         raise NotImplementedError()
 
 
     def test_signWithUngenerated(self):
         """
-        L{X509Req.sign} raises L{ValueError} when pass a L{PKey} with no parts.
+        :py:meth:`X509Req.sign` raises :py:exc:`ValueError` when pass a
+        :py:class:`PKey` with no parts.
         """
         request = self.signable()
         key = PKey()
-        self.assertRaises(ValueError, request.sign, key, 'MD5')
+        self.assertRaises(ValueError, request.sign, key, GOOD_DIGEST)
 
 
     def test_signWithPublicKey(self):
         """
-        L{X509Req.sign} raises L{ValueError} when pass a L{PKey} with no
-        private part as the signing key.
+        :py:meth:`X509Req.sign` raises :py:exc:`ValueError` when pass a
+        :py:class:`PKey` with no private part as the signing key.
         """
         request = self.signable()
         key = PKey()
         key.generate_key(TYPE_RSA, 512)
         request.set_pubkey(key)
         pub = request.get_pubkey()
-        self.assertRaises(ValueError, request.sign, pub, 'MD5')
+        self.assertRaises(ValueError, request.sign, pub, GOOD_DIGEST)
 
 
     def test_signWithUnknownDigest(self):
         """
-        L{X509Req.sign} raises L{ValueError} when passed a digest name which is
+        :py:meth:`X509Req.sign` raises :py:exc:`ValueError` when passed a digest name which is
         not known.
         """
         request = self.signable()
         key = PKey()
         key.generate_key(TYPE_RSA, 512)
-        self.assertRaises(ValueError, request.sign, key, "monkeys")
+        self.assertRaises(ValueError, request.sign, key, BAD_DIGEST)
 
 
     def test_sign(self):
         """
-        L{X509Req.sign} succeeds when passed a private key object and a valid
-        digest function.  C{X509Req.verify} can be used to check the signature.
+        :py:meth:`X509Req.sign` succeeds when passed a private key object and a valid
+        digest function.  :py:meth:`X509Req.verify` can be used to check the signature.
         """
         request = self.signable()
         key = PKey()
         key.generate_key(TYPE_RSA, 512)
         request.set_pubkey(key)
-        request.sign(key, 'MD5')
+        request.sign(key, GOOD_DIGEST)
         # If the type has a verify method, cover that too.
         if getattr(request, 'verify', None) is not None:
             pub = request.get_pubkey()
@@ -924,18 +1115,18 @@
 
 class X509ReqTests(TestCase, _PKeyInteractionTestsMixin):
     """
-    Tests for L{OpenSSL.crypto.X509Req}.
+    Tests for :py:class:`OpenSSL.crypto.X509Req`.
     """
     def signable(self):
         """
-        Create and return a new L{X509Req}.
+        Create and return a new :py:class:`X509Req`.
         """
         return X509Req()
 
 
     def test_type(self):
         """
-        L{X509Req} and L{X509ReqType} refer to the same type object and can be
+        :py:obj:`X509Req` and :py:obj:`X509ReqType` refer to the same type object and can be
         used to create instances of that type.
         """
         self.assertIdentical(X509Req, X509ReqType)
@@ -944,7 +1135,7 @@
 
     def test_construction(self):
         """
-        L{X509Req} takes no arguments and returns an L{X509ReqType} instance.
+        :py:obj:`X509Req` takes no arguments and returns an :py:obj:`X509ReqType` instance.
         """
         request = X509Req()
         self.assertTrue(
@@ -954,8 +1145,8 @@
 
     def test_version(self):
         """
-        L{X509ReqType.set_version} sets the X.509 version of the certificate
-        request.  L{X509ReqType.get_version} returns the X.509 version of
+        :py:obj:`X509ReqType.set_version` sets the X.509 version of the certificate
+        request.  :py:obj:`X509ReqType.get_version` returns the X.509 version of
         the certificate request.  The initial value of the version is 0.
         """
         request = X509Req()
@@ -968,9 +1159,9 @@
 
     def test_version_wrong_args(self):
         """
-        L{X509ReqType.set_version} raises L{TypeError} if called with the wrong
-        number of arguments or with a non-C{int} argument.
-        L{X509ReqType.get_version} raises L{TypeError} if called with any
+        :py:obj:`X509ReqType.set_version` raises :py:obj:`TypeError` if called with the wrong
+        number of arguments or with a non-:py:obj:`int` argument.
+        :py:obj:`X509ReqType.get_version` raises :py:obj:`TypeError` if called with any
         arguments.
         """
         request = X509Req()
@@ -982,7 +1173,7 @@
 
     def test_get_subject(self):
         """
-        L{X509ReqType.get_subject} returns an L{X509Name} for the subject of
+        :py:obj:`X509ReqType.get_subject` returns an :py:obj:`X509Name` for the subject of
         the request and which is valid even after the request object is
         otherwise dead.
         """
@@ -1000,7 +1191,7 @@
 
     def test_get_subject_wrong_args(self):
         """
-        L{X509ReqType.get_subject} raises L{TypeError} if called with any
+        :py:obj:`X509ReqType.get_subject` raises :py:obj:`TypeError` if called with any
         arguments.
         """
         request = X509Req()
@@ -1009,20 +1200,45 @@
 
     def test_add_extensions(self):
         """
-        L{X509Req.add_extensions} accepts a C{list} of L{X509Extension}
+        :py:obj:`X509Req.add_extensions` accepts a :py:obj:`list` of :py:obj:`X509Extension`
         instances and adds them to the X509 request.
         """
         request = X509Req()
         request.add_extensions([
                 X509Extension(b('basicConstraints'), True, b('CA:false'))])
-        # XXX Add get_extensions so the rest of this unit test can be written.
+        exts = request.get_extensions()
+        self.assertEqual(len(exts), 1)
+        self.assertEqual(exts[0].get_short_name(), b('basicConstraints'))
+        self.assertEqual(exts[0].get_critical(), 1)
+        self.assertEqual(exts[0].get_data(), b('0\x00'))
+
+
+    def test_get_extensions(self):
+        """
+        :py:obj:`X509Req.get_extensions` returns a :py:obj:`list` of
+        extensions added to this X509 request.
+        """
+        request = X509Req()
+        exts = request.get_extensions()
+        self.assertEqual(exts, [])
+        request.add_extensions([
+                X509Extension(b('basicConstraints'), True, b('CA:true')),
+                X509Extension(b('keyUsage'), False, b('digitalSignature'))])
+        exts = request.get_extensions()
+        self.assertEqual(len(exts), 2)
+        self.assertEqual(exts[0].get_short_name(), b('basicConstraints'))
+        self.assertEqual(exts[0].get_critical(), 1)
+        self.assertEqual(exts[0].get_data(), b('0\x03\x01\x01\xff'))
+        self.assertEqual(exts[1].get_short_name(), b('keyUsage'))
+        self.assertEqual(exts[1].get_critical(), 0)
+        self.assertEqual(exts[1].get_data(), b('\x03\x02\x07\x80'))
 
 
     def test_add_extensions_wrong_args(self):
         """
-        L{X509Req.add_extensions} raises L{TypeError} if called with the wrong
-        number of arguments or with a non-C{list}.  Or it raises L{ValueError}
-        if called with a C{list} containing objects other than L{X509Extension}
+        :py:obj:`X509Req.add_extensions` raises :py:obj:`TypeError` if called with the wrong
+        number of arguments or with a non-:py:obj:`list`.  Or it raises :py:obj:`ValueError`
+        if called with a :py:obj:`list` containing objects other than :py:obj:`X509Extension`
         instances.
         """
         request = X509Req()
@@ -1032,10 +1248,57 @@
         self.assertRaises(TypeError, request.add_extensions, [], None)
 
 
+    def test_verify_wrong_args(self):
+        """
+        :py:obj:`X509Req.verify` raises :py:obj:`TypeError` if called with zero
+        arguments or more than one argument or if passed anything other than a
+        :py:obj:`PKey` instance as its single argument.
+        """
+        request = X509Req()
+        self.assertRaises(TypeError, request.verify)
+        self.assertRaises(TypeError, request.verify, object())
+        self.assertRaises(TypeError, request.verify, PKey(), object())
+
+
+    def test_verify_uninitialized_key(self):
+        """
+        :py:obj:`X509Req.verify` raises :py:obj:`OpenSSL.crypto.Error` if called
+        with a :py:obj:`OpenSSL.crypto.PKey` which contains no key data.
+        """
+        request = X509Req()
+        pkey = PKey()
+        self.assertRaises(Error, request.verify, pkey)
+
+
+    def test_verify_wrong_key(self):
+        """
+        :py:obj:`X509Req.verify` raises :py:obj:`OpenSSL.crypto.Error` if called
+        with a :py:obj:`OpenSSL.crypto.PKey` which does not represent the public
+        part of the key which signed the request.
+        """
+        request = X509Req()
+        pkey = load_privatekey(FILETYPE_PEM, cleartextPrivateKeyPEM)
+        request.sign(pkey, GOOD_DIGEST)
+        another_pkey = load_privatekey(FILETYPE_PEM, client_key_pem)
+        self.assertRaises(Error, request.verify, another_pkey)
+
+
+    def test_verify_success(self):
+        """
+        :py:obj:`X509Req.verify` returns :py:obj:`True` if called with a
+        :py:obj:`OpenSSL.crypto.PKey` which represents the public part of the key
+        which signed the request.
+        """
+        request = X509Req()
+        pkey = load_privatekey(FILETYPE_PEM, cleartextPrivateKeyPEM)
+        request.sign(pkey, GOOD_DIGEST)
+        self.assertEqual(True, request.verify(pkey))
+
+
 
 class X509Tests(TestCase, _PKeyInteractionTestsMixin):
     """
-    Tests for L{OpenSSL.crypto.X509}.
+    Tests for :py:obj:`OpenSSL.crypto.X509`.
     """
     pemData = cleartextCertificatePEM + cleartextPrivateKeyPEM
 
@@ -1061,14 +1324,14 @@
     """
     def signable(self):
         """
-        Create and return a new L{X509}.
+        Create and return a new :py:obj:`X509`.
         """
         return X509()
 
 
     def test_type(self):
         """
-        L{X509} and L{X509Type} refer to the same type object and can be used
+        :py:obj:`X509` and :py:obj:`X509Type` refer to the same type object and can be used
         to create instances of that type.
         """
         self.assertIdentical(X509, X509Type)
@@ -1077,7 +1340,7 @@
 
     def test_construction(self):
         """
-        L{X509} takes no arguments and returns an instance of L{X509Type}.
+        :py:obj:`X509` takes no arguments and returns an instance of :py:obj:`X509Type`.
         """
         certificate = X509()
         self.assertTrue(
@@ -1093,7 +1356,7 @@
 
     def test_get_version_wrong_args(self):
         """
-        L{X509.get_version} raises L{TypeError} if invoked with any arguments.
+        :py:obj:`X509.get_version` raises :py:obj:`TypeError` if invoked with any arguments.
         """
         cert = X509()
         self.assertRaises(TypeError, cert.get_version, None)
@@ -1101,8 +1364,8 @@
 
     def test_set_version_wrong_args(self):
         """
-        L{X509.set_version} raises L{TypeError} if invoked with the wrong number
-        of arguments or an argument not of type C{int}.
+        :py:obj:`X509.set_version` raises :py:obj:`TypeError` if invoked with the wrong number
+        of arguments or an argument not of type :py:obj:`int`.
         """
         cert = X509()
         self.assertRaises(TypeError, cert.set_version)
@@ -1112,8 +1375,8 @@
 
     def test_version(self):
         """
-        L{X509.set_version} sets the certificate version number.
-        L{X509.get_version} retrieves it.
+        :py:obj:`X509.set_version` sets the certificate version number.
+        :py:obj:`X509.get_version` retrieves it.
         """
         cert = X509()
         cert.set_version(1234)
@@ -1122,7 +1385,7 @@
 
     def test_get_serial_number_wrong_args(self):
         """
-        L{X509.get_serial_number} raises L{TypeError} if invoked with any
+        :py:obj:`X509.get_serial_number` raises :py:obj:`TypeError` if invoked with any
         arguments.
         """
         cert = X509()
@@ -1131,8 +1394,8 @@
 
     def test_serial_number(self):
         """
-        The serial number of an L{X509Type} can be retrieved and modified with
-        L{X509Type.get_serial_number} and L{X509Type.set_serial_number}.
+        The serial number of an :py:obj:`X509Type` can be retrieved and modified with
+        :py:obj:`X509Type.get_serial_number` and :py:obj:`X509Type.set_serial_number`.
         """
         certificate = X509()
         self.assertRaises(TypeError, certificate.set_serial_number)
@@ -1152,7 +1415,7 @@
 
     def _setBoundTest(self, which):
         """
-        L{X509Type.set_notBefore} takes a string in the format of an ASN1
+        :py:obj:`X509Type.set_notBefore` takes a string in the format of an ASN1
         GENERALIZEDTIME and sets the beginning of the certificate's validity
         period to it.
         """
@@ -1191,7 +1454,7 @@
 
     def test_set_notBefore(self):
         """
-        L{X509Type.set_notBefore} takes a string in the format of an ASN1
+        :py:obj:`X509Type.set_notBefore` takes a string in the format of an ASN1
         GENERALIZEDTIME and sets the beginning of the certificate's validity
         period to it.
         """
@@ -1200,7 +1463,7 @@
 
     def test_set_notAfter(self):
         """
-        L{X509Type.set_notAfter} takes a string in the format of an ASN1
+        :py:obj:`X509Type.set_notAfter` takes a string in the format of an ASN1
         GENERALIZEDTIME and sets the end of the certificate's validity period
         to it.
         """
@@ -1209,7 +1472,7 @@
 
     def test_get_notBefore(self):
         """
-        L{X509Type.get_notBefore} returns a string in the format of an ASN1
+        :py:obj:`X509Type.get_notBefore` returns a string in the format of an ASN1
         GENERALIZEDTIME even for certificates which store it as UTCTIME
         internally.
         """
@@ -1219,7 +1482,7 @@
 
     def test_get_notAfter(self):
         """
-        L{X509Type.get_notAfter} returns a string in the format of an ASN1
+        :py:obj:`X509Type.get_notAfter` returns a string in the format of an ASN1
         GENERALIZEDTIME even for certificates which store it as UTCTIME
         internally.
         """
@@ -1229,8 +1492,8 @@
 
     def test_gmtime_adj_notBefore_wrong_args(self):
         """
-        L{X509Type.gmtime_adj_notBefore} raises L{TypeError} if called with the
-        wrong number of arguments or a non-C{int} argument.
+        :py:obj:`X509Type.gmtime_adj_notBefore` raises :py:obj:`TypeError` if called with the
+        wrong number of arguments or a non-:py:obj:`int` argument.
         """
         cert = X509()
         self.assertRaises(TypeError, cert.gmtime_adj_notBefore)
@@ -1240,7 +1503,7 @@
 
     def test_gmtime_adj_notBefore(self):
         """
-        L{X509Type.gmtime_adj_notBefore} changes the not-before timestamp to be
+        :py:obj:`X509Type.gmtime_adj_notBefore` changes the not-before timestamp to be
         the current time plus the number of seconds passed in.
         """
         cert = load_certificate(FILETYPE_PEM, self.pemData)
@@ -1251,8 +1514,8 @@
 
     def test_gmtime_adj_notAfter_wrong_args(self):
         """
-        L{X509Type.gmtime_adj_notAfter} raises L{TypeError} if called with the
-        wrong number of arguments or a non-C{int} argument.
+        :py:obj:`X509Type.gmtime_adj_notAfter` raises :py:obj:`TypeError` if called with the
+        wrong number of arguments or a non-:py:obj:`int` argument.
         """
         cert = X509()
         self.assertRaises(TypeError, cert.gmtime_adj_notAfter)
@@ -1262,7 +1525,7 @@
 
     def test_gmtime_adj_notAfter(self):
         """
-        L{X509Type.gmtime_adj_notAfter} changes the not-after timestamp to be
+        :py:obj:`X509Type.gmtime_adj_notAfter` changes the not-after timestamp to be
         the current time plus the number of seconds passed in.
         """
         cert = load_certificate(FILETYPE_PEM, self.pemData)
@@ -1273,7 +1536,7 @@
 
     def test_has_expired_wrong_args(self):
         """
-        L{X509Type.has_expired} raises L{TypeError} if called with any
+        :py:obj:`X509Type.has_expired` raises :py:obj:`TypeError` if called with any
         arguments.
         """
         cert = X509()
@@ -1282,7 +1545,7 @@
 
     def test_has_expired(self):
         """
-        L{X509Type.has_expired} returns C{True} if the certificate's not-after
+        :py:obj:`X509Type.has_expired` returns :py:obj:`True` if the certificate's not-after
         time is in the past.
         """
         cert = X509()
@@ -1292,7 +1555,7 @@
 
     def test_has_not_expired(self):
         """
-        L{X509Type.has_expired} returns C{False} if the certificate's not-after
+        :py:obj:`X509Type.has_expired` returns :py:obj:`False` if the certificate's not-after
         time is in the future.
         """
         cert = X509()
@@ -1302,12 +1565,15 @@
 
     def test_digest(self):
         """
-        L{X509.digest} returns a string giving ":"-separated hex-encoded words
+        :py:obj:`X509.digest` returns a string giving ":"-separated hex-encoded words
         of the digest of the certificate.
         """
         cert = X509()
         self.assertEqual(
-            cert.digest("md5"),
+            # This is MD5 instead of GOOD_DIGEST because the digest algorithm
+            # actually matters to the assertion (ie, another arbitrary, good
+            # digest will not product the same digest).
+            cert.digest("MD5"),
             b("A8:EB:07:F8:53:25:0A:F2:56:05:C5:A5:C4:C4:C7:15"))
 
 
@@ -1327,7 +1593,7 @@
 
     def test_extension_count(self):
         """
-        L{X509.get_extension_count} returns the number of extensions that are
+        :py:obj:`X509.get_extension_count` returns the number of extensions that are
         present in the certificate.
         """
         pkey = load_privatekey(FILETYPE_PEM, client_key_pem)
@@ -1351,7 +1617,7 @@
 
     def test_get_extension(self):
         """
-        L{X509.get_extension} takes an integer and returns an L{X509Extension}
+        :py:obj:`X509.get_extension` takes an integer and returns an :py:obj:`X509Extension`
         corresponding to the extension at that index.
         """
         pkey = load_privatekey(FILETYPE_PEM, client_key_pem)
@@ -1382,18 +1648,36 @@
         self.assertRaises(TypeError, cert.get_extension, "hello")
 
 
+    def test_nullbyte_subjectAltName(self):
+        """
+        The fields of a `subjectAltName` extension on an X509 may contain NUL
+        bytes and this value is reflected in the string representation of the
+        extension object.
+        """
+        cert = load_certificate(FILETYPE_PEM, nulbyteSubjectAltNamePEM)
+
+        ext = cert.get_extension(3)
+        self.assertEqual(ext.get_short_name(), b('subjectAltName'))
+        self.assertEqual(
+            b("DNS:altnull.python.org\x00example.com, "
+              "email:null@python.org\x00user@example.org, "
+              "URI:http://null.python.org\x00http://example.org, "
+              "IP Address:192.0.2.1, IP Address:2001:DB8:0:0:0:0:0:1\n"),
+            b(str(ext)))
+
+
     def test_invalid_digest_algorithm(self):
         """
-        L{X509.digest} raises L{ValueError} if called with an unrecognized hash
+        :py:obj:`X509.digest` raises :py:obj:`ValueError` if called with an unrecognized hash
         algorithm.
         """
         cert = X509()
-        self.assertRaises(ValueError, cert.digest, "monkeys")
+        self.assertRaises(ValueError, cert.digest, BAD_DIGEST)
 
 
     def test_get_subject_wrong_args(self):
         """
-        L{X509.get_subject} raises L{TypeError} if called with any arguments.
+        :py:obj:`X509.get_subject` raises :py:obj:`TypeError` if called with any arguments.
         """
         cert = X509()
         self.assertRaises(TypeError, cert.get_subject, None)
@@ -1401,7 +1685,7 @@
 
     def test_get_subject(self):
         """
-        L{X509.get_subject} returns an L{X509Name} instance.
+        :py:obj:`X509.get_subject` returns an :py:obj:`X509Name` instance.
         """
         cert = load_certificate(FILETYPE_PEM, self.pemData)
         subj = cert.get_subject()
@@ -1414,8 +1698,8 @@
 
     def test_set_subject_wrong_args(self):
         """
-        L{X509.set_subject} raises a L{TypeError} if called with the wrong
-        number of arguments or an argument not of type L{X509Name}.
+        :py:obj:`X509.set_subject` raises a :py:obj:`TypeError` if called with the wrong
+        number of arguments or an argument not of type :py:obj:`X509Name`.
         """
         cert = X509()
         self.assertRaises(TypeError, cert.set_subject)
@@ -1425,7 +1709,7 @@
 
     def test_set_subject(self):
         """
-        L{X509.set_subject} changes the subject of the certificate to the one
+        :py:obj:`X509.set_subject` changes the subject of the certificate to the one
         passed in.
         """
         cert = X509()
@@ -1440,7 +1724,7 @@
 
     def test_get_issuer_wrong_args(self):
         """
-        L{X509.get_issuer} raises L{TypeError} if called with any arguments.
+        :py:obj:`X509.get_issuer` raises :py:obj:`TypeError` if called with any arguments.
         """
         cert = X509()
         self.assertRaises(TypeError, cert.get_issuer, None)
@@ -1448,7 +1732,7 @@
 
     def test_get_issuer(self):
         """
-        L{X509.get_issuer} returns an L{X509Name} instance.
+        :py:obj:`X509.get_issuer` returns an :py:obj:`X509Name` instance.
         """
         cert = load_certificate(FILETYPE_PEM, self.pemData)
         subj = cert.get_issuer()
@@ -1462,8 +1746,8 @@
 
     def test_set_issuer_wrong_args(self):
         """
-        L{X509.set_issuer} raises a L{TypeError} if called with the wrong
-        number of arguments or an argument not of type L{X509Name}.
+        :py:obj:`X509.set_issuer` raises a :py:obj:`TypeError` if called with the wrong
+        number of arguments or an argument not of type :py:obj:`X509Name`.
         """
         cert = X509()
         self.assertRaises(TypeError, cert.set_issuer)
@@ -1473,7 +1757,7 @@
 
     def test_set_issuer(self):
         """
-        L{X509.set_issuer} changes the issuer of the certificate to the one
+        :py:obj:`X509.set_issuer` changes the issuer of the certificate to the one
         passed in.
         """
         cert = X509()
@@ -1488,8 +1772,8 @@
 
     def test_get_pubkey_uninitialized(self):
         """
-        When called on a certificate with no public key, L{X509.get_pubkey}
-        raises L{OpenSSL.crypto.Error}.
+        When called on a certificate with no public key, :py:obj:`X509.get_pubkey`
+        raises :py:obj:`OpenSSL.crypto.Error`.
         """
         cert = X509()
         self.assertRaises(Error, cert.get_pubkey)
@@ -1497,7 +1781,7 @@
 
     def test_subject_name_hash_wrong_args(self):
         """
-        L{X509.subject_name_hash} raises L{TypeError} if called with any
+        :py:obj:`X509.subject_name_hash` raises :py:obj:`TypeError` if called with any
         arguments.
         """
         cert = X509()
@@ -1506,7 +1790,7 @@
 
     def test_subject_name_hash(self):
         """
-        L{X509.subject_name_hash} returns the hash of the certificate's subject
+        :py:obj:`X509.subject_name_hash` returns the hash of the certificate's subject
         name.
         """
         cert = load_certificate(FILETYPE_PEM, self.pemData)
@@ -1519,7 +1803,7 @@
 
     def test_get_signature_algorithm(self):
         """
-        L{X509Type.get_signature_algorithm} returns a string which means
+        :py:obj:`X509Type.get_signature_algorithm` returns a string which means
         the algorithm used to sign the certificate.
         """
         cert = load_certificate(FILETYPE_PEM, self.pemData)
@@ -1529,12 +1813,12 @@
 
     def test_get_undefined_signature_algorithm(self):
         """
-        L{X509Type.get_signature_algorithm} raises L{ValueError} if the
+        :py:obj:`X509Type.get_signature_algorithm` raises :py:obj:`ValueError` if the
         signature algorithm is undefined or unknown.
         """
         # This certificate has been modified to indicate a bogus OID in the
         # signature algorithm field so that OpenSSL does not recognize it.
-        certPEM = """\
+        certPEM = b("""\
 -----BEGIN CERTIFICATE-----
 MIIC/zCCAmigAwIBAgIBATAGBgJ8BQUAMHsxCzAJBgNVBAYTAlNHMREwDwYDVQQK
 EwhNMkNyeXB0bzEUMBIGA1UECxMLTTJDcnlwdG8gQ0ExJDAiBgNVBAMTG00yQ3J5
@@ -1554,21 +1838,62 @@
 PEVk0Mk/V0aIsDE9bolfCi/i/QWZ3N8s5nTWMNyBBBmoSliWCm4jkkRZRD0ejgTN
 tgI5
 -----END CERTIFICATE-----
-"""
+""")
         cert = load_certificate(FILETYPE_PEM, certPEM)
         self.assertRaises(ValueError, cert.get_signature_algorithm)
 
 
 
+class X509StoreTests(TestCase):
+    """
+    Test for :py:obj:`OpenSSL.crypto.X509Store`.
+    """
+    def test_type(self):
+        """
+        :py:obj:`X509StoreType` is a type object.
+        """
+        self.assertIdentical(X509Store, X509StoreType)
+        self.assertConsistentType(X509Store, 'X509Store')
+
+
+    def test_add_cert_wrong_args(self):
+        store = X509Store()
+        self.assertRaises(TypeError, store.add_cert)
+        self.assertRaises(TypeError, store.add_cert, object())
+        self.assertRaises(TypeError, store.add_cert, X509(), object())
+
+
+    def test_add_cert(self):
+        """
+        :py:obj:`X509Store.add_cert` adds a :py:obj:`X509` instance to the
+        certificate store.
+        """
+        cert = load_certificate(FILETYPE_PEM, cleartextCertificatePEM)
+        store = X509Store()
+        store.add_cert(cert)
+
+
+    def test_add_cert_rejects_duplicate(self):
+        """
+        :py:obj:`X509Store.add_cert` raises :py:obj:`OpenSSL.crypto.Error` if an
+        attempt is made to add the same certificate to the store more than once.
+        """
+        cert = load_certificate(FILETYPE_PEM, cleartextCertificatePEM)
+        store = X509Store()
+        store.add_cert(cert)
+        self.assertRaises(Error, store.add_cert, cert)
+
+
+
 class PKCS12Tests(TestCase):
     """
-    Test for L{OpenSSL.crypto.PKCS12} and L{OpenSSL.crypto.load_pkcs12}.
+    Test for :py:obj:`OpenSSL.crypto.PKCS12` and :py:obj:`OpenSSL.crypto.load_pkcs12`.
     """
     pemData = cleartextCertificatePEM + cleartextPrivateKeyPEM
 
     def test_type(self):
         """
-        L{PKCS12Type} is a type object.
+        :py:obj:`PKCS12Type` is a type object.
         """
         self.assertIdentical(PKCS12, PKCS12Type)
         self.assertConsistentType(PKCS12, 'PKCS12')
@@ -1576,7 +1901,7 @@
 
     def test_empty_construction(self):
         """
-        L{PKCS12} returns a new instance of L{PKCS12} with no certificate,
+        :py:obj:`PKCS12` returns a new instance of :py:obj:`PKCS12` with no certificate,
         private key, CA certificates, or friendly name.
         """
         p12 = PKCS12()
@@ -1588,8 +1913,8 @@
 
     def test_type_errors(self):
         """
-        The L{PKCS12} setter functions (C{set_certificate}, C{set_privatekey},
-        C{set_ca_certificates}, and C{set_friendlyname}) raise L{TypeError}
+        The :py:obj:`PKCS12` setter functions (:py:obj:`set_certificate`, :py:obj:`set_privatekey`,
+        :py:obj:`set_ca_certificates`, and :py:obj:`set_friendlyname`) raise :py:obj:`TypeError`
         when passed objects of types other than those expected.
         """
         p12 = PKCS12()
@@ -1609,10 +1934,10 @@
 
     def test_key_only(self):
         """
-        A L{PKCS12} with only a private key can be exported using
-        L{PKCS12.export} and loaded again using L{load_pkcs12}.
+        A :py:obj:`PKCS12` with only a private key can be exported using
+        :py:obj:`PKCS12.export` and loaded again using :py:obj:`load_pkcs12`.
         """
-        passwd = 'blah'
+        passwd = b"blah"
         p12 = PKCS12()
         pkey = load_privatekey(FILETYPE_PEM, cleartextPrivateKeyPEM)
         p12.set_privatekey(pkey)
@@ -1636,10 +1961,10 @@
 
     def test_cert_only(self):
         """
-        A L{PKCS12} with only a certificate can be exported using
-        L{PKCS12.export} and loaded again using L{load_pkcs12}.
+        A :py:obj:`PKCS12` with only a certificate can be exported using
+        :py:obj:`PKCS12.export` and loaded again using :py:obj:`load_pkcs12`.
         """
-        passwd = 'blah'
+        passwd = b"blah"
         p12 = PKCS12()
         cert = load_certificate(FILETYPE_PEM, cleartextCertificatePEM)
         p12.set_certificate(cert)
@@ -1690,7 +2015,7 @@
         return p12
 
 
-    def check_recovery(self, p12_str, key=None, cert=None, ca=None, passwd='',
+    def check_recovery(self, p12_str, key=None, cert=None, ca=None, passwd=b"",
                        extra=()):
         """
         Use openssl program to confirm three components are recoverable from a
@@ -1698,56 +2023,152 @@
         """
         if key:
             recovered_key = _runopenssl(
-                p12_str, "pkcs12", '-nocerts', '-nodes', '-passin',
-                'pass:' + passwd, *extra)
+                p12_str, b"pkcs12", b"-nocerts", b"-nodes", b"-passin",
+                b"pass:" + passwd, *extra)
             self.assertEqual(recovered_key[-len(key):], key)
         if cert:
             recovered_cert = _runopenssl(
-                p12_str, "pkcs12", '-clcerts', '-nodes', '-passin',
-                'pass:' + passwd, '-nokeys', *extra)
+                p12_str, b"pkcs12", b"-clcerts", b"-nodes", b"-passin",
+                b"pass:" + passwd, b"-nokeys", *extra)
             self.assertEqual(recovered_cert[-len(cert):], cert)
         if ca:
             recovered_cert = _runopenssl(
-                p12_str, "pkcs12", '-cacerts', '-nodes', '-passin',
-                'pass:' + passwd, '-nokeys', *extra)
+                p12_str, b"pkcs12", b"-cacerts", b"-nodes", b"-passin",
+                b"pass:" + passwd, b"-nokeys", *extra)
             self.assertEqual(recovered_cert[-len(ca):], ca)
 
 
+    def verify_pkcs12_container(self, p12):
+        """
+        Verify that the PKCS#12 container contains the correct client
+        certificate and private key.
+
+        :param p12: The PKCS12 instance to verify.
+        :type p12: :py:class:`PKCS12`
+        """
+        cert_pem = dump_certificate(FILETYPE_PEM, p12.get_certificate())
+        key_pem = dump_privatekey(FILETYPE_PEM, p12.get_privatekey())
+        self.assertEqual(
+            (client_cert_pem, client_key_pem, None),
+            (cert_pem, key_pem, p12.get_ca_certificates()))
+
+
     def test_load_pkcs12(self):
         """
         A PKCS12 string generated using the openssl command line can be loaded
-        with L{load_pkcs12} and its components extracted and examined.
+        with :py:obj:`load_pkcs12` and its components extracted and examined.
         """
-        passwd = 'whatever'
+        passwd = b"whatever"
         pem = client_key_pem + client_cert_pem
         p12_str = _runopenssl(
-            pem, "pkcs12", '-export', '-clcerts', '-passout', 'pass:' + passwd)
-        p12 = load_pkcs12(p12_str, passwd)
-        # verify
-        self.assertTrue(isinstance(p12, PKCS12))
-        cert_pem = dump_certificate(FILETYPE_PEM, p12.get_certificate())
-        self.assertEqual(cert_pem, client_cert_pem)
-        key_pem = dump_privatekey(FILETYPE_PEM, p12.get_privatekey())
-        self.assertEqual(key_pem, client_key_pem)
-        self.assertEqual(None, p12.get_ca_certificates())
+            pem, b"pkcs12", b"-export", b"-clcerts", b"-passout", b"pass:" + passwd)
+        p12 = load_pkcs12(p12_str, passphrase=passwd)
+        self.verify_pkcs12_container(p12)
+
+
+    def test_load_pkcs12_text_passphrase(self):
+        """
+        A PKCS12 string generated using the openssl command line can be loaded
+        with :py:obj:`load_pkcs12` and its components extracted and examined.
+        Using text as passphrase instead of bytes. DeprecationWarning expected.
+        """
+        pem = client_key_pem + client_cert_pem
+        passwd = b"whatever"
+        p12_str = _runopenssl(pem, b"pkcs12", b"-export", b"-clcerts",
+                              b"-passout", b"pass:" + passwd)
+        with catch_warnings(record=True) as w:
+            simplefilter("always")
+            p12 = load_pkcs12(p12_str, passphrase=b"whatever".decode("ascii"))
+
+            self.assertEqual(
+                "{0} for passphrase is no longer accepted, use bytes".format(
+                    WARNING_TYPE_EXPECTED
+                ),
+                str(w[-1].message)
+            )
+            self.assertIs(w[-1].category, DeprecationWarning)
+
+        self.verify_pkcs12_container(p12)
+
+
+    def test_load_pkcs12_no_passphrase(self):
+        """
+        A PKCS12 string generated using openssl command line can be loaded with
+        :py:obj:`load_pkcs12` without a passphrase and its components extracted
+        and examined.
+        """
+        pem = client_key_pem + client_cert_pem
+        p12_str = _runopenssl(
+            pem, b"pkcs12", b"-export", b"-clcerts", b"-passout", b"pass:")
+        p12 = load_pkcs12(p12_str)
+        self.verify_pkcs12_container(p12)
+
+
+    def _dump_and_load(self, dump_passphrase, load_passphrase):
+        """
+        A helper method to dump and load a PKCS12 object.
+        """
+        p12 = self.gen_pkcs12(client_cert_pem, client_key_pem)
+        dumped_p12 = p12.export(passphrase=dump_passphrase, iter=2, maciter=3)
+        return load_pkcs12(dumped_p12, passphrase=load_passphrase)
+
+
+    def test_load_pkcs12_null_passphrase_load_empty(self):
+        """
+        A PKCS12 string can be dumped with a null passphrase, loaded with an
+        empty passphrase with :py:obj:`load_pkcs12`, and its components
+        extracted and examined.
+        """
+        self.verify_pkcs12_container(
+            self._dump_and_load(dump_passphrase=None, load_passphrase=b''))
+
+
+    def test_load_pkcs12_null_passphrase_load_null(self):
+        """
+        A PKCS12 string can be dumped with a null passphrase, loaded with a
+        null passphrase with :py:obj:`load_pkcs12`, and its components
+        extracted and examined.
+        """
+        self.verify_pkcs12_container(
+            self._dump_and_load(dump_passphrase=None, load_passphrase=None))
+
+
+    def test_load_pkcs12_empty_passphrase_load_empty(self):
+        """
+        A PKCS12 string can be dumped with an empty passphrase, loaded with an
+        empty passphrase with :py:obj:`load_pkcs12`, and its components
+        extracted and examined.
+        """
+        self.verify_pkcs12_container(
+            self._dump_and_load(dump_passphrase=b'', load_passphrase=b''))
+
+
+    def test_load_pkcs12_empty_passphrase_load_null(self):
+        """
+        A PKCS12 string can be dumped with an empty passphrase, loaded with a
+        null passphrase with :py:obj:`load_pkcs12`, and its components
+        extracted and examined.
+        """
+        self.verify_pkcs12_container(
+            self._dump_and_load(dump_passphrase=b'', load_passphrase=None))
 
 
     def test_load_pkcs12_garbage(self):
         """
-        L{load_pkcs12} raises L{OpenSSL.crypto.Error} when passed a string
+        :py:obj:`load_pkcs12` raises :py:obj:`OpenSSL.crypto.Error` when passed a string
         which is not a PKCS12 dump.
         """
         passwd = 'whatever'
-        e = self.assertRaises(Error, load_pkcs12, 'fruit loops', passwd)
+        e = self.assertRaises(Error, load_pkcs12, b'fruit loops', passwd)
         self.assertEqual( e.args[0][0][0], 'asn1 encoding routines')
         self.assertEqual( len(e.args[0][0]), 3)
 
 
     def test_replace(self):
         """
-        L{PKCS12.set_certificate} replaces the certificate in a PKCS12 cluster.
-        L{PKCS12.set_privatekey} replaces the private key.
-        L{PKCS12.set_ca_certificates} replaces the CA certificates.
+        :py:obj:`PKCS12.set_certificate` replaces the certificate in a PKCS12 cluster.
+        :py:obj:`PKCS12.set_privatekey` replaces the private key.
+        :py:obj:`PKCS12.set_ca_certificates` replaces the CA certificates.
         """
         p12 = self.gen_pkcs12(client_cert_pem, client_key_pem, root_cert_pem)
         p12.set_certificate(load_certificate(FILETYPE_PEM, server_cert_pem))
@@ -1765,11 +2186,11 @@
 
     def test_friendly_name(self):
         """
-        The I{friendlyName} of a PKCS12 can be set and retrieved via
-        L{PKCS12.get_friendlyname} and L{PKCS12_set_friendlyname}, and a
-        L{PKCS12} with a friendly name set can be dumped with L{PKCS12.export}.
+        The *friendlyName* of a PKCS12 can be set and retrieved via
+        :py:obj:`PKCS12.get_friendlyname` and :py:obj:`PKCS12_set_friendlyname`, and a
+        :py:obj:`PKCS12` with a friendly name set can be dumped with :py:obj:`PKCS12.export`.
         """
-        passwd = 'Dogmeat[]{}!@#$%^&*()~`?/.,<>-_+=";:'
+        passwd = b'Dogmeat[]{}!@#$%^&*()~`?/.,<>-_+=";:'
         p12 = self.gen_pkcs12(server_cert_pem, server_key_pem, root_cert_pem)
         for friendly_name in [b('Serverlicious'), None, b('###')]:
             p12.set_friendlyname(friendly_name)
@@ -1793,7 +2214,7 @@
         export.
         """
         p12 = self.gen_pkcs12(client_cert_pem, client_key_pem, root_cert_pem)
-        passwd = ''
+        passwd = b""
         dumped_p12_empty = p12.export(iter=2, maciter=0, passphrase=passwd)
         dumped_p12_none = p12.export(iter=3, maciter=2, passphrase=None)
         dumped_p12_nopw = p12.export(iter=9, maciter=4)
@@ -1805,7 +2226,7 @@
 
     def test_removing_ca_cert(self):
         """
-        Passing C{None} to L{PKCS12.set_ca_certificates} removes all CA
+        Passing :py:obj:`None` to :py:obj:`PKCS12.set_ca_certificates` removes all CA
         certificates.
         """
         p12 = self.gen_pkcs12(server_cert_pem, server_key_pem, root_cert_pem)
@@ -1815,22 +2236,22 @@
 
     def test_export_without_mac(self):
         """
-        Exporting a PKCS12 with a C{maciter} of C{-1} excludes the MAC
+        Exporting a PKCS12 with a :py:obj:`maciter` of ``-1`` excludes the MAC
         entirely.
         """
-        passwd = 'Lake Michigan'
+        passwd = b"Lake Michigan"
         p12 = self.gen_pkcs12(server_cert_pem, server_key_pem, root_cert_pem)
         dumped_p12 = p12.export(maciter=-1, passphrase=passwd, iter=2)
         self.check_recovery(
             dumped_p12, key=server_key_pem, cert=server_cert_pem,
-            passwd=passwd, extra=('-nomacver',))
+            passwd=passwd, extra=(b"-nomacver",))
 
 
     def test_load_without_mac(self):
         """
         Loading a PKCS12 without a MAC does something other than crash.
         """
-        passwd = 'Lake Michigan'
+        passwd = b"Lake Michigan"
         p12 = self.gen_pkcs12(server_cert_pem, server_key_pem, root_cert_pem)
         dumped_p12 = p12.export(maciter=-1, passphrase=passwd, iter=2)
         try:
@@ -1853,27 +2274,47 @@
         """
         passwd = 'Hobie 18'
         p12 = self.gen_pkcs12(server_cert_pem, server_key_pem)
-        p12.set_ca_certificates([])
-        self.assertEqual((), p12.get_ca_certificates())
-        dumped_p12 = p12.export(passphrase=passwd, iter=3)
-        self.check_recovery(
-            dumped_p12, key=server_key_pem, cert=server_cert_pem,
-            passwd=passwd)
+        # p12.set_ca_certificates([])
+        # self.assertEqual((), p12.get_ca_certificates())
+        # dumped_p12 = p12.export(passphrase=passwd, iter=3)
+        # self.check_recovery(
+        #     dumped_p12, key=server_key_pem, cert=server_cert_pem,
+        #     passwd=passwd)
 
 
     def test_export_without_args(self):
         """
-        All the arguments to L{PKCS12.export} are optional.
+        All the arguments to :py:obj:`PKCS12.export` are optional.
         """
         p12 = self.gen_pkcs12(server_cert_pem, server_key_pem, root_cert_pem)
         dumped_p12 = p12.export()  # no args
         self.check_recovery(
-            dumped_p12, key=server_key_pem, cert=server_cert_pem, passwd='')
+            dumped_p12, key=server_key_pem, cert=server_cert_pem, passwd=b"")
+
+
+    def test_export_without_bytes(self):
+        """
+        Test :py:obj:`PKCS12.export` with text not bytes as passphrase
+        """
+        p12 = self.gen_pkcs12(server_cert_pem, server_key_pem, root_cert_pem)
+
+        with catch_warnings(record=True) as w:
+            simplefilter("always")
+            dumped_p12 = p12.export(passphrase=b"randomtext".decode("ascii"))
+            self.assertEqual(
+                "{0} for passphrase is no longer accepted, use bytes".format(
+                    WARNING_TYPE_EXPECTED
+                ),
+                str(w[-1].message)
+            )
+            self.assertIs(w[-1].category, DeprecationWarning)
+        self.check_recovery(
+            dumped_p12, key=server_key_pem, cert=server_cert_pem, passwd=b"randomtext")
 
 
     def test_key_cert_mismatch(self):
         """
-        L{PKCS12.export} raises an exception when a key and certificate
+        :py:obj:`PKCS12.export` raises an exception when a key and certificate
         mismatch.
         """
         p12 = self.gen_pkcs12(server_cert_pem, client_key_pem, root_cert_pem)
@@ -1882,39 +2323,39 @@
 
 
 # These quoting functions taken directly from Twisted's twisted.python.win32.
-_cmdLineQuoteRe = re.compile(r'(\\*)"')
-_cmdLineQuoteRe2 = re.compile(r'(\\+)\Z')
+_cmdLineQuoteRe = re.compile(br'(\\*)"')
+_cmdLineQuoteRe2 = re.compile(br'(\\+)\Z')
 def cmdLineQuote(s):
     """
     Internal method for quoting a single command-line argument.
 
-    @type: C{str}
-    @param s: A single unquoted string to quote for something that is expecting
-        cmd.exe-style quoting
+    See http://www.perlmonks.org/?node_id=764004
 
-    @rtype: C{str}
-    @return: A cmd.exe-style quoted string
+    :type: :py:obj:`str`
+    :param s: A single unquoted string to quote for something that is expecting
+        cmd.exe-style quoting
 
-    @see: U{http://www.perlmonks.org/?node_id=764004}
+    :rtype: :py:obj:`str`
+    :return: A cmd.exe-style quoted string
     """
-    s = _cmdLineQuoteRe2.sub(r"\1\1", _cmdLineQuoteRe.sub(r'\1\1\\"', s))
-    return '"%s"' % s
+    s = _cmdLineQuoteRe2.sub(br"\1\1", _cmdLineQuoteRe.sub(br'\1\1\\"', s))
+    return b'"' + s + b'"'
 
 
 
 def quoteArguments(arguments):
     """
     Quote an iterable of command-line arguments for passing to CreateProcess or
-    a similar API.  This allows the list passed to C{reactor.spawnProcess} to
-    match the child process's C{sys.argv} properly.
+    a similar API.  This allows the list passed to :py:obj:`reactor.spawnProcess` to
+    match the child process's :py:obj:`sys.argv` properly.
 
-    @type arguments: C{iterable} of C{str}
-    @param arguments: An iterable of unquoted arguments to quote
+    :type arguments: :py:obj:`iterable` of :py:obj:`str`
+    :param arguments: An iterable of unquoted arguments to quote
 
-    @rtype: C{str}
-    @return: A space-delimited string containing quoted versions of L{arguments}
+    :rtype: :py:obj:`str`
+    :return: A space-delimited string containing quoted versions of :py:obj:`arguments`
     """
-    return ' '.join(map(cmdLineQuote, arguments))
+    return b' '.join(map(cmdLineQuote, arguments))
 
 
 
@@ -1924,33 +2365,37 @@
     the given PEM to its stdin.  Not safe for quotes.
     """
     if os.name == 'posix':
-        command = "openssl " + " ".join([
-                "'%s'" % (arg.replace("'", "'\\''"),) for arg in args])
+        command = b"openssl " + b" ".join([
+                (b"'" + arg.replace(b"'", b"'\\''") + b"'")
+                for arg in args])
     else:
-        command = "openssl " + quoteArguments(args)
-    proc = Popen(command, shell=True, stdin=PIPE, stdout=PIPE)
+        command = b"openssl " + quoteArguments(args)
+    proc = Popen(native(command), shell=True, stdin=PIPE, stdout=PIPE)
     proc.stdin.write(pem)
     proc.stdin.close()
-    return proc.stdout.read()
+    output = proc.stdout.read()
+    proc.stdout.close()
+    proc.wait()
+    return output
 
 
 
 class FunctionTests(TestCase):
     """
-    Tests for free-functions in the L{OpenSSL.crypto} module.
+    Tests for free-functions in the :py:obj:`OpenSSL.crypto` module.
     """
 
     def test_load_privatekey_invalid_format(self):
         """
-        L{load_privatekey} raises L{ValueError} if passed an unknown filetype.
+        :py:obj:`load_privatekey` raises :py:obj:`ValueError` if passed an unknown filetype.
         """
         self.assertRaises(ValueError, load_privatekey, 100, root_key_pem)
 
 
     def test_load_privatekey_invalid_passphrase_type(self):
         """
-        L{load_privatekey} raises L{TypeError} if passed a passphrase that is
-        neither a c{str} nor a callable.
+        :py:obj:`load_privatekey` raises :py:obj:`TypeError` if passed a passphrase that is
+        neither a :py:obj:`str` nor a callable.
         """
         self.assertRaises(
             TypeError,
@@ -1960,7 +2405,7 @@
 
     def test_load_privatekey_wrong_args(self):
         """
-        L{load_privatekey} raises L{TypeError} if called with the wrong number
+        :py:obj:`load_privatekey` raises :py:obj:`TypeError` if called with the wrong number
         of arguments.
         """
         self.assertRaises(TypeError, load_privatekey)
@@ -1968,7 +2413,7 @@
 
     def test_load_privatekey_wrongPassphrase(self):
         """
-        L{load_privatekey} raises L{OpenSSL.crypto.Error} when it is passed an
+        :py:obj:`load_privatekey` raises :py:obj:`OpenSSL.crypto.Error` when it is passed an
         encrypted PEM and an incorrect passphrase.
         """
         self.assertRaises(
@@ -1976,9 +2421,21 @@
             load_privatekey, FILETYPE_PEM, encryptedPrivateKeyPEM, b("quack"))
 
 
+    def test_load_privatekey_passphraseWrongType(self):
+        """
+        :py:obj:`load_privatekey` raises :py:obj:`ValueError` when it is passed a passphrase
+        with a private key encoded in a format, that doesn't support
+        encryption.
+        """
+        key = load_privatekey(FILETYPE_PEM, cleartextPrivateKeyPEM)
+        blob = dump_privatekey(FILETYPE_ASN1, key)
+        self.assertRaises(ValueError,
+            load_privatekey, FILETYPE_ASN1, blob, "secret")
+
+
     def test_load_privatekey_passphrase(self):
         """
-        L{load_privatekey} can create a L{PKey} object from an encrypted PEM
+        :py:obj:`load_privatekey` can create a :py:obj:`PKey` object from an encrypted PEM
         string if given the passphrase.
         """
         key = load_privatekey(
@@ -1987,16 +2444,28 @@
         self.assertTrue(isinstance(key, PKeyType))
 
 
+    def test_load_privatekey_passphrase_exception(self):
+        """
+        If the passphrase callback raises an exception, that exception is raised
+        by :py:obj:`load_privatekey`.
+        """
+        def cb(ignored):
+            raise ArithmeticError
+
+        self.assertRaises(ArithmeticError,
+            load_privatekey, FILETYPE_PEM, encryptedPrivateKeyPEM, cb)
+
+
     def test_load_privatekey_wrongPassphraseCallback(self):
         """
-        L{load_privatekey} raises L{OpenSSL.crypto.Error} when it is passed an
-        encrypted PEM and a passphrase callback which returns an incorrect
-        passphrase.
+        :py:obj:`load_privatekey` raises :py:obj:`OpenSSL.crypto.Error` when it
+        is passed an encrypted PEM and a passphrase callback which returns an
+        incorrect passphrase.
         """
         called = []
         def cb(*a):
             called.append(None)
-            return "quack"
+            return b("quack")
         self.assertRaises(
             Error,
             load_privatekey, FILETYPE_PEM, encryptedPrivateKeyPEM, cb)
@@ -2005,7 +2474,7 @@
 
     def test_load_privatekey_passphraseCallback(self):
         """
-        L{load_privatekey} can create a L{PKey} object from an encrypted PEM
+        :py:obj:`load_privatekey` can create a :py:obj:`PKey` object from an encrypted PEM
         string if given a passphrase callback which returns the correct
         password.
         """
@@ -2018,57 +2487,55 @@
         self.assertEqual(called, [False])
 
 
-    def test_load_privatekey_passphrase_exception(self):
+    def test_load_privatekey_passphrase_wrong_return_type(self):
         """
-        An exception raised by the passphrase callback passed to
-        L{load_privatekey} causes L{OpenSSL.crypto.Error} to be raised.
-
-        This isn't as nice as just letting the exception pass through.  The
-        behavior might be changed to that eventually.
+        :py:obj:`load_privatekey` raises :py:obj:`ValueError` if the passphrase
+        callback returns something other than a byte string.
         """
-        def broken(ignored):
-            raise RuntimeError("This is not working.")
         self.assertRaises(
-            Error,
+            ValueError,
             load_privatekey,
-            FILETYPE_PEM, encryptedPrivateKeyPEM, broken)
+            FILETYPE_PEM, encryptedPrivateKeyPEM, lambda *args: 3)
 
 
     def test_dump_privatekey_wrong_args(self):
         """
-        L{dump_privatekey} raises L{TypeError} if called with the wrong number
+        :py:obj:`dump_privatekey` raises :py:obj:`TypeError` if called with the wrong number
         of arguments.
         """
         self.assertRaises(TypeError, dump_privatekey)
+        # If cipher name is given, password is required.
+        self.assertRaises(
+            TypeError, dump_privatekey, FILETYPE_PEM, PKey(), GOOD_CIPHER)
 
 
     def test_dump_privatekey_unknown_cipher(self):
         """
-        L{dump_privatekey} raises L{ValueError} if called with an unrecognized
+        :py:obj:`dump_privatekey` raises :py:obj:`ValueError` if called with an unrecognized
         cipher name.
         """
         key = PKey()
         key.generate_key(TYPE_RSA, 512)
         self.assertRaises(
             ValueError, dump_privatekey,
-            FILETYPE_PEM, key, "zippers", "passphrase")
+            FILETYPE_PEM, key, BAD_CIPHER, "passphrase")
 
 
     def test_dump_privatekey_invalid_passphrase_type(self):
         """
-        L{dump_privatekey} raises L{TypeError} if called with a passphrase which
-        is neither a C{str} nor a callable.
+        :py:obj:`dump_privatekey` raises :py:obj:`TypeError` if called with a passphrase which
+        is neither a :py:obj:`str` nor a callable.
         """
         key = PKey()
         key.generate_key(TYPE_RSA, 512)
         self.assertRaises(
             TypeError,
-            dump_privatekey, FILETYPE_PEM, key, "blowfish", object())
+            dump_privatekey, FILETYPE_PEM, key, GOOD_CIPHER, object())
 
 
     def test_dump_privatekey_invalid_filetype(self):
         """
-        L{dump_privatekey} raises L{ValueError} if called with an unrecognized
+        :py:obj:`dump_privatekey` raises :py:obj:`ValueError` if called with an unrecognized
         filetype.
         """
         key = PKey()
@@ -2076,81 +2543,122 @@
         self.assertRaises(ValueError, dump_privatekey, 100, key)
 
 
+    def test_load_privatekey_passphraseCallbackLength(self):
+        """
+        :py:obj:`crypto.load_privatekey` should raise an error when the passphrase
+        provided by the callback is too long, not silently truncate it.
+        """
+        def cb(ignored):
+            return "a" * 1025
+
+        self.assertRaises(ValueError,
+            load_privatekey, FILETYPE_PEM, encryptedPrivateKeyPEM, cb)
+
+
     def test_dump_privatekey_passphrase(self):
         """
-        L{dump_privatekey} writes an encrypted PEM when given a passphrase.
+        :py:obj:`dump_privatekey` writes an encrypted PEM when given a passphrase.
         """
         passphrase = b("foo")
         key = load_privatekey(FILETYPE_PEM, cleartextPrivateKeyPEM)
-        pem = dump_privatekey(FILETYPE_PEM, key, "blowfish", passphrase)
-        self.assertTrue(isinstance(pem, bytes))
+        pem = dump_privatekey(FILETYPE_PEM, key, GOOD_CIPHER, passphrase)
+        self.assertTrue(isinstance(pem, binary_type))
         loadedKey = load_privatekey(FILETYPE_PEM, pem, passphrase)
         self.assertTrue(isinstance(loadedKey, PKeyType))
         self.assertEqual(loadedKey.type(), key.type())
         self.assertEqual(loadedKey.bits(), key.bits())
 
 
+    def test_dump_privatekey_passphraseWrongType(self):
+        """
+        :py:obj:`dump_privatekey` raises :py:obj:`ValueError` when it is passed a passphrase
+        with a private key encoded in a format, that doesn't support
+        encryption.
+        """
+        key = load_privatekey(FILETYPE_PEM, cleartextPrivateKeyPEM)
+        self.assertRaises(ValueError,
+            dump_privatekey, FILETYPE_ASN1, key, GOOD_CIPHER, "secret")
+
+
     def test_dump_certificate(self):
         """
-        L{dump_certificate} writes PEM, DER, and text.
+        :py:obj:`dump_certificate` writes PEM, DER, and text.
         """
         pemData = cleartextCertificatePEM + cleartextPrivateKeyPEM
         cert = load_certificate(FILETYPE_PEM, pemData)
         dumped_pem = dump_certificate(FILETYPE_PEM, cert)
         self.assertEqual(dumped_pem, cleartextCertificatePEM)
         dumped_der = dump_certificate(FILETYPE_ASN1, cert)
-        good_der = _runopenssl(dumped_pem, "x509", "-outform", "DER")
+        good_der = _runopenssl(dumped_pem, b"x509", b"-outform", b"DER")
         self.assertEqual(dumped_der, good_der)
         cert2 = load_certificate(FILETYPE_ASN1, dumped_der)
         dumped_pem2 = dump_certificate(FILETYPE_PEM, cert2)
         self.assertEqual(dumped_pem2, cleartextCertificatePEM)
         dumped_text = dump_certificate(FILETYPE_TEXT, cert)
-        good_text = _runopenssl(dumped_pem, "x509", "-noout", "-text")
+        good_text = _runopenssl(dumped_pem, b"x509", b"-noout", b"-text")
         self.assertEqual(dumped_text, good_text)
 
 
-    def test_dump_privatekey(self):
+    def test_dump_privatekey_pem(self):
         """
-        L{dump_privatekey} writes a PEM, DER, and text.
+        :py:obj:`dump_privatekey` writes a PEM
         """
         key = load_privatekey(FILETYPE_PEM, cleartextPrivateKeyPEM)
         self.assertTrue(key.check())
         dumped_pem = dump_privatekey(FILETYPE_PEM, key)
         self.assertEqual(dumped_pem, cleartextPrivateKeyPEM)
+
+
+    def test_dump_privatekey_asn1(self):
+        """
+        :py:obj:`dump_privatekey` writes a DER
+        """
+        key = load_privatekey(FILETYPE_PEM, cleartextPrivateKeyPEM)
+        dumped_pem = dump_privatekey(FILETYPE_PEM, key)
+
         dumped_der = dump_privatekey(FILETYPE_ASN1, key)
         # XXX This OpenSSL call writes "writing RSA key" to standard out.  Sad.
-        good_der = _runopenssl(dumped_pem, "rsa", "-outform", "DER")
+        good_der = _runopenssl(dumped_pem, b"rsa", b"-outform", b"DER")
         self.assertEqual(dumped_der, good_der)
         key2 = load_privatekey(FILETYPE_ASN1, dumped_der)
         dumped_pem2 = dump_privatekey(FILETYPE_PEM, key2)
         self.assertEqual(dumped_pem2, cleartextPrivateKeyPEM)
+
+
+    def test_dump_privatekey_text(self):
+        """
+        :py:obj:`dump_privatekey` writes a text
+        """
+        key = load_privatekey(FILETYPE_PEM, cleartextPrivateKeyPEM)
+        dumped_pem = dump_privatekey(FILETYPE_PEM, key)
+
         dumped_text = dump_privatekey(FILETYPE_TEXT, key)
-        good_text = _runopenssl(dumped_pem, "rsa", "-noout", "-text")
+        good_text = _runopenssl(dumped_pem, b"rsa", b"-noout", b"-text")
         self.assertEqual(dumped_text, good_text)
 
 
     def test_dump_certificate_request(self):
         """
-        L{dump_certificate_request} writes a PEM, DER, and text.
+        :py:obj:`dump_certificate_request` writes a PEM, DER, and text.
         """
         req = load_certificate_request(FILETYPE_PEM, cleartextCertificateRequestPEM)
         dumped_pem = dump_certificate_request(FILETYPE_PEM, req)
         self.assertEqual(dumped_pem, cleartextCertificateRequestPEM)
         dumped_der = dump_certificate_request(FILETYPE_ASN1, req)
-        good_der = _runopenssl(dumped_pem, "req", "-outform", "DER")
+        good_der = _runopenssl(dumped_pem, b"req", b"-outform", b"DER")
         self.assertEqual(dumped_der, good_der)
         req2 = load_certificate_request(FILETYPE_ASN1, dumped_der)
         dumped_pem2 = dump_certificate_request(FILETYPE_PEM, req2)
         self.assertEqual(dumped_pem2, cleartextCertificateRequestPEM)
         dumped_text = dump_certificate_request(FILETYPE_TEXT, req)
-        good_text = _runopenssl(dumped_pem, "req", "-noout", "-text")
+        good_text = _runopenssl(dumped_pem, b"req", b"-noout", b"-text")
         self.assertEqual(dumped_text, good_text)
         self.assertRaises(ValueError, dump_certificate_request, 100, req)
 
 
     def test_dump_privatekey_passphraseCallback(self):
         """
-        L{dump_privatekey} writes an encrypted PEM when given a callback which
+        :py:obj:`dump_privatekey` writes an encrypted PEM when given a callback which
         returns the correct passphrase.
         """
         passphrase = b("foo")
@@ -2159,8 +2667,8 @@
             called.append(writing)
             return passphrase
         key = load_privatekey(FILETYPE_PEM, cleartextPrivateKeyPEM)
-        pem = dump_privatekey(FILETYPE_PEM, key, "blowfish", cb)
-        self.assertTrue(isinstance(pem, bytes))
+        pem = dump_privatekey(FILETYPE_PEM, key, GOOD_CIPHER, cb)
+        self.assertTrue(isinstance(pem, binary_type))
         self.assertEqual(called, [True])
         loadedKey = load_privatekey(FILETYPE_PEM, pem, passphrase)
         self.assertTrue(isinstance(loadedKey, PKeyType))
@@ -2168,23 +2676,80 @@
         self.assertEqual(loadedKey.bits(), key.bits())
 
 
-    def test_load_pkcs7_data(self):
+    def test_dump_privatekey_passphrase_exception(self):
         """
-        L{load_pkcs7_data} accepts a PKCS#7 string and returns an instance of
-        L{PKCS7Type}.
+        :py:obj:`dump_privatekey` should not overwrite the exception raised
+        by the passphrase callback.
+        """
+        def cb(ignored):
+            raise ArithmeticError
+
+        key = load_privatekey(FILETYPE_PEM, cleartextPrivateKeyPEM)
+        self.assertRaises(ArithmeticError,
+            dump_privatekey, FILETYPE_PEM, key, GOOD_CIPHER, cb)
+
+
+    def test_dump_privatekey_passphraseCallbackLength(self):
+        """
+        :py:obj:`crypto.dump_privatekey` should raise an error when the passphrase
+        provided by the callback is too long, not silently truncate it.
+        """
+        def cb(ignored):
+            return "a" * 1025
+
+        key = load_privatekey(FILETYPE_PEM, cleartextPrivateKeyPEM)
+        self.assertRaises(ValueError,
+            dump_privatekey, FILETYPE_PEM, key, GOOD_CIPHER, cb)
+
+
+    def test_load_pkcs7_data_pem(self):
+        """
+        :py:obj:`load_pkcs7_data` accepts a PKCS#7 string and returns an instance of
+        :py:obj:`PKCS7Type`.
         """
         pkcs7 = load_pkcs7_data(FILETYPE_PEM, pkcs7Data)
         self.assertTrue(isinstance(pkcs7, PKCS7Type))
 
 
+    def test_load_pkcs7_data_asn1(self):
+        """
+        :py:obj:`load_pkcs7_data` accepts a bytes containing ASN1 data
+        representing PKCS#7 and returns an instance of :py:obj`PKCS7Type`.
+        """
+        pkcs7 = load_pkcs7_data(FILETYPE_ASN1, pkcs7DataASN1)
+        self.assertTrue(isinstance(pkcs7, PKCS7Type))
+
+
+    def test_load_pkcs7_data_invalid(self):
+        """
+        If the data passed to :py:obj:`load_pkcs7_data` is invalid,
+        :py:obj:`Error` is raised.
+        """
+        self.assertRaises(Error, load_pkcs7_data, FILETYPE_PEM, b"foo")
+
+
+
+class LoadCertificateTests(TestCase):
+    """
+    Tests for :py:obj:`load_certificate_request`.
+    """
+    def test_badFileType(self):
+        """
+        If the file type passed to :py:obj:`load_certificate_request` is
+        neither :py:obj:`FILETYPE_PEM` nor :py:obj:`FILETYPE_ASN1` then
+        :py:class:`ValueError` is raised.
+        """
+        self.assertRaises(ValueError, load_certificate_request, object(), b"")
+
+
 
 class PKCS7Tests(TestCase):
     """
-    Tests for L{PKCS7Type}.
+    Tests for :py:obj:`PKCS7Type`.
     """
     def test_type(self):
         """
-        L{PKCS7Type} is a type object.
+        :py:obj:`PKCS7Type` is a type object.
         """
         self.assertTrue(isinstance(PKCS7Type, type))
         self.assertEqual(PKCS7Type.__name__, 'PKCS7')
@@ -2197,7 +2762,7 @@
 
     def test_type_is_signed_wrong_args(self):
         """
-        L{PKCS7Type.type_is_signed} raises L{TypeError} if called with any
+        :py:obj:`PKCS7Type.type_is_signed` raises :py:obj:`TypeError` if called with any
         arguments.
         """
         pkcs7 = load_pkcs7_data(FILETYPE_PEM, pkcs7Data)
@@ -2206,8 +2771,8 @@
 
     def test_type_is_signed(self):
         """
-        L{PKCS7Type.type_is_signed} returns C{True} if the PKCS7 object is of
-        the type I{signed}.
+        :py:obj:`PKCS7Type.type_is_signed` returns :py:obj:`True` if the PKCS7 object is of
+        the type *signed*.
         """
         pkcs7 = load_pkcs7_data(FILETYPE_PEM, pkcs7Data)
         self.assertTrue(pkcs7.type_is_signed())
@@ -2215,7 +2780,7 @@
 
     def test_type_is_enveloped_wrong_args(self):
         """
-        L{PKCS7Type.type_is_enveloped} raises L{TypeError} if called with any
+        :py:obj:`PKCS7Type.type_is_enveloped` raises :py:obj:`TypeError` if called with any
         arguments.
         """
         pkcs7 = load_pkcs7_data(FILETYPE_PEM, pkcs7Data)
@@ -2224,8 +2789,8 @@
 
     def test_type_is_enveloped(self):
         """
-        L{PKCS7Type.type_is_enveloped} returns C{False} if the PKCS7 object is
-        not of the type I{enveloped}.
+        :py:obj:`PKCS7Type.type_is_enveloped` returns :py:obj:`False` if the PKCS7 object is
+        not of the type *enveloped*.
         """
         pkcs7 = load_pkcs7_data(FILETYPE_PEM, pkcs7Data)
         self.assertFalse(pkcs7.type_is_enveloped())
@@ -2233,7 +2798,7 @@
 
     def test_type_is_signedAndEnveloped_wrong_args(self):
         """
-        L{PKCS7Type.type_is_signedAndEnveloped} raises L{TypeError} if called
+        :py:obj:`PKCS7Type.type_is_signedAndEnveloped` raises :py:obj:`TypeError` if called
         with any arguments.
         """
         pkcs7 = load_pkcs7_data(FILETYPE_PEM, pkcs7Data)
@@ -2242,8 +2807,8 @@
 
     def test_type_is_signedAndEnveloped(self):
         """
-        L{PKCS7Type.type_is_signedAndEnveloped} returns C{False} if the PKCS7
-        object is not of the type I{signed and enveloped}.
+        :py:obj:`PKCS7Type.type_is_signedAndEnveloped` returns :py:obj:`False` if the PKCS7
+        object is not of the type *signed and enveloped*.
         """
         pkcs7 = load_pkcs7_data(FILETYPE_PEM, pkcs7Data)
         self.assertFalse(pkcs7.type_is_signedAndEnveloped())
@@ -2251,7 +2816,7 @@
 
     def test_type_is_data(self):
         """
-        L{PKCS7Type.type_is_data} returns C{False} if the PKCS7 object is not of
+        :py:obj:`PKCS7Type.type_is_data` returns :py:obj:`False` if the PKCS7 object is not of
         the type data.
         """
         pkcs7 = load_pkcs7_data(FILETYPE_PEM, pkcs7Data)
@@ -2260,7 +2825,7 @@
 
     def test_type_is_data_wrong_args(self):
         """
-        L{PKCS7Type.type_is_data} raises L{TypeError} if called with any
+        :py:obj:`PKCS7Type.type_is_data` raises :py:obj:`TypeError` if called with any
         arguments.
         """
         pkcs7 = load_pkcs7_data(FILETYPE_PEM, pkcs7Data)
@@ -2269,7 +2834,7 @@
 
     def test_get_type_name_wrong_args(self):
         """
-        L{PKCS7Type.get_type_name} raises L{TypeError} if called with any
+        :py:obj:`PKCS7Type.get_type_name` raises :py:obj:`TypeError` if called with any
         arguments.
         """
         pkcs7 = load_pkcs7_data(FILETYPE_PEM, pkcs7Data)
@@ -2278,7 +2843,7 @@
 
     def test_get_type_name(self):
         """
-        L{PKCS7Type.get_type_name} returns a C{str} giving the type name.
+        :py:obj:`PKCS7Type.get_type_name` returns a :py:obj:`str` giving the type name.
         """
         pkcs7 = load_pkcs7_data(FILETYPE_PEM, pkcs7Data)
         self.assertEquals(pkcs7.get_type_name(), b('pkcs7-signedData'))
@@ -2287,7 +2852,7 @@
     def test_attribute(self):
         """
         If an attribute other than one of the methods tested here is accessed on
-        an instance of L{PKCS7Type}, L{AttributeError} is raised.
+        an instance of :py:obj:`PKCS7Type`, :py:obj:`AttributeError` is raised.
         """
         pkcs7 = load_pkcs7_data(FILETYPE_PEM, pkcs7Data)
         self.assertRaises(AttributeError, getattr, pkcs7, "foo")
@@ -2296,18 +2861,18 @@
 
 class NetscapeSPKITests(TestCase, _PKeyInteractionTestsMixin):
     """
-    Tests for L{OpenSSL.crypto.NetscapeSPKI}.
+    Tests for :py:obj:`OpenSSL.crypto.NetscapeSPKI`.
     """
     def signable(self):
         """
-        Return a new L{NetscapeSPKI} for use with signing tests.
+        Return a new :py:obj:`NetscapeSPKI` for use with signing tests.
         """
         return NetscapeSPKI()
 
 
     def test_type(self):
         """
-        L{NetscapeSPKI} and L{NetscapeSPKIType} refer to the same type object
+        :py:obj:`NetscapeSPKI` and :py:obj:`NetscapeSPKIType` refer to the same type object
         and can be used to create instances of that type.
         """
         self.assertIdentical(NetscapeSPKI, NetscapeSPKIType)
@@ -2316,7 +2881,7 @@
 
     def test_construction(self):
         """
-        L{NetscapeSPKI} returns an instance of L{NetscapeSPKIType}.
+        :py:obj:`NetscapeSPKI` returns an instance of :py:obj:`NetscapeSPKIType`.
         """
         nspki = NetscapeSPKI()
         self.assertTrue(isinstance(nspki, NetscapeSPKIType))
@@ -2324,8 +2889,8 @@
 
     def test_invalid_attribute(self):
         """
-        Accessing a non-existent attribute of a L{NetscapeSPKI} instance causes
-        an L{AttributeError} to be raised.
+        Accessing a non-existent attribute of a :py:obj:`NetscapeSPKI` instance causes
+        an :py:obj:`AttributeError` to be raised.
         """
         nspki = NetscapeSPKI()
         self.assertRaises(AttributeError, lambda: nspki.foo)
@@ -2333,21 +2898,21 @@
 
     def test_b64_encode(self):
         """
-        L{NetscapeSPKI.b64_encode} encodes the certificate to a base64 blob.
+        :py:obj:`NetscapeSPKI.b64_encode` encodes the certificate to a base64 blob.
         """
         nspki = NetscapeSPKI()
         blob = nspki.b64_encode()
-        self.assertTrue(isinstance(blob, bytes))
+        self.assertTrue(isinstance(blob, binary_type))
 
 
 
 class RevokedTests(TestCase):
     """
-    Tests for L{OpenSSL.crypto.Revoked}
+    Tests for :py:obj:`OpenSSL.crypto.Revoked`
     """
     def test_construction(self):
         """
-        Confirm we can create L{OpenSSL.crypto.Revoked}.  Check
+        Confirm we can create :py:obj:`OpenSSL.crypto.Revoked`.  Check
         that it is empty.
         """
         revoked = Revoked()
@@ -2360,8 +2925,8 @@
 
     def test_construction_wrong_args(self):
         """
-        Calling L{OpenSSL.crypto.Revoked} with any arguments results
-        in a L{TypeError} being raised.
+        Calling :py:obj:`OpenSSL.crypto.Revoked` with any arguments results
+        in a :py:obj:`TypeError` being raised.
         """
         self.assertRaises(TypeError, Revoked, None)
         self.assertRaises(TypeError, Revoked, 1)
@@ -2371,7 +2936,7 @@
     def test_serial(self):
         """
         Confirm we can set and get serial numbers from
-        L{OpenSSL.crypto.Revoked}.  Confirm errors are handled
+        :py:obj:`OpenSSL.crypto.Revoked`.  Confirm errors are handled
         with grace.
         """
         revoked = Revoked()
@@ -2394,7 +2959,7 @@
     def test_date(self):
         """
         Confirm we can set and get revocation dates from
-        L{OpenSSL.crypto.Revoked}.  Confirm errors are handled
+        :py:obj:`OpenSSL.crypto.Revoked`.  Confirm errors are handled
         with grace.
         """
         revoked = Revoked()
@@ -2411,7 +2976,7 @@
     def test_reason(self):
         """
         Confirm we can set and get revocation reasons from
-        L{OpenSSL.crypto.Revoked}.  The "get" need to work
+        :py:obj:`OpenSSL.crypto.Revoked`.  The "get" need to work
         as "set".  Likewise, each reason of all_reasons() must work.
         """
         revoked = Revoked()
@@ -2431,9 +2996,9 @@
 
     def test_set_reason_wrong_arguments(self):
         """
-        Calling L{OpenSSL.crypto.Revoked.set_reason} with other than
+        Calling :py:obj:`OpenSSL.crypto.Revoked.set_reason` with other than
         one argument, or an argument which isn't a valid reason,
-        results in L{TypeError} or L{ValueError} being raised.
+        results in :py:obj:`TypeError` or :py:obj:`ValueError` being raised.
         """
         revoked = Revoked()
         self.assertRaises(TypeError, revoked.set_reason, 100)
@@ -2442,8 +3007,8 @@
 
     def test_get_reason_wrong_arguments(self):
         """
-        Calling L{OpenSSL.crypto.Revoked.get_reason} with any
-        arguments results in L{TypeError} being raised.
+        Calling :py:obj:`OpenSSL.crypto.Revoked.get_reason` with any
+        arguments results in :py:obj:`TypeError` being raised.
         """
         revoked = Revoked()
         self.assertRaises(TypeError, revoked.get_reason, None)
@@ -2454,14 +3019,14 @@
 
 class CRLTests(TestCase):
     """
-    Tests for L{OpenSSL.crypto.CRL}
+    Tests for :py:obj:`OpenSSL.crypto.CRL`
     """
     cert = load_certificate(FILETYPE_PEM, cleartextCertificatePEM)
     pkey = load_privatekey(FILETYPE_PEM, cleartextPrivateKeyPEM)
 
     def test_construction(self):
         """
-        Confirm we can create L{OpenSSL.crypto.CRL}.  Check
+        Confirm we can create :py:obj:`OpenSSL.crypto.CRL`.  Check
         that it is empty
         """
         crl = CRL()
@@ -2471,19 +3036,17 @@
 
     def test_construction_wrong_args(self):
         """
-        Calling L{OpenSSL.crypto.CRL} with any number of arguments
-        results in a L{TypeError} being raised.
+        Calling :py:obj:`OpenSSL.crypto.CRL` with any number of arguments
+        results in a :py:obj:`TypeError` being raised.
         """
         self.assertRaises(TypeError, CRL, 1)
         self.assertRaises(TypeError, CRL, "")
         self.assertRaises(TypeError, CRL, None)
 
 
-    def test_export(self):
+    def _get_crl(self):
         """
-        Use python to create a simple CRL with a revocation, and export
-        the CRL in formats of PEM, DER and text.  Those outputs are verified
-        with the openssl program.
+        Get a new ``CRL`` with a revocation.
         """
         crl = CRL()
         revoked = Revoked()
@@ -2492,30 +3055,123 @@
         revoked.set_serial(b('3ab'))
         revoked.set_reason(b('sUpErSeDEd'))
         crl.add_revoked(revoked)
+        return crl
 
+
+    def test_export_pem(self):
+        """
+        If not passed a format, ``CRL.export`` returns a "PEM" format string
+        representing a serial number, a revoked reason, and certificate issuer
+        information.
+        """
+        crl = self._get_crl()
         # PEM format
         dumped_crl = crl.export(self.cert, self.pkey, days=20)
-        text = _runopenssl(dumped_crl, "crl", "-noout", "-text")
+        text = _runopenssl(dumped_crl, b"crl", b"-noout", b"-text")
+
+        # These magic values are based on the way the CRL above was constructed
+        # and with what certificate it was exported.
         text.index(b('Serial Number: 03AB'))
         text.index(b('Superseded'))
-        text.index(b('Issuer: /C=US/ST=IL/L=Chicago/O=Testing/CN=Testing Root CA'))
+        text.index(
+            b('Issuer: /C=US/ST=IL/L=Chicago/O=Testing/CN=Testing Root CA')
+        )
+
+
+    def test_export_der(self):
+        """
+        If passed ``FILETYPE_ASN1`` for the format, ``CRL.export`` returns a
+        "DER" format string representing a serial number, a revoked reason, and
+        certificate issuer information.
+        """
+        crl = self._get_crl()
 
         # DER format
         dumped_crl = crl.export(self.cert, self.pkey, FILETYPE_ASN1)
-        text = _runopenssl(dumped_crl, "crl", "-noout", "-text", "-inform", "DER")
+        text = _runopenssl(
+            dumped_crl, b"crl", b"-noout", b"-text", b"-inform", b"DER"
+        )
         text.index(b('Serial Number: 03AB'))
         text.index(b('Superseded'))
-        text.index(b('Issuer: /C=US/ST=IL/L=Chicago/O=Testing/CN=Testing Root CA'))
+        text.index(
+            b('Issuer: /C=US/ST=IL/L=Chicago/O=Testing/CN=Testing Root CA')
+        )
+
+
+    def test_export_text(self):
+        """
+        If passed ``FILETYPE_TEXT`` for the format, ``CRL.export`` returns a
+        text format string like the one produced by the openssl command line
+        tool.
+        """
+        crl = self._get_crl()
+
+        dumped_crl = crl.export(self.cert, self.pkey, FILETYPE_ASN1)
+        text = _runopenssl(
+            dumped_crl, b"crl", b"-noout", b"-text", b"-inform", b"DER"
+        )
 
         # text format
         dumped_text = crl.export(self.cert, self.pkey, type=FILETYPE_TEXT)
         self.assertEqual(text, dumped_text)
 
 
+    def test_export_custom_digest(self):
+        """
+        If passed the name of a digest function, ``CRL.export`` uses a
+        signature algorithm based on that digest function.
+        """
+        crl = self._get_crl()
+        dumped_crl = crl.export(self.cert, self.pkey, digest=b"sha1")
+        text = _runopenssl(dumped_crl, b"crl", b"-noout", b"-text")
+        text.index(b('Signature Algorithm: sha1'))
+
+
+    def test_export_md5_digest(self):
+        """
+        If passed md5 as the digest function, ``CRL.export`` uses md5 and does
+        not emit a deprecation warning.
+        """
+        crl = self._get_crl()
+        with catch_warnings(record=True) as catcher:
+            simplefilter("always")
+            self.assertEqual(0, len(catcher))
+        dumped_crl = crl.export(self.cert, self.pkey, digest=b"md5")
+        text = _runopenssl(dumped_crl, b"crl", b"-noout", b"-text")
+        text.index(b('Signature Algorithm: md5'))
+
+
+    def test_export_default_digest(self):
+        """
+        If not passed the name of a digest function, ``CRL.export`` uses a
+        signature algorithm based on MD5 and emits a deprecation warning.
+        """
+        crl = self._get_crl()
+        with catch_warnings(record=True) as catcher:
+            simplefilter("always")
+            dumped_crl = crl.export(self.cert, self.pkey)
+            self.assertEqual(
+                "The default message digest (md5) is deprecated.  "
+                "Pass the name of a message digest explicitly.",
+                str(catcher[0].message),
+            )
+        text = _runopenssl(dumped_crl, b"crl", b"-noout", b"-text")
+        text.index(b('Signature Algorithm: md5'))
+
+
+    def test_export_invalid(self):
+        """
+        If :py:obj:`CRL.export` is used with an uninitialized :py:obj:`X509`
+        instance, :py:obj:`OpenSSL.crypto.Error` is raised.
+        """
+        crl = CRL()
+        self.assertRaises(Error, crl.export, X509(), PKey())
+
+
     def test_add_revoked_keyword(self):
         """
-        L{OpenSSL.CRL.add_revoked} accepts its single argument as the
-        I{revoked} keyword argument.
+        :py:obj:`OpenSSL.CRL.add_revoked` accepts its single argument as the
+        ``revoked`` keyword argument.
         """
         crl = CRL()
         revoked = Revoked()
@@ -2525,15 +3181,15 @@
 
     def test_export_wrong_args(self):
         """
-        Calling L{OpenSSL.CRL.export} with fewer than two or more than
+        Calling :py:obj:`OpenSSL.CRL.export` with fewer than two or more than
         four arguments, or with arguments other than the certificate,
         private key, integer file type, and integer number of days it
-        expects, results in a L{TypeError} being raised.
+        expects, results in a :py:obj:`TypeError` being raised.
         """
         crl = CRL()
         self.assertRaises(TypeError, crl.export)
         self.assertRaises(TypeError, crl.export, self.cert)
-        self.assertRaises(TypeError, crl.export, self.cert, self.pkey, FILETYPE_PEM, 10, "foo")
+        self.assertRaises(TypeError, crl.export, self.cert, self.pkey, FILETYPE_PEM, 10, "md5", "foo")
 
         self.assertRaises(TypeError, crl.export, None, self.pkey, FILETYPE_PEM, 10)
         self.assertRaises(TypeError, crl.export, self.cert, None, FILETYPE_PEM, 10)
@@ -2543,18 +3199,31 @@
 
     def test_export_unknown_filetype(self):
         """
-        Calling L{OpenSSL.CRL.export} with a file type other than
-        L{FILETYPE_PEM}, L{FILETYPE_ASN1}, or L{FILETYPE_TEXT} results
-        in a L{ValueError} being raised.
+        Calling :py:obj:`OpenSSL.CRL.export` with a file type other than
+        :py:obj:`FILETYPE_PEM`, :py:obj:`FILETYPE_ASN1`, or :py:obj:`FILETYPE_TEXT` results
+        in a :py:obj:`ValueError` being raised.
         """
         crl = CRL()
         self.assertRaises(ValueError, crl.export, self.cert, self.pkey, 100, 10)
 
 
+    def test_export_unknown_digest(self):
+        """
+        Calling :py:obj:`OpenSSL.CRL.export` with a unsupported digest results
+        in a :py:obj:`ValueError` being raised.
+        """
+        crl = CRL()
+        self.assertRaises(
+            ValueError,
+            crl.export,
+            self.cert, self.pkey, FILETYPE_PEM, 10, b"strange-digest"
+        )
+
+
     def test_get_revoked(self):
         """
         Use python to create a simple CRL with two revocations.
-        Get back the L{Revoked} using L{OpenSSL.CRL.get_revoked} and
+        Get back the :py:obj:`Revoked` using :py:obj:`OpenSSL.CRL.get_revoked` and
         verify them.
         """
         crl = CRL()
@@ -2580,8 +3249,8 @@
 
     def test_get_revoked_wrong_args(self):
         """
-        Calling L{OpenSSL.CRL.get_revoked} with any arguments results
-        in a L{TypeError} being raised.
+        Calling :py:obj:`OpenSSL.CRL.get_revoked` with any arguments results
+        in a :py:obj:`TypeError` being raised.
         """
         crl = CRL()
         self.assertRaises(TypeError, crl.get_revoked, None)
@@ -2592,8 +3261,8 @@
 
     def test_add_revoked_wrong_args(self):
         """
-        Calling L{OpenSSL.CRL.add_revoked} with other than one
-        argument results in a L{TypeError} being raised.
+        Calling :py:obj:`OpenSSL.CRL.add_revoked` with other than one
+        argument results in a :py:obj:`TypeError` being raised.
         """
         crl = CRL()
         self.assertRaises(TypeError, crl.add_revoked)
@@ -2614,7 +3283,7 @@
         self.assertEqual(revs[1].get_serial(), b('0100'))
         self.assertEqual(revs[1].get_reason(), b('Superseded'))
 
-        der = _runopenssl(crlData, "crl", "-outform", "DER")
+        der = _runopenssl(crlData, b"crl", b"-outform", b"DER")
         crl = load_crl(FILETYPE_ASN1, der)
         revs = crl.get_revoked()
         self.assertEqual(len(revs), 2)
@@ -2626,8 +3295,8 @@
 
     def test_load_crl_wrong_args(self):
         """
-        Calling L{OpenSSL.crypto.load_crl} with other than two
-        arguments results in a L{TypeError} being raised.
+        Calling :py:obj:`OpenSSL.crypto.load_crl` with other than two
+        arguments results in a :py:obj:`TypeError` being raised.
         """
         self.assertRaises(TypeError, load_crl)
         self.assertRaises(TypeError, load_crl, FILETYPE_PEM)
@@ -2636,27 +3305,129 @@
 
     def test_load_crl_bad_filetype(self):
         """
-        Calling L{OpenSSL.crypto.load_crl} with an unknown file type
-        raises a L{ValueError}.
+        Calling :py:obj:`OpenSSL.crypto.load_crl` with an unknown file type
+        raises a :py:obj:`ValueError`.
         """
         self.assertRaises(ValueError, load_crl, 100, crlData)
 
 
     def test_load_crl_bad_data(self):
         """
-        Calling L{OpenSSL.crypto.load_crl} with file data which can't
-        be loaded raises a L{OpenSSL.crypto.Error}.
+        Calling :py:obj:`OpenSSL.crypto.load_crl` with file data which can't
+        be loaded raises a :py:obj:`OpenSSL.crypto.Error`.
+        """
+        self.assertRaises(Error, load_crl, FILETYPE_PEM, b"hello, world")
+
+
+
+class X509StoreContextTests(TestCase):
+    """
+    Tests for :py:obj:`OpenSSL.crypto.X509StoreContext`.
+    """
+    root_cert = load_certificate(FILETYPE_PEM, root_cert_pem)
+    intermediate_cert = load_certificate(FILETYPE_PEM, intermediate_cert_pem)
+    intermediate_server_cert = load_certificate(FILETYPE_PEM, intermediate_server_cert_pem)
+
+    def test_valid(self):
+        """
+        :py:obj:`verify_certificate` returns ``None`` when called with a certificate
+        and valid chain.
+        """
+        store = X509Store()
+        store.add_cert(self.root_cert)
+        store.add_cert(self.intermediate_cert)
+        store_ctx = X509StoreContext(store, self.intermediate_server_cert)
+        self.assertEqual(store_ctx.verify_certificate(), None)
+
+
+    def test_reuse(self):
+        """
+        :py:obj:`verify_certificate` can be called multiple times with the same
+        ``X509StoreContext`` instance to produce the same result.
+        """
+        store = X509Store()
+        store.add_cert(self.root_cert)
+        store.add_cert(self.intermediate_cert)
+        store_ctx = X509StoreContext(store, self.intermediate_server_cert)
+        self.assertEqual(store_ctx.verify_certificate(), None)
+        self.assertEqual(store_ctx.verify_certificate(), None)
+
+
+    def test_trusted_self_signed(self):
+        """
+        :py:obj:`verify_certificate` returns ``None`` when called with a self-signed
+        certificate and itself in the chain.
+        """
+        store = X509Store()
+        store.add_cert(self.root_cert)
+        store_ctx = X509StoreContext(store, self.root_cert)
+        self.assertEqual(store_ctx.verify_certificate(), None)
+
+
+    def test_untrusted_self_signed(self):
+        """
+        :py:obj:`verify_certificate` raises error when a self-signed certificate is
+        verified without itself in the chain.
+        """
+        store = X509Store()
+        store_ctx = X509StoreContext(store, self.root_cert)
+        e = self.assertRaises(X509StoreContextError, store_ctx.verify_certificate)
+        self.assertEqual(e.args[0][2], 'self signed certificate')
+        self.assertEqual(e.certificate.get_subject().CN, 'Testing Root CA')
+
+
+    def test_invalid_chain_no_root(self):
+        """
+        :py:obj:`verify_certificate` raises error when a root certificate is missing
+        from the chain.
+        """
+        store = X509Store()
+        store.add_cert(self.intermediate_cert)
+        store_ctx = X509StoreContext(store, self.intermediate_server_cert)
+        e = self.assertRaises(X509StoreContextError, store_ctx.verify_certificate)
+        self.assertEqual(e.args[0][2], 'unable to get issuer certificate')
+        self.assertEqual(e.certificate.get_subject().CN, 'intermediate')
+
+
+    def test_invalid_chain_no_intermediate(self):
+        """
+        :py:obj:`verify_certificate` raises error when an intermediate certificate is
+        missing from the chain.
+        """
+        store = X509Store()
+        store.add_cert(self.root_cert)
+        store_ctx = X509StoreContext(store, self.intermediate_server_cert)
+        e = self.assertRaises(X509StoreContextError, store_ctx.verify_certificate)
+        self.assertEqual(e.args[0][2], 'unable to get local issuer certificate')
+        self.assertEqual(e.certificate.get_subject().CN, 'intermediate-service')
+
+
+    def test_modification_pre_verify(self):
+        """
+        :py:obj:`verify_certificate` can use a store context modified after
+        instantiation.
         """
-        self.assertRaises(Error, load_crl, FILETYPE_PEM, "hello, world")
+        store_bad = X509Store()
+        store_bad.add_cert(self.intermediate_cert)
+        store_good = X509Store()
+        store_good.add_cert(self.root_cert)
+        store_good.add_cert(self.intermediate_cert)
+        store_ctx = X509StoreContext(store_bad, self.intermediate_server_cert)
+        e = self.assertRaises(X509StoreContextError, store_ctx.verify_certificate)
+        self.assertEqual(e.args[0][2], 'unable to get issuer certificate')
+        self.assertEqual(e.certificate.get_subject().CN, 'intermediate')
+        store_ctx.set_store(store_good)
+        self.assertEqual(store_ctx.verify_certificate(), None)
+
 
 
 class SignVerifyTests(TestCase):
     """
-    Tests for L{OpenSSL.crypto.sign} and L{OpenSSL.crypto.verify}.
+    Tests for :py:obj:`OpenSSL.crypto.sign` and :py:obj:`OpenSSL.crypto.verify`.
     """
     def test_sign_verify(self):
         """
-        L{sign} generates a cryptographic signature which L{verify} can check.
+        :py:obj:`sign` generates a cryptographic signature which :py:obj:`verify` can check.
         """
         content = b(
             "It was a bright cold day in April, and the clocks were striking "
@@ -2695,9 +3466,50 @@
             ValueError, verify, good_cert, sig, content, "strange-digest")
 
 
+    def test_sign_verify_with_text(self):
+        """
+        :py:obj:`sign` generates a cryptographic signature which :py:obj:`verify` can check.
+        Deprecation warnings raised because using text instead of bytes as content
+        """
+        content = (
+            b"It was a bright cold day in April, and the clocks were striking "
+            b"thirteen. Winston Smith, his chin nuzzled into his breast in an "
+            b"effort to escape the vile wind, slipped quickly through the "
+            b"glass doors of Victory Mansions, though not quickly enough to "
+            b"prevent a swirl of gritty dust from entering along with him."
+        ).decode("ascii")
+
+        priv_key = load_privatekey(FILETYPE_PEM, root_key_pem)
+        cert = load_certificate(FILETYPE_PEM, root_cert_pem)
+        for digest in ['md5', 'sha1']:
+            with catch_warnings(record=True) as w:
+                simplefilter("always")
+                sig = sign(priv_key, content, digest)
+
+                self.assertEqual(
+                    "{0} for data is no longer accepted, use bytes".format(
+                        WARNING_TYPE_EXPECTED
+                    ),
+                    str(w[-1].message)
+                )
+                self.assertIs(w[-1].category, DeprecationWarning)
+
+            with catch_warnings(record=True) as w:
+                simplefilter("always")
+                verify(cert, sig, content, digest)
+
+                self.assertEqual(
+                    "{0} for data is no longer accepted, use bytes".format(
+                        WARNING_TYPE_EXPECTED
+                    ),
+                    str(w[-1].message)
+                )
+                self.assertIs(w[-1].category, DeprecationWarning)
+
+
     def test_sign_nulls(self):
         """
-        L{sign} produces a signature for a string with embedded nulls.
+        :py:obj:`sign` produces a signature for a string with embedded nulls.
         """
         content = b("Watch out!  \0  Did you see it?")
         priv_key = load_privatekey(FILETYPE_PEM, root_key_pem)
@@ -2706,5 +3518,154 @@
         verify(good_cert, sig, content, "sha1")
 
 
+
+class EllipticCurveTests(TestCase):
+    """
+    Tests for :py:class:`_EllipticCurve`, :py:obj:`get_elliptic_curve`, and
+    :py:obj:`get_elliptic_curves`.
+    """
+    def test_set(self):
+        """
+        :py:obj:`get_elliptic_curves` returns a :py:obj:`set`.
+        """
+        self.assertIsInstance(get_elliptic_curves(), set)
+
+
+    def test_some_curves(self):
+        """
+        If :py:mod:`cryptography` has elliptic curve support then the set
+        returned by :py:obj:`get_elliptic_curves` has some elliptic curves in
+        it.
+
+        There could be an OpenSSL that violates this assumption.  If so, this
+        test will fail and we'll find out.
+        """
+        curves = get_elliptic_curves()
+        if lib.Cryptography_HAS_EC:
+            self.assertTrue(curves)
+        else:
+            self.assertFalse(curves)
+
+
+    def test_a_curve(self):
+        """
+        :py:obj:`get_elliptic_curve` can be used to retrieve a particular
+        supported curve.
+        """
+        curves = get_elliptic_curves()
+        if curves:
+            curve = next(iter(curves))
+            self.assertEqual(curve.name, get_elliptic_curve(curve.name).name)
+        else:
+            self.assertRaises(ValueError, get_elliptic_curve, u("prime256v1"))
+
+
+    def test_not_a_curve(self):
+        """
+        :py:obj:`get_elliptic_curve` raises :py:class:`ValueError` if called
+        with a name which does not identify a supported curve.
+        """
+        self.assertRaises(
+            ValueError, get_elliptic_curve, u("this curve was just invented"))
+
+
+    def test_repr(self):
+        """
+        The string representation of a curve object includes simply states the
+        object is a curve and what its name is.
+        """
+        curves = get_elliptic_curves()
+        if curves:
+            curve = next(iter(curves))
+            self.assertEqual("<Curve %r>" % (curve.name,), repr(curve))
+
+
+    def test_to_EC_KEY(self):
+        """
+        The curve object can export a version of itself as an EC_KEY* via the
+        private :py:meth:`_EllipticCurve._to_EC_KEY`.
+        """
+        curves = get_elliptic_curves()
+        if curves:
+            curve = next(iter(curves))
+            # It's not easy to assert anything about this object.  However, see
+            # leakcheck/crypto.py for a test that demonstrates it at least does
+            # not leak memory.
+            curve._to_EC_KEY()
+
+
+
+class EllipticCurveFactory(object):
+    """
+    A helper to get the names of two curves.
+    """
+    def __init__(self):
+        curves = iter(get_elliptic_curves())
+        try:
+            self.curve_name = next(curves).name
+            self.another_curve_name = next(curves).name
+        except StopIteration:
+            self.curve_name = self.another_curve_name = None
+
+
+
+class EllipticCurveEqualityTests(TestCase, EqualityTestsMixin):
+    """
+    Tests :py:type:`_EllipticCurve`\ 's implementation of ``==`` and ``!=``.
+    """
+    curve_factory = EllipticCurveFactory()
+
+    if curve_factory.curve_name is None:
+        skip = "There are no curves available there can be no curve objects."
+
+
+    def anInstance(self):
+        """
+        Get the curve object for an arbitrary curve supported by the system.
+        """
+        return get_elliptic_curve(self.curve_factory.curve_name)
+
+
+    def anotherInstance(self):
+        """
+        Get the curve object for an arbitrary curve supported by the system -
+        but not the one returned by C{anInstance}.
+        """
+        return get_elliptic_curve(self.curve_factory.another_curve_name)
+
+
+
+class EllipticCurveHashTests(TestCase):
+    """
+    Tests for :py:type:`_EllipticCurve`\ 's implementation of hashing (thus use
+    as an item in a :py:type:`dict` or :py:type:`set`).
+    """
+    curve_factory = EllipticCurveFactory()
+
+    if curve_factory.curve_name is None:
+        skip = "There are no curves available there can be no curve objects."
+
+
+    def test_contains(self):
+        """
+        The ``in`` operator reports that a :py:type:`set` containing a curve
+        does contain that curve.
+        """
+        curve = get_elliptic_curve(self.curve_factory.curve_name)
+        curves = set([curve])
+        self.assertIn(curve, curves)
+
+
+    def test_does_not_contain(self):
+        """
+        The ``in`` operator reports that a :py:type:`set` not containing a
+        curve does not contain that curve.
+        """
+        curve = get_elliptic_curve(self.curve_factory.curve_name)
+        curves = set([get_elliptic_curve(self.curve_factory.another_curve_name)])
+        self.assertNotIn(curve, curves)
+
+
+
 if __name__ == '__main__':
     main()
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/test/test_rand.py hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/test/test_rand.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/test/test_rand.py	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/test/test_rand.py	2015-04-13 23:58:06.000000000 +0200
@@ -2,28 +2,36 @@
 # See LICENSE for details.
 
 """
-Unit tests for L{OpenSSL.rand}.
+Unit tests for :py:obj:`OpenSSL.rand`.
 """
 
 from unittest import main
 import os
 import stat
+import sys
 
-from OpenSSL.test.util import TestCase, b
+from OpenSSL.test.util import NON_ASCII, TestCase, b
 from OpenSSL import rand
 
 
 class RandTests(TestCase):
     def test_bytes_wrong_args(self):
         """
-        L{OpenSSL.rand.bytes} raises L{TypeError} if called with the wrong
-        number of arguments or with a non-C{int} argument.
+        :py:obj:`OpenSSL.rand.bytes` raises :py:obj:`TypeError` if called with the wrong
+        number of arguments or with a non-:py:obj:`int` argument.
         """
         self.assertRaises(TypeError, rand.bytes)
         self.assertRaises(TypeError, rand.bytes, None)
         self.assertRaises(TypeError, rand.bytes, 3, None)
 
-    # XXX Test failure of the malloc() in rand_bytes.
+
+    def test_insufficientMemory(self):
+        """
+        :py:obj:`OpenSSL.rand.bytes` raises :py:obj:`MemoryError` if more bytes
+        are requested than will fit in memory.
+        """
+        self.assertRaises(MemoryError, rand.bytes, sys.maxsize)
+
 
     def test_bytes(self):
         """
@@ -44,7 +52,7 @@
     def test_add_wrong_args(self):
         """
         When called with the wrong number of arguments, or with arguments not of
-        type C{str} and C{int}, L{OpenSSL.rand.add} raises L{TypeError}.
+        type :py:obj:`str` and :py:obj:`int`, :py:obj:`OpenSSL.rand.add` raises :py:obj:`TypeError`.
         """
         self.assertRaises(TypeError, rand.add)
         self.assertRaises(TypeError, rand.add, b("foo"), None)
@@ -54,15 +62,15 @@
 
     def test_add(self):
         """
-        L{OpenSSL.rand.add} adds entropy to the PRNG.
+        :py:obj:`OpenSSL.rand.add` adds entropy to the PRNG.
         """
         rand.add(b('hamburger'), 3)
 
 
     def test_seed_wrong_args(self):
         """
-        When called with the wrong number of arguments, or with a non-C{str}
-        argument, L{OpenSSL.rand.seed} raises L{TypeError}.
+        When called with the wrong number of arguments, or with a non-:py:obj:`str`
+        argument, :py:obj:`OpenSSL.rand.seed` raises :py:obj:`TypeError`.
         """
         self.assertRaises(TypeError, rand.seed)
         self.assertRaises(TypeError, rand.seed, None)
@@ -71,14 +79,14 @@
 
     def test_seed(self):
         """
-        L{OpenSSL.rand.seed} adds entropy to the PRNG.
+        :py:obj:`OpenSSL.rand.seed` adds entropy to the PRNG.
         """
         rand.seed(b('milk shake'))
 
 
     def test_status_wrong_args(self):
         """
-        L{OpenSSL.rand.status} raises L{TypeError} when called with any
+        :py:obj:`OpenSSL.rand.status` raises :py:obj:`TypeError` when called with any
         arguments.
         """
         self.assertRaises(TypeError, rand.status, None)
@@ -86,8 +94,8 @@
 
     def test_status(self):
         """
-        L{OpenSSL.rand.status} returns C{True} if the PRNG has sufficient
-        entropy, C{False} otherwise.
+        :py:obj:`OpenSSL.rand.status` returns :py:obj:`True` if the PRNG has sufficient
+        entropy, :py:obj:`False` otherwise.
         """
         # It's hard to know what it is actually going to return.  Different
         # OpenSSL random engines decide differently whether they have enough
@@ -97,8 +105,8 @@
 
     def test_egd_wrong_args(self):
         """
-        L{OpenSSL.rand.egd} raises L{TypeError} when called with the wrong
-        number of arguments or with arguments not of type C{str} and C{int}.
+        :py:obj:`OpenSSL.rand.egd` raises :py:obj:`TypeError` when called with the wrong
+        number of arguments or with arguments not of type :py:obj:`str` and :py:obj:`int`.
         """
         self.assertRaises(TypeError, rand.egd)
         self.assertRaises(TypeError, rand.egd, None)
@@ -109,8 +117,8 @@
 
     def test_egd_missing(self):
         """
-        L{OpenSSL.rand.egd} returns C{0} or C{-1} if the EGD socket passed
-        to it does not exist.
+        :py:obj:`OpenSSL.rand.egd` returns :py:obj:`0` or :py:obj:`-1` if the
+        EGD socket passed to it does not exist.
         """
         result = rand.egd(self.mktemp())
         expected = (-1, 0)
@@ -119,9 +127,22 @@
             "%r not in %r" % (result, expected))
 
 
+    def test_egd_missing_and_bytes(self):
+        """
+        :py:obj:`OpenSSL.rand.egd` returns :py:obj:`0` or :py:obj:`-1` if the
+        EGD socket passed to it does not exist even if a size argument is
+        explicitly passed.
+        """
+        result = rand.egd(self.mktemp(), 1024)
+        expected = (-1, 0)
+        self.assertTrue(
+            result in expected,
+            "%r not in %r" % (result, expected))
+
+
     def test_cleanup_wrong_args(self):
         """
-        L{OpenSSL.rand.cleanup} raises L{TypeError} when called with any
+        :py:obj:`OpenSSL.rand.cleanup` raises :py:obj:`TypeError` when called with any
         arguments.
         """
         self.assertRaises(TypeError, rand.cleanup, None)
@@ -129,16 +150,16 @@
 
     def test_cleanup(self):
         """
-        L{OpenSSL.rand.cleanup} releases the memory used by the PRNG and returns
-        C{None}.
+        :py:obj:`OpenSSL.rand.cleanup` releases the memory used by the PRNG and returns
+        :py:obj:`None`.
         """
         self.assertIdentical(rand.cleanup(), None)
 
 
     def test_load_file_wrong_args(self):
         """
-        L{OpenSSL.rand.load_file} raises L{TypeError} when called the wrong
-        number of arguments or arguments not of type C{str} and C{int}.
+        :py:obj:`OpenSSL.rand.load_file` raises :py:obj:`TypeError` when called the wrong
+        number of arguments or arguments not of type :py:obj:`str` and :py:obj:`int`.
         """
         self.assertRaises(TypeError, rand.load_file)
         self.assertRaises(TypeError, rand.load_file, "foo", None)
@@ -148,34 +169,54 @@
 
     def test_write_file_wrong_args(self):
         """
-        L{OpenSSL.rand.write_file} raises L{TypeError} when called with the
-        wrong number of arguments or a non-C{str} argument.
+        :py:obj:`OpenSSL.rand.write_file` raises :py:obj:`TypeError` when called with the
+        wrong number of arguments or a non-:py:obj:`str` argument.
         """
         self.assertRaises(TypeError, rand.write_file)
         self.assertRaises(TypeError, rand.write_file, None)
         self.assertRaises(TypeError, rand.write_file, "foo", None)
 
-
-    def test_files(self):
+    def _read_write_test(self, path):
         """
-        Test reading and writing of files via rand functions.
+        Verify that ``rand.write_file`` and ``rand.load_file`` can be used.
         """
-        # Write random bytes to a file
-        tmpfile = self.mktemp()
-        # Make sure it exists (so cleanup definitely succeeds)
-        fObj = open(tmpfile, 'w')
-        fObj.close()
+        # Create the file so cleanup is more straightforward
+        with open(path, "w"):
+            pass
+
         try:
-            rand.write_file(tmpfile)
+            # Write random bytes to a file
+            rand.write_file(path)
+
             # Verify length of written file
-            size = os.stat(tmpfile)[stat.ST_SIZE]
-            self.assertEquals(size, 1024)
+            size = os.stat(path)[stat.ST_SIZE]
+            self.assertEqual(1024, size)
+
             # Read random bytes from file
-            rand.load_file(tmpfile)
-            rand.load_file(tmpfile, 4)  # specify a length
+            rand.load_file(path)
+            rand.load_file(path, 4)  # specify a length
         finally:
             # Cleanup
-            os.unlink(tmpfile)
+            os.unlink(path)
+
+
+    def test_bytes_paths(self):
+        """
+        Random data can be saved and loaded to files with paths specified as
+        bytes.
+        """
+        path = self.mktemp()
+        path += NON_ASCII.encode(sys.getfilesystemencoding())
+        self._read_write_test(path)
+
+
+    def test_unicode_paths(self):
+        """
+        Random data can be saved and loaded to files with paths specified as
+        unicode.
+        """
+        path = self.mktemp().decode('utf-8') + NON_ASCII
+        self._read_write_test(path)
 
 
 if __name__ == '__main__':
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/test/test_ssl.py hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/test/test_ssl.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/test/test_ssl.py	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/test/test_ssl.py	2015-04-15 00:43:59.000000000 +0200
@@ -2,38 +2,52 @@
 # See LICENSE for details.
 
 """
-Unit tests for L{OpenSSL.SSL}.
+Unit tests for :py:obj:`OpenSSL.SSL`.
 """
 
-from gc import collect
-from errno import ECONNREFUSED, EINPROGRESS, EWOULDBLOCK
-from sys import platform, version_info
-from socket import error, socket
+from gc import collect, get_referrers
+from errno import ECONNREFUSED, EINPROGRESS, EWOULDBLOCK, EPIPE, ESHUTDOWN
+from sys import platform, getfilesystemencoding
+from socket import SHUT_RDWR, error, socket
 from os import makedirs
 from os.path import join
 from unittest import main
 from weakref import ref
+from warnings import catch_warnings, simplefilter
+
+from six import PY3, text_type, u
 
 from OpenSSL.crypto import TYPE_RSA, FILETYPE_PEM
-from OpenSSL.crypto import PKey, X509, X509Extension
+from OpenSSL.crypto import PKey, X509, X509Extension, X509Store
 from OpenSSL.crypto import dump_privatekey, load_privatekey
 from OpenSSL.crypto import dump_certificate, load_certificate
+from OpenSSL.crypto import get_elliptic_curves
 
 from OpenSSL.SSL import OPENSSL_VERSION_NUMBER, SSLEAY_VERSION, SSLEAY_CFLAGS
 from OpenSSL.SSL import SSLEAY_PLATFORM, SSLEAY_DIR, SSLEAY_BUILT_ON
 from OpenSSL.SSL import SENT_SHUTDOWN, RECEIVED_SHUTDOWN
-from OpenSSL.SSL import SSLv2_METHOD, SSLv3_METHOD, SSLv23_METHOD, TLSv1_METHOD
-from OpenSSL.SSL import OP_NO_SSLv2, OP_NO_SSLv3, OP_SINGLE_DH_USE
+from OpenSSL.SSL import (
+    SSLv2_METHOD, SSLv3_METHOD, SSLv23_METHOD, TLSv1_METHOD,
+    TLSv1_1_METHOD, TLSv1_2_METHOD)
+from OpenSSL.SSL import OP_SINGLE_DH_USE, OP_NO_SSLv2, OP_NO_SSLv3
 from OpenSSL.SSL import (
     VERIFY_PEER, VERIFY_FAIL_IF_NO_PEER_CERT, VERIFY_CLIENT_ONCE, VERIFY_NONE)
+
 from OpenSSL.SSL import (
-    Error, SysCallError, WantReadError, ZeroReturnError, SSLeay_version)
-from OpenSSL.SSL import Context, ContextType, Connection, ConnectionType
+    SESS_CACHE_OFF, SESS_CACHE_CLIENT, SESS_CACHE_SERVER, SESS_CACHE_BOTH,
+    SESS_CACHE_NO_AUTO_CLEAR, SESS_CACHE_NO_INTERNAL_LOOKUP,
+    SESS_CACHE_NO_INTERNAL_STORE, SESS_CACHE_NO_INTERNAL)
 
-from OpenSSL.test.util import TestCase, bytes, b
-from OpenSSL.test.test_crypto import (
-    cleartextCertificatePEM, cleartextPrivateKeyPEM)
+from OpenSSL.SSL import (
+    Error, SysCallError, WantReadError, WantWriteError, ZeroReturnError)
+from OpenSSL.SSL import (
+    Context, ContextType, Session, Connection, ConnectionType, SSLeay_version)
+
+from OpenSSL._util import lib as _lib
+
+from OpenSSL.test.util import WARNING_TYPE_EXPECTED, NON_ASCII, TestCase, b
 from OpenSSL.test.test_crypto import (
+    cleartextCertificatePEM, cleartextPrivateKeyPEM,
     client_cert_pem, client_key_pem, server_cert_pem, server_key_pem,
     root_cert_pem)
 
@@ -50,6 +64,21 @@
 except ImportError:
     OP_NO_TICKET = None
 
+try:
+    from OpenSSL.SSL import OP_NO_COMPRESSION
+except ImportError:
+    OP_NO_COMPRESSION = None
+
+try:
+    from OpenSSL.SSL import MODE_RELEASE_BUFFERS
+except ImportError:
+    MODE_RELEASE_BUFFERS = None
+
+try:
+    from OpenSSL.SSL import OP_NO_TLSv1, OP_NO_TLSv1_1, OP_NO_TLSv1_2
+except ImportError:
+    OP_NO_TLSv1 = OP_NO_TLSv1_1 = OP_NO_TLSv1_2 = None
+
 from OpenSSL.SSL import (
     SSL_ST_CONNECT, SSL_ST_ACCEPT, SSL_ST_MASK, SSL_ST_INIT, SSL_ST_BEFORE,
     SSL_ST_OK, SSL_ST_RENEGOTIATE,
@@ -67,6 +96,23 @@
 """
 
 
+def join_bytes_or_unicode(prefix, suffix):
+    """
+    Join two path components of either ``bytes`` or ``unicode``.
+
+    The return type is the same as the type of ``prefix``.
+    """
+    # If the types are the same, nothing special is necessary.
+    if type(prefix) == type(suffix):
+        return join(prefix, suffix)
+
+    # Otherwise, coerce suffix to the type of prefix.
+    if isinstance(prefix, text_type):
+        return join(prefix, suffix.decode(getfilesystemencoding()))
+    else:
+        return join(prefix, suffix.encode(getfilesystemencoding()))
+
+
 def verify_cb(conn, cert, errnum, depth, ok):
     return ok
 
@@ -172,16 +218,30 @@
     Helper mixin which defines methods for creating a connected socket pair and
     for forcing two connected SSL sockets to talk to each other via memory BIOs.
     """
-    def _loopback(self):
-        (server, client) = socket_pair()
+    def _loopbackClientFactory(self, socket):
+        client = Connection(Context(TLSv1_METHOD), socket)
+        client.set_connect_state()
+        return client
 
+
+    def _loopbackServerFactory(self, socket):
         ctx = Context(TLSv1_METHOD)
         ctx.use_privatekey(load_privatekey(FILETYPE_PEM, server_key_pem))
         ctx.use_certificate(load_certificate(FILETYPE_PEM, server_cert_pem))
-        server = Connection(ctx, server)
+        server = Connection(ctx, socket)
         server.set_accept_state()
-        client = Connection(Context(TLSv1_METHOD), client)
-        client.set_connect_state()
+        return server
+
+
+    def _loopback(self, serverFactory=None, clientFactory=None):
+        if serverFactory is None:
+            serverFactory = self._loopbackServerFactory
+        if clientFactory is None:
+            clientFactory = self._loopbackClientFactory
+
+        (server, client) = socket_pair()
+        server = serverFactory(server)
+        client = clientFactory(client)
 
         handshake(client, server)
 
@@ -192,10 +252,10 @@
 
     def _interactInMemory(self, client_conn, server_conn):
         """
-        Try to read application bytes from each of the two L{Connection}
+        Try to read application bytes from each of the two :py:obj:`Connection`
         objects.  Copy bytes back and forth between their send/receive buffers
         for as long as there is anything to copy.  When there is nothing more
-        to copy, return C{None}.  If one of them actually manages to deliver
+        to copy, return :py:obj:`None`.  If one of them actually manages to deliver
         some application bytes, return a two-tuple of the connection from which
         the bytes were read and the bytes themselves.
         """
@@ -237,16 +297,33 @@
                         write.bio_write(dirty)
 
 
+    def _handshakeInMemory(self, client_conn, server_conn):
+        """
+        Perform the TLS handshake between two :py:class:`Connection` instances
+        connected to each other via memory BIOs.
+        """
+        client_conn.set_connect_state()
+        server_conn.set_accept_state()
+
+        for conn in [client_conn, server_conn]:
+            try:
+                conn.do_handshake()
+            except WantReadError:
+                pass
+
+        self._interactInMemory(client_conn, server_conn)
+
+
 
 class VersionTests(TestCase):
     """
     Tests for version information exposed by
-    L{OpenSSL.SSL.SSLeay_version} and
-    L{OpenSSL.SSL.OPENSSL_VERSION_NUMBER}.
+    :py:obj:`OpenSSL.SSL.SSLeay_version` and
+    :py:obj:`OpenSSL.SSL.OPENSSL_VERSION_NUMBER`.
     """
     def test_OPENSSL_VERSION_NUMBER(self):
         """
-        L{OPENSSL_VERSION_NUMBER} is an integer with status in the low
+        :py:obj:`OPENSSL_VERSION_NUMBER` is an integer with status in the low
         byte and the patch, fix, minor, and major versions in the
         nibbles above that.
         """
@@ -255,7 +332,7 @@
 
     def test_SSLeay_version(self):
         """
-        L{SSLeay_version} takes a version type indicator and returns
+        :py:obj:`SSLeay_version` takes a version type indicator and returns
         one of a number of version strings based on that indicator.
         """
         versions = {}
@@ -270,30 +347,46 @@
 
 class ContextTests(TestCase, _LoopbackMixin):
     """
-    Unit tests for L{OpenSSL.SSL.Context}.
+    Unit tests for :py:obj:`OpenSSL.SSL.Context`.
     """
     def test_method(self):
         """
-        L{Context} can be instantiated with one of L{SSLv2_METHOD},
-        L{SSLv3_METHOD}, L{SSLv23_METHOD}, or L{TLSv1_METHOD}.
-        """
-        for meth in [SSLv3_METHOD, SSLv23_METHOD, TLSv1_METHOD]:
+        :py:obj:`Context` can be instantiated with one of :py:obj:`SSLv2_METHOD`,
+        :py:obj:`SSLv3_METHOD`, :py:obj:`SSLv23_METHOD`, :py:obj:`TLSv1_METHOD`,
+        :py:obj:`TLSv1_1_METHOD`, or :py:obj:`TLSv1_2_METHOD`.
+        """
+        methods = [
+            SSLv3_METHOD, SSLv23_METHOD, TLSv1_METHOD]
+        for meth in methods:
             Context(meth)
 
-        try:
-            Context(SSLv2_METHOD)
-        except ValueError:
-            # Some versions of OpenSSL have SSLv2, some don't.
-            # Difficult to say in advance.
-            pass
+
+        maybe = [SSLv2_METHOD, TLSv1_1_METHOD, TLSv1_2_METHOD]
+        for meth in maybe:
+            try:
+                Context(meth)
+            except (Error, ValueError):
+                # Some versions of OpenSSL have SSLv2 / TLSv1.1 / TLSv1.2, some
+                # don't.  Difficult to say in advance.
+                pass
 
         self.assertRaises(TypeError, Context, "")
         self.assertRaises(ValueError, Context, 10)
 
 
+    if not PY3:
+        def test_method_long(self):
+            """
+            On Python 2 :py:class:`Context` accepts values of type
+            :py:obj:`long` as well as :py:obj:`int`.
+            """
+            Context(long(TLSv1_METHOD))
+
+
+
     def test_type(self):
         """
-        L{Context} and L{ContextType} refer to the same type object and can be
+        :py:obj:`Context` and :py:obj:`ContextType` refer to the same type object and can be
         used to create instances of that type.
         """
         self.assertIdentical(Context, ContextType)
@@ -302,7 +395,7 @@
 
     def test_use_privatekey(self):
         """
-        L{Context.use_privatekey} takes an L{OpenSSL.crypto.PKey} instance.
+        :py:obj:`Context.use_privatekey` takes an :py:obj:`OpenSSL.crypto.PKey` instance.
         """
         key = PKey()
         key.generate_key(TYPE_RSA, 128)
@@ -311,9 +404,215 @@
         self.assertRaises(TypeError, ctx.use_privatekey, "")
 
 
+    def test_use_privatekey_file_missing(self):
+        """
+        :py:obj:`Context.use_privatekey_file` raises :py:obj:`OpenSSL.SSL.Error`
+        when passed the name of a file which does not exist.
+        """
+        ctx = Context(TLSv1_METHOD)
+        self.assertRaises(Error, ctx.use_privatekey_file, self.mktemp())
+
+
+    def _use_privatekey_file_test(self, pemfile, filetype):
+        """
+        Verify that calling ``Context.use_privatekey_file`` with the given
+        arguments does not raise an exception.
+        """
+        key = PKey()
+        key.generate_key(TYPE_RSA, 128)
+
+        with open(pemfile, "wt") as pem:
+            pem.write(
+                dump_privatekey(FILETYPE_PEM, key).decode("ascii")
+            )
+
+        ctx = Context(TLSv1_METHOD)
+        ctx.use_privatekey_file(pemfile, filetype)
+
+
+    def test_use_privatekey_file_bytes(self):
+        """
+        A private key can be specified from a file by passing a ``bytes``
+        instance giving the file name to ``Context.use_privatekey_file``.
+        """
+        self._use_privatekey_file_test(
+            self.mktemp() + NON_ASCII.encode(getfilesystemencoding()),
+            FILETYPE_PEM,
+        )
+
+
+    def test_use_privatekey_file_unicode(self):
+        """
+        A private key can be specified from a file by passing a ``unicode``
+        instance giving the file name to ``Context.use_privatekey_file``.
+        """
+        self._use_privatekey_file_test(
+            self.mktemp().decode(getfilesystemencoding()) + NON_ASCII,
+            FILETYPE_PEM,
+        )
+
+
+    if not PY3:
+        def test_use_privatekey_file_long(self):
+            """
+            On Python 2 :py:obj:`Context.use_privatekey_file` accepts a
+            filetype of type :py:obj:`long` as well as :py:obj:`int`.
+            """
+            self._use_privatekey_file_test(self.mktemp(), long(FILETYPE_PEM))
+
+
+    def test_use_certificate_wrong_args(self):
+        """
+        :py:obj:`Context.use_certificate_wrong_args` raises :py:obj:`TypeError`
+        when not passed exactly one :py:obj:`OpenSSL.crypto.X509` instance as an
+        argument.
+        """
+        ctx = Context(TLSv1_METHOD)
+        self.assertRaises(TypeError, ctx.use_certificate)
+        self.assertRaises(TypeError, ctx.use_certificate, "hello, world")
+        self.assertRaises(TypeError, ctx.use_certificate, X509(), "hello, world")
+
+
+    def test_use_certificate_uninitialized(self):
+        """
+        :py:obj:`Context.use_certificate` raises :py:obj:`OpenSSL.SSL.Error`
+        when passed a :py:obj:`OpenSSL.crypto.X509` instance which has not been
+        initialized (ie, which does not actually have any certificate data).
+        """
+        ctx = Context(TLSv1_METHOD)
+        self.assertRaises(Error, ctx.use_certificate, X509())
+
+
+    def test_use_certificate(self):
+        """
+        :py:obj:`Context.use_certificate` sets the certificate which will be
+        used to identify connections created using the context.
+        """
+        # TODO
+        # Hard to assert anything.  But we could set a privatekey then ask
+        # OpenSSL if the cert and key agree using check_privatekey.  Then as
+        # long as check_privatekey works right we're good...
+        ctx = Context(TLSv1_METHOD)
+        ctx.use_certificate(load_certificate(FILETYPE_PEM, cleartextCertificatePEM))
+
+
+    def test_use_certificate_file_wrong_args(self):
+        """
+        :py:obj:`Context.use_certificate_file` raises :py:obj:`TypeError` if
+        called with zero arguments or more than two arguments, or if the first
+        argument is not a byte string or the second argumnent is not an integer.
+        """
+        ctx = Context(TLSv1_METHOD)
+        self.assertRaises(TypeError, ctx.use_certificate_file)
+        self.assertRaises(TypeError, ctx.use_certificate_file, b"somefile", object())
+        self.assertRaises(
+            TypeError, ctx.use_certificate_file, b"somefile", FILETYPE_PEM, object())
+        self.assertRaises(
+            TypeError, ctx.use_certificate_file, object(), FILETYPE_PEM)
+        self.assertRaises(
+            TypeError, ctx.use_certificate_file, b"somefile", object())
+
+
+    def test_use_certificate_file_missing(self):
+        """
+        :py:obj:`Context.use_certificate_file` raises
+        `:py:obj:`OpenSSL.SSL.Error` if passed the name of a file which does not
+        exist.
+        """
+        ctx = Context(TLSv1_METHOD)
+        self.assertRaises(Error, ctx.use_certificate_file, self.mktemp())
+
+
+    def _use_certificate_file_test(self, certificate_file):
+        """
+        Verify that calling ``Context.use_certificate_file`` with the given
+        filename doesn't raise an exception.
+        """
+        # TODO
+        # Hard to assert anything.  But we could set a privatekey then ask
+        # OpenSSL if the cert and key agree using check_privatekey.  Then as
+        # long as check_privatekey works right we're good...
+        with open(certificate_file, "wb") as pem_file:
+            pem_file.write(cleartextCertificatePEM)
+
+        ctx = Context(TLSv1_METHOD)
+        ctx.use_certificate_file(certificate_file)
+
+
+    def test_use_certificate_file_bytes(self):
+        """
+        :py:obj:`Context.use_certificate_file` sets the certificate (given as a
+        ``bytes`` filename) which will be used to identify connections created
+        using the context.
+        """
+        filename = self.mktemp() + NON_ASCII.encode(getfilesystemencoding())
+        self._use_certificate_file_test(filename)
+
+
+    def test_use_certificate_file_unicode(self):
+        """
+        :py:obj:`Context.use_certificate_file` sets the certificate (given as a
+        ``bytes`` filename) which will be used to identify connections created
+        using the context.
+        """
+        filename = self.mktemp().decode(getfilesystemencoding()) + NON_ASCII
+        self._use_certificate_file_test(filename)
+
+
+    if not PY3:
+        def test_use_certificate_file_long(self):
+            """
+            On Python 2 :py:obj:`Context.use_certificate_file` accepts a
+            filetype of type :py:obj:`long` as well as :py:obj:`int`.
+            """
+            pem_filename = self.mktemp()
+            with open(pem_filename, "wb") as pem_file:
+                pem_file.write(cleartextCertificatePEM)
+
+            ctx = Context(TLSv1_METHOD)
+            ctx.use_certificate_file(pem_filename, long(FILETYPE_PEM))
+
+
+    def test_check_privatekey_valid(self):
+        """
+        :py:obj:`Context.check_privatekey` returns :py:obj:`None` if the
+        :py:obj:`Context` instance has been configured to use a matched key and
+        certificate pair.
+        """
+        key = load_privatekey(FILETYPE_PEM, client_key_pem)
+        cert = load_certificate(FILETYPE_PEM, client_cert_pem)
+        context = Context(TLSv1_METHOD)
+        context.use_privatekey(key)
+        context.use_certificate(cert)
+        self.assertIs(None, context.check_privatekey())
+
+
+    def test_check_privatekey_invalid(self):
+        """
+        :py:obj:`Context.check_privatekey` raises :py:obj:`Error` if the
+        :py:obj:`Context` instance has been configured to use a key and
+        certificate pair which don't relate to each other.
+        """
+        key = load_privatekey(FILETYPE_PEM, client_key_pem)
+        cert = load_certificate(FILETYPE_PEM, server_cert_pem)
+        context = Context(TLSv1_METHOD)
+        context.use_privatekey(key)
+        context.use_certificate(cert)
+        self.assertRaises(Error, context.check_privatekey)
+
+
+    def test_check_privatekey_wrong_args(self):
+        """
+        :py:obj:`Context.check_privatekey` raises :py:obj:`TypeError` if called
+        with other than no arguments.
+        """
+        context = Context(TLSv1_METHOD)
+        self.assertRaises(TypeError, context.check_privatekey, object())
+
+
     def test_set_app_data_wrong_args(self):
         """
-        L{Context.set_app_data} raises L{TypeError} if called with other than
+        :py:obj:`Context.set_app_data` raises :py:obj:`TypeError` if called with other than
         one argument.
         """
         context = Context(TLSv1_METHOD)
@@ -323,7 +622,7 @@
 
     def test_get_app_data_wrong_args(self):
         """
-        L{Context.get_app_data} raises L{TypeError} if called with any
+        :py:obj:`Context.get_app_data` raises :py:obj:`TypeError` if called with any
         arguments.
         """
         context = Context(TLSv1_METHOD)
@@ -332,8 +631,8 @@
 
     def test_app_data(self):
         """
-        L{Context.set_app_data} stores an object for later retrieval using
-        L{Context.get_app_data}.
+        :py:obj:`Context.set_app_data` stores an object for later retrieval using
+        :py:obj:`Context.get_app_data`.
         """
         app_data = object()
         context = Context(TLSv1_METHOD)
@@ -343,8 +642,8 @@
 
     def test_set_options_wrong_args(self):
         """
-        L{Context.set_options} raises L{TypeError} if called with the wrong
-        number of arguments or a non-C{int} argument.
+        :py:obj:`Context.set_options` raises :py:obj:`TypeError` if called with the wrong
+        number of arguments or a non-:py:obj:`int` argument.
         """
         context = Context(TLSv1_METHOD)
         self.assertRaises(TypeError, context.set_options)
@@ -352,10 +651,64 @@
         self.assertRaises(TypeError, context.set_options, 1, None)
 
 
+    def test_set_options(self):
+        """
+        :py:obj:`Context.set_options` returns the new options value.
+        """
+        context = Context(TLSv1_METHOD)
+        options = context.set_options(OP_NO_SSLv2)
+        self.assertTrue(OP_NO_SSLv2 & options)
+
+
+    if not PY3:
+        def test_set_options_long(self):
+            """
+            On Python 2 :py:obj:`Context.set_options` accepts values of type
+            :py:obj:`long` as well as :py:obj:`int`.
+            """
+            context = Context(TLSv1_METHOD)
+            options = context.set_options(long(OP_NO_SSLv2))
+            self.assertTrue(OP_NO_SSLv2 & options)
+
+
+    def test_set_mode_wrong_args(self):
+        """
+        :py:obj:`Context.set`mode} raises :py:obj:`TypeError` if called with the wrong
+        number of arguments or a non-:py:obj:`int` argument.
+        """
+        context = Context(TLSv1_METHOD)
+        self.assertRaises(TypeError, context.set_mode)
+        self.assertRaises(TypeError, context.set_mode, None)
+        self.assertRaises(TypeError, context.set_mode, 1, None)
+
+
+    if MODE_RELEASE_BUFFERS is not None:
+        def test_set_mode(self):
+            """
+            :py:obj:`Context.set_mode` accepts a mode bitvector and returns the newly
+            set mode.
+            """
+            context = Context(TLSv1_METHOD)
+            self.assertTrue(
+                MODE_RELEASE_BUFFERS & context.set_mode(MODE_RELEASE_BUFFERS))
+
+        if not PY3:
+            def test_set_mode_long(self):
+                """
+                On Python 2 :py:obj:`Context.set_mode` accepts values of type
+                :py:obj:`long` as well as :py:obj:`int`.
+                """
+                context = Context(TLSv1_METHOD)
+                mode = context.set_mode(long(MODE_RELEASE_BUFFERS))
+                self.assertTrue(MODE_RELEASE_BUFFERS & mode)
+    else:
+        "MODE_RELEASE_BUFFERS unavailable - OpenSSL version may be too old"
+
+
     def test_set_timeout_wrong_args(self):
         """
-        L{Context.set_timeout} raises L{TypeError} if called with the wrong
-        number of arguments or a non-C{int} argument.
+        :py:obj:`Context.set_timeout` raises :py:obj:`TypeError` if called with the wrong
+        number of arguments or a non-:py:obj:`int` argument.
         """
         context = Context(TLSv1_METHOD)
         self.assertRaises(TypeError, context.set_timeout)
@@ -365,7 +718,7 @@
 
     def test_get_timeout_wrong_args(self):
         """
-        L{Context.get_timeout} raises L{TypeError} if called with any arguments.
+        :py:obj:`Context.get_timeout` raises :py:obj:`TypeError` if called with any arguments.
         """
         context = Context(TLSv1_METHOD)
         self.assertRaises(TypeError, context.get_timeout, None)
@@ -373,8 +726,8 @@
 
     def test_timeout(self):
         """
-        L{Context.set_timeout} sets the session timeout for all connections
-        created using the context object.  L{Context.get_timeout} retrieves this
+        :py:obj:`Context.set_timeout` sets the session timeout for all connections
+        created using the context object.  :py:obj:`Context.get_timeout` retrieves this
         value.
         """
         context = Context(TLSv1_METHOD)
@@ -382,10 +735,21 @@
         self.assertEquals(context.get_timeout(), 1234)
 
 
+    if not PY3:
+        def test_timeout_long(self):
+            """
+            On Python 2 :py:obj:`Context.set_timeout` accepts values of type
+            `long` as well as int.
+            """
+            context = Context(TLSv1_METHOD)
+            context.set_timeout(long(1234))
+            self.assertEquals(context.get_timeout(), 1234)
+
+
     def test_set_verify_depth_wrong_args(self):
         """
-        L{Context.set_verify_depth} raises L{TypeError} if called with the wrong
-        number of arguments or a non-C{int} argument.
+        :py:obj:`Context.set_verify_depth` raises :py:obj:`TypeError` if called with the wrong
+        number of arguments or a non-:py:obj:`int` argument.
         """
         context = Context(TLSv1_METHOD)
         self.assertRaises(TypeError, context.set_verify_depth)
@@ -395,7 +759,7 @@
 
     def test_get_verify_depth_wrong_args(self):
         """
-        L{Context.get_verify_depth} raises L{TypeError} if called with any arguments.
+        :py:obj:`Context.get_verify_depth` raises :py:obj:`TypeError` if called with any arguments.
         """
         context = Context(TLSv1_METHOD)
         self.assertRaises(TypeError, context.get_verify_depth, None)
@@ -403,15 +767,26 @@
 
     def test_verify_depth(self):
         """
-        L{Context.set_verify_depth} sets the number of certificates in a chain
+        :py:obj:`Context.set_verify_depth` sets the number of certificates in a chain
         to follow before giving up.  The value can be retrieved with
-        L{Context.get_verify_depth}.
+        :py:obj:`Context.get_verify_depth`.
         """
         context = Context(TLSv1_METHOD)
         context.set_verify_depth(11)
         self.assertEquals(context.get_verify_depth(), 11)
 
 
+    if not PY3:
+        def test_verify_depth_long(self):
+            """
+            On Python 2 :py:obj:`Context.set_verify_depth` accepts values of
+            type `long` as well as int.
+            """
+            context = Context(TLSv1_METHOD)
+            context.set_verify_depth(long(11))
+            self.assertEquals(context.get_verify_depth(), 11)
+
+
     def _write_encrypted_pem(self, passphrase):
         """
         Write a new private key out to a new file, encrypted using the given
@@ -429,7 +804,7 @@
 
     def test_set_passwd_cb_wrong_args(self):
         """
-        L{Context.set_passwd_cb} raises L{TypeError} if called with the
+        :py:obj:`Context.set_passwd_cb` raises :py:obj:`TypeError` if called with the
         wrong arguments or with a non-callable first argument.
         """
         context = Context(TLSv1_METHOD)
@@ -440,7 +815,7 @@
 
     def test_set_passwd_cb(self):
         """
-        L{Context.set_passwd_cb} accepts a callable which will be invoked when
+        :py:obj:`Context.set_passwd_cb` accepts a callable which will be invoked when
         a private key is loaded from an encrypted PEM.
         """
         passphrase = b("foobar")
@@ -460,7 +835,7 @@
 
     def test_passwd_callback_exception(self):
         """
-        L{Context.use_privatekey_file} propagates any exception raised by the
+        :py:obj:`Context.use_privatekey_file` propagates any exception raised by the
         passphrase callback.
         """
         pemFile = self._write_encrypted_pem(b("monkeys are nice"))
@@ -474,12 +849,12 @@
 
     def test_passwd_callback_false(self):
         """
-        L{Context.use_privatekey_file} raises L{OpenSSL.SSL.Error} if the
+        :py:obj:`Context.use_privatekey_file` raises :py:obj:`OpenSSL.SSL.Error` if the
         passphrase callback returns a false value.
         """
         pemFile = self._write_encrypted_pem(b("monkeys are nice"))
         def passphraseCallback(maxlen, verify, extra):
-            return None
+            return b""
 
         context = Context(TLSv1_METHOD)
         context.set_passwd_cb(passphraseCallback)
@@ -488,7 +863,7 @@
 
     def test_passwd_callback_non_string(self):
         """
-        L{Context.use_privatekey_file} raises L{OpenSSL.SSL.Error} if the
+        :py:obj:`Context.use_privatekey_file` raises :py:obj:`OpenSSL.SSL.Error` if the
         passphrase callback returns a true non-string value.
         """
         pemFile = self._write_encrypted_pem(b("monkeys are nice"))
@@ -497,7 +872,7 @@
 
         context = Context(TLSv1_METHOD)
         context.set_passwd_cb(passphraseCallback)
-        self.assertRaises(Error, context.use_privatekey_file, pemFile)
+        self.assertRaises(ValueError, context.use_privatekey_file, pemFile)
 
 
     def test_passwd_callback_too_long(self):
@@ -521,7 +896,7 @@
 
     def test_set_info_callback(self):
         """
-        L{Context.set_info_callback} accepts a callable which will be invoked
+        :py:obj:`Context.set_info_callback` accepts a callable which will be invoked
         when certain information about an SSL connection is available.
         """
         (server, client) = socket_pair()
@@ -542,22 +917,26 @@
         serverSSL = Connection(context, server)
         serverSSL.set_accept_state()
 
-        while not called:
-            for ssl in clientSSL, serverSSL:
-                try:
-                    ssl.do_handshake()
-                except WantReadError:
-                    pass
+        handshake(clientSSL, serverSSL)
 
-        # Kind of lame.  Just make sure it got called somehow.
-        self.assertTrue(called)
+        # The callback must always be called with a Connection instance as the
+        # first argument.  It would probably be better to split this into
+        # separate tests for client and server side info callbacks so we could
+        # assert it is called with the right Connection instance.  It would
+        # also be good to assert *something* about `where` and `ret`.
+        notConnections = [
+            conn for (conn, where, ret) in called
+            if not isinstance(conn, Connection)]
+        self.assertEqual(
+            [], notConnections,
+            "Some info callback arguments were not Connection instaces.")
 
 
     def _load_verify_locations_test(self, *args):
         """
         Create a client context which will verify the peer certificate and call
-        its C{load_verify_locations} method with C{*args}.  Then connect it to a
-        server and ensure that the handshake succeeds.
+        its :py:obj:`load_verify_locations` method with the given arguments.
+        Then connect it to a server and ensure that the handshake succeeds.
         """
         (server, client) = socket_pair()
 
@@ -591,12 +970,13 @@
         self.assertEqual(cert.get_subject().CN, 'Testing Root CA')
 
 
-    def test_load_verify_file(self):
+    def _load_verify_cafile(self, cafile):
         """
-        L{Context.load_verify_locations} accepts a file name and uses the
-        certificates within for verification purposes.
+        Verify that if path to a file containing a certificate is passed to
+        ``Context.load_verify_locations`` for the ``cafile`` parameter, that
+        certificate is used as a trust root for the purposes of verifying
+        connections created using that ``Context``.
         """
-        cafile = self.mktemp()
         fObj = open(cafile, 'w')
         fObj.write(cleartextCertificatePEM.decode('ascii'))
         fObj.close()
@@ -604,9 +984,30 @@
         self._load_verify_locations_test(cafile)
 
 
+    def test_load_verify_bytes_cafile(self):
+        """
+        :py:obj:`Context.load_verify_locations` accepts a file name as a
+        ``bytes`` instance and uses the certificates within for verification
+        purposes.
+        """
+        cafile = self.mktemp() + NON_ASCII.encode(getfilesystemencoding())
+        self._load_verify_cafile(cafile)
+
+
+    def test_load_verify_unicode_cafile(self):
+        """
+        :py:obj:`Context.load_verify_locations` accepts a file name as a
+        ``unicode`` instance and uses the certificates within for verification
+        purposes.
+        """
+        self._load_verify_cafile(
+            self.mktemp().decode(getfilesystemencoding()) + NON_ASCII
+        )
+
+
     def test_load_verify_invalid_file(self):
         """
-        L{Context.load_verify_locations} raises L{Error} when passed a
+        :py:obj:`Context.load_verify_locations` raises :py:obj:`Error` when passed a
         non-existent cafile.
         """
         clientContext = Context(TLSv1_METHOD)
@@ -614,29 +1015,51 @@
             Error, clientContext.load_verify_locations, self.mktemp())
 
 
-    def test_load_verify_directory(self):
+    def _load_verify_directory_locations_capath(self, capath):
         """
-        L{Context.load_verify_locations} accepts a directory name and uses
-        the certificates within for verification purposes.
+        Verify that if path to a directory containing certificate files is
+        passed to ``Context.load_verify_locations`` for the ``capath``
+        parameter, those certificates are used as trust roots for the purposes
+        of verifying connections created using that ``Context``.
         """
-        capath = self.mktemp()
         makedirs(capath)
         # Hash values computed manually with c_rehash to avoid depending on
         # c_rehash in the test suite.  One is from OpenSSL 0.9.8, the other
         # from OpenSSL 1.0.0.
-        for name in ['c7adac82.0', 'c3705638.0']:
-            cafile = join(capath, name)
-            fObj = open(cafile, 'w')
-            fObj.write(cleartextCertificatePEM.decode('ascii'))
-            fObj.close()
+        for name in [b'c7adac82.0', b'c3705638.0']:
+            cafile = join_bytes_or_unicode(capath, name)
+            with open(cafile, 'w') as fObj:
+                fObj.write(cleartextCertificatePEM.decode('ascii'))
 
         self._load_verify_locations_test(None, capath)
 
 
+    def test_load_verify_directory_bytes_capath(self):
+        """
+        :py:obj:`Context.load_verify_locations` accepts a directory name as a
+        ``bytes`` instance and uses the certificates within for verification
+        purposes.
+        """
+        self._load_verify_directory_locations_capath(
+            self.mktemp() + NON_ASCII.encode(getfilesystemencoding())
+        )
+
+
+    def test_load_verify_directory_unicode_capath(self):
+        """
+        :py:obj:`Context.load_verify_locations` accepts a directory name as a
+        ``unicode`` instance and uses the certificates within for verification
+        purposes.
+        """
+        self._load_verify_directory_locations_capath(
+            self.mktemp().decode(getfilesystemencoding()) + NON_ASCII
+        )
+
+
     def test_load_verify_locations_wrong_args(self):
         """
-        L{Context.load_verify_locations} raises L{TypeError} if called with
-        the wrong number of arguments or with non-C{str} arguments.
+        :py:obj:`Context.load_verify_locations` raises :py:obj:`TypeError` if called with
+        the wrong number of arguments or with non-:py:obj:`str` arguments.
         """
         context = Context(TLSv1_METHOD)
         self.assertRaises(TypeError, context.load_verify_locations)
@@ -651,7 +1074,7 @@
     else:
         def test_set_default_verify_paths(self):
             """
-            L{Context.set_default_verify_paths} causes the platform-specific CA
+            :py:obj:`Context.set_default_verify_paths` causes the platform-specific CA
             certificate locations to be used for verification purposes.
             """
             # Testing this requires a server with a certificate signed by one of
@@ -662,8 +1085,8 @@
             # in a unit test is bad, but it's the only way I can think of to
             # really test this. -exarkun
 
-            # Arg, verisign.com doesn't speak TLSv1
-            context = Context(SSLv3_METHOD)
+            # Arg, verisign.com doesn't speak anything newer than TLS 1.0
+            context = Context(TLSv1_METHOD)
             context.set_default_verify_paths()
             context.set_verify(
                 VERIFY_PEER,
@@ -674,14 +1097,14 @@
             clientSSL = Connection(context, client)
             clientSSL.set_connect_state()
             clientSSL.do_handshake()
-            clientSSL.send('GET / HTTP/1.0\r\n\r\n')
+            clientSSL.send(b"GET / HTTP/1.0\r\n\r\n")
             self.assertTrue(clientSSL.recv(1024))
 
 
     def test_set_default_verify_paths_signature(self):
         """
-        L{Context.set_default_verify_paths} takes no arguments and raises
-        L{TypeError} if given any.
+        :py:obj:`Context.set_default_verify_paths` takes no arguments and raises
+        :py:obj:`TypeError` if given any.
         """
         context = Context(TLSv1_METHOD)
         self.assertRaises(TypeError, context.set_default_verify_paths, None)
@@ -691,9 +1114,9 @@
 
     def test_add_extra_chain_cert_invalid_cert(self):
         """
-        L{Context.add_extra_chain_cert} raises L{TypeError} if called with
+        :py:obj:`Context.add_extra_chain_cert` raises :py:obj:`TypeError` if called with
         other than one argument or if called with an object which is not an
-        instance of L{X509}.
+        instance of :py:obj:`X509`.
         """
         context = Context(TLSv1_METHOD)
         self.assertRaises(TypeError, context.add_extra_chain_cert)
@@ -724,12 +1147,62 @@
                     pass
 
 
+    def test_set_verify_callback_connection_argument(self):
+        """
+        The first argument passed to the verify callback is the
+        :py:class:`Connection` instance for which verification is taking place.
+        """
+        serverContext = Context(TLSv1_METHOD)
+        serverContext.use_privatekey(
+            load_privatekey(FILETYPE_PEM, cleartextPrivateKeyPEM))
+        serverContext.use_certificate(
+            load_certificate(FILETYPE_PEM, cleartextCertificatePEM))
+        serverConnection = Connection(serverContext, None)
+
+        class VerifyCallback(object):
+            def callback(self, connection, *args):
+                self.connection = connection
+                return 1
+
+        verify = VerifyCallback()
+        clientContext = Context(TLSv1_METHOD)
+        clientContext.set_verify(VERIFY_PEER, verify.callback)
+        clientConnection = Connection(clientContext, None)
+        clientConnection.set_connect_state()
+
+        self._handshakeInMemory(clientConnection, serverConnection)
+
+        self.assertIdentical(verify.connection, clientConnection)
+
+
+    def test_set_verify_callback_exception(self):
+        """
+        If the verify callback passed to :py:obj:`Context.set_verify` raises an
+        exception, verification fails and the exception is propagated to the
+        caller of :py:obj:`Connection.do_handshake`.
+        """
+        serverContext = Context(TLSv1_METHOD)
+        serverContext.use_privatekey(
+            load_privatekey(FILETYPE_PEM, cleartextPrivateKeyPEM))
+        serverContext.use_certificate(
+            load_certificate(FILETYPE_PEM, cleartextCertificatePEM))
+
+        clientContext = Context(TLSv1_METHOD)
+        def verify_callback(*args):
+            raise Exception("silly verify failure")
+        clientContext.set_verify(VERIFY_PEER, verify_callback)
+
+        exc = self.assertRaises(
+            Exception, self._handshake_test, serverContext, clientContext)
+        self.assertEqual("silly verify failure", str(exc))
+
+
     def test_add_extra_chain_cert(self):
         """
-        L{Context.add_extra_chain_cert} accepts an L{X509} instance to add to
+        :py:obj:`Context.add_extra_chain_cert` accepts an :py:obj:`X509` instance to add to
         the certificate chain.
 
-        See L{_create_certificate_chain} for the details of the certificate
+        See :py:obj:`_create_certificate_chain` for the details of the certificate
         chain tested.
 
         The chain is tested by starting a server with scert and connecting
@@ -762,64 +1235,104 @@
         clientContext = Context(TLSv1_METHOD)
         clientContext.set_verify(
             VERIFY_PEER | VERIFY_FAIL_IF_NO_PEER_CERT, verify_cb)
-        clientContext.load_verify_locations('ca.pem')
+        clientContext.load_verify_locations(b"ca.pem")
 
         # Try it out.
         self._handshake_test(serverContext, clientContext)
 
 
-    def test_use_certificate_chain_file(self):
+    def _use_certificate_chain_file_test(self, certdir):
         """
-        L{Context.use_certificate_chain_file} reads a certificate chain from
-        the specified file.
+        Verify that :py:obj:`Context.use_certificate_chain_file` reads a
+        certificate chain from a specified file.
 
-        The chain is tested by starting a server with scert and connecting
-        to it with a client which trusts cacert and requires verification to
+        The chain is tested by starting a server with scert and connecting to
+        it with a client which trusts cacert and requires verification to
         succeed.
         """
         chain = _create_certificate_chain()
         [(cakey, cacert), (ikey, icert), (skey, scert)] = chain
 
+        makedirs(certdir)
+
+        chainFile = join_bytes_or_unicode(certdir, "chain.pem")
+        caFile = join_bytes_or_unicode(certdir, "ca.pem")
+
         # Write out the chain file.
-        chainFile = self.mktemp()
-        fObj = open(chainFile, 'w')
-        # Most specific to least general.
-        fObj.write(dump_certificate(FILETYPE_PEM, scert).decode('ascii'))
-        fObj.write(dump_certificate(FILETYPE_PEM, icert).decode('ascii'))
-        fObj.write(dump_certificate(FILETYPE_PEM, cacert).decode('ascii'))
-        fObj.close()
+        with open(chainFile, 'wb') as fObj:
+            # Most specific to least general.
+            fObj.write(dump_certificate(FILETYPE_PEM, scert))
+            fObj.write(dump_certificate(FILETYPE_PEM, icert))
+            fObj.write(dump_certificate(FILETYPE_PEM, cacert))
+
+        with open(caFile, 'w') as fObj:
+            fObj.write(dump_certificate(FILETYPE_PEM, cacert).decode('ascii'))
 
         serverContext = Context(TLSv1_METHOD)
         serverContext.use_certificate_chain_file(chainFile)
         serverContext.use_privatekey(skey)
 
-        fObj = open('ca.pem', 'w')
-        fObj.write(dump_certificate(FILETYPE_PEM, cacert).decode('ascii'))
-        fObj.close()
-
         clientContext = Context(TLSv1_METHOD)
         clientContext.set_verify(
             VERIFY_PEER | VERIFY_FAIL_IF_NO_PEER_CERT, verify_cb)
-        clientContext.load_verify_locations('ca.pem')
+        clientContext.load_verify_locations(caFile)
 
         self._handshake_test(serverContext, clientContext)
 
+
+    def test_use_certificate_chain_file_bytes(self):
+        """
+        ``Context.use_certificate_chain_file`` accepts the name of a file (as
+        an instance of ``bytes``) to specify additional certificates to use to
+        construct and verify a trust chain.
+        """
+        self._use_certificate_chain_file_test(
+            self.mktemp() + NON_ASCII.encode(getfilesystemencoding())
+        )
+
+
+    def test_use_certificate_chain_file_unicode(self):
+        """
+        ``Context.use_certificate_chain_file`` accepts the name of a file (as
+        an instance of ``unicode``) to specify additional certificates to use
+        to construct and verify a trust chain.
+        """
+        self._use_certificate_chain_file_test(
+            self.mktemp().decode(getfilesystemencoding()) + NON_ASCII
+        )
+
+
+    def test_use_certificate_chain_file_wrong_args(self):
+        """
+        :py:obj:`Context.use_certificate_chain_file` raises :py:obj:`TypeError`
+        if passed zero or more than one argument or when passed a non-byte
+        string single argument.  It also raises :py:obj:`OpenSSL.SSL.Error` when
+        passed a bad chain file name (for example, the name of a file which does
+        not exist).
+        """
+        context = Context(TLSv1_METHOD)
+        self.assertRaises(TypeError, context.use_certificate_chain_file)
+        self.assertRaises(TypeError, context.use_certificate_chain_file, object())
+        self.assertRaises(TypeError, context.use_certificate_chain_file, b"foo", object())
+
+        self.assertRaises(Error, context.use_certificate_chain_file, self.mktemp())
+
     # XXX load_client_ca
     # XXX set_session_id
 
     def test_get_verify_mode_wrong_args(self):
         """
-        L{Context.get_verify_mode} raises L{TypeError} if called with any
+        :py:obj:`Context.get_verify_mode` raises :py:obj:`TypeError` if called with any
         arguments.
         """
         context = Context(TLSv1_METHOD)
         self.assertRaises(TypeError, context.get_verify_mode, None)
 
 
-    def test_get_verify_mode(self):
+    def test_set_verify_mode(self):
         """
-        L{Context.get_verify_mode} returns the verify mode flags previously
-        passed to L{Context.set_verify}.
+        :py:obj:`Context.get_verify_mode` returns the verify mode flags previously
+        passed to :py:obj:`Context.set_verify`.
         """
         context = Context(TLSv1_METHOD)
         self.assertEquals(context.get_verify_mode(), 0)
@@ -829,10 +1342,24 @@
             context.get_verify_mode(), VERIFY_PEER | VERIFY_CLIENT_ONCE)
 
 
+    if not PY3:
+        def test_set_verify_mode_long(self):
+            """
+            On Python 2 :py:obj:`Context.set_verify_mode` accepts values of
+            type :py:obj:`long` as well as :py:obj:`int`.
+            """
+            context = Context(TLSv1_METHOD)
+            self.assertEquals(context.get_verify_mode(), 0)
+            context.set_verify(
+                long(VERIFY_PEER | VERIFY_CLIENT_ONCE), lambda *args: None)
+            self.assertEquals(
+                context.get_verify_mode(), VERIFY_PEER | VERIFY_CLIENT_ONCE)
+
+
     def test_load_tmp_dh_wrong_args(self):
         """
-        L{Context.load_tmp_dh} raises L{TypeError} if called with the wrong
-        number of arguments or with a non-C{str} argument.
+        :py:obj:`Context.load_tmp_dh` raises :py:obj:`TypeError` if called with the wrong
+        number of arguments or with a non-:py:obj:`str` argument.
         """
         context = Context(TLSv1_METHOD)
         self.assertRaises(TypeError, context.load_tmp_dh)
@@ -842,47 +1369,158 @@
 
     def test_load_tmp_dh_missing_file(self):
         """
-        L{Context.load_tmp_dh} raises L{OpenSSL.SSL.Error} if the specified file
+        :py:obj:`Context.load_tmp_dh` raises :py:obj:`OpenSSL.SSL.Error` if the specified file
         does not exist.
         """
         context = Context(TLSv1_METHOD)
-        self.assertRaises(Error, context.load_tmp_dh, "hello")
+        self.assertRaises(Error, context.load_tmp_dh, b"hello")
 
 
-    def test_load_tmp_dh(self):
+    def _load_tmp_dh_test(self, dhfilename):
         """
-        L{Context.load_tmp_dh} loads Diffie-Hellman parameters from the
-        specified file.
+        Verify that calling ``Context.load_tmp_dh`` with the given filename
+        does not raise an exception.
         """
         context = Context(TLSv1_METHOD)
-        dhfilename = self.mktemp()
-        dhfile = open(dhfilename, "w")
-        dhfile.write(dhparam)
-        dhfile.close()
+        with open(dhfilename, "w") as dhfile:
+            dhfile.write(dhparam)
+
         context.load_tmp_dh(dhfilename)
         # XXX What should I assert here? -exarkun
 
 
-    def test_set_cipher_list(self):
+    def test_load_tmp_dh_bytes(self):
         """
-        L{Context.set_cipher_list} accepts a C{str} naming the ciphers which
-        connections created with the context object will be able to choose from.
+        :py:obj:`Context.load_tmp_dh` loads Diffie-Hellman parameters from the
+        specified file (given as ``bytes``).
         """
-        context = Context(TLSv1_METHOD)
-        context.set_cipher_list("hello world:EXP-RC4-MD5")
-        conn = Connection(context, None)
-        self.assertEquals(conn.get_cipher_list(), ["EXP-RC4-MD5"])
-
+        self._load_tmp_dh_test(
+            self.mktemp() + NON_ASCII.encode(getfilesystemencoding()),
+        )
 
 
-class ServerNameCallbackTests(TestCase, _LoopbackMixin):
-    """
-    Tests for L{Context.set_tlsext_servername_callback} and its interaction with
-    L{Connection}.
-    """
-    def test_wrong_args(self):
+    def test_load_tmp_dh_unicode(self):
         """
-        L{Context.set_tlsext_servername_callback} raises L{TypeError} if called
+        :py:obj:`Context.load_tmp_dh` loads Diffie-Hellman parameters from the
+        specified file (given as ``unicode``).
+        """
+        self._load_tmp_dh_test(
+            self.mktemp().decode(getfilesystemencoding()) + NON_ASCII,
+        )
+
+
+    def test_set_tmp_ecdh(self):
+        """
+        :py:obj:`Context.set_tmp_ecdh` sets the elliptic curve for
+        Diffie-Hellman to the specified curve.
+        """
+        context = Context(TLSv1_METHOD)
+        for curve in get_elliptic_curves():
+            # The only easily "assertable" thing is that it does not raise an
+            # exception.
+            context.set_tmp_ecdh(curve)
+
+
+    def test_set_cipher_list_bytes(self):
+        """
+        :py:obj:`Context.set_cipher_list` accepts a :py:obj:`bytes` naming the
+        ciphers which connections created with the context object will be able
+        to choose from.
+        """
+        context = Context(TLSv1_METHOD)
+        context.set_cipher_list(b"hello world:EXP-RC4-MD5")
+        conn = Connection(context, None)
+        self.assertEquals(conn.get_cipher_list(), ["EXP-RC4-MD5"])
+
+
+    def test_set_cipher_list_text(self):
+        """
+        :py:obj:`Context.set_cipher_list` accepts a :py:obj:`unicode` naming
+        the ciphers which connections created with the context object will be
+        able to choose from.
+        """
+        context = Context(TLSv1_METHOD)
+        context.set_cipher_list(u("hello world:EXP-RC4-MD5"))
+        conn = Connection(context, None)
+        self.assertEquals(conn.get_cipher_list(), ["EXP-RC4-MD5"])
+
+
+    def test_set_cipher_list_wrong_args(self):
+        """
+        :py:obj:`Context.set_cipher_list` raises :py:obj:`TypeError` when
+        passed zero arguments or more than one argument or when passed a
+        non-string single argument and raises :py:obj:`OpenSSL.SSL.Error` when
+        passed an incorrect cipher list string.
+        """
+        context = Context(TLSv1_METHOD)
+        self.assertRaises(TypeError, context.set_cipher_list)
+        self.assertRaises(TypeError, context.set_cipher_list, object())
+        self.assertRaises(TypeError, context.set_cipher_list, b"EXP-RC4-MD5", object())
+
+        self.assertRaises(Error, context.set_cipher_list, "imaginary-cipher")
+
+
+    def test_set_session_cache_mode_wrong_args(self):
+        """
+        :py:obj:`Context.set_session_cache_mode` raises :py:obj:`TypeError` if
+        called with other than one integer argument.
+        """
+        context = Context(TLSv1_METHOD)
+        self.assertRaises(TypeError, context.set_session_cache_mode)
+        self.assertRaises(TypeError, context.set_session_cache_mode, object())
+
+
+    def test_get_session_cache_mode_wrong_args(self):
+        """
+        :py:obj:`Context.get_session_cache_mode` raises :py:obj:`TypeError` if
+        called with any arguments.
+        """
+        context = Context(TLSv1_METHOD)
+        self.assertRaises(TypeError, context.get_session_cache_mode, 1)
+
+
+    def test_session_cache_mode(self):
+        """
+        :py:obj:`Context.set_session_cache_mode` specifies how sessions are
+        cached.  The setting can be retrieved via
+        :py:obj:`Context.get_session_cache_mode`.
+        """
+        context = Context(TLSv1_METHOD)
+        context.set_session_cache_mode(SESS_CACHE_OFF)
+        off = context.set_session_cache_mode(SESS_CACHE_BOTH)
+        self.assertEqual(SESS_CACHE_OFF, off)
+        self.assertEqual(SESS_CACHE_BOTH, context.get_session_cache_mode())
+
+    if not PY3:
+        def test_session_cache_mode_long(self):
+            """
+            On Python 2 :py:obj:`Context.set_session_cache_mode` accepts values
+            of type :py:obj:`long` as well as :py:obj:`int`.
+            """
+            context = Context(TLSv1_METHOD)
+            context.set_session_cache_mode(long(SESS_CACHE_BOTH))
+            self.assertEqual(
+                SESS_CACHE_BOTH, context.get_session_cache_mode())
+
+
+    def test_get_cert_store(self):
+        """
+        :py:obj:`Context.get_cert_store` returns a :py:obj:`X509Store` instance.
+        """
+        context = Context(TLSv1_METHOD)
+        store = context.get_cert_store()
+        self.assertIsInstance(store, X509Store)
+
+
+
+class ServerNameCallbackTests(TestCase, _LoopbackMixin):
+    """
+    Tests for :py:obj:`Context.set_tlsext_servername_callback` and its interaction with
+    :py:obj:`Connection`.
+    """
+    def test_wrong_args(self):
+        """
+        :py:obj:`Context.set_tlsext_servername_callback` raises :py:obj:`TypeError` if called
         with other than one argument.
         """
         context = Context(TLSv1_METHOD)
@@ -890,9 +1528,10 @@
         self.assertRaises(
             TypeError, context.set_tlsext_servername_callback, 1, 2)
 
+
     def test_old_callback_forgotten(self):
         """
-        If L{Context.set_tlsext_servername_callback} is used to specify a new
+        If :py:obj:`Context.set_tlsext_servername_callback` is used to specify a new
         callback, the one it replaces is dereferenced.
         """
         def callback(connection):
@@ -908,15 +1547,26 @@
         del callback
 
         context.set_tlsext_servername_callback(replacement)
+
+        # One run of the garbage collector happens to work on CPython.  PyPy
+        # doesn't collect the underlying object until a second run for whatever
+        # reason.  That's fine, it still demonstrates our code has properly
+        # dropped the reference.
+        collect()
         collect()
-        self.assertIdentical(None, tracker())
+
+        callback = tracker()
+        if callback is not None:
+            referrers = get_referrers(callback)
+            if len(referrers) > 1:
+                self.fail("Some references remain: %r" % (referrers,))
 
 
     def test_no_servername(self):
         """
         When a client specifies no server name, the callback passed to
-        L{Context.set_tlsext_servername_callback} is invoked and the result of
-        L{Connection.get_servername} is C{None}.
+        :py:obj:`Context.set_tlsext_servername_callback` is invoked and the result of
+        :py:obj:`Connection.get_servername` is :py:obj:`None`.
         """
         args = []
         def servername(conn):
@@ -948,8 +1598,8 @@
     def test_servername(self):
         """
         When a client specifies a server name in its hello message, the callback
-        passed to L{Contexts.set_tlsext_servername_callback} is invoked and the
-        result of L{Connection.get_servername} is that server name.
+        passed to :py:obj:`Contexts.set_tlsext_servername_callback` is invoked and the
+        result of :py:obj:`Connection.get_servername` is that server name.
         """
         args = []
         def servername(conn):
@@ -974,13 +1624,425 @@
         self.assertEqual([(server, b("foo1.example.com"))], args)
 
 
+class NextProtoNegotiationTests(TestCase, _LoopbackMixin):
+    """
+    Test for Next Protocol Negotiation in PyOpenSSL.
+    """
+    if _lib.Cryptography_HAS_NEXTPROTONEG:
+        def test_npn_success(self):
+            """
+            Tests that clients and servers that agree on the negotiated next
+            protocol can correct establish a connection, and that the agreed
+            protocol is reported by the connections.
+            """
+            advertise_args = []
+            select_args = []
+            def advertise(conn):
+                advertise_args.append((conn,))
+                return [b'http/1.1', b'spdy/2']
+            def select(conn, options):
+                select_args.append((conn, options))
+                return b'spdy/2'
+
+            server_context = Context(TLSv1_METHOD)
+            server_context.set_npn_advertise_callback(advertise)
+
+            client_context = Context(TLSv1_METHOD)
+            client_context.set_npn_select_callback(select)
+
+            # Necessary to actually accept the connection
+            server_context.use_privatekey(
+                load_privatekey(FILETYPE_PEM, server_key_pem))
+            server_context.use_certificate(
+                load_certificate(FILETYPE_PEM, server_cert_pem))
+
+            # Do a little connection to trigger the logic
+            server = Connection(server_context, None)
+            server.set_accept_state()
+
+            client = Connection(client_context, None)
+            client.set_connect_state()
+
+            self._interactInMemory(server, client)
+
+            self.assertEqual([(server,)], advertise_args)
+            self.assertEqual([(client, [b'http/1.1', b'spdy/2'])], select_args)
+
+            self.assertEqual(server.get_next_proto_negotiated(), b'spdy/2')
+            self.assertEqual(client.get_next_proto_negotiated(), b'spdy/2')
+
+
+        def test_npn_client_fail(self):
+            """
+            Tests that when clients and servers cannot agree on what protocol
+            to use next that the TLS connection does not get established.
+            """
+            advertise_args = []
+            select_args = []
+            def advertise(conn):
+                advertise_args.append((conn,))
+                return [b'http/1.1', b'spdy/2']
+            def select(conn, options):
+                select_args.append((conn, options))
+                return b''
+
+            server_context = Context(TLSv1_METHOD)
+            server_context.set_npn_advertise_callback(advertise)
+
+            client_context = Context(TLSv1_METHOD)
+            client_context.set_npn_select_callback(select)
+
+            # Necessary to actually accept the connection
+            server_context.use_privatekey(
+                load_privatekey(FILETYPE_PEM, server_key_pem))
+            server_context.use_certificate(
+                load_certificate(FILETYPE_PEM, server_cert_pem))
+
+            # Do a little connection to trigger the logic
+            server = Connection(server_context, None)
+            server.set_accept_state()
+
+            client = Connection(client_context, None)
+            client.set_connect_state()
+
+            # If the client doesn't return anything, the connection will fail.
+            self.assertRaises(Error, self._interactInMemory, server, client)
+
+            self.assertEqual([(server,)], advertise_args)
+            self.assertEqual([(client, [b'http/1.1', b'spdy/2'])], select_args)
+
+
+        def test_npn_select_error(self):
+            """
+            Test that we can handle exceptions in the select callback. If
+            select fails it should be fatal to the connection.
+            """
+            advertise_args = []
+            def advertise(conn):
+                advertise_args.append((conn,))
+                return [b'http/1.1', b'spdy/2']
+            def select(conn, options):
+                raise TypeError
+
+            server_context = Context(TLSv1_METHOD)
+            server_context.set_npn_advertise_callback(advertise)
+
+            client_context = Context(TLSv1_METHOD)
+            client_context.set_npn_select_callback(select)
+
+            # Necessary to actually accept the connection
+            server_context.use_privatekey(
+                load_privatekey(FILETYPE_PEM, server_key_pem))
+            server_context.use_certificate(
+                load_certificate(FILETYPE_PEM, server_cert_pem))
+
+            # Do a little connection to trigger the logic
+            server = Connection(server_context, None)
+            server.set_accept_state()
+
+            client = Connection(client_context, None)
+            client.set_connect_state()
+
+            # If the callback throws an exception it should be raised here.
+            self.assertRaises(
+                TypeError, self._interactInMemory, server, client
+            )
+            self.assertEqual([(server,)], advertise_args)
+
+
+        def test_npn_advertise_error(self):
+            """
+            Test that we can handle exceptions in the advertise callback. If
+            advertise fails no NPN is advertised to the client.
+            """
+            select_args = []
+            def advertise(conn):
+                raise TypeError
+            def select(conn, options):
+                select_args.append((conn, options))
+                return b''
+
+            server_context = Context(TLSv1_METHOD)
+            server_context.set_npn_advertise_callback(advertise)
+
+            client_context = Context(TLSv1_METHOD)
+            client_context.set_npn_select_callback(select)
+
+            # Necessary to actually accept the connection
+            server_context.use_privatekey(
+                load_privatekey(FILETYPE_PEM, server_key_pem))
+            server_context.use_certificate(
+                load_certificate(FILETYPE_PEM, server_cert_pem))
+
+            # Do a little connection to trigger the logic
+            server = Connection(server_context, None)
+            server.set_accept_state()
+
+            client = Connection(client_context, None)
+            client.set_connect_state()
+
+            # If the client doesn't return anything, the connection will fail.
+            self.assertRaises(
+                TypeError, self._interactInMemory, server, client
+            )
+            self.assertEqual([], select_args)
+
+    else:
+        # No NPN.
+        def test_npn_not_implemented(self):
+            # Test the context methods first.
+            context = Context(TLSv1_METHOD)
+            fail_methods = [
+                context.set_npn_advertise_callback,
+                context.set_npn_select_callback,
+            ]
+            for method in fail_methods:
+                self.assertRaises(
+                    NotImplementedError, method, None
+                )
+
+            # Now test a connection.
+            conn = Connection(context)
+            fail_methods = [
+                conn.get_next_proto_negotiated,
+            ]
+            for method in fail_methods:
+                self.assertRaises(NotImplementedError, method)
+
+
+
+class ApplicationLayerProtoNegotiationTests(TestCase, _LoopbackMixin):
+    """
+    Tests for ALPN in PyOpenSSL.
+    """
+    # Skip tests on versions that don't support ALPN.
+    if _lib.Cryptography_HAS_ALPN:
+
+        def test_alpn_success(self):
+            """
+            Clients and servers that agree on the negotiated ALPN protocol can
+            correct establish a connection, and the agreed protocol is reported
+            by the connections.
+            """
+            select_args = []
+            def select(conn, options):
+                select_args.append((conn, options))
+                return b'spdy/2'
+
+            client_context = Context(TLSv1_METHOD)
+            client_context.set_alpn_protos([b'http/1.1', b'spdy/2'])
+
+            server_context = Context(TLSv1_METHOD)
+            server_context.set_alpn_select_callback(select)
+
+            # Necessary to actually accept the connection
+            server_context.use_privatekey(
+                load_privatekey(FILETYPE_PEM, server_key_pem))
+            server_context.use_certificate(
+                load_certificate(FILETYPE_PEM, server_cert_pem))
+
+            # Do a little connection to trigger the logic
+            server = Connection(server_context, None)
+            server.set_accept_state()
+
+            client = Connection(client_context, None)
+            client.set_connect_state()
+
+            self._interactInMemory(server, client)
+
+            self.assertEqual([(server, [b'http/1.1', b'spdy/2'])], select_args)
+
+            self.assertEqual(server.get_alpn_proto_negotiated(), b'spdy/2')
+            self.assertEqual(client.get_alpn_proto_negotiated(), b'spdy/2')
+
+
+        def test_alpn_set_on_connection(self):
+            """
+            The same as test_alpn_success, but setting the ALPN protocols on
+            the connection rather than the context.
+            """
+            select_args = []
+            def select(conn, options):
+                select_args.append((conn, options))
+                return b'spdy/2'
+
+            # Setup the client context but don't set any ALPN protocols.
+            client_context = Context(TLSv1_METHOD)
+
+            server_context = Context(TLSv1_METHOD)
+            server_context.set_alpn_select_callback(select)
+
+            # Necessary to actually accept the connection
+            server_context.use_privatekey(
+                load_privatekey(FILETYPE_PEM, server_key_pem))
+            server_context.use_certificate(
+                load_certificate(FILETYPE_PEM, server_cert_pem))
+
+            # Do a little connection to trigger the logic
+            server = Connection(server_context, None)
+            server.set_accept_state()
+
+            # Set the ALPN protocols on the client connection.
+            client = Connection(client_context, None)
+            client.set_alpn_protos([b'http/1.1', b'spdy/2'])
+            client.set_connect_state()
+
+            self._interactInMemory(server, client)
+
+            self.assertEqual([(server, [b'http/1.1', b'spdy/2'])], select_args)
+
+            self.assertEqual(server.get_alpn_proto_negotiated(), b'spdy/2')
+            self.assertEqual(client.get_alpn_proto_negotiated(), b'spdy/2')
+
+
+        def test_alpn_server_fail(self):
+            """
+            When clients and servers cannot agree on what protocol to use next
+            the TLS connection does not get established.
+            """
+            select_args = []
+            def select(conn, options):
+                select_args.append((conn, options))
+                return b''
+
+            client_context = Context(TLSv1_METHOD)
+            client_context.set_alpn_protos([b'http/1.1', b'spdy/2'])
+
+            server_context = Context(TLSv1_METHOD)
+            server_context.set_alpn_select_callback(select)
+
+            # Necessary to actually accept the connection
+            server_context.use_privatekey(
+                load_privatekey(FILETYPE_PEM, server_key_pem))
+            server_context.use_certificate(
+                load_certificate(FILETYPE_PEM, server_cert_pem))
+
+            # Do a little connection to trigger the logic
+            server = Connection(server_context, None)
+            server.set_accept_state()
+
+            client = Connection(client_context, None)
+            client.set_connect_state()
+
+            # If the client doesn't return anything, the connection will fail.
+            self.assertRaises(Error, self._interactInMemory, server, client)
+
+            self.assertEqual([(server, [b'http/1.1', b'spdy/2'])], select_args)
+
+
+        def test_alpn_no_server(self):
+            """
+            When clients and servers cannot agree on what protocol to use next
+            because the server doesn't offer ALPN, no protocol is negotiated.
+            """
+            client_context = Context(TLSv1_METHOD)
+            client_context.set_alpn_protos([b'http/1.1', b'spdy/2'])
+
+            server_context = Context(TLSv1_METHOD)
+
+            # Necessary to actually accept the connection
+            server_context.use_privatekey(
+                load_privatekey(FILETYPE_PEM, server_key_pem))
+            server_context.use_certificate(
+                load_certificate(FILETYPE_PEM, server_cert_pem))
+
+            # Do a little connection to trigger the logic
+            server = Connection(server_context, None)
+            server.set_accept_state()
+
+            client = Connection(client_context, None)
+            client.set_connect_state()
+
+            # Do the dance.
+            self._interactInMemory(server, client)
+
+            self.assertEqual(client.get_alpn_proto_negotiated(), b'')
+
+
+        def test_alpn_callback_exception(self):
+            """
+            We can handle exceptions in the ALPN select callback.
+            """
+            select_args = []
+            def select(conn, options):
+                select_args.append((conn, options))
+                raise TypeError()
+
+            client_context = Context(TLSv1_METHOD)
+            client_context.set_alpn_protos([b'http/1.1', b'spdy/2'])
+
+            server_context = Context(TLSv1_METHOD)
+            server_context.set_alpn_select_callback(select)
+
+            # Necessary to actually accept the connection
+            server_context.use_privatekey(
+                load_privatekey(FILETYPE_PEM, server_key_pem))
+            server_context.use_certificate(
+                load_certificate(FILETYPE_PEM, server_cert_pem))
+
+            # Do a little connection to trigger the logic
+            server = Connection(server_context, None)
+            server.set_accept_state()
+
+            client = Connection(client_context, None)
+            client.set_connect_state()
+
+            self.assertRaises(
+                TypeError, self._interactInMemory, server, client
+            )
+            self.assertEqual([(server, [b'http/1.1', b'spdy/2'])], select_args)
+
+    else:
+        # No ALPN.
+        def test_alpn_not_implemented(self):
+            """
+            If ALPN is not in OpenSSL, we should raise NotImplementedError.
+            """
+            # Test the context methods first.
+            context = Context(TLSv1_METHOD)
+            self.assertRaises(
+                NotImplementedError, context.set_alpn_protos, None
+            )
+            self.assertRaises(
+                NotImplementedError, context.set_alpn_select_callback, None
+            )
+
+            # Now test a connection.
+            conn = Connection(context)
+            self.assertRaises(
+                NotImplementedError, context.set_alpn_protos, None
+            )
+
+
+
+class SessionTests(TestCase):
+    """
+    Unit tests for :py:obj:`OpenSSL.SSL.Session`.
+    """
+    def test_construction(self):
+        """
+        :py:class:`Session` can be constructed with no arguments, creating a new
+        instance of that type.
+        """
+        new_session = Session()
+        self.assertTrue(isinstance(new_session, Session))
+
+
+    def test_construction_wrong_args(self):
+        """
+        If any arguments are passed to :py:class:`Session`, :py:obj:`TypeError`
+        is raised.
+        """
+        self.assertRaises(TypeError, Session, 123)
+        self.assertRaises(TypeError, Session, "hello")
+        self.assertRaises(TypeError, Session, object())
+
+
 
 class ConnectionTests(TestCase, _LoopbackMixin):
     """
-    Unit tests for L{OpenSSL.SSL.Connection}.
+    Unit tests for :py:obj:`OpenSSL.SSL.Connection`.
     """
-    # XXX want_write
-    # XXX want_read
     # XXX get_peer_certificate -> None
     # XXX sock_shutdown
     # XXX master_key -> TypeError
@@ -999,7 +2061,7 @@
 
     def test_type(self):
         """
-        L{Connection} and L{ConnectionType} refer to the same type object and
+        :py:obj:`Connection` and :py:obj:`ConnectionType` refer to the same type object and
         can be used to create instances of that type.
         """
         self.assertIdentical(Connection, ConnectionType)
@@ -1009,8 +2071,8 @@
 
     def test_get_context(self):
         """
-        L{Connection.get_context} returns the L{Context} instance used to
-        construct the L{Connection} instance.
+        :py:obj:`Connection.get_context` returns the :py:obj:`Context` instance used to
+        construct the :py:obj:`Connection` instance.
         """
         context = Context(TLSv1_METHOD)
         connection = Connection(context, None)
@@ -1019,7 +2081,7 @@
 
     def test_get_context_wrong_args(self):
         """
-        L{Connection.get_context} raises L{TypeError} if called with any
+        :py:obj:`Connection.get_context` raises :py:obj:`TypeError` if called with any
         arguments.
         """
         connection = Connection(Context(TLSv1_METHOD), None)
@@ -1028,8 +2090,8 @@
 
     def test_set_context_wrong_args(self):
         """
-        L{Connection.set_context} raises L{TypeError} if called with a
-        non-L{Context} instance argument or with any number of arguments other
+        :py:obj:`Connection.set_context` raises :py:obj:`TypeError` if called with a
+        non-:py:obj:`Context` instance argument or with any number of arguments other
         than 1.
         """
         ctx = Context(TLSv1_METHOD)
@@ -1046,7 +2108,7 @@
 
     def test_set_context(self):
         """
-        L{Connection.set_context} specifies a new L{Context} instance to be used
+        :py:obj:`Connection.set_context` specifies a new :py:obj:`Context` instance to be used
         for the connection.
         """
         original = Context(SSLv23_METHOD)
@@ -1062,9 +2124,9 @@
 
     def test_set_tlsext_host_name_wrong_args(self):
         """
-        If L{Connection.set_tlsext_host_name} is called with a non-byte string
+        If :py:obj:`Connection.set_tlsext_host_name` is called with a non-byte string
         argument or a byte string with an embedded NUL or other than one
-        argument, L{TypeError} is raised.
+        argument, :py:obj:`TypeError` is raised.
         """
         conn = Connection(Context(TLSv1_METHOD), None)
         self.assertRaises(TypeError, conn.set_tlsext_host_name)
@@ -1073,7 +2135,7 @@
         self.assertRaises(
             TypeError, conn.set_tlsext_host_name, b("with\0null"))
 
-        if version_info >= (3,):
+        if PY3:
             # On Python 3.x, don't accidentally implicitly convert from text.
             self.assertRaises(
                 TypeError,
@@ -1082,7 +2144,7 @@
 
     def test_get_servername_wrong_args(self):
         """
-        L{Connection.get_servername} raises L{TypeError} if called with any
+        :py:obj:`Connection.get_servername` raises :py:obj:`TypeError` if called with any
         arguments.
         """
         connection = Connection(Context(TLSv1_METHOD), None)
@@ -1093,7 +2155,7 @@
 
     def test_pending(self):
         """
-        L{Connection.pending} returns the number of bytes available for
+        :py:obj:`Connection.pending` returns the number of bytes available for
         immediate read.
         """
         connection = Connection(Context(TLSv1_METHOD), None)
@@ -1102,7 +2164,7 @@
 
     def test_pending_wrong_args(self):
         """
-        L{Connection.pending} raises L{TypeError} if called with any arguments.
+        :py:obj:`Connection.pending` raises :py:obj:`TypeError` if called with any arguments.
         """
         connection = Connection(Context(TLSv1_METHOD), None)
         self.assertRaises(TypeError, connection.pending, None)
@@ -1110,7 +2172,7 @@
 
     def test_connect_wrong_args(self):
         """
-        L{Connection.connect} raises L{TypeError} if called with a non-address
+        :py:obj:`Connection.connect` raises :py:obj:`TypeError` if called with a non-address
         argument or with the wrong number of arguments.
         """
         connection = Connection(Context(TLSv1_METHOD), socket())
@@ -1121,7 +2183,7 @@
 
     def test_connect_refused(self):
         """
-        L{Connection.connect} raises L{socket.error} if the underlying socket
+        :py:obj:`Connection.connect` raises :py:obj:`socket.error` if the underlying socket
         connect method raises it.
         """
         client = socket()
@@ -1133,7 +2195,7 @@
 
     def test_connect(self):
         """
-        L{Connection.connect} establishes a connection to the specified address.
+        :py:obj:`Connection.connect` establishes a connection to the specified address.
         """
         port = socket()
         port.bind(('', 0))
@@ -1149,7 +2211,7 @@
     else:
         def test_connect_ex(self):
             """
-            If there is a connection error, L{Connection.connect_ex} returns the
+            If there is a connection error, :py:obj:`Connection.connect_ex` returns the
             errno instead of raising an exception.
             """
             port = socket()
@@ -1166,7 +2228,7 @@
 
     def test_accept_wrong_args(self):
         """
-        L{Connection.accept} raises L{TypeError} if called with any arguments.
+        :py:obj:`Connection.accept` raises :py:obj:`TypeError` if called with any arguments.
         """
         connection = Connection(Context(TLSv1_METHOD), socket())
         self.assertRaises(TypeError, connection.accept, None)
@@ -1174,8 +2236,8 @@
 
     def test_accept(self):
         """
-        L{Connection.accept} accepts a pending connection attempt and returns a
-        tuple of a new L{Connection} (the accepted client) and the address the
+        :py:obj:`Connection.accept` accepts a pending connection attempt and returns a
+        tuple of a new :py:obj:`Connection` (the accepted client) and the address the
         connection originated from.
         """
         ctx = Context(TLSv1_METHOD)
@@ -1201,7 +2263,7 @@
 
     def test_shutdown_wrong_args(self):
         """
-        L{Connection.shutdown} raises L{TypeError} if called with the wrong
+        :py:obj:`Connection.shutdown` raises :py:obj:`TypeError` if called with the wrong
         number of arguments or with arguments other than integers.
         """
         connection = Connection(Context(TLSv1_METHOD), None)
@@ -1214,7 +2276,7 @@
 
     def test_shutdown(self):
         """
-        L{Connection.shutdown} performs an SSL-level connection shutdown.
+        :py:obj:`Connection.shutdown` performs an SSL-level connection shutdown.
         """
         server, client = self._loopback()
         self.assertFalse(server.shutdown())
@@ -1227,9 +2289,43 @@
         self.assertEquals(server.get_shutdown(), SENT_SHUTDOWN|RECEIVED_SHUTDOWN)
 
 
+    def test_shutdown_closed(self):
+        """
+        If the underlying socket is closed, :py:obj:`Connection.shutdown` propagates the
+        write error from the low level write call.
+        """
+        server, client = self._loopback()
+        server.sock_shutdown(2)
+        exc = self.assertRaises(SysCallError, server.shutdown)
+        if platform == "win32":
+            self.assertEqual(exc.args[0], ESHUTDOWN)
+        else:
+            self.assertEqual(exc.args[0], EPIPE)
+
+
+    def test_shutdown_truncated(self):
+        """
+        If the underlying connection is truncated, :obj:`Connection.shutdown`
+        raises an :obj:`Error`.
+        """
+        server_ctx = Context(TLSv1_METHOD)
+        client_ctx = Context(TLSv1_METHOD)
+        server_ctx.use_privatekey(
+            load_privatekey(FILETYPE_PEM, server_key_pem))
+        server_ctx.use_certificate(
+            load_certificate(FILETYPE_PEM, server_cert_pem))
+        server = Connection(server_ctx, None)
+        client = Connection(client_ctx, None)
+        self._handshakeInMemory(client, server)
+        self.assertEqual(server.shutdown(), False)
+        self.assertRaises(WantReadError, server.shutdown)
+        server.bio_shutdown()
+        self.assertRaises(Error, server.shutdown)
+
+
     def test_set_shutdown(self):
         """
-        L{Connection.set_shutdown} sets the state of the SSL connection shutdown
+        :py:obj:`Connection.set_shutdown` sets the state of the SSL connection shutdown
         process.
         """
         connection = Connection(Context(TLSv1_METHOD), socket())
@@ -1237,10 +2333,21 @@
         self.assertEquals(connection.get_shutdown(), RECEIVED_SHUTDOWN)
 
 
+    if not PY3:
+        def test_set_shutdown_long(self):
+            """
+            On Python 2 :py:obj:`Connection.set_shutdown` accepts an argument
+            of type :py:obj:`long` as well as :py:obj:`int`.
+            """
+            connection = Connection(Context(TLSv1_METHOD), socket())
+            connection.set_shutdown(long(RECEIVED_SHUTDOWN))
+            self.assertEquals(connection.get_shutdown(), RECEIVED_SHUTDOWN)
+
+
     def test_app_data_wrong_args(self):
         """
-        L{Connection.set_app_data} raises L{TypeError} if called with other than
-        one argument.  L{Connection.get_app_data} raises L{TypeError} if called
+        :py:obj:`Connection.set_app_data` raises :py:obj:`TypeError` if called with other than
+        one argument.  :py:obj:`Connection.get_app_data` raises :py:obj:`TypeError` if called
         with any arguments.
         """
         conn = Connection(Context(TLSv1_METHOD), None)
@@ -1252,8 +2359,8 @@
     def test_app_data(self):
         """
         Any object can be set as app data by passing it to
-        L{Connection.set_app_data} and later retrieved with
-        L{Connection.get_app_data}.
+        :py:obj:`Connection.set_app_data` and later retrieved with
+        :py:obj:`Connection.get_app_data`.
         """
         conn = Connection(Context(TLSv1_METHOD), None)
         app_data = object()
@@ -1263,8 +2370,8 @@
 
     def test_makefile(self):
         """
-        L{Connection.makefile} is not implemented and calling that method raises
-        L{NotImplementedError}.
+        :py:obj:`Connection.makefile` is not implemented and calling that method raises
+        :py:obj:`NotImplementedError`.
         """
         conn = Connection(Context(TLSv1_METHOD), None)
         self.assertRaises(NotImplementedError, conn.makefile)
@@ -1272,7 +2379,7 @@
 
     def test_get_peer_cert_chain_wrong_args(self):
         """
-        L{Connection.get_peer_cert_chain} raises L{TypeError} if called with any
+        :py:obj:`Connection.get_peer_cert_chain` raises :py:obj:`TypeError` if called with any
         arguments.
         """
         conn = Connection(Context(TLSv1_METHOD), None)
@@ -1284,7 +2391,7 @@
 
     def test_get_peer_cert_chain(self):
         """
-        L{Connection.get_peer_cert_chain} returns a list of certificates which
+        :py:obj:`Connection.get_peer_cert_chain` returns a list of certificates which
         the connected server returned for the certification verification.
         """
         chain = _create_certificate_chain()
@@ -1318,7 +2425,7 @@
 
     def test_get_peer_cert_chain_none(self):
         """
-        L{Connection.get_peer_cert_chain} returns C{None} if the peer sends no
+        :py:obj:`Connection.get_peer_cert_chain` returns :py:obj:`None` if the peer sends no
         certificate chain.
         """
         ctx = Context(TLSv1_METHOD)
@@ -1332,14 +2439,318 @@
         self.assertIdentical(None, server.get_peer_cert_chain())
 
 
+    def test_get_session_wrong_args(self):
+        """
+        :py:obj:`Connection.get_session` raises :py:obj:`TypeError` if called
+        with any arguments.
+        """
+        ctx = Context(TLSv1_METHOD)
+        server = Connection(ctx, None)
+        self.assertRaises(TypeError, server.get_session, 123)
+        self.assertRaises(TypeError, server.get_session, "hello")
+        self.assertRaises(TypeError, server.get_session, object())
+
+
+    def test_get_session_unconnected(self):
+        """
+        :py:obj:`Connection.get_session` returns :py:obj:`None` when used with
+        an object which has not been connected.
+        """
+        ctx = Context(TLSv1_METHOD)
+        server = Connection(ctx, None)
+        session = server.get_session()
+        self.assertIdentical(None, session)
+
+
+    def test_server_get_session(self):
+        """
+        On the server side of a connection, :py:obj:`Connection.get_session`
+        returns a :py:class:`Session` instance representing the SSL session for
+        that connection.
+        """
+        server, client = self._loopback()
+        session = server.get_session()
+        self.assertIsInstance(session, Session)
+
+
+    def test_client_get_session(self):
+        """
+        On the client side of a connection, :py:obj:`Connection.get_session`
+        returns a :py:class:`Session` instance representing the SSL session for
+        that connection.
+        """
+        server, client = self._loopback()
+        session = client.get_session()
+        self.assertIsInstance(session, Session)
+
+
+    def test_set_session_wrong_args(self):
+        """
+        If called with an object that is not an instance of :py:class:`Session`,
+        or with other than one argument, :py:obj:`Connection.set_session` raises
+        :py:obj:`TypeError`.
+        """
+        ctx = Context(TLSv1_METHOD)
+        connection = Connection(ctx, None)
+        self.assertRaises(TypeError, connection.set_session)
+        self.assertRaises(TypeError, connection.set_session, 123)
+        self.assertRaises(TypeError, connection.set_session, "hello")
+        self.assertRaises(TypeError, connection.set_session, object())
+        self.assertRaises(
+            TypeError, connection.set_session, Session(), Session())
+
+
+    def test_client_set_session(self):
+        """
+        :py:obj:`Connection.set_session`, when used prior to a connection being
+        established, accepts a :py:class:`Session` instance and causes an
+        attempt to re-use the session it represents when the SSL handshake is
+        performed.
+        """
+        key = load_privatekey(FILETYPE_PEM, server_key_pem)
+        cert = load_certificate(FILETYPE_PEM, server_cert_pem)
+        ctx = Context(TLSv1_METHOD)
+        ctx.use_privatekey(key)
+        ctx.use_certificate(cert)
+        ctx.set_session_id("unity-test")
+
+        def makeServer(socket):
+            server = Connection(ctx, socket)
+            server.set_accept_state()
+            return server
+
+        originalServer, originalClient = self._loopback(
+            serverFactory=makeServer)
+        originalSession = originalClient.get_session()
+
+        def makeClient(socket):
+            client = self._loopbackClientFactory(socket)
+            client.set_session(originalSession)
+            return client
+        resumedServer, resumedClient = self._loopback(
+            serverFactory=makeServer,
+            clientFactory=makeClient)
+
+        # This is a proxy: in general, we have no access to any unique
+        # identifier for the session (new enough versions of OpenSSL expose a
+        # hash which could be usable, but "new enough" is very, very new).
+        # Instead, exploit the fact that the master key is re-used if the
+        # session is re-used.  As long as the master key for the two connections
+        # is the same, the session was re-used!
+        self.assertEqual(
+            originalServer.master_key(), resumedServer.master_key())
+
+
+    def test_set_session_wrong_method(self):
+        """
+        If :py:obj:`Connection.set_session` is passed a :py:class:`Session`
+        instance associated with a context using a different SSL method than the
+        :py:obj:`Connection` is using, a :py:class:`OpenSSL.SSL.Error` is
+        raised.
+        """
+        key = load_privatekey(FILETYPE_PEM, server_key_pem)
+        cert = load_certificate(FILETYPE_PEM, server_cert_pem)
+        ctx = Context(TLSv1_METHOD)
+        ctx.use_privatekey(key)
+        ctx.use_certificate(cert)
+        ctx.set_session_id("unity-test")
+
+        def makeServer(socket):
+            server = Connection(ctx, socket)
+            server.set_accept_state()
+            return server
+
+        originalServer, originalClient = self._loopback(
+            serverFactory=makeServer)
+        originalSession = originalClient.get_session()
+
+        def makeClient(socket):
+            # Intentionally use a different, incompatible method here.
+            client = Connection(Context(SSLv3_METHOD), socket)
+            client.set_connect_state()
+            client.set_session(originalSession)
+            return client
+
+        self.assertRaises(
+            Error,
+            self._loopback, clientFactory=makeClient, serverFactory=makeServer)
+
+
+    def test_wantWriteError(self):
+        """
+        :py:obj:`Connection` methods which generate output raise
+        :py:obj:`OpenSSL.SSL.WantWriteError` if writing to the connection's BIO
+        fail indicating a should-write state.
+        """
+        client_socket, server_socket = socket_pair()
+        # Fill up the client's send buffer so Connection won't be able to write
+        # anything.  Only write a single byte at a time so we can be sure we
+        # completely fill the buffer.  Even though the socket API is allowed to
+        # signal a short write via its return value it seems this doesn't
+        # always happen on all platforms (FreeBSD and OS X particular) for the
+        # very last bit of available buffer space.
+        msg = b"x"
+        for i in range(1024 * 1024 * 4):
+            try:
+                client_socket.send(msg)
+            except error as e:
+                if e.errno == EWOULDBLOCK:
+                    break
+                raise
+        else:
+            self.fail(
+                "Failed to fill socket buffer, cannot test BIO want write")
+
+        ctx = Context(TLSv1_METHOD)
+        conn = Connection(ctx, client_socket)
+        # Client's speak first, so make it an SSL client
+        conn.set_connect_state()
+        self.assertRaises(WantWriteError, conn.do_handshake)
+
+    # XXX want_read
+
+    def test_get_finished_before_connect(self):
+        """
+        :py:obj:`Connection.get_finished` returns :py:obj:`None` before TLS
+        handshake is completed.
+        """
+        ctx = Context(TLSv1_METHOD)
+        connection = Connection(ctx, None)
+        self.assertEqual(connection.get_finished(), None)
+
+
+    def test_get_peer_finished_before_connect(self):
+        """
+        :py:obj:`Connection.get_peer_finished` returns :py:obj:`None` before
+        TLS handshake is completed.
+        """
+        ctx = Context(TLSv1_METHOD)
+        connection = Connection(ctx, None)
+        self.assertEqual(connection.get_peer_finished(), None)
+
+
+    def test_get_finished(self):
+        """
+        :py:obj:`Connection.get_finished` method returns the TLS Finished
+        message send from client, or server. Finished messages are send during
+        TLS handshake.
+        """
+
+        server, client = self._loopback()
+
+        self.assertNotEqual(server.get_finished(), None)
+        self.assertTrue(len(server.get_finished()) > 0)
+
+
+    def test_get_peer_finished(self):
+        """
+        :py:obj:`Connection.get_peer_finished` method returns the TLS Finished
+        message received from client, or server. Finished messages are send
+        during TLS handshake.
+        """
+        server, client = self._loopback()
+
+        self.assertNotEqual(server.get_peer_finished(), None)
+        self.assertTrue(len(server.get_peer_finished()) > 0)
+
+
+    def test_tls_finished_message_symmetry(self):
+        """
+        The TLS Finished message send by server must be the TLS Finished message
+        received by client.
+
+        The TLS Finished message send by client must be the TLS Finished message
+        received by server.
+        """
+        server, client = self._loopback()
+
+        self.assertEqual(server.get_finished(), client.get_peer_finished())
+        self.assertEqual(client.get_finished(), server.get_peer_finished())
+
+
+    def test_get_cipher_name_before_connect(self):
+        """
+        :py:obj:`Connection.get_cipher_name` returns :py:obj:`None` if no
+        connection has been established.
+        """
+        ctx = Context(TLSv1_METHOD)
+        conn = Connection(ctx, None)
+        self.assertIdentical(conn.get_cipher_name(), None)
+
+
+    def test_get_cipher_name(self):
+        """
+        :py:obj:`Connection.get_cipher_name` returns a :py:class:`unicode`
+        string giving the name of the currently used cipher.
+        """
+        server, client = self._loopback()
+        server_cipher_name, client_cipher_name = \
+            server.get_cipher_name(), client.get_cipher_name()
+
+        self.assertIsInstance(server_cipher_name, text_type)
+        self.assertIsInstance(client_cipher_name, text_type)
+
+        self.assertEqual(server_cipher_name, client_cipher_name)
+
+
+    def test_get_cipher_version_before_connect(self):
+        """
+        :py:obj:`Connection.get_cipher_version` returns :py:obj:`None` if no
+        connection has been established.
+        """
+        ctx = Context(TLSv1_METHOD)
+        conn = Connection(ctx, None)
+        self.assertIdentical(conn.get_cipher_version(), None)
+
+
+    def test_get_cipher_version(self):
+        """
+        :py:obj:`Connection.get_cipher_version` returns a :py:class:`unicode`
+        string giving the protocol name of the currently used cipher.
+        """
+        server, client = self._loopback()
+        server_cipher_version, client_cipher_version = \
+            server.get_cipher_version(), client.get_cipher_version()
+
+        self.assertIsInstance(server_cipher_version, text_type)
+        self.assertIsInstance(client_cipher_version, text_type)
+
+        self.assertEqual(server_cipher_version, client_cipher_version)
+
+
+    def test_get_cipher_bits_before_connect(self):
+        """
+        :py:obj:`Connection.get_cipher_bits` returns :py:obj:`None` if no
+        connection has been established.
+        """
+        ctx = Context(TLSv1_METHOD)
+        conn = Connection(ctx, None)
+        self.assertIdentical(conn.get_cipher_bits(), None)
+
+
+    def test_get_cipher_bits(self):
+        """
+        :py:obj:`Connection.get_cipher_bits` returns the number of secret bits
+        of the currently used cipher.
+        """
+        server, client = self._loopback()
+        server_cipher_bits, client_cipher_bits = \
+            server.get_cipher_bits(), client.get_cipher_bits()
+
+        self.assertIsInstance(server_cipher_bits, int)
+        self.assertIsInstance(client_cipher_bits, int)
+
+        self.assertEqual(server_cipher_bits, client_cipher_bits)
+
+
 
 class ConnectionGetCipherListTests(TestCase):
     """
-    Tests for L{Connection.get_cipher_list}.
+    Tests for :py:obj:`Connection.get_cipher_list`.
     """
     def test_wrong_args(self):
         """
-        L{Connection.get_cipher_list} raises L{TypeError} if called with any
+        :py:obj:`Connection.get_cipher_list` raises :py:obj:`TypeError` if called with any
         arguments.
         """
         connection = Connection(Context(TLSv1_METHOD), None)
@@ -1348,8 +2759,8 @@
 
     def test_result(self):
         """
-        L{Connection.get_cipher_list} returns a C{list} of C{str} giving the
-        names of the ciphers which might be used.
+        :py:obj:`Connection.get_cipher_list` returns a :py:obj:`list` of
+        :py:obj:`bytes` giving the names of the ciphers which might be used.
         """
         connection = Connection(Context(TLSv1_METHOD), None)
         ciphers = connection.get_cipher_list()
@@ -1361,22 +2772,23 @@
 
 class ConnectionSendTests(TestCase, _LoopbackMixin):
     """
-    Tests for L{Connection.send}
+    Tests for :py:obj:`Connection.send`
     """
     def test_wrong_args(self):
         """
-        When called with arguments other than a single string,
-        L{Connection.send} raises L{TypeError}.
+        When called with arguments other than string argument for its first
+        parameter or more than two arguments, :py:obj:`Connection.send` raises
+        :py:obj:`TypeError`.
         """
         connection = Connection(Context(TLSv1_METHOD), None)
         self.assertRaises(TypeError, connection.send)
         self.assertRaises(TypeError, connection.send, object())
-        self.assertRaises(TypeError, connection.send, "foo", "bar")
+        self.assertRaises(TypeError, connection.send, "foo", object(), "bar")
 
 
     def test_short_bytes(self):
         """
-        When passed a short byte string, L{Connection.send} transmits all of it
+        When passed a short byte string, :py:obj:`Connection.send` transmits all of it
         and returns the number of bytes sent.
         """
         server, client = self._loopback()
@@ -1384,6 +2796,26 @@
         self.assertEquals(count, 2)
         self.assertEquals(client.recv(2), b('xy'))
 
+
+    def test_text(self):
+        """
+        When passed a text, :py:obj:`Connection.send` transmits all of it and
+        returns the number of bytes sent. It also raises a DeprecationWarning.
+        """
+        server, client = self._loopback()
+        with catch_warnings(record=True) as w:
+            simplefilter("always")
+            count = server.send(b"xy".decode("ascii"))
+            self.assertEqual(
+                "{0} for buf is no longer accepted, use bytes".format(
+                    WARNING_TYPE_EXPECTED
+                ),
+                str(w[-1].message)
+            )
+            self.assertIs(w[-1].category, DeprecationWarning)
+        self.assertEquals(count, 2)
+        self.assertEquals(client.recv(2), b"xy")
+
     try:
         memoryview
     except NameError:
@@ -1392,7 +2824,7 @@
         def test_short_memoryview(self):
             """
             When passed a memoryview onto a small number of bytes,
-            L{Connection.send} transmits all of them and returns the number of
+            :py:obj:`Connection.send` transmits all of them and returns the number of
             bytes sent.
             """
             server, client = self._loopback()
@@ -1401,25 +2833,202 @@
             self.assertEquals(client.recv(2), b('xy'))
 
 
+    try:
+        buffer
+    except NameError:
+        "cannot test sending buffer without buffer"
+    else:
+        def test_short_buffer(self):
+            """
+            When passed a buffer containing a small number of bytes,
+            :py:obj:`Connection.send` transmits all of them and returns the number of
+            bytes sent.
+            """
+            server, client = self._loopback()
+            count = server.send(buffer(b('xy')))
+            self.assertEquals(count, 2)
+            self.assertEquals(client.recv(2), b('xy'))
+
+
+
+def _make_memoryview(size):
+    """
+    Create a new ``memoryview`` wrapped around a ``bytearray`` of the given
+    size.
+    """
+    return memoryview(bytearray(size))
+
+
+
+class ConnectionRecvIntoTests(TestCase, _LoopbackMixin):
+    """
+    Tests for :py:obj:`Connection.recv_into`
+    """
+    def _no_length_test(self, factory):
+        """
+        Assert that when the given buffer is passed to
+        ``Connection.recv_into``, whatever bytes are available to be received
+        that fit into that buffer are written into that buffer.
+        """
+        output_buffer = factory(5)
+
+        server, client = self._loopback()
+        server.send(b('xy'))
+
+        self.assertEqual(client.recv_into(output_buffer), 2)
+        self.assertEqual(output_buffer, bytearray(b('xy\x00\x00\x00')))
+
+
+    def test_bytearray_no_length(self):
+        """
+        :py:obj:`Connection.recv_into` can be passed a ``bytearray`` instance
+        and data in the receive buffer is written to it.
+        """
+        self._no_length_test(bytearray)
+
+
+    def _respects_length_test(self, factory):
+        """
+        Assert that when the given buffer is passed to ``Connection.recv_into``
+        along with a value for ``nbytes`` that is less than the size of that
+        buffer, only ``nbytes`` bytes are written into the buffer.
+        """
+        output_buffer = factory(10)
+
+        server, client = self._loopback()
+        server.send(b('abcdefghij'))
+
+        self.assertEqual(client.recv_into(output_buffer, 5), 5)
+        self.assertEqual(
+            output_buffer, bytearray(b('abcde\x00\x00\x00\x00\x00'))
+        )
+
+
+    def test_bytearray_respects_length(self):
+        """
+        When called with a ``bytearray`` instance,
+        :py:obj:`Connection.recv_into` respects the ``nbytes`` parameter and
+        doesn't copy in more than that number of bytes.
+        """
+        self._respects_length_test(bytearray)
+
+
+    def _doesnt_overfill_test(self, factory):
+        """
+        Assert that if there are more bytes available to be read from the
+        receive buffer than would fit into the buffer passed to
+        :py:obj:`Connection.recv_into`, only as many as fit are written into
+        it.
+        """
+        output_buffer = factory(5)
+
+        server, client = self._loopback()
+        server.send(b('abcdefghij'))
+
+        self.assertEqual(client.recv_into(output_buffer), 5)
+        self.assertEqual(output_buffer, bytearray(b('abcde')))
+        rest = client.recv(5)
+        self.assertEqual(b('fghij'), rest)
+
+
+    def test_bytearray_doesnt_overfill(self):
+        """
+        When called with a ``bytearray`` instance,
+        :py:obj:`Connection.recv_into` respects the size of the array and
+        doesn't write more bytes into it than will fit.
+        """
+        self._doesnt_overfill_test(bytearray)
+
+
+    def _really_doesnt_overfill_test(self, factory):
+        """
+        Assert that if the value given by ``nbytes`` is greater than the actual
+        size of the output buffer passed to :py:obj:`Connection.recv_into`, the
+        behavior is as if no value was given for ``nbytes`` at all.
+        """
+        output_buffer = factory(5)
+
+        server, client = self._loopback()
+        server.send(b('abcdefghij'))
+
+        self.assertEqual(client.recv_into(output_buffer, 50), 5)
+        self.assertEqual(output_buffer, bytearray(b('abcde')))
+        rest = client.recv(5)
+        self.assertEqual(b('fghij'), rest)
+
+
+    def test_bytearray_really_doesnt_overfill(self):
+        """
+        When called with a ``bytearray`` instance and an ``nbytes`` value that
+        is too large, :py:obj:`Connection.recv_into` respects the size of the
+        array and not the ``nbytes`` value and doesn't write more bytes into
+        the buffer than will fit.
+        """
+        self._doesnt_overfill_test(bytearray)
+
+
+    try:
+        memoryview
+    except NameError:
+        "cannot test recv_into memoryview without memoryview"
+    else:
+        def test_memoryview_no_length(self):
+            """
+            :py:obj:`Connection.recv_into` can be passed a ``memoryview``
+            instance and data in the receive buffer is written to it.
+            """
+            self._no_length_test(_make_memoryview)
+
+
+        def test_memoryview_respects_length(self):
+            """
+            When called with a ``memoryview`` instance,
+            :py:obj:`Connection.recv_into` respects the ``nbytes`` parameter
+            and doesn't copy more than that number of bytes in.
+            """
+            self._respects_length_test(_make_memoryview)
+
+
+        def test_memoryview_doesnt_overfill(self):
+            """
+            When called with a ``memoryview`` instance,
+            :py:obj:`Connection.recv_into` respects the size of the array and
+            doesn't write more bytes into it than will fit.
+            """
+            self._doesnt_overfill_test(_make_memoryview)
+
+
+        def test_memoryview_really_doesnt_overfill(self):
+            """
+            When called with a ``memoryview`` instance and an ``nbytes`` value
+            that is too large, :py:obj:`Connection.recv_into` respects the size
+            of the array and not the ``nbytes`` value and doesn't write more
+            bytes into the buffer than will fit.
+            """
+            self._doesnt_overfill_test(_make_memoryview)
+
+
 
 class ConnectionSendallTests(TestCase, _LoopbackMixin):
     """
-    Tests for L{Connection.sendall}.
+    Tests for :py:obj:`Connection.sendall`.
     """
     def test_wrong_args(self):
         """
-        When called with arguments other than a single string,
-        L{Connection.sendall} raises L{TypeError}.
+        When called with arguments other than a string argument for its first
+        parameter or with more than two arguments, :py:obj:`Connection.sendall`
+        raises :py:obj:`TypeError`.
         """
         connection = Connection(Context(TLSv1_METHOD), None)
         self.assertRaises(TypeError, connection.sendall)
         self.assertRaises(TypeError, connection.sendall, object())
-        self.assertRaises(TypeError, connection.sendall, "foo", "bar")
+        self.assertRaises(
+            TypeError, connection.sendall, "foo", object(), "bar")
 
 
     def test_short(self):
         """
-        L{Connection.sendall} transmits all of the bytes in the string passed to
+        :py:obj:`Connection.sendall` transmits all of the bytes in the string passed to
         it.
         """
         server, client = self._loopback()
@@ -1427,6 +3036,25 @@
         self.assertEquals(client.recv(1), b('x'))
 
 
+    def test_text(self):
+        """
+        :py:obj:`Connection.sendall` transmits all the content in the string
+        passed to it raising a DeprecationWarning in case of this being a text.
+        """
+        server, client = self._loopback()
+        with catch_warnings(record=True) as w:
+            simplefilter("always")
+            server.sendall(b"x".decode("ascii"))
+            self.assertEqual(
+                "{0} for buf is no longer accepted, use bytes".format(
+                    WARNING_TYPE_EXPECTED
+                ),
+                str(w[-1].message)
+            )
+            self.assertIs(w[-1].category, DeprecationWarning)
+        self.assertEquals(client.recv(1), b"x")
+
+
     try:
         memoryview
     except NameError:
@@ -1435,16 +3063,31 @@
         def test_short_memoryview(self):
             """
             When passed a memoryview onto a small number of bytes,
-            L{Connection.sendall} transmits all of them.
+            :py:obj:`Connection.sendall` transmits all of them.
             """
             server, client = self._loopback()
             server.sendall(memoryview(b('x')))
             self.assertEquals(client.recv(1), b('x'))
 
 
+    try:
+        buffer
+    except NameError:
+        "cannot test sending buffers without buffers"
+    else:
+        def test_short_buffers(self):
+            """
+            When passed a buffer containing a small number of bytes,
+            :py:obj:`Connection.sendall` transmits all of them.
+            """
+            server, client = self._loopback()
+            server.sendall(buffer(b('x')))
+            self.assertEquals(client.recv(1), b('x'))
+
+
     def test_long(self):
         """
-        L{Connection.sendall} transmits all of the bytes in the string passed to
+        :py:obj:`Connection.sendall` transmits all of the bytes in the string passed to
         it even if this requires multiple calls of an underlying write function.
         """
         server, client = self._loopback()
@@ -1464,12 +3107,16 @@
 
     def test_closed(self):
         """
-        If the underlying socket is closed, L{Connection.sendall} propagates the
+        If the underlying socket is closed, :py:obj:`Connection.sendall` propagates the
         write error from the low level write call.
         """
         server, client = self._loopback()
         server.sock_shutdown(2)
-        self.assertRaises(SysCallError, server.sendall, "hello, world")
+        exc = self.assertRaises(SysCallError, server.sendall, b"hello, world")
+        if platform == "win32":
+            self.assertEqual(exc.args[0], ESHUTDOWN)
+        else:
+            self.assertEqual(exc.args[0], EPIPE)
 
 
 
@@ -1479,7 +3126,7 @@
     """
     def test_renegotiate_wrong_args(self):
         """
-        L{Connection.renegotiate} raises L{TypeError} if called with any
+        :py:obj:`Connection.renegotiate` raises :py:obj:`TypeError` if called with any
         arguments.
         """
         connection = Connection(Context(TLSv1_METHOD), None)
@@ -1488,7 +3135,7 @@
 
     def test_total_renegotiations_wrong_args(self):
         """
-        L{Connection.total_renegotiations} raises L{TypeError} if called with
+        :py:obj:`Connection.total_renegotiations` raises :py:obj:`TypeError` if called with
         any arguments.
         """
         connection = Connection(Context(TLSv1_METHOD), None)
@@ -1497,7 +3144,7 @@
 
     def test_total_renegotiations(self):
         """
-        L{Connection.total_renegotiations} returns C{0} before any
+        :py:obj:`Connection.total_renegotiations` returns :py:obj:`0` before any
         renegotiations have happened.
         """
         connection = Connection(Context(TLSv1_METHOD), None)
@@ -1528,11 +3175,11 @@
 
 class ErrorTests(TestCase):
     """
-    Unit tests for L{OpenSSL.SSL.Error}.
+    Unit tests for :py:obj:`OpenSSL.SSL.Error`.
     """
     def test_type(self):
         """
-        L{Error} is an exception type.
+        :py:obj:`Error` is an exception type.
         """
         self.assertTrue(issubclass(Error, Exception))
         self.assertEqual(Error.__name__, 'Error')
@@ -1541,7 +3188,7 @@
 
 class ConstantsTests(TestCase):
     """
-    Tests for the values of constants exposed in L{OpenSSL.SSL}.
+    Tests for the values of constants exposed in :py:obj:`OpenSSL.SSL`.
 
     These are values defined by OpenSSL intended only to be used as flags to
     OpenSSL APIs.  The only assertions it seems can be made about them is
@@ -1551,8 +3198,8 @@
     if OP_NO_QUERY_MTU is not None:
         def test_op_no_query_mtu(self):
             """
-            The value of L{OpenSSL.SSL.OP_NO_QUERY_MTU} is 0x1000, the value of
-            I{SSL_OP_NO_QUERY_MTU} defined by I{openssl/ssl.h}.
+            The value of :py:obj:`OpenSSL.SSL.OP_NO_QUERY_MTU` is 0x1000, the value of
+            :py:const:`SSL_OP_NO_QUERY_MTU` defined by :file:`openssl/ssl.h`.
             """
             self.assertEqual(OP_NO_QUERY_MTU, 0x1000)
     else:
@@ -1562,8 +3209,8 @@
     if OP_COOKIE_EXCHANGE is not None:
         def test_op_cookie_exchange(self):
             """
-            The value of L{OpenSSL.SSL.OP_COOKIE_EXCHANGE} is 0x2000, the value
-            of I{SSL_OP_COOKIE_EXCHANGE} defined by I{openssl/ssl.h}.
+            The value of :py:obj:`OpenSSL.SSL.OP_COOKIE_EXCHANGE` is 0x2000, the value
+            of :py:const:`SSL_OP_COOKIE_EXCHANGE` defined by :file:`openssl/ssl.h`.
             """
             self.assertEqual(OP_COOKIE_EXCHANGE, 0x2000)
     else:
@@ -1573,23 +3220,102 @@
     if OP_NO_TICKET is not None:
         def test_op_no_ticket(self):
             """
-            The value of L{OpenSSL.SSL.OP_NO_TICKET} is 0x4000, the value of
-            I{SSL_OP_NO_TICKET} defined by I{openssl/ssl.h}.
+            The value of :py:obj:`OpenSSL.SSL.OP_NO_TICKET` is 0x4000, the value of
+            :py:const:`SSL_OP_NO_TICKET` defined by :file:`openssl/ssl.h`.
             """
             self.assertEqual(OP_NO_TICKET, 0x4000)
     else:
         "OP_NO_TICKET unavailable - OpenSSL version may be too old"
 
 
+    if OP_NO_COMPRESSION is not None:
+        def test_op_no_compression(self):
+            """
+            The value of :py:obj:`OpenSSL.SSL.OP_NO_COMPRESSION` is 0x20000, the value
+            of :py:const:`SSL_OP_NO_COMPRESSION` defined by :file:`openssl/ssl.h`.
+            """
+            self.assertEqual(OP_NO_COMPRESSION, 0x20000)
+    else:
+        "OP_NO_COMPRESSION unavailable - OpenSSL version may be too old"
+
+
+    def test_sess_cache_off(self):
+        """
+        The value of :py:obj:`OpenSSL.SSL.SESS_CACHE_OFF` 0x0, the value of
+        :py:obj:`SSL_SESS_CACHE_OFF` defined by ``openssl/ssl.h``.
+        """
+        self.assertEqual(0x0, SESS_CACHE_OFF)
+
+
+    def test_sess_cache_client(self):
+        """
+        The value of :py:obj:`OpenSSL.SSL.SESS_CACHE_CLIENT` 0x1, the value of
+        :py:obj:`SSL_SESS_CACHE_CLIENT` defined by ``openssl/ssl.h``.
+        """
+        self.assertEqual(0x1, SESS_CACHE_CLIENT)
+
+
+    def test_sess_cache_server(self):
+        """
+        The value of :py:obj:`OpenSSL.SSL.SESS_CACHE_SERVER` 0x2, the value of
+        :py:obj:`SSL_SESS_CACHE_SERVER` defined by ``openssl/ssl.h``.
+        """
+        self.assertEqual(0x2, SESS_CACHE_SERVER)
+
+
+    def test_sess_cache_both(self):
+        """
+        The value of :py:obj:`OpenSSL.SSL.SESS_CACHE_BOTH` 0x3, the value of
+        :py:obj:`SSL_SESS_CACHE_BOTH` defined by ``openssl/ssl.h``.
+        """
+        self.assertEqual(0x3, SESS_CACHE_BOTH)
+
+
+    def test_sess_cache_no_auto_clear(self):
+        """
+        The value of :py:obj:`OpenSSL.SSL.SESS_CACHE_NO_AUTO_CLEAR` 0x80, the
+        value of :py:obj:`SSL_SESS_CACHE_NO_AUTO_CLEAR` defined by
+        ``openssl/ssl.h``.
+        """
+        self.assertEqual(0x80, SESS_CACHE_NO_AUTO_CLEAR)
+
+
+    def test_sess_cache_no_internal_lookup(self):
+        """
+        The value of :py:obj:`OpenSSL.SSL.SESS_CACHE_NO_INTERNAL_LOOKUP` 0x100,
+        the value of :py:obj:`SSL_SESS_CACHE_NO_INTERNAL_LOOKUP` defined by
+        ``openssl/ssl.h``.
+        """
+        self.assertEqual(0x100, SESS_CACHE_NO_INTERNAL_LOOKUP)
+
+
+    def test_sess_cache_no_internal_store(self):
+        """
+        The value of :py:obj:`OpenSSL.SSL.SESS_CACHE_NO_INTERNAL_STORE` 0x200,
+        the value of :py:obj:`SSL_SESS_CACHE_NO_INTERNAL_STORE` defined by
+        ``openssl/ssl.h``.
+        """
+        self.assertEqual(0x200, SESS_CACHE_NO_INTERNAL_STORE)
+
+
+    def test_sess_cache_no_internal(self):
+        """
+        The value of :py:obj:`OpenSSL.SSL.SESS_CACHE_NO_INTERNAL` 0x300, the
+        value of :py:obj:`SSL_SESS_CACHE_NO_INTERNAL` defined by
+        ``openssl/ssl.h``.
+        """
+        self.assertEqual(0x300, SESS_CACHE_NO_INTERNAL)
+
+
 
 class MemoryBIOTests(TestCase, _LoopbackMixin):
     """
-    Tests for L{OpenSSL.SSL.Connection} using a memory BIO.
+    Tests for :py:obj:`OpenSSL.SSL.Connection` using a memory BIO.
     """
     def _server(self, sock):
         """
-        Create a new server-side SSL L{Connection} object wrapped around
-        C{sock}.
+        Create a new server-side SSL :py:obj:`Connection` object wrapped around
+        :py:obj:`sock`.
         """
         # Create the server side Connection.  This is mostly setup boilerplate
         # - use TLSv1, use a particular certificate, etc.
@@ -1610,8 +3336,8 @@
 
     def _client(self, sock):
         """
-        Create a new client-side SSL L{Connection} object wrapped around
-        C{sock}.
+        Create a new client-side SSL :py:obj:`Connection` object wrapped around
+        :py:obj:`sock`.
         """
         # Now create the client side Connection.  Similar boilerplate to the
         # above.
@@ -1630,7 +3356,7 @@
 
     def test_memoryConnect(self):
         """
-        Two L{Connection}s which use memory BIOs can be manually connected by
+        Two :py:obj:`Connection`s which use memory BIOs can be manually connected by
         reading from the output of each and writing those bytes to the input of
         the other and in this way establish a connection and exchange
         application-level bytes with each other.
@@ -1674,10 +3400,10 @@
 
     def test_socketConnect(self):
         """
-        Just like L{test_memoryConnect} but with an actual socket.
+        Just like :py:obj:`test_memoryConnect` but with an actual socket.
 
         This is primarily to rule out the memory BIO code as the source of
-        any problems encountered while passing data over a L{Connection} (if
+        any problems encountered while passing data over a :py:obj:`Connection` (if
         this test fails, there must be a problem outside the memory BIO
         code, as no memory BIO is involved here).  Even though this isn't a
         memory BIO test, it's convenient to have it here.
@@ -1698,8 +3424,8 @@
 
     def test_socketOverridesMemory(self):
         """
-        Test that L{OpenSSL.SSL.bio_read} and L{OpenSSL.SSL.bio_write} don't
-        work on L{OpenSSL.SSL.Connection}() that use sockets.
+        Test that :py:obj:`OpenSSL.SSL.bio_read` and :py:obj:`OpenSSL.SSL.bio_write` don't
+        work on :py:obj:`OpenSSL.SSL.Connection`() that use sockets.
         """
         context = Context(SSLv3_METHOD)
         client = socket()
@@ -1712,7 +3438,7 @@
     def test_outgoingOverflow(self):
         """
         If more bytes than can be written to the memory BIO are passed to
-        L{Connection.send} at once, the number of bytes which were written is
+        :py:obj:`Connection.send` at once, the number of bytes which were written is
         returned and that many bytes from the beginning of the input can be
         read from the other end of the connection.
         """
@@ -1722,7 +3448,7 @@
         self._interactInMemory(client, server)
 
         size = 2 ** 15
-        sent = client.send("x" * size)
+        sent = client.send(b"x" * size)
         # Sanity check.  We're trying to test what happens when the entire
         # input can't be sent.  If the entire input was sent, this test is
         # meaningless.
@@ -1738,8 +3464,8 @@
 
     def test_shutdown(self):
         """
-        L{Connection.bio_shutdown} signals the end of the data stream from
-        which the L{Connection} reads.
+        :py:obj:`Connection.bio_shutdown` signals the end of the data stream from
+        which the :py:obj:`Connection` reads.
         """
         server = self._server(None)
         server.bio_shutdown()
@@ -1749,15 +3475,27 @@
         self.assertEquals(e.__class__, Error)
 
 
+    def test_unexpectedEndOfFile(self):
+        """
+        If the connection is lost before an orderly SSL shutdown occurs,
+        :py:obj:`OpenSSL.SSL.SysCallError` is raised with a message of
+        "Unexpected EOF".
+        """
+        server_conn, client_conn = self._loopback()
+        client_conn.sock_shutdown(SHUT_RDWR)
+        exc = self.assertRaises(SysCallError, server_conn.recv, 1024)
+        self.assertEqual(exc.args, (-1, "Unexpected EOF"))
+
+
     def _check_client_ca_list(self, func):
         """
-        Verify the return value of the C{get_client_ca_list} method for server and client connections.
+        Verify the return value of the :py:obj:`get_client_ca_list` method for server and client connections.
 
-        @param func: A function which will be called with the server context
+        :param func: A function which will be called with the server context
             before the client and server are connected to each other.  This
             function should specify a list of CAs for the server to send to the
             client and return that same list.  The list will be used to verify
-            that C{get_client_ca_list} returns the proper value at various
+            that :py:obj:`get_client_ca_list` returns the proper value at various
             times.
         """
         server = self._server(None)
@@ -1775,7 +3513,7 @@
 
     def test_set_client_ca_list_errors(self):
         """
-        L{Context.set_client_ca_list} raises a L{TypeError} if called with a
+        :py:obj:`Context.set_client_ca_list` raises a :py:obj:`TypeError` if called with a
         non-list or a list that contains objects other than X509Names.
         """
         ctx = Context(TLSv1_METHOD)
@@ -1786,9 +3524,9 @@
 
     def test_set_empty_ca_list(self):
         """
-        If passed an empty list, L{Context.set_client_ca_list} configures the
+        If passed an empty list, :py:obj:`Context.set_client_ca_list` configures the
         context to send no CA names to the client and, on both the server and
-        client sides, L{Connection.get_client_ca_list} returns an empty list
+        client sides, :py:obj:`Connection.get_client_ca_list` returns an empty list
         after the connection is set up.
         """
         def no_ca(ctx):
@@ -1800,9 +3538,9 @@
     def test_set_one_ca_list(self):
         """
         If passed a list containing a single X509Name,
-        L{Context.set_client_ca_list} configures the context to send that CA
+        :py:obj:`Context.set_client_ca_list` configures the context to send that CA
         name to the client and, on both the server and client sides,
-        L{Connection.get_client_ca_list} returns a list containing that
+        :py:obj:`Connection.get_client_ca_list` returns a list containing that
         X509Name after the connection is set up.
         """
         cacert = load_certificate(FILETYPE_PEM, root_cert_pem)
@@ -1816,9 +3554,9 @@
     def test_set_multiple_ca_list(self):
         """
         If passed a list containing multiple X509Name objects,
-        L{Context.set_client_ca_list} configures the context to send those CA
+        :py:obj:`Context.set_client_ca_list` configures the context to send those CA
         names to the client and, on both the server and client sides,
-        L{Connection.get_client_ca_list} returns a list containing those
+        :py:obj:`Connection.get_client_ca_list` returns a list containing those
         X509Names after the connection is set up.
         """
         secert = load_certificate(FILETYPE_PEM, server_cert_pem)
@@ -1837,7 +3575,7 @@
     def test_reset_ca_list(self):
         """
         If called multiple times, only the X509Names passed to the final call
-        of L{Context.set_client_ca_list} are used to configure the CA names
+        of :py:obj:`Context.set_client_ca_list` are used to configure the CA names
         sent to the client.
         """
         cacert = load_certificate(FILETYPE_PEM, root_cert_pem)
@@ -1857,7 +3595,7 @@
 
     def test_mutated_ca_list(self):
         """
-        If the list passed to L{Context.set_client_ca_list} is mutated
+        If the list passed to :py:obj:`Context.set_client_ca_list` is mutated
         afterwards, this does not affect the list of CA names sent to the
         client.
         """
@@ -1877,7 +3615,7 @@
 
     def test_add_client_ca_errors(self):
         """
-        L{Context.add_client_ca} raises L{TypeError} if called with a non-X509
+        :py:obj:`Context.add_client_ca` raises :py:obj:`TypeError` if called with a non-X509
         object or with a number of arguments other than one.
         """
         ctx = Context(TLSv1_METHOD)
@@ -1890,7 +3628,7 @@
     def test_one_add_client_ca(self):
         """
         A certificate's subject can be added as a CA to be sent to the client
-        with L{Context.add_client_ca}.
+        with :py:obj:`Context.add_client_ca`.
         """
         cacert = load_certificate(FILETYPE_PEM, root_cert_pem)
         cadesc = cacert.get_subject()
@@ -1903,7 +3641,7 @@
     def test_multiple_add_client_ca(self):
         """
         Multiple CA names can be sent to the client by calling
-        L{Context.add_client_ca} with multiple X509 objects.
+        :py:obj:`Context.add_client_ca` with multiple X509 objects.
         """
         cacert = load_certificate(FILETYPE_PEM, root_cert_pem)
         secert = load_certificate(FILETYPE_PEM, server_cert_pem)
@@ -1920,8 +3658,8 @@
 
     def test_set_and_add_client_ca(self):
         """
-        A call to L{Context.set_client_ca_list} followed by a call to
-        L{Context.add_client_ca} results in using the CA names from the first
+        A call to :py:obj:`Context.set_client_ca_list` followed by a call to
+        :py:obj:`Context.add_client_ca` results in using the CA names from the first
         call and the CA name from the second call.
         """
         cacert = load_certificate(FILETYPE_PEM, root_cert_pem)
@@ -1941,8 +3679,8 @@
 
     def test_set_after_add_client_ca(self):
         """
-        A call to L{Context.set_client_ca_list} after a call to
-        L{Context.add_client_ca} replaces the CA name specified by the former
+        A call to :py:obj:`Context.set_client_ca_list` after a call to
+        :py:obj:`Context.add_client_ca` replaces the CA name specified by the former
         call with the names specified by the latter cal.
         """
         cacert = load_certificate(FILETYPE_PEM, root_cert_pem)
@@ -1960,6 +3698,56 @@
         self._check_client_ca_list(set_replaces_add_ca)
 
 
+
+class ConnectionBIOTests(TestCase):
+    """
+    Tests for :py:obj:`Connection.bio_read` and :py:obj:`Connection.bio_write`.
+    """
+    def test_wantReadError(self):
+        """
+        :py:obj:`Connection.bio_read` raises :py:obj:`OpenSSL.SSL.WantReadError`
+        if there are no bytes available to be read from the BIO.
+        """
+        ctx = Context(TLSv1_METHOD)
+        conn = Connection(ctx, None)
+        self.assertRaises(WantReadError, conn.bio_read, 1024)
+
+
+    def test_buffer_size(self):
+        """
+        :py:obj:`Connection.bio_read` accepts an integer giving the maximum
+        number of bytes to read and return.
+        """
+        ctx = Context(TLSv1_METHOD)
+        conn = Connection(ctx, None)
+        conn.set_connect_state()
+        try:
+            conn.do_handshake()
+        except WantReadError:
+            pass
+        data = conn.bio_read(2)
+        self.assertEqual(2, len(data))
+
+
+    if not PY3:
+        def test_buffer_size_long(self):
+            """
+            On Python 2 :py:obj:`Connection.bio_read` accepts values of type
+            :py:obj:`long` as well as :py:obj:`int`.
+            """
+            ctx = Context(TLSv1_METHOD)
+            conn = Connection(ctx, None)
+            conn.set_connect_state()
+            try:
+                conn.do_handshake()
+            except WantReadError:
+                pass
+            data = conn.bio_read(long(2))
+            self.assertEqual(2, len(data))
+
+
+
+
 class InfoConstantTests(TestCase):
     """
     Tests for assorted constants exposed for use in info callbacks.
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/test/test_tsafe.py hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/test/test_tsafe.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/test/test_tsafe.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/test/test_tsafe.py	2014-08-14 22:37:39.000000000 +0200
@@ -0,0 +1,24 @@
+# Copyright (C) Jean-Paul Calderone
+# See LICENSE for details.
+
+"""
+Unit tests for :py:obj:`OpenSSL.tsafe`.
+"""
+
+from OpenSSL.SSL import TLSv1_METHOD, Context
+from OpenSSL.tsafe import Connection
+from OpenSSL.test.util import TestCase
+
+
+class ConnectionTest(TestCase):
+    """
+    Tests for :py:obj:`OpenSSL.tsafe.Connection`.
+    """
+    def test_instantiation(self):
+        """
+        :py:obj:`OpenSSL.tsafe.Connection` can be instantiated.
+        """
+        # The following line should not throw an error.  This isn't an ideal
+        # test.  It would be great to refactor the other Connection tests so
+        # they could automatically be applied to this class too.
+        Connection(Context(TLSv1_METHOD), None)
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/test/test_util.py hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/test/test_util.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/test/test_util.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/test/test_util.py	2015-04-13 23:58:06.000000000 +0200
@@ -0,0 +1,17 @@
+from OpenSSL._util import exception_from_error_queue, lib
+from OpenSSL.test.util import TestCase
+
+
+
+class ErrorTests(TestCase):
+    """
+    Tests for handling of certain OpenSSL error cases.
+    """
+    def test_exception_from_error_queue_nonexistent_reason(self):
+        """
+        :py:func:`exception_from_error_queue` raises ``ValueError`` when it
+        encounters an OpenSSL error code which does not have a reason string.
+        """
+        lib.ERR_put_error(lib.ERR_LIB_EVP, 0, 1112, b"", 10)
+        exc = self.assertRaises(ValueError, exception_from_error_queue, ValueError)
+        self.assertEqual(exc.args[0][0][2], "")
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/test/util.py hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/test/util.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/test/util.py	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/test/util.py	2015-04-14 04:48:10.000000000 +0200
@@ -8,31 +8,158 @@
 """
 
 import shutil
+import traceback
 import os, os.path
 from tempfile import mktemp
 from unittest import TestCase
 import sys
 
-from OpenSSL.crypto import Error, _exception_from_error_queue
+from six import PY3
 
-if sys.version_info < (3, 0):
-    def b(s):
-        return s
-    bytes = str
-else:
-    def b(s):
-        return s.encode("charmap")
-    bytes = bytes
+from OpenSSL._util import exception_from_error_queue
+from OpenSSL.crypto import Error
+
+try:
+    import memdbg
+except Exception:
+    class _memdbg(object): heap = None
+    memdbg = _memdbg()
+
+from OpenSSL._util import ffi, lib, byte_string as b
+
+
+# This is the UTF-8 encoding of the SNOWMAN unicode code point.
+NON_ASCII = b("\xe2\x98\x83").decode("utf-8")
 
 
 class TestCase(TestCase):
     """
-    L{TestCase} adds useful testing functionality beyond what is available
-    from the standard library L{unittest.TestCase}.
+    :py:class:`TestCase` adds useful testing functionality beyond what is available
+    from the standard library :py:class:`unittest.TestCase`.
     """
+    def run(self, result):
+        run = super(TestCase, self).run
+        if memdbg.heap is None:
+            return run(result)
+
+        # Run the test as usual
+        before = set(memdbg.heap)
+        run(result)
+
+        # Clean up some long-lived allocations so they won't be reported as
+        # memory leaks.
+        lib.CRYPTO_cleanup_all_ex_data()
+        lib.ERR_remove_thread_state(ffi.NULL)
+        after = set(memdbg.heap)
+
+        if not after - before:
+            # No leaks, fast succeed
+            return
+
+        if result.wasSuccessful():
+            # If it passed, run it again with memory debugging
+            before = set(memdbg.heap)
+            run(result)
+
+            # Clean up some long-lived allocations so they won't be reported as
+            # memory leaks.
+            lib.CRYPTO_cleanup_all_ex_data()
+            lib.ERR_remove_thread_state(ffi.NULL)
+
+            after = set(memdbg.heap)
+
+            self._reportLeaks(after - before, result)
+
+
+    def _reportLeaks(self, leaks, result):
+        def format_leak(p):
+            stacks = memdbg.heap[p]
+            # Eventually look at multiple stacks for the realloc() case.  For
+            # now just look at the original allocation location.
+            (size, python_stack, c_stack) = stacks[0]
+
+            stack = traceback.format_list(python_stack)[:-1]
+
+            # c_stack looks something like this (interesting parts indicated
+            # with inserted arrows not part of the data):
+            #
+            # /home/exarkun/Projects/pyOpenSSL/branches/use-opentls/__pycache__/_cffi__x89095113xb9185b9b.so(+0x12cf) [0x7fe2e20582cf]
+            # /home/exarkun/Projects/cpython/2.7/python(PyCFunction_Call+0x8b) [0x56265a]
+            # /home/exarkun/Projects/cpython/2.7/python() [0x4d5f52]
+            # /home/exarkun/Projects/cpython/2.7/python(PyEval_EvalFrameEx+0x753b) [0x4d0e1e]
+            # /home/exarkun/Projects/cpython/2.7/python() [0x4d6419]
+            # /home/exarkun/Projects/cpython/2.7/python() [0x4d6129]
+            # /home/exarkun/Projects/cpython/2.7/python(PyEval_EvalFrameEx+0x753b) [0x4d0e1e]
+            # /home/exarkun/Projects/cpython/2.7/python(PyEval_EvalCodeEx+0x1043) [0x4d3726]
+            # /home/exarkun/Projects/cpython/2.7/python() [0x55fd51]
+            # /home/exarkun/Projects/cpython/2.7/python(PyObject_Call+0x7e) [0x420ee6]
+            # /home/exarkun/Projects/cpython/2.7/python(PyEval_CallObjectWithKeywords+0x158) [0x4d56ec]
+            # /home/exarkun/.local/lib/python2.7/site-packages/cffi-0.5-py2.7-linux-x86_64.egg/_cffi_backend.so(+0xe96e) [0x7fe2e38be96e]
+            # /usr/lib/x86_64-linux-gnu/libffi.so.6(ffi_closure_unix64_inner+0x1b9) [0x7fe2e36ad819]
+            # /usr/lib/x86_64-linux-gnu/libffi.so.6(ffi_closure_unix64+0x46) [0x7fe2e36adb7c]
+            # /lib/x86_64-linux-gnu/libcrypto.so.1.0.0(CRYPTO_malloc+0x64) [0x7fe2e1cef784]           <------ end interesting
+            # /lib/x86_64-linux-gnu/libcrypto.so.1.0.0(lh_insert+0x16b) [0x7fe2e1d6a24b]                      .
+            # /lib/x86_64-linux-gnu/libcrypto.so.1.0.0(+0x61c18) [0x7fe2e1cf0c18]                             .
+            # /lib/x86_64-linux-gnu/libcrypto.so.1.0.0(+0x625ec) [0x7fe2e1cf15ec]                             .
+            # /lib/x86_64-linux-gnu/libcrypto.so.1.0.0(DSA_new_method+0xe6) [0x7fe2e1d524d6]                  .
+            # /lib/x86_64-linux-gnu/libcrypto.so.1.0.0(DSA_generate_parameters+0x3a) [0x7fe2e1d5364a] <------ begin interesting
+            # /home/exarkun/Projects/opentls/trunk/tls/c/__pycache__/_cffi__x305d4698xb539baaa.so(+0x1f397) [0x7fe2df84d397]
+            # /home/exarkun/Projects/cpython/2.7/python(PyCFunction_Call+0x8b) [0x56265a]
+            # /home/exarkun/Projects/cpython/2.7/python() [0x4d5f52]
+            # /home/exarkun/Projects/cpython/2.7/python(PyEval_EvalFrameEx+0x753b) [0x4d0e1e]
+            # /home/exarkun/Projects/cpython/2.7/python() [0x4d6419]
+            # ...
+            #
+            # Notice the stack is upside down compared to a Python traceback.
+            # Identify the start and end of interesting bits and stuff it into the stack we report.
+
+            saved = list(c_stack)
+
+            # Figure the first interesting frame will be after a the cffi-compiled module
+            while c_stack and '/__pycache__/_cffi__' not in c_stack[-1]:
+                c_stack.pop()
+
+            # Figure the last interesting frame will always be CRYPTO_malloc,
+            # since that's where we hooked in to things.
+            while c_stack and 'CRYPTO_malloc' not in c_stack[0] and 'CRYPTO_realloc' not in c_stack[0]:
+                c_stack.pop(0)
+
+            if c_stack:
+                c_stack.reverse()
+            else:
+                c_stack = saved[::-1]
+            stack.extend([frame + "\n" for frame in c_stack])
+
+            stack.insert(0, "Leaked (%s) at:\n")
+            return "".join(stack)
+
+        if leaks:
+            unique_leaks = {}
+            for p in leaks:
+                size = memdbg.heap[p][-1][0]
+                new_leak = format_leak(p)
+                if new_leak not in unique_leaks:
+                    unique_leaks[new_leak] = [(size, p)]
+                else:
+                    unique_leaks[new_leak].append((size, p))
+                memdbg.free(p)
+
+            for (stack, allocs) in unique_leaks.iteritems():
+                allocs_accum = []
+                for (size, pointer) in allocs:
+
+                    addr = int(ffi.cast('uintptr_t', pointer))
+                    allocs_accum.append("%d@0x%x" % (size, addr))
+                allocs_report = ", ".join(sorted(allocs_accum))
+
+                result.addError(
+                    self,
+                    (None, Exception(stack % (allocs_report,)), None))
+
+
     def tearDown(self):
         """
-        Clean up any files or directories created using L{TestCase.mktemp}.
+        Clean up any files or directories created using :py:meth:`TestCase.mktemp`.
         Subclasses must invoke this method if they override it or the
         cleanup will not occur.
         """
@@ -43,21 +170,45 @@
                 elif os.path.exists(temp):
                     os.unlink(temp)
         try:
-            _exception_from_error_queue()
+            exception_from_error_queue(Error)
         except Error:
             e = sys.exc_info()[1]
             if e.args != ([],):
                 self.fail("Left over errors in OpenSSL error queue: " + repr(e))
 
 
+    def assertIsInstance(self, instance, classOrTuple, message=None):
+        """
+        Fail if C{instance} is not an instance of the given class or of
+        one of the given classes.
+
+        @param instance: the object to test the type (first argument of the
+            C{isinstance} call).
+        @type instance: any.
+        @param classOrTuple: the class or classes to test against (second
+            argument of the C{isinstance} call).
+        @type classOrTuple: class, type, or tuple.
+
+        @param message: Custom text to include in the exception text if the
+            assertion fails.
+        """
+        if not isinstance(instance, classOrTuple):
+            if message is None:
+                suffix = ""
+            else:
+                suffix = ": " + message
+            self.fail("%r is not an instance of %s%s" % (
+                    instance, classOrTuple, suffix))
+
+
     def failUnlessIn(self, containee, container, msg=None):
         """
-        Fail the test if C{containee} is not found in C{container}.
+        Fail the test if :py:data:`containee` is not found in :py:data:`container`.
 
-        @param containee: the value that should be in C{container}
-        @param container: a sequence type, or in the case of a mapping type,
+        :param containee: the value that should be in :py:class:`container`
+        :param container: a sequence type, or in the case of a mapping type,
                           will follow semantics of 'if key in dict.keys()'
-        @param msg: if msg is None, then the failure message will be
+        :param msg: if msg is None, then the failure message will be
                     '%r not in %r' % (first, second)
         """
         if containee not in container:
@@ -66,47 +217,65 @@
         return containee
     assertIn = failUnlessIn
 
-    def failUnlessIdentical(self, first, second, msg=None):
+    def assertNotIn(self, containee, container, msg=None):
         """
-        Fail the test if C{first} is not C{second}.  This is an
-        obect-identity-equality test, not an object equality
-        (i.e. C{__eq__}) test.
+        Fail the test if C{containee} is found in C{container}.
 
+        @param containee: the value that should not be in C{container}
+        @param container: a sequence type, or in the case of a mapping type,
+                          will follow semantics of 'if key in dict.keys()'
         @param msg: if msg is None, then the failure message will be
+                    '%r in %r' % (first, second)
+        """
+        if containee in container:
+            raise self.failureException(msg or "%r in %r"
+                                        % (containee, container))
+        return containee
+    failIfIn = assertNotIn
+
+
+    def assertIs(self, first, second, msg=None):
+        """
+        Fail the test if :py:data:`first` is not :py:data:`second`.  This is an
+        obect-identity-equality test, not an object equality
+        (i.e. :py:func:`__eq__`) test.
+
+        :param msg: if msg is None, then the failure message will be
         '%r is not %r' % (first, second)
         """
         if first is not second:
             raise self.failureException(msg or '%r is not %r' % (first, second))
         return first
-    assertIdentical = failUnlessIdentical
+    assertIdentical = failUnlessIdentical = assertIs
 
 
-    def failIfIdentical(self, first, second, msg=None):
+    def assertIsNot(self, first, second, msg=None):
         """
-        Fail the test if C{first} is C{second}.  This is an
+        Fail the test if :py:data:`first` is :py:data:`second`.  This is an
         obect-identity-equality test, not an object equality
-        (i.e. C{__eq__}) test.
+        (i.e. :py:func:`__eq__`) test.
 
-        @param msg: if msg is None, then the failure message will be
+        :param msg: if msg is None, then the failure message will be
         '%r is %r' % (first, second)
         """
         if first is second:
             raise self.failureException(msg or '%r is %r' % (first, second))
         return first
-    assertNotIdentical = failIfIdentical
+    assertNotIdentical = failIfIdentical = assertIsNot
 
 
     def failUnlessRaises(self, exception, f, *args, **kwargs):
         """
-        Fail the test unless calling the function C{f} with the given
-        C{args} and C{kwargs} raises C{exception}. The failure will report
-        the traceback and call stack of the unexpected exception.
+        Fail the test unless calling the function :py:data:`f` with the given
+        :py:data:`args` and :py:data:`kwargs` raises :py:data:`exception`. The
+        failure will report the traceback and call stack of the unexpected
+        exception.
 
-        @param exception: exception type that is to be expected
-        @param f: the function to call
+        :param exception: exception type that is to be expected
+        :param f: the function to call
 
-        @return: The raised exception instance, if it is of the given type.
-        @raise self.failureException: Raised if the function call does
+        :return: The raised exception instance, if it is of the given type.
+        :raise self.failureException: Raised if the function call does
             not raise an exception or if it raises an exception of a
             different type.
         """
@@ -133,34 +302,162 @@
         """
         if self._temporaryFiles is None:
             self._temporaryFiles = []
-        temp = mktemp(dir=".")
+        temp = b(mktemp(dir="."))
         self._temporaryFiles.append(temp)
         return temp
 
 
-    # Python 2.3 compatibility.
-    def assertTrue(self, *a, **kw):
-        return self.failUnless(*a, **kw)
-
-
-    def assertFalse(self, *a, **kw):
-        return self.failIf(*a, **kw)
-
-
     # Other stuff
     def assertConsistentType(self, theType, name, *constructionArgs):
         """
-        Perform various assertions about C{theType} to ensure that it is a
+        Perform various assertions about :py:data:`theType` to ensure that it is a
         well-defined type.  This is useful for extension types, where it's
         pretty easy to do something wacky.  If something about the type is
         unusual, an exception will be raised.
 
-        @param theType: The type object about which to make assertions.
-        @param name: A string giving the name of the type.
-        @param constructionArgs: Positional arguments to use with C{theType} to
+        :param theType: The type object about which to make assertions.
+        :param name: A string giving the name of the type.
+        :param constructionArgs: Positional arguments to use with :py:data:`theType` to
             create an instance of it.
         """
         self.assertEqual(theType.__name__, name)
         self.assertTrue(isinstance(theType, type))
         instance = theType(*constructionArgs)
         self.assertIdentical(type(instance), theType)
+
+
+
+class EqualityTestsMixin(object):
+    """
+    A mixin defining tests for the standard implementation of C{==} and C{!=}.
+    """
+    def anInstance(self):
+        """
+        Return an instance of the class under test.  Each call to this method
+        must return a different object.  All objects returned must be equal to
+        each other.
+        """
+        raise NotImplementedError()
+
+
+    def anotherInstance(self):
+        """
+        Return an instance of the class under test.  Each call to this method
+        must return a different object.  The objects must not be equal to the
+        objects returned by C{anInstance}.  They may or may not be equal to
+        each other (they will not be compared against each other).
+        """
+        raise NotImplementedError()
+
+
+    def test_identicalEq(self):
+        """
+        An object compares equal to itself using the C{==} operator.
+        """
+        o = self.anInstance()
+        self.assertTrue(o == o)
+
+
+    def test_identicalNe(self):
+        """
+        An object doesn't compare not equal to itself using the C{!=} operator.
+        """
+        o = self.anInstance()
+        self.assertFalse(o != o)
+
+
+    def test_sameEq(self):
+        """
+        Two objects that are equal to each other compare equal to each other
+        using the C{==} operator.
+        """
+        a = self.anInstance()
+        b = self.anInstance()
+        self.assertTrue(a == b)
+
+
+    def test_sameNe(self):
+        """
+        Two objects that are equal to each other do not compare not equal to
+        each other using the C{!=} operator.
+        """
+        a = self.anInstance()
+        b = self.anInstance()
+        self.assertFalse(a != b)
+
+
+    def test_differentEq(self):
+        """
+        Two objects that are not equal to each other do not compare equal to
+        each other using the C{==} operator.
+        """
+        a = self.anInstance()
+        b = self.anotherInstance()
+        self.assertFalse(a == b)
+
+
+    def test_differentNe(self):
+        """
+        Two objects that are not equal to each other compare not equal to each
+        other using the C{!=} operator.
+        """
+        a = self.anInstance()
+        b = self.anotherInstance()
+        self.assertTrue(a != b)
+
+
+    def test_anotherTypeEq(self):
+        """
+        The object does not compare equal to an object of an unrelated type
+        (which does not implement the comparison) using the C{==} operator.
+        """
+        a = self.anInstance()
+        b = object()
+        self.assertFalse(a == b)
+
+
+    def test_anotherTypeNe(self):
+        """
+        The object compares not equal to an object of an unrelated type (which
+        does not implement the comparison) using the C{!=} operator.
+        """
+        a = self.anInstance()
+        b = object()
+        self.assertTrue(a != b)
+
+
+    def test_delegatedEq(self):
+        """
+        The result of comparison using C{==} is delegated to the right-hand
+        operand if it is of an unrelated type.
+        """
+        class Delegate(object):
+            def __eq__(self, other):
+                # Do something crazy and obvious.
+                return [self]
+
+        a = self.anInstance()
+        b = Delegate()
+        self.assertEqual(a == b, [b])
+
+
+    def test_delegateNe(self):
+        """
+        The result of comparison using C{!=} is delegated to the right-hand
+        operand if it is of an unrelated type.
+        """
+        class Delegate(object):
+            def __ne__(self, other):
+                # Do something crazy and obvious.
+                return [self]
+
+        a = self.anInstance()
+        b = Delegate()
+        self.assertEqual(a != b, [b])
+
+
+# The type name expected in warnings about using the wrong string type.
+if PY3:
+    WARNING_TYPE_EXPECTED = "str"
+else:
+    WARNING_TYPE_EXPECTED = "unicode"
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/tsafe.py hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/tsafe.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/tsafe.py	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/tsafe.py	2014-08-14 22:37:39.000000000 +0200
@@ -8,7 +8,7 @@
 
 class Connection:
     def __init__(self, *args):
-        self._ssl_conn = apply(_ssl.Connection, args)
+        self._ssl_conn = _ssl.Connection(*args)
         self._lock = _RLock()
 
     for f in ('get_context', 'pending', 'send', 'write', 'recv', 'read',
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/util.c hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/util.c
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/util.c	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/util.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,96 +0,0 @@
-/*
- * util.c
- *
- * Copyright (C) AB Strakt
- * Copyright (C) Jean-Paul Calderone
- * See LICENSE for details.
- *
- * Utility functions.
- * See the file RATIONALE for a short explanation of why this module was written.
- *
- * Reviewed 2001-07-23
- */
-#include <Python.h>
-#include "util.h"
-
-/*
- * Flush OpenSSL's error queue and return a list of errors (a (library,
- * function, reason) string tuple)
- *
- * Arguments: None
- * Returns:   A list of errors (new reference)
- */
-PyObject *
-error_queue_to_list(void) {
-    PyObject *errlist, *tuple;
-    long err;
-
-    errlist = PyList_New(0);
-
-    while ((err = ERR_get_error()) != 0) {
-	tuple = Py_BuildValue("(sss)", ERR_lib_error_string(err),
-		                       ERR_func_error_string(err),
-				       ERR_reason_error_string(err));
-        PyList_Append(errlist, tuple);
-        Py_DECREF(tuple);
-    }
-
-    return errlist;
-}
-
-void exception_from_error_queue(PyObject *the_Error) { 
-    PyObject *errlist = error_queue_to_list();
-    PyErr_SetObject(the_Error, errlist);
-    Py_DECREF(errlist);
-} 
-
-/*
- * Flush OpenSSL's error queue and ignore the result
- *
- * Arguments: None
- * Returns:   None
- */
-void
-flush_error_queue(void) {
-    /*
-     * Make sure to save the errors to a local.  Py_DECREF might expand such
-     * that it evaluates its argument more than once, which would lead to
-     * very nasty things if we just invoked it with error_queue_to_list().
-     */
-    PyObject *list = error_queue_to_list();
-    Py_DECREF(list);
-}
-
-#if (PY_VERSION_HEX < 0x02600000)
-PyObject* PyOpenSSL_LongToHex(PyObject *o) {
-    PyObject *hex = NULL;
-    PyObject *format = NULL;
-    PyObject *format_args = NULL;
-
-    if ((format_args = Py_BuildValue("(O)", o)) == NULL) {
-        goto err;
-    }
-
-    if ((format = PyString_FromString("%x")) == NULL) {
-        goto err;
-    }
-
-    if ((hex = PyString_Format(format, format_args)) == NULL) {
-        goto err;
-    }
-
-    return hex;
-
-  err:
-    if (format_args) {
-        Py_DECREF(format_args);
-    }
-    if (format) {
-        Py_DECREF(format);
-    }
-    if (hex) {
-        Py_DECREF(hex);
-    }
-    return NULL;
-}
-#endif
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/util.h hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/util.h
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/util.h	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/util.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,144 +0,0 @@
-/*
- * util.h
- *
- * Copyright (C) AB Strakt
- * See LICENSE for details.
- *
- * Export utility functions and macros.
- * See the file RATIONALE for a short explanation of why this module was written.
- *
- * Reviewed 2001-07-23
- *
- */
-#ifndef PyOpenSSL_UTIL_H_
-#define PyOpenSSL_UTIL_H_
-
-#include <Python.h>
-#include <openssl/err.h>
-
-/*
- * pymemcompat written by Michael Hudson and lets you program to the
- * Python 2.3 memory API while keeping backwards compatibility.
- */
-#include "pymemcompat.h"
-
-/*
- * py3k defines macros that help with Python 2.x/3.x compatibility.
- */
-#include "py3k.h"
-
-
-extern  PyObject *error_queue_to_list(void);
-extern void exception_from_error_queue(PyObject *the_Error);
-extern  void      flush_error_queue(void);
-
-/*
- * These are needed because there is no "official" way to specify
- * WHERE to save the thread state.
- */
-#ifdef WITH_THREAD
-
-/*
- * Get the current Python threadstate and put it somewhere any code running
- * in this thread can get it, if it needs to restore the threadstate to run
- * some Python.
- */
-#  define MY_BEGIN_ALLOW_THREADS(ignored)                               \
-    PyThread_delete_key_value(_pyOpenSSL_tstate_key);			\
-    PyThread_set_key_value(_pyOpenSSL_tstate_key, PyEval_SaveThread());
-
-/*
- * Get the previous Python threadstate and restore it.
- */
-#  define MY_END_ALLOW_THREADS(ignored)                                 \
-    PyEval_RestoreThread(PyThread_get_key_value(_pyOpenSSL_tstate_key));
-
-#else
-#  define MY_BEGIN_ALLOW_THREADS(st)
-#  define MY_END_ALLOW_THREADS(st)      { st = NULL; }
-#endif
-
-#if !defined(PY_MAJOR_VERSION) || PY_VERSION_HEX < 0x02000000
-static int
-PyModule_AddObject(PyObject *m, char *name, PyObject *o)
-{
-    PyObject *dict;
-    if (!PyModule_Check(m) || o == NULL)
-        return -1;
-    dict = PyModule_GetDict(m);
-    if (dict == NULL)
-        return -1;
-    if (PyDict_SetItemString(dict, name, o))
-        return -1;
-    Py_DECREF(o);
-    return 0;
-}
-
-static int
-PyModule_AddIntConstant(PyObject *m, char *name, long value)
-{
-    return PyModule_AddObject(m, name, PyInt_FromLong(value));
-}
-
-static int PyObject_AsFileDescriptor(PyObject *o)
-{
-    int fd;
-    PyObject *meth;
-
-    if (PyInt_Check(o)) {
-        fd = PyInt_AsLong(o);
-    }
-    else if (PyLong_Check(o)) {
-        fd = PyLong_AsLong(o);
-    }
-    else if ((meth = PyObject_GetAttrString(o, "fileno")) != NULL)
-    {
-        PyObject *fno = PyEval_CallObject(meth, NULL);
-        Py_DECREF(meth);
-        if (fno == NULL)
-            return -1;
-
-        if (PyInt_Check(fno)) {
-            fd = PyInt_AsLong(fno);
-            Py_DECREF(fno);
-        }
-        else if (PyLong_Check(fno)) {
-            fd = PyLong_AsLong(fno);
-            Py_DECREF(fno);
-        }
-        else {
-            PyErr_SetString(PyExc_TypeError, "fileno() returned a non-integer");
-            Py_DECREF(fno);
-            return -1;
-        }
-    }
-    else {
-        PyErr_SetString(PyExc_TypeError, "argument must be an int, or have a fileno() method.");
-        return -1;
-    }
-
-    if (fd < 0) {
-        PyErr_Format(PyExc_ValueError, "file descriptor cannot be a negative integer (%i)", fd);
-        return -1;
-    }
-    return fd;
-}
-#endif
-
-#if !defined(PY_SSIZE_T_MIN)
-typedef int Py_ssize_t;
-#define PY_SSIZE_T_MAX INT_MAX
-#define PY_SSIZE_T_MIN INT_MIN
-#endif
-
-#if (PY_VERSION_HEX < 0x02600000)
-extern PyObject* PyOpenSSL_LongToHex(PyObject *o);
-#else
-#define PyOpenSSL_LongToHex(o) PyNumber_ToBase(o, 16)
-#endif
-
-#ifndef Py_TYPE
-#define Py_TYPE(ob)             (((PyObject*)(ob))->ob_type)
-#endif
-
-#endif
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/_util.py hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/_util.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/_util.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/_util.py	2015-04-14 04:50:11.000000000 +0200
@@ -0,0 +1,127 @@
+from warnings import warn
+import sys
+
+from six import PY3, binary_type, text_type
+
+from cryptography.hazmat.bindings.openssl.binding import Binding
+binding = Binding()
+ffi = binding.ffi
+lib = binding.lib
+
+
+
+def text(charp):
+    """
+    Get a native string type representing of the given CFFI ``char*`` object.
+
+    :param charp: A C-style string represented using CFFI.
+
+    :return: :class:`str`
+    """
+    if not charp:
+        return ""
+    return native(ffi.string(charp))
+
+
+
+def exception_from_error_queue(exception_type):
+    """
+    Convert an OpenSSL library failure into a Python exception.
+
+    When a call to the native OpenSSL library fails, this is usually signalled
+    by the return value, and an error code is stored in an error queue
+    associated with the current thread. The err library provides functions to
+    obtain these error codes and textual error messages.
+    """
+
+    errors = []
+
+    while True:
+        error = lib.ERR_get_error()
+        if error == 0:
+            break
+        errors.append((
+                text(lib.ERR_lib_error_string(error)),
+                text(lib.ERR_func_error_string(error)),
+                text(lib.ERR_reason_error_string(error))))
+
+    raise exception_type(errors)
+
+
+
+def native(s):
+    """
+    Convert :py:class:`bytes` or :py:class:`unicode` to the native
+    :py:class:`str` type, using UTF-8 encoding if conversion is necessary.
+
+    :raise UnicodeError: The input string is not UTF-8 decodeable.
+
+    :raise TypeError: The input is neither :py:class:`bytes` nor
+        :py:class:`unicode`.
+    """
+    if not isinstance(s, (binary_type, text_type)):
+        raise TypeError("%r is neither bytes nor unicode" % s)
+    if PY3:
+        if isinstance(s, binary_type):
+            return s.decode("utf-8")
+    else:
+        if isinstance(s, text_type):
+            return s.encode("utf-8")
+    return s
+
+
+
+def path_string(s):
+    """
+    Convert a Python string to a :py:class:`bytes` string identifying the same
+    path and which can be passed into an OpenSSL API accepting a filename.
+
+    :param s: An instance of :py:class:`bytes` or :py:class:`unicode`.
+
+    :return: An instance of :py:class:`bytes`.
+    """
+    if isinstance(s, binary_type):
+        return s
+    elif isinstance(s, text_type):
+        return s.encode(sys.getfilesystemencoding())
+    else:
+        raise TypeError("Path must be represented as bytes or unicode string")
+
+
+if PY3:
+    def byte_string(s):
+        return s.encode("charmap")
+else:
+    def byte_string(s):
+        return s
+
+
+# A marker object to observe whether some optional arguments are passed any
+# value or not.
+UNSPECIFIED = object()
+
+_TEXT_WARNING = (
+    text_type.__name__ + " for {0} is no longer accepted, use bytes"
+)
+
+def text_to_bytes_and_warn(label, obj):
+    """
+    If ``obj`` is text, emit a warning that it should be bytes instead and try
+    to convert it to bytes automatically.
+
+    :param str label: The name of the parameter from which ``obj`` was taken
+        (so a developer can easily find the source of the problem and correct
+        it).
+
+    :return: If ``obj`` is the text string type, a ``bytes`` object giving the
+        UTF-8 encoding of that text is returned.  Otherwise, ``obj`` itself is
+        returned.
+    """
+    if isinstance(obj, text_type):
+        warn(
+            _TEXT_WARNING.format(label),
+            category=DeprecationWarning,
+            stacklevel=3
+        )
+        return obj.encode('utf-8')
+    return obj
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/version.py hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/version.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/OpenSSL/version.py	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/OpenSSL/version.py	2015-04-15 01:02:27.000000000 +0200
@@ -6,4 +6,4 @@
 pyOpenSSL - A simple wrapper around the OpenSSL library
 """
 
-__version__ = '0.13'
+__version__ = '0.15.1'
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/PKG-INFO hue-release-3.9.0/desktop/core/ext-py/pyopenssl/PKG-INFO
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/PKG-INFO	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/PKG-INFO	2015-04-15 01:03:46.000000000 +0200
@@ -1,15 +1,32 @@
-Metadata-Version: 1.0
+Metadata-Version: 1.1
 Name: pyOpenSSL
-Version: 0.13
+Version: 0.15.1
 Summary: Python wrapper module around the OpenSSL library
-Home-page: http://pyopenssl.sourceforge.net/
+Home-page: https://github.com/pyca/pyopenssl
 Author: Jean-Paul Calderone
 Author-email: exarkun@twistedmatrix.com
 License: APL2
 Description: High-level wrapper around a subset of the OpenSSL library, includes
-        * SSL.Connection objects, wrapping the methods of Python's portable
-        sockets
-        * Callbacks written in Python
-        * Extensive error-handling mechanism, mirroring OpenSSL's error codes
+         * SSL.Connection objects, wrapping the methods of Python's portable
+           sockets
+         * Callbacks written in Python
+         * Extensive error-handling mechanism, mirroring OpenSSL's error codes
         ...  and much more ;)
 Platform: UNKNOWN
+Classifier: Development Status :: 6 - Mature
+Classifier: Intended Audience :: Developers
+Classifier: License :: OSI Approved :: Apache Software License
+Classifier: Operating System :: MacOS :: MacOS X
+Classifier: Operating System :: Microsoft :: Windows
+Classifier: Operating System :: POSIX
+Classifier: Programming Language :: Python :: 2
+Classifier: Programming Language :: Python :: 3
+Classifier: Programming Language :: Python :: 2.6
+Classifier: Programming Language :: Python :: 2.7
+Classifier: Programming Language :: Python :: 3.2
+Classifier: Programming Language :: Python :: 3.3
+Classifier: Programming Language :: Python :: Implementation :: CPython
+Classifier: Programming Language :: Python :: Implementation :: PyPy
+Classifier: Topic :: Security :: Cryptography
+Classifier: Topic :: Software Development :: Libraries :: Python Modules
+Classifier: Topic :: System :: Networking
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/pyOpenSSL.egg-info/dependency_links.txt hue-release-3.9.0/desktop/core/ext-py/pyopenssl/pyOpenSSL.egg-info/dependency_links.txt
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/pyOpenSSL.egg-info/dependency_links.txt	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/pyOpenSSL.egg-info/dependency_links.txt	2015-04-15 01:03:46.000000000 +0200
@@ -0,0 +1 @@
+
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/pyOpenSSL.egg-info/PKG-INFO hue-release-3.9.0/desktop/core/ext-py/pyopenssl/pyOpenSSL.egg-info/PKG-INFO
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/pyOpenSSL.egg-info/PKG-INFO	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/pyOpenSSL.egg-info/PKG-INFO	2015-04-15 01:03:46.000000000 +0200
@@ -0,0 +1,32 @@
+Metadata-Version: 1.1
+Name: pyOpenSSL
+Version: 0.15.1
+Summary: Python wrapper module around the OpenSSL library
+Home-page: https://github.com/pyca/pyopenssl
+Author: Jean-Paul Calderone
+Author-email: exarkun@twistedmatrix.com
+License: APL2
+Description: High-level wrapper around a subset of the OpenSSL library, includes
+         * SSL.Connection objects, wrapping the methods of Python's portable
+           sockets
+         * Callbacks written in Python
+         * Extensive error-handling mechanism, mirroring OpenSSL's error codes
+        ...  and much more ;)
+Platform: UNKNOWN
+Classifier: Development Status :: 6 - Mature
+Classifier: Intended Audience :: Developers
+Classifier: License :: OSI Approved :: Apache Software License
+Classifier: Operating System :: MacOS :: MacOS X
+Classifier: Operating System :: Microsoft :: Windows
+Classifier: Operating System :: POSIX
+Classifier: Programming Language :: Python :: 2
+Classifier: Programming Language :: Python :: 3
+Classifier: Programming Language :: Python :: 2.6
+Classifier: Programming Language :: Python :: 2.7
+Classifier: Programming Language :: Python :: 3.2
+Classifier: Programming Language :: Python :: 3.3
+Classifier: Programming Language :: Python :: Implementation :: CPython
+Classifier: Programming Language :: Python :: Implementation :: PyPy
+Classifier: Topic :: Security :: Cryptography
+Classifier: Topic :: Software Development :: Libraries :: Python Modules
+Classifier: Topic :: System :: Networking
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/pyOpenSSL.egg-info/requires.txt hue-release-3.9.0/desktop/core/ext-py/pyopenssl/pyOpenSSL.egg-info/requires.txt
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/pyOpenSSL.egg-info/requires.txt	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/pyOpenSSL.egg-info/requires.txt	2015-04-15 01:03:46.000000000 +0200
@@ -0,0 +1,2 @@
+cryptography>=0.7
+six>=1.5.2
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/pyOpenSSL.egg-info/SOURCES.txt hue-release-3.9.0/desktop/core/ext-py/pyopenssl/pyOpenSSL.egg-info/SOURCES.txt
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/pyOpenSSL.egg-info/SOURCES.txt	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/pyOpenSSL.egg-info/SOURCES.txt	2015-04-15 01:03:46.000000000 +0200
@@ -0,0 +1,64 @@
+CONTRIBUTING.rst
+ChangeLog
+INSTALL.rst
+LICENSE
+MANIFEST.in
+README.rst
+TODO
+memdbg.py
+runtests.py
+setup.cfg
+setup.py
+tox.ini
+OpenSSL/SSL.py
+OpenSSL/__init__.py
+OpenSSL/_util.py
+OpenSSL/crypto.py
+OpenSSL/rand.py
+OpenSSL/tsafe.py
+OpenSSL/version.py
+OpenSSL/test/README
+OpenSSL/test/__init__.py
+OpenSSL/test/test_crypto.py
+OpenSSL/test/test_rand.py
+OpenSSL/test/test_ssl.py
+OpenSSL/test/test_tsafe.py
+OpenSSL/test/test_util.py
+OpenSSL/test/util.py
+doc/Makefile
+doc/Quotes
+doc/README
+doc/api.rst
+doc/conf.py
+doc/index.rst
+doc/internals.rst
+doc/introduction.rst
+doc/make.bat
+doc/api/crypto.rst
+doc/api/rand.rst
+doc/api/ssl.rst
+doc/images/pyopenssl-brand.png
+doc/images/pyopenssl-icon.png
+doc/images/pyopenssl-logo.png
+doc/images/pyopenssl.svg
+examples/README
+examples/SecureXMLRPCServer.py
+examples/certgen.py
+examples/mk_simple_certs.py
+examples/proxy.py
+examples/simple/README
+examples/simple/client.py
+examples/simple/server.py
+examples/sni/README
+examples/sni/another.invalid.crt
+examples/sni/another.invalid.key
+examples/sni/client.py
+examples/sni/example.invalid.crt
+examples/sni/example.invalid.key
+examples/sni/server.py
+pyOpenSSL.egg-info/PKG-INFO
+pyOpenSSL.egg-info/SOURCES.txt
+pyOpenSSL.egg-info/dependency_links.txt
+pyOpenSSL.egg-info/requires.txt
+pyOpenSSL.egg-info/top_level.txt
+rpm/build_script
\ Kein Zeilenumbruch am Dateiende.
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/pyOpenSSL.egg-info/top_level.txt hue-release-3.9.0/desktop/core/ext-py/pyopenssl/pyOpenSSL.egg-info/top_level.txt
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/pyOpenSSL.egg-info/top_level.txt	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/pyOpenSSL.egg-info/top_level.txt	2015-04-15 01:03:46.000000000 +0200
@@ -0,0 +1 @@
+OpenSSL
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/README hue-release-3.9.0/desktop/core/ext-py/pyopenssl/README
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/README	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/README	1970-01-01 01:00:00.000000000 +0100
@@ -1,8 +0,0 @@
-
-pyOpenSSL - A Python wrapper around the OpenSSL library
-------------------------------------------------------------------------------
-
-See the file INSTALL for installation instructions.
-
-I appreciate bug reports and patches.  Please visit
-<http://bugs.launchpad.net/pyopenssl>.
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/README.rst hue-release-3.9.0/desktop/core/ext-py/pyopenssl/README.rst
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/README.rst	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/README.rst	2015-04-14 04:50:11.000000000 +0200
@@ -0,0 +1,14 @@
+
+pyOpenSSL - A Python wrapper around the OpenSSL library
+------------------------------------------------------------------------------
+
+See the file INSTALL.rst for installation instructions.
+
+See https://github.com/pyca/pyopenssl for development.
+
+See https://pyopenssl.readthedocs.org for documentation.
+
+See https://mail.python.org/mailman/listinfo/pyopenssl-users for the discussion mailing list.
+
+.. image:: https://coveralls.io/repos/pyca/pyopenssl/badge.png
+  :target: https://coveralls.io/r/pyca/pyopenssl
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/runtests.py hue-release-3.9.0/desktop/core/ext-py/pyopenssl/runtests.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/runtests.py	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/runtests.py	2014-02-02 16:24:09.000000000 +0100
@@ -0,0 +1,11 @@
+import sys
+sys.modules['ssl'] = None
+sys.modules['_hashlib'] = None
+
+try:
+   import memdbg
+except Exception as e:
+   pass
+
+from twisted.scripts.trial import run
+run()
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/setup.cfg hue-release-3.9.0/desktop/core/ext-py/pyopenssl/setup.cfg
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/setup.cfg	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/setup.cfg	2015-04-15 01:03:46.000000000 +0200
@@ -1,10 +1,18 @@
 [sdist]
-force_manifest=1
+force_manifest = 1
+
+[wheel]
+universal = 1
 
-# bdist_rpm settings contributed by Mihai Ibanescu <misa@redhat.com>
 [bdist_rpm]
 release = 1
-build-requires = lynx openssl-devel python-devel perl tetex-dvips tetex-latex
+build-requires = lynx openssl-devel python-devel python-sphinx
 group = Development/Libraries
 build_script = rpm/build_script
-doc-files = doc/pyOpenSSL.txt doc/pyOpenSSL.ps doc/html
+doc-files = doc/_build/html
+
+[egg_info]
+tag_build = 
+tag_date = 0
+tag_svn_revision = 0
+
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/setup.py hue-release-3.9.0/desktop/core/ext-py/pyopenssl/setup.py
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/setup.py	2015-08-07 19:50:46.000000000 +0200
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/setup.py	2015-04-15 01:02:27.000000000 +0200
@@ -1,222 +1,78 @@
 #!/usr/bin/env python
 # -*- coding: utf-8 -*-
 #
-# Copyright (C) AB Strakt 2001, All rights reserved
-# Copyright (C) Jean-Paul Calderone 2008-2010, All rights reserved
+# Copyright (C) Jean-Paul Calderone 2008-2015, All rights reserved
 #
 
 """
 Installation script for the OpenSSL module
 """
 
-import sys, os
-from distutils.core import Extension, setup
-from distutils.errors import DistutilsFileError
-from distutils.command.build_ext import build_ext
+from setuptools import setup
 
-# XXX Deduplicate this
-__version__ = '0.13'
-
-crypto_src = ['OpenSSL/crypto/crypto.c', 'OpenSSL/crypto/x509.c',
-              'OpenSSL/crypto/x509name.c', 'OpenSSL/crypto/pkey.c',
-              'OpenSSL/crypto/x509store.c', 'OpenSSL/crypto/x509req.c',
-              'OpenSSL/crypto/x509ext.c', 'OpenSSL/crypto/pkcs7.c',
-              'OpenSSL/crypto/pkcs12.c', 'OpenSSL/crypto/netscape_spki.c',
-              'OpenSSL/crypto/revoked.c', 'OpenSSL/crypto/crl.c',
-              'OpenSSL/util.c']
-crypto_dep = ['OpenSSL/crypto/crypto.h', 'OpenSSL/crypto/x509.h',
-              'OpenSSL/crypto/x509name.h', 'OpenSSL/crypto/pkey.h',
-              'OpenSSL/crypto/x509store.h', 'OpenSSL/crypto/x509req.h',
-              'OpenSSL/crypto/x509ext.h', 'OpenSSL/crypto/pkcs7.h',
-              'OpenSSL/crypto/pkcs12.h', 'OpenSSL/crypto/netscape_spki.h',
-              'OpenSSL/crypto/revoked.h', 'OpenSSL/crypto/crl.h',
-              'OpenSSL/util.h']
-rand_src = ['OpenSSL/rand/rand.c', 'OpenSSL/util.c']
-rand_dep = ['OpenSSL/util.h']
-ssl_src = ['OpenSSL/ssl/connection.c', 'OpenSSL/ssl/context.c', 'OpenSSL/ssl/ssl.c',
-           'OpenSSL/util.c']
-ssl_dep = ['OpenSSL/ssl/connection.h', 'OpenSSL/ssl/context.h', 'OpenSSL/ssl/ssl.h',
-           'OpenSSL/util.h']
-
-IncludeDirs = None
-LibraryDirs = None
-
-# Add more platforms here when needed
-if os.name == 'nt' or sys.platform == 'win32':
-
-    Libraries = ['Ws2_32']
-
-
-
-    class BuildExtension(build_ext):
-        """
-        A custom command that semiautomatically finds dependencies required by
-        PyOpenSSL.
-        """
-
-        user_options = (build_ext.user_options +
-                        [("with-openssl=", None,
-                          "directory where OpenSSL is installed")])
-        with_openssl = None
-        openssl_dlls = ()
-        openssl_mingw = False
-
-
-        def finalize_options(self):
-            """
-            Update build options with details about OpenSSL.
-            """
-            build_ext.finalize_options(self)
-            if self.with_openssl is None:
-                self.find_openssl()
-            self.find_openssl_dlls()
-            self.add_openssl_compile_info()
-
-
-        def find_openssl(self):
-            """
-            Find OpenSSL's install directory.
-            """
-            potentials = []
-            dirs = os.environ.get("PATH").split(os.pathsep)
-            for d in dirs:
-                if os.path.exists(os.path.join(d, "openssl.exe")):
-                    ssldir, bin = os.path.split(d)
-                    if not bin:
-                        ssldir, bin = os.path.split(ssldir)
-                    potentials.append(ssldir)
-                    childdirs = os.listdir(ssldir)
-                    if "lib" in childdirs and "include" in childdirs:
-                        self.with_openssl = ssldir
-                        return
-            if potentials:
-                raise DistutilsFileError(
-                    "Only found improper OpenSSL directories: %r" % (
-                        potentials,))
-            else:
-                raise DistutilsFileError("Could not find 'openssl.exe'")
-
-
-        def find_openssl_dlls(self):
-            """
-            Find OpenSSL's shared libraries.
-            """
-            self.openssl_dlls = []
-            self.find_openssl_dll("libssl32.dll", False)
-            if self.openssl_dlls:
-                self.openssl_mingw = True
-            else:
-                self.find_openssl_dll("ssleay32.dll", True)
-            self.find_openssl_dll("libeay32.dll", True)
-            # add zlib to the mix if it looks like OpenSSL
-            # was linked with a private copy of it
-            self.find_openssl_dll("zlib1.dll", False)
-
-
-        def find_openssl_dll(self, name, required):
-            """
-            Find OpenSSL's shared library and its path after installation.
-            """
-            dllpath = os.path.join(self.with_openssl, "bin", name)
-            if not os.path.exists(dllpath):
-                if required:
-                    raise DistutilsFileError("could not find '%s'" % name)
-                else:
-                    return
-            newpath = os.path.join(self.build_lib, "OpenSSL", name)
-            self.openssl_dlls.append((dllpath, newpath))
-
-
-        def add_openssl_compile_info(self):
-            """
-            Set up various compile and link parameters.
-            """
-            if self.compiler == "mingw32":
-                if self.openssl_mingw:
-                    # Library path and library names are sane when OpenSSL is
-                    # built with MinGW .
-                    libdir = "lib"
-                    libs = ["eay32", "ssl32"]
-                else:
-                    libdir = ""
-                    libs = []
-                    # Unlike when using the binary installer, which creates
-                    # an atypical shared library name 'ssleay32', so we have
-                    # to use this workaround.
-                    if self.link_objects is None:
-                        self.link_objects = []
-                    for dllpath, _ in self.openssl_dlls:
-                        dllname = os.path.basename(dllpath)
-                        libname = os.path.splitext(dllname)[0] + ".a"
-                        libpath = os.path.join(self.with_openssl,
-                                               "lib", "MinGW", libname)
-                        self.link_objects.append(libpath)
-            else:
-                libdir = "lib"
-                libs = ["libeay32", "ssleay32"]
-            self.include_dirs.append(os.path.join(self.with_openssl, "include"))
-            self.library_dirs.append(os.path.join(self.with_openssl, libdir))
-            self.libraries.extend(libs)
-
-
-        def run(self):
-            """
-            Build extension modules and copy shared libraries.
-            """
-            build_ext.run(self)
-            for dllpath, newpath in self.openssl_dlls:
-                self.copy_file(dllpath, newpath)
-
-
-        def get_outputs(self):
-            """
-            Return a list of file paths built by this comand.
-            """
-            output = [pathpair[1] for pathpair in self.openssl_dlls]
-            output.extend(build_ext.get_outputs(self))
-            return output
-
-
-
-else:
-    Libraries = ['ssl', 'crypto']
-    BuildExtension = build_ext
-
-
-
-def mkExtension(name):
-    modname = 'OpenSSL.' + name
-    src = globals()[name.lower() + '_src']
-    dep = globals()[name.lower() + '_dep']
-    return Extension(modname, src, libraries=Libraries, depends=dep,
-                     include_dirs=IncludeDirs, library_dirs=LibraryDirs)
 
+# XXX Deduplicate this
+__version__ = '0.15.1'
 
 setup(name='pyOpenSSL', version=__version__,
       packages = ['OpenSSL'],
       package_dir = {'OpenSSL': 'OpenSSL'},
-      ext_modules = [mkExtension('crypto'), mkExtension('rand'),
-                     mkExtension('SSL')],
-      py_modules  = ['OpenSSL.__init__', 'OpenSSL.tsafe',
-                     'OpenSSL.version', 'OpenSSL.test.__init__',
+      py_modules  = ['OpenSSL.__init__',
+                     'OpenSSL.tsafe',
+                     'OpenSSL.rand',
+                     'OpenSSL.crypto',
+                     'OpenSSL.SSL',
+                     'OpenSSL.version',
+                     'OpenSSL.test.__init__',
                      'OpenSSL.test.util',
                      'OpenSSL.test.test_crypto',
                      'OpenSSL.test.test_rand',
-                     'OpenSSL.test.test_ssl'],
-      zip_safe = False,
-      cmdclass = {"build_ext": BuildExtension},
+                     'OpenSSL.test.test_ssl',
+                     'OpenSSL.test.test_tsafe',
+                     'OpenSSL.test.test_util',],
       description = 'Python wrapper module around the OpenSSL library',
-      author = 'Martin SjÃ¶gren, AB Strakt',
-      author_email = 'msjogren@gmail.com',
+      author = 'Jean-Paul Calderone',
+      author_email = 'exarkun@twistedmatrix.com',
       maintainer = 'Jean-Paul Calderone',
       maintainer_email = 'exarkun@twistedmatrix.com',
-      url = 'http://pyopenssl.sourceforge.net/',
+      url = 'https://github.com/pyca/pyopenssl',
       license = 'APL2',
+      install_requires=["cryptography>=0.7", "six>=1.5.2"],
       long_description = """\
 High-level wrapper around a subset of the OpenSSL library, includes
  * SSL.Connection objects, wrapping the methods of Python's portable
    sockets
  * Callbacks written in Python
  * Extensive error-handling mechanism, mirroring OpenSSL's error codes
-...  and much more ;)"""
-     )
+...  and much more ;)""",
+      classifiers = [
+        'Development Status :: 6 - Mature',
+        'Intended Audience :: Developers',
+        'License :: OSI Approved :: Apache Software License',
+        'Operating System :: MacOS :: MacOS X',
+        'Operating System :: Microsoft :: Windows',
+        'Operating System :: POSIX',
+
+        # General classifiers to indicate "this project supports Python 2" and
+        # "this project supports Python 3".
+        'Programming Language :: Python :: 2',
+        # In particular, this makes pyOpenSSL show up on
+        # https://pypi.python.org/pypi?:action=browse&c=533&show=all and is in
+        # accordance with
+        # http://docs.python.org/2/howto/pyporting.html#universal-bits-of-advice
+        'Programming Language :: Python :: 3',
+
+        # More specific classifiers to indicate more precisely which versions
+        # of those languages the project supports.
+        'Programming Language :: Python :: 2.6',
+        'Programming Language :: Python :: 2.7',
+        'Programming Language :: Python :: 3.2',
+        'Programming Language :: Python :: 3.3',
+
+        'Programming Language :: Python :: Implementation :: CPython',
+        'Programming Language :: Python :: Implementation :: PyPy',
+        'Topic :: Security :: Cryptography',
+        'Topic :: Software Development :: Libraries :: Python Modules',
+        'Topic :: System :: Networking',
+        ],
+      test_suite="OpenSSL")
diff -urN hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/tox.ini hue-release-3.9.0/desktop/core/ext-py/pyopenssl/tox.ini
--- hue-release-3.9.0.orig/desktop/core/ext-py/pyopenssl/tox.ini	1970-01-01 01:00:00.000000000 +0100
+++ hue-release-3.9.0/desktop/core/ext-py/pyopenssl/tox.ini	2014-01-11 19:56:38.000000000 +0100
@@ -0,0 +1,10 @@
+[tox]
+envlist = pypy,py26,py27,py32,py33
+
+[testenv]
+setenv =
+    # Do not allowed the executing environment to pollute the test environment
+    # with extra packages.
+    PYTHONPATH=
+# The standard library unittest module can run tests on Python 2.7 and newer
+commands = python setup.py test
